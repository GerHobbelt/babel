(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === "object" && typeof module === "object")
    module.exports = factory(require("Babel"));
  else if (typeof define === "function" && define.amd)
    define(["Babel"], factory);
  else if (typeof exports === "object")
    exports["babelPresetEnv"] = factory(require("Babel"));
  else root["babelPresetEnv"] = factory(root["Babel"]);
})(
  typeof window !== "undefined"
    ? window
    : typeof self !== "undefined"
      ? self
      : this,
  function(__WEBPACK_EXTERNAL_MODULE__22__) {
    return (function(modules) {
      // webpackBootstrap
      // The module cache
      var installedModules = {};
      /******/
      // The require function
      function __webpack_require__(moduleId) {
        /******/
        // Check if module is in cache
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        // Create a new module (and put it into the cache)
        var module = (installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {},
        });
        /******/
        // Execute the module function
        modules[moduleId].call(
          module.exports,
          module,
          module.exports,
          __webpack_require__
        );
        /******/
        // Flag the module as loaded
        module.l = true;
        /******/
        // Return the exports of the module
        return module.exports;
      }
      /******/
      /******/
      // expose the modules object (__webpack_modules__)
      __webpack_require__.m = modules;
      /******/
      // expose the module cache
      __webpack_require__.c = installedModules;
      /******/
      // define getter function for harmony exports
      __webpack_require__.d = function(exports, name, getter) {
        if (!__webpack_require__.o(exports, name)) {
          Object.defineProperty(exports, name, {
            enumerable: true,
            get: getter,
          });
        }
      };
      /******/
      // define __esModule on exports
      __webpack_require__.r = function(exports) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports, Symbol.toStringTag, {
            value: "Module",
          });
        }
        Object.defineProperty(exports, "__esModule", { value: true });
      };
      /******/
      // create a fake namespace object
      // mode & 1: value is a module id, require it
      // mode & 2: merge all properties of value into the ns
      // mode & 4: return value when already ns object
      // mode & 8|1: behave like require
      __webpack_require__.t = function(value, mode) {
        if (mode & 1) value = __webpack_require__(value);
        if (mode & 8) return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
          return value;
        var ns = Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", {
          enumerable: true,
          value: value,
        });
        if (mode & 2 && typeof value != "string")
          for (var key in value)
            __webpack_require__.d(
              ns,
              key,
              function(key) {
                return value[key];
              }.bind(null, key)
            );
        return ns;
      };
      /******/
      // getDefaultExport function for compatibility with non-harmony modules
      __webpack_require__.n = function(module) {
        var getter =
          module && module.__esModule
            ? function getDefault() {
                return module["default"];
              }
            : function getModuleExports() {
                return module;
              };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      /******/
      // Object.prototype.hasOwnProperty.call
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/
      // __webpack_public_path__
      __webpack_require__.p = "";
      /******/
      /******/
      // Load entry module and return exports
      return __webpack_require__((__webpack_require__.s = 170));
    })(
      /************************************************************************/
      [
        /* 0 */
        function(module, exports) {
          function _taggedTemplateLiteralLoose(strings, raw) {
            if (!raw) {
              raw = strings.slice(0);
            }

            strings.raw = raw;
            return strings;
          }

          module.exports = _taggedTemplateLiteralLoose;
        },
        /* 1 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          var _exportNames = {
            react: true,
            assertNode: true,
            createTypeAnnotationBasedOnTypeof: true,
            createUnionTypeAnnotation: true,
            cloneNode: true,
            clone: true,
            cloneDeep: true,
            cloneWithoutLoc: true,
            addComment: true,
            addComments: true,
            inheritInnerComments: true,
            inheritLeadingComments: true,
            inheritsComments: true,
            inheritTrailingComments: true,
            removeComments: true,
            ensureBlock: true,
            toBindingIdentifierName: true,
            toBlock: true,
            toComputedKey: true,
            toExpression: true,
            toIdentifier: true,
            toKeyAlias: true,
            toSequenceExpression: true,
            toStatement: true,
            valueToNode: true,
            appendToMemberExpression: true,
            inherits: true,
            prependToMemberExpression: true,
            removeProperties: true,
            removePropertiesDeep: true,
            removeTypeDuplicates: true,
            getBindingIdentifiers: true,
            getOuterBindingIdentifiers: true,
            traverse: true,
            traverseFast: true,
            shallowEqual: true,
            is: true,
            isBinding: true,
            isBlockScoped: true,
            isImmutable: true,
            isLet: true,
            isNode: true,
            isNodesEquivalent: true,
            isReferenced: true,
            isScope: true,
            isSpecifierDefault: true,
            isType: true,
            isValidES3Identifier: true,
            isValidIdentifier: true,
            isVar: true,
            matchesPattern: true,
            validate: true,
            buildMatchMemberExpression: true,
          };
          Object.defineProperty(exports, "assertNode", {
            enumerable: true,
            get: function get() {
              return _assertNode.default;
            },
          });
          Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
            enumerable: true,
            get: function get() {
              return _createTypeAnnotationBasedOnTypeof.default;
            },
          });
          Object.defineProperty(exports, "createUnionTypeAnnotation", {
            enumerable: true,
            get: function get() {
              return _createUnionTypeAnnotation.default;
            },
          });
          Object.defineProperty(exports, "cloneNode", {
            enumerable: true,
            get: function get() {
              return _cloneNode.default;
            },
          });
          Object.defineProperty(exports, "clone", {
            enumerable: true,
            get: function get() {
              return _clone.default;
            },
          });
          Object.defineProperty(exports, "cloneDeep", {
            enumerable: true,
            get: function get() {
              return _cloneDeep.default;
            },
          });
          Object.defineProperty(exports, "cloneWithoutLoc", {
            enumerable: true,
            get: function get() {
              return _cloneWithoutLoc.default;
            },
          });
          Object.defineProperty(exports, "addComment", {
            enumerable: true,
            get: function get() {
              return _addComment.default;
            },
          });
          Object.defineProperty(exports, "addComments", {
            enumerable: true,
            get: function get() {
              return _addComments.default;
            },
          });
          Object.defineProperty(exports, "inheritInnerComments", {
            enumerable: true,
            get: function get() {
              return _inheritInnerComments.default;
            },
          });
          Object.defineProperty(exports, "inheritLeadingComments", {
            enumerable: true,
            get: function get() {
              return _inheritLeadingComments.default;
            },
          });
          Object.defineProperty(exports, "inheritsComments", {
            enumerable: true,
            get: function get() {
              return _inheritsComments.default;
            },
          });
          Object.defineProperty(exports, "inheritTrailingComments", {
            enumerable: true,
            get: function get() {
              return _inheritTrailingComments.default;
            },
          });
          Object.defineProperty(exports, "removeComments", {
            enumerable: true,
            get: function get() {
              return _removeComments.default;
            },
          });
          Object.defineProperty(exports, "ensureBlock", {
            enumerable: true,
            get: function get() {
              return _ensureBlock.default;
            },
          });
          Object.defineProperty(exports, "toBindingIdentifierName", {
            enumerable: true,
            get: function get() {
              return _toBindingIdentifierName.default;
            },
          });
          Object.defineProperty(exports, "toBlock", {
            enumerable: true,
            get: function get() {
              return _toBlock.default;
            },
          });
          Object.defineProperty(exports, "toComputedKey", {
            enumerable: true,
            get: function get() {
              return _toComputedKey.default;
            },
          });
          Object.defineProperty(exports, "toExpression", {
            enumerable: true,
            get: function get() {
              return _toExpression.default;
            },
          });
          Object.defineProperty(exports, "toIdentifier", {
            enumerable: true,
            get: function get() {
              return _toIdentifier.default;
            },
          });
          Object.defineProperty(exports, "toKeyAlias", {
            enumerable: true,
            get: function get() {
              return _toKeyAlias.default;
            },
          });
          Object.defineProperty(exports, "toSequenceExpression", {
            enumerable: true,
            get: function get() {
              return _toSequenceExpression.default;
            },
          });
          Object.defineProperty(exports, "toStatement", {
            enumerable: true,
            get: function get() {
              return _toStatement.default;
            },
          });
          Object.defineProperty(exports, "valueToNode", {
            enumerable: true,
            get: function get() {
              return _valueToNode.default;
            },
          });
          Object.defineProperty(exports, "appendToMemberExpression", {
            enumerable: true,
            get: function get() {
              return _appendToMemberExpression.default;
            },
          });
          Object.defineProperty(exports, "inherits", {
            enumerable: true,
            get: function get() {
              return _inherits.default;
            },
          });
          Object.defineProperty(exports, "prependToMemberExpression", {
            enumerable: true,
            get: function get() {
              return _prependToMemberExpression.default;
            },
          });
          Object.defineProperty(exports, "removeProperties", {
            enumerable: true,
            get: function get() {
              return _removeProperties.default;
            },
          });
          Object.defineProperty(exports, "removePropertiesDeep", {
            enumerable: true,
            get: function get() {
              return _removePropertiesDeep.default;
            },
          });
          Object.defineProperty(exports, "removeTypeDuplicates", {
            enumerable: true,
            get: function get() {
              return _removeTypeDuplicates.default;
            },
          });
          Object.defineProperty(exports, "getBindingIdentifiers", {
            enumerable: true,
            get: function get() {
              return _getBindingIdentifiers.default;
            },
          });
          Object.defineProperty(exports, "getOuterBindingIdentifiers", {
            enumerable: true,
            get: function get() {
              return _getOuterBindingIdentifiers.default;
            },
          });
          Object.defineProperty(exports, "traverse", {
            enumerable: true,
            get: function get() {
              return _traverse.default;
            },
          });
          Object.defineProperty(exports, "traverseFast", {
            enumerable: true,
            get: function get() {
              return _traverseFast.default;
            },
          });
          Object.defineProperty(exports, "shallowEqual", {
            enumerable: true,
            get: function get() {
              return _shallowEqual.default;
            },
          });
          Object.defineProperty(exports, "is", {
            enumerable: true,
            get: function get() {
              return _is.default;
            },
          });
          Object.defineProperty(exports, "isBinding", {
            enumerable: true,
            get: function get() {
              return _isBinding.default;
            },
          });
          Object.defineProperty(exports, "isBlockScoped", {
            enumerable: true,
            get: function get() {
              return _isBlockScoped.default;
            },
          });
          Object.defineProperty(exports, "isImmutable", {
            enumerable: true,
            get: function get() {
              return _isImmutable.default;
            },
          });
          Object.defineProperty(exports, "isLet", {
            enumerable: true,
            get: function get() {
              return _isLet.default;
            },
          });
          Object.defineProperty(exports, "isNode", {
            enumerable: true,
            get: function get() {
              return _isNode.default;
            },
          });
          Object.defineProperty(exports, "isNodesEquivalent", {
            enumerable: true,
            get: function get() {
              return _isNodesEquivalent.default;
            },
          });
          Object.defineProperty(exports, "isReferenced", {
            enumerable: true,
            get: function get() {
              return _isReferenced.default;
            },
          });
          Object.defineProperty(exports, "isScope", {
            enumerable: true,
            get: function get() {
              return _isScope.default;
            },
          });
          Object.defineProperty(exports, "isSpecifierDefault", {
            enumerable: true,
            get: function get() {
              return _isSpecifierDefault.default;
            },
          });
          Object.defineProperty(exports, "isType", {
            enumerable: true,
            get: function get() {
              return _isType.default;
            },
          });
          Object.defineProperty(exports, "isValidES3Identifier", {
            enumerable: true,
            get: function get() {
              return _isValidES3Identifier.default;
            },
          });
          Object.defineProperty(exports, "isValidIdentifier", {
            enumerable: true,
            get: function get() {
              return _isValidIdentifier.default;
            },
          });
          Object.defineProperty(exports, "isVar", {
            enumerable: true,
            get: function get() {
              return _isVar.default;
            },
          });
          Object.defineProperty(exports, "matchesPattern", {
            enumerable: true,
            get: function get() {
              return _matchesPattern.default;
            },
          });
          Object.defineProperty(exports, "validate", {
            enumerable: true,
            get: function get() {
              return _validate.default;
            },
          });
          Object.defineProperty(exports, "buildMatchMemberExpression", {
            enumerable: true,
            get: function get() {
              return _buildMatchMemberExpression.default;
            },
          });
          exports.react = void 0;

          var _isReactComponent = _interopRequireDefault(
            __webpack_require__(177)
          );

          var _isCompatTag = _interopRequireDefault(__webpack_require__(178));

          var _buildChildren = _interopRequireDefault(__webpack_require__(179));

          var _assertNode = _interopRequireDefault(__webpack_require__(250));

          var _generated = __webpack_require__(251);

          Object.keys(_generated).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _generated[key];
              },
            });
          });

          var _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(
            __webpack_require__(252)
          );

          var _createUnionTypeAnnotation = _interopRequireDefault(
            __webpack_require__(253)
          );

          var _generated2 = __webpack_require__(4);

          Object.keys(_generated2).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _generated2[key];
              },
            });
          });

          var _cloneNode = _interopRequireDefault(__webpack_require__(28));

          var _clone = _interopRequireDefault(__webpack_require__(111));

          var _cloneDeep = _interopRequireDefault(__webpack_require__(254));

          var _cloneWithoutLoc = _interopRequireDefault(
            __webpack_require__(255)
          );

          var _addComment = _interopRequireDefault(__webpack_require__(256));

          var _addComments = _interopRequireDefault(__webpack_require__(112));

          var _inheritInnerComments = _interopRequireDefault(
            __webpack_require__(113)
          );

          var _inheritLeadingComments = _interopRequireDefault(
            __webpack_require__(117)
          );

          var _inheritsComments = _interopRequireDefault(
            __webpack_require__(118)
          );

          var _inheritTrailingComments = _interopRequireDefault(
            __webpack_require__(119)
          );

          var _removeComments = _interopRequireDefault(
            __webpack_require__(268)
          );

          var _generated3 = __webpack_require__(269);

          Object.keys(_generated3).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _generated3[key];
              },
            });
          });

          var _constants = __webpack_require__(14);

          Object.keys(_constants).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _constants[key];
              },
            });
          });

          var _ensureBlock = _interopRequireDefault(__webpack_require__(270));

          var _toBindingIdentifierName = _interopRequireDefault(
            __webpack_require__(271)
          );

          var _toBlock = _interopRequireDefault(__webpack_require__(120));

          var _toComputedKey = _interopRequireDefault(__webpack_require__(272));

          var _toExpression = _interopRequireDefault(__webpack_require__(273));

          var _toIdentifier = _interopRequireDefault(__webpack_require__(121));

          var _toKeyAlias = _interopRequireDefault(__webpack_require__(274));

          var _toSequenceExpression = _interopRequireDefault(
            __webpack_require__(275)
          );

          var _toStatement = _interopRequireDefault(__webpack_require__(277));

          var _valueToNode = _interopRequireDefault(__webpack_require__(278));

          var _definitions = __webpack_require__(8);

          Object.keys(_definitions).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _definitions[key];
              },
            });
          });

          var _appendToMemberExpression = _interopRequireDefault(
            __webpack_require__(282)
          );

          var _inherits = _interopRequireDefault(__webpack_require__(283));

          var _prependToMemberExpression = _interopRequireDefault(
            __webpack_require__(284)
          );

          var _removeProperties = _interopRequireDefault(
            __webpack_require__(124)
          );

          var _removePropertiesDeep = _interopRequireDefault(
            __webpack_require__(122)
          );

          var _removeTypeDuplicates = _interopRequireDefault(
            __webpack_require__(110)
          );

          var _getBindingIdentifiers = _interopRequireDefault(
            __webpack_require__(40)
          );

          var _getOuterBindingIdentifiers = _interopRequireDefault(
            __webpack_require__(285)
          );

          var _traverse = _interopRequireDefault(__webpack_require__(286));

          var _traverseFast = _interopRequireDefault(__webpack_require__(123));

          var _shallowEqual = _interopRequireDefault(__webpack_require__(51));

          var _is = _interopRequireDefault(__webpack_require__(66));

          var _isBinding = _interopRequireDefault(__webpack_require__(287));

          var _isBlockScoped = _interopRequireDefault(__webpack_require__(288));

          var _isImmutable = _interopRequireDefault(__webpack_require__(289));

          var _isLet = _interopRequireDefault(__webpack_require__(125));

          var _isNode = _interopRequireDefault(__webpack_require__(109));

          var _isNodesEquivalent = _interopRequireDefault(
            __webpack_require__(290)
          );

          var _isReferenced = _interopRequireDefault(__webpack_require__(291));

          var _isScope = _interopRequireDefault(__webpack_require__(292));

          var _isSpecifierDefault = _interopRequireDefault(
            __webpack_require__(293)
          );

          var _isType = _interopRequireDefault(__webpack_require__(67));

          var _isValidES3Identifier = _interopRequireDefault(
            __webpack_require__(294)
          );

          var _isValidIdentifier = _interopRequireDefault(
            __webpack_require__(27)
          );

          var _isVar = _interopRequireDefault(__webpack_require__(295));

          var _matchesPattern = _interopRequireDefault(__webpack_require__(88));

          var _validate = _interopRequireDefault(__webpack_require__(108));

          var _buildMatchMemberExpression = _interopRequireDefault(
            __webpack_require__(87)
          );

          var _generated4 = __webpack_require__(2);

          Object.keys(_generated4).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _generated4[key];
              },
            });
          });

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var react = {
            isReactComponent: _isReactComponent.default,
            isCompatTag: _isCompatTag.default,
            buildChildren: _buildChildren.default,
          };
          exports.react = react;
        },
        /* 2 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.isArrayExpression = isArrayExpression;
          exports.isAssignmentExpression = isAssignmentExpression;
          exports.isBinaryExpression = isBinaryExpression;
          exports.isInterpreterDirective = isInterpreterDirective;
          exports.isDirective = isDirective;
          exports.isDirectiveLiteral = isDirectiveLiteral;
          exports.isBlockStatement = isBlockStatement;
          exports.isBreakStatement = isBreakStatement;
          exports.isCallExpression = isCallExpression;
          exports.isCatchClause = isCatchClause;
          exports.isConditionalExpression = isConditionalExpression;
          exports.isContinueStatement = isContinueStatement;
          exports.isDebuggerStatement = isDebuggerStatement;
          exports.isDoWhileStatement = isDoWhileStatement;
          exports.isEmptyStatement = isEmptyStatement;
          exports.isExpressionStatement = isExpressionStatement;
          exports.isFile = isFile;
          exports.isForInStatement = isForInStatement;
          exports.isForStatement = isForStatement;
          exports.isFunctionDeclaration = isFunctionDeclaration;
          exports.isFunctionExpression = isFunctionExpression;
          exports.isIdentifier = isIdentifier;
          exports.isIfStatement = isIfStatement;
          exports.isLabeledStatement = isLabeledStatement;
          exports.isStringLiteral = isStringLiteral;
          exports.isNumericLiteral = isNumericLiteral;
          exports.isNullLiteral = isNullLiteral;
          exports.isBooleanLiteral = isBooleanLiteral;
          exports.isRegExpLiteral = isRegExpLiteral;
          exports.isLogicalExpression = isLogicalExpression;
          exports.isMemberExpression = isMemberExpression;
          exports.isNewExpression = isNewExpression;
          exports.isProgram = isProgram;
          exports.isObjectExpression = isObjectExpression;
          exports.isObjectMethod = isObjectMethod;
          exports.isObjectProperty = isObjectProperty;
          exports.isRestElement = isRestElement;
          exports.isReturnStatement = isReturnStatement;
          exports.isSequenceExpression = isSequenceExpression;
          exports.isSwitchCase = isSwitchCase;
          exports.isSwitchStatement = isSwitchStatement;
          exports.isThisExpression = isThisExpression;
          exports.isThrowStatement = isThrowStatement;
          exports.isTryStatement = isTryStatement;
          exports.isUnaryExpression = isUnaryExpression;
          exports.isUpdateExpression = isUpdateExpression;
          exports.isVariableDeclaration = isVariableDeclaration;
          exports.isVariableDeclarator = isVariableDeclarator;
          exports.isWhileStatement = isWhileStatement;
          exports.isWithStatement = isWithStatement;
          exports.isAssignmentPattern = isAssignmentPattern;
          exports.isArrayPattern = isArrayPattern;
          exports.isArrowFunctionExpression = isArrowFunctionExpression;
          exports.isClassBody = isClassBody;
          exports.isClassDeclaration = isClassDeclaration;
          exports.isClassExpression = isClassExpression;
          exports.isExportAllDeclaration = isExportAllDeclaration;
          exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
          exports.isExportNamedDeclaration = isExportNamedDeclaration;
          exports.isExportSpecifier = isExportSpecifier;
          exports.isForOfStatement = isForOfStatement;
          exports.isImportDeclaration = isImportDeclaration;
          exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
          exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
          exports.isImportSpecifier = isImportSpecifier;
          exports.isMetaProperty = isMetaProperty;
          exports.isClassMethod = isClassMethod;
          exports.isObjectPattern = isObjectPattern;
          exports.isSpreadElement = isSpreadElement;
          exports.isSuper = isSuper;
          exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
          exports.isTemplateElement = isTemplateElement;
          exports.isTemplateLiteral = isTemplateLiteral;
          exports.isYieldExpression = isYieldExpression;
          exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
          exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
          exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
          exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
          exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
          exports.isClassImplements = isClassImplements;
          exports.isDeclareClass = isDeclareClass;
          exports.isDeclareFunction = isDeclareFunction;
          exports.isDeclareInterface = isDeclareInterface;
          exports.isDeclareModule = isDeclareModule;
          exports.isDeclareModuleExports = isDeclareModuleExports;
          exports.isDeclareTypeAlias = isDeclareTypeAlias;
          exports.isDeclareOpaqueType = isDeclareOpaqueType;
          exports.isDeclareVariable = isDeclareVariable;
          exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
          exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
          exports.isDeclaredPredicate = isDeclaredPredicate;
          exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
          exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
          exports.isFunctionTypeParam = isFunctionTypeParam;
          exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
          exports.isInferredPredicate = isInferredPredicate;
          exports.isInterfaceExtends = isInterfaceExtends;
          exports.isInterfaceDeclaration = isInterfaceDeclaration;
          exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
          exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
          exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
          exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
          exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
          exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
          exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
          exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
          exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
          exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
          exports.isObjectTypeIndexer = isObjectTypeIndexer;
          exports.isObjectTypeProperty = isObjectTypeProperty;
          exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
          exports.isOpaqueType = isOpaqueType;
          exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
          exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
          exports.isStringTypeAnnotation = isStringTypeAnnotation;
          exports.isThisTypeAnnotation = isThisTypeAnnotation;
          exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
          exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
          exports.isTypeAlias = isTypeAlias;
          exports.isTypeAnnotation = isTypeAnnotation;
          exports.isTypeCastExpression = isTypeCastExpression;
          exports.isTypeParameter = isTypeParameter;
          exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
          exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
          exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
          exports.isVariance = isVariance;
          exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
          exports.isJSXAttribute = isJSXAttribute;
          exports.isJSXClosingElement = isJSXClosingElement;
          exports.isJSXElement = isJSXElement;
          exports.isJSXEmptyExpression = isJSXEmptyExpression;
          exports.isJSXExpressionContainer = isJSXExpressionContainer;
          exports.isJSXSpreadChild = isJSXSpreadChild;
          exports.isJSXIdentifier = isJSXIdentifier;
          exports.isJSXMemberExpression = isJSXMemberExpression;
          exports.isJSXNamespacedName = isJSXNamespacedName;
          exports.isJSXOpeningElement = isJSXOpeningElement;
          exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
          exports.isJSXText = isJSXText;
          exports.isJSXFragment = isJSXFragment;
          exports.isJSXOpeningFragment = isJSXOpeningFragment;
          exports.isJSXClosingFragment = isJSXClosingFragment;
          exports.isNoop = isNoop;
          exports.isParenthesizedExpression = isParenthesizedExpression;
          exports.isAwaitExpression = isAwaitExpression;
          exports.isBindExpression = isBindExpression;
          exports.isClassProperty = isClassProperty;
          exports.isOptionalMemberExpression = isOptionalMemberExpression;
          exports.isOptionalCallExpression = isOptionalCallExpression;
          exports.isClassPrivateProperty = isClassPrivateProperty;
          exports.isImport = isImport;
          exports.isDecorator = isDecorator;
          exports.isDoExpression = isDoExpression;
          exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
          exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
          exports.isPrivateName = isPrivateName;
          exports.isBigIntLiteral = isBigIntLiteral;
          exports.isTSParameterProperty = isTSParameterProperty;
          exports.isTSDeclareFunction = isTSDeclareFunction;
          exports.isTSDeclareMethod = isTSDeclareMethod;
          exports.isTSQualifiedName = isTSQualifiedName;
          exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
          exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
          exports.isTSPropertySignature = isTSPropertySignature;
          exports.isTSMethodSignature = isTSMethodSignature;
          exports.isTSIndexSignature = isTSIndexSignature;
          exports.isTSAnyKeyword = isTSAnyKeyword;
          exports.isTSNumberKeyword = isTSNumberKeyword;
          exports.isTSObjectKeyword = isTSObjectKeyword;
          exports.isTSBooleanKeyword = isTSBooleanKeyword;
          exports.isTSStringKeyword = isTSStringKeyword;
          exports.isTSSymbolKeyword = isTSSymbolKeyword;
          exports.isTSVoidKeyword = isTSVoidKeyword;
          exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
          exports.isTSNullKeyword = isTSNullKeyword;
          exports.isTSNeverKeyword = isTSNeverKeyword;
          exports.isTSThisType = isTSThisType;
          exports.isTSFunctionType = isTSFunctionType;
          exports.isTSConstructorType = isTSConstructorType;
          exports.isTSTypeReference = isTSTypeReference;
          exports.isTSTypePredicate = isTSTypePredicate;
          exports.isTSTypeQuery = isTSTypeQuery;
          exports.isTSTypeLiteral = isTSTypeLiteral;
          exports.isTSArrayType = isTSArrayType;
          exports.isTSTupleType = isTSTupleType;
          exports.isTSUnionType = isTSUnionType;
          exports.isTSIntersectionType = isTSIntersectionType;
          exports.isTSConditionalType = isTSConditionalType;
          exports.isTSInferType = isTSInferType;
          exports.isTSParenthesizedType = isTSParenthesizedType;
          exports.isTSTypeOperator = isTSTypeOperator;
          exports.isTSIndexedAccessType = isTSIndexedAccessType;
          exports.isTSMappedType = isTSMappedType;
          exports.isTSLiteralType = isTSLiteralType;
          exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
          exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
          exports.isTSInterfaceBody = isTSInterfaceBody;
          exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
          exports.isTSAsExpression = isTSAsExpression;
          exports.isTSTypeAssertion = isTSTypeAssertion;
          exports.isTSEnumDeclaration = isTSEnumDeclaration;
          exports.isTSEnumMember = isTSEnumMember;
          exports.isTSModuleDeclaration = isTSModuleDeclaration;
          exports.isTSModuleBlock = isTSModuleBlock;
          exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
          exports.isTSExternalModuleReference = isTSExternalModuleReference;
          exports.isTSNonNullExpression = isTSNonNullExpression;
          exports.isTSExportAssignment = isTSExportAssignment;
          exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
          exports.isTSTypeAnnotation = isTSTypeAnnotation;
          exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
          exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
          exports.isTSTypeParameter = isTSTypeParameter;
          exports.isExpression = isExpression;
          exports.isBinary = isBinary;
          exports.isScopable = isScopable;
          exports.isBlockParent = isBlockParent;
          exports.isBlock = isBlock;
          exports.isStatement = isStatement;
          exports.isTerminatorless = isTerminatorless;
          exports.isCompletionStatement = isCompletionStatement;
          exports.isConditional = isConditional;
          exports.isLoop = isLoop;
          exports.isWhile = isWhile;
          exports.isExpressionWrapper = isExpressionWrapper;
          exports.isFor = isFor;
          exports.isForXStatement = isForXStatement;
          exports.isFunction = isFunction;
          exports.isFunctionParent = isFunctionParent;
          exports.isPureish = isPureish;
          exports.isDeclaration = isDeclaration;
          exports.isPatternLike = isPatternLike;
          exports.isLVal = isLVal;
          exports.isTSEntityName = isTSEntityName;
          exports.isLiteral = isLiteral;
          exports.isImmutable = isImmutable;
          exports.isUserWhitespacable = isUserWhitespacable;
          exports.isMethod = isMethod;
          exports.isObjectMember = isObjectMember;
          exports.isProperty = isProperty;
          exports.isUnaryLike = isUnaryLike;
          exports.isPattern = isPattern;
          exports.isClass = isClass;
          exports.isModuleDeclaration = isModuleDeclaration;
          exports.isExportDeclaration = isExportDeclaration;
          exports.isModuleSpecifier = isModuleSpecifier;
          exports.isFlow = isFlow;
          exports.isFlowType = isFlowType;
          exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
          exports.isFlowDeclaration = isFlowDeclaration;
          exports.isFlowPredicate = isFlowPredicate;
          exports.isJSX = isJSX;
          exports.isPrivate = isPrivate;
          exports.isTSTypeElement = isTSTypeElement;
          exports.isTSType = isTSType;
          exports.isNumberLiteral = isNumberLiteral;
          exports.isRegexLiteral = isRegexLiteral;
          exports.isRestProperty = isRestProperty;
          exports.isSpreadProperty = isSpreadProperty;

          var _shallowEqual = _interopRequireDefault(__webpack_require__(51));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function isArrayExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ArrayExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isAssignmentExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "AssignmentExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isBinaryExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "BinaryExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isInterpreterDirective(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "InterpreterDirective") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDirective(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "Directive") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDirectiveLiteral(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DirectiveLiteral") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isBlockStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "BlockStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isBreakStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "BreakStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isCallExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "CallExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isCatchClause(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "CatchClause") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isConditionalExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ConditionalExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isContinueStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ContinueStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDebuggerStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DebuggerStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDoWhileStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DoWhileStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isEmptyStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "EmptyStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isExpressionStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ExpressionStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFile(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "File") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isForInStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ForInStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isForStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ForStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFunctionDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "FunctionDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFunctionExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "FunctionExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isIdentifier(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "Identifier") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isIfStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "IfStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isLabeledStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "LabeledStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isStringLiteral(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "StringLiteral") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isNumericLiteral(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "NumericLiteral") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isNullLiteral(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "NullLiteral") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isBooleanLiteral(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "BooleanLiteral") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isRegExpLiteral(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "RegExpLiteral") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isLogicalExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "LogicalExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isMemberExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "MemberExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isNewExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "NewExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isProgram(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "Program") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isObjectExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ObjectExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isObjectMethod(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ObjectMethod") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isObjectProperty(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ObjectProperty") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isRestElement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "RestElement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isReturnStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ReturnStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isSequenceExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "SequenceExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isSwitchCase(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "SwitchCase") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isSwitchStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "SwitchStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isThisExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ThisExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isThrowStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ThrowStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTryStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TryStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isUnaryExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "UnaryExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isUpdateExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "UpdateExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isVariableDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "VariableDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isVariableDeclarator(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "VariableDeclarator") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isWhileStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "WhileStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isWithStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "WithStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isAssignmentPattern(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "AssignmentPattern") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isArrayPattern(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ArrayPattern") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isArrowFunctionExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ArrowFunctionExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isClassBody(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ClassBody") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isClassDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ClassDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isClassExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ClassExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isExportAllDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ExportAllDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isExportDefaultDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ExportDefaultDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isExportNamedDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ExportNamedDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isExportSpecifier(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ExportSpecifier") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isForOfStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ForOfStatement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isImportDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ImportDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isImportDefaultSpecifier(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ImportDefaultSpecifier") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isImportNamespaceSpecifier(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ImportNamespaceSpecifier") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isImportSpecifier(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ImportSpecifier") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isMetaProperty(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "MetaProperty") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isClassMethod(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ClassMethod") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isObjectPattern(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ObjectPattern") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isSpreadElement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "SpreadElement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isSuper(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "Super") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTaggedTemplateExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TaggedTemplateExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTemplateElement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TemplateElement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTemplateLiteral(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TemplateLiteral") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isYieldExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "YieldExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isAnyTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "AnyTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isArrayTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ArrayTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isBooleanTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "BooleanTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isBooleanLiteralTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "BooleanLiteralTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isNullLiteralTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "NullLiteralTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isClassImplements(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ClassImplements") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclareClass(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DeclareClass") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclareFunction(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DeclareFunction") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclareInterface(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DeclareInterface") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclareModule(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DeclareModule") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclareModuleExports(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DeclareModuleExports") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclareTypeAlias(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DeclareTypeAlias") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclareOpaqueType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DeclareOpaqueType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclareVariable(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DeclareVariable") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclareExportDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DeclareExportDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclareExportAllDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DeclareExportAllDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclaredPredicate(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DeclaredPredicate") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isExistsTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ExistsTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFunctionTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "FunctionTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFunctionTypeParam(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "FunctionTypeParam") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isGenericTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "GenericTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isInferredPredicate(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "InferredPredicate") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isInterfaceExtends(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "InterfaceExtends") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isInterfaceDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "InterfaceDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isInterfaceTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "InterfaceTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isIntersectionTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "IntersectionTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isMixedTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "MixedTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isEmptyTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "EmptyTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isNullableTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "NullableTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isNumberLiteralTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "NumberLiteralTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isNumberTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "NumberTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isObjectTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ObjectTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isObjectTypeInternalSlot(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ObjectTypeInternalSlot") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isObjectTypeCallProperty(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ObjectTypeCallProperty") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isObjectTypeIndexer(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ObjectTypeIndexer") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isObjectTypeProperty(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ObjectTypeProperty") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isObjectTypeSpreadProperty(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ObjectTypeSpreadProperty") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isOpaqueType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "OpaqueType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isQualifiedTypeIdentifier(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "QualifiedTypeIdentifier") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isStringLiteralTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "StringLiteralTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isStringTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "StringTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isThisTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ThisTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTupleTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TupleTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTypeofTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TypeofTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTypeAlias(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TypeAlias") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTypeCastExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TypeCastExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTypeParameter(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TypeParameter") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTypeParameterDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TypeParameterDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTypeParameterInstantiation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TypeParameterInstantiation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isUnionTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "UnionTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isVariance(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "Variance") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isVoidTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "VoidTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXAttribute(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXAttribute") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXClosingElement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXClosingElement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXElement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXElement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXEmptyExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXEmptyExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXExpressionContainer(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXExpressionContainer") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXSpreadChild(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXSpreadChild") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXIdentifier(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXIdentifier") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXMemberExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXMemberExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXNamespacedName(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXNamespacedName") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXOpeningElement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXOpeningElement") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXSpreadAttribute(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXSpreadAttribute") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXText(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXText") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXFragment(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXFragment") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXOpeningFragment(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXOpeningFragment") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSXClosingFragment(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "JSXClosingFragment") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isNoop(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "Noop") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isParenthesizedExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ParenthesizedExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isAwaitExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "AwaitExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isBindExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "BindExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isClassProperty(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ClassProperty") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isOptionalMemberExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "OptionalMemberExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isOptionalCallExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "OptionalCallExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isClassPrivateProperty(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ClassPrivateProperty") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isImport(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "Import") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDecorator(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "Decorator") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDoExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "DoExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isExportDefaultSpecifier(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ExportDefaultSpecifier") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isExportNamespaceSpecifier(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "ExportNamespaceSpecifier") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isPrivateName(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "PrivateName") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isBigIntLiteral(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "BigIntLiteral") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSParameterProperty(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSParameterProperty") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSDeclareFunction(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSDeclareFunction") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSDeclareMethod(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSDeclareMethod") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSQualifiedName(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSQualifiedName") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSCallSignatureDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSCallSignatureDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSConstructSignatureDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSConstructSignatureDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSPropertySignature(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSPropertySignature") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSMethodSignature(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSMethodSignature") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSIndexSignature(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSIndexSignature") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSAnyKeyword(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSAnyKeyword") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSNumberKeyword(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSNumberKeyword") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSObjectKeyword(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSObjectKeyword") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSBooleanKeyword(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSBooleanKeyword") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSStringKeyword(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSStringKeyword") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSSymbolKeyword(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSSymbolKeyword") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSVoidKeyword(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSVoidKeyword") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSUndefinedKeyword(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSUndefinedKeyword") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSNullKeyword(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSNullKeyword") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSNeverKeyword(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSNeverKeyword") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSThisType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSThisType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSFunctionType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSFunctionType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSConstructorType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSConstructorType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypeReference(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTypeReference") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypePredicate(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTypePredicate") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypeQuery(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTypeQuery") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypeLiteral(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTypeLiteral") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSArrayType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSArrayType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTupleType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTupleType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSUnionType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSUnionType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSIntersectionType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSIntersectionType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSConditionalType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSConditionalType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSInferType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSInferType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSParenthesizedType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSParenthesizedType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypeOperator(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTypeOperator") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSIndexedAccessType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSIndexedAccessType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSMappedType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSMappedType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSLiteralType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSLiteralType") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSExpressionWithTypeArguments(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSExpressionWithTypeArguments") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSInterfaceDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSInterfaceDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSInterfaceBody(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSInterfaceBody") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypeAliasDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTypeAliasDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSAsExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSAsExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypeAssertion(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTypeAssertion") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSEnumDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSEnumDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSEnumMember(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSEnumMember") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSModuleDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSModuleDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSModuleBlock(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSModuleBlock") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSImportEqualsDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSImportEqualsDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSExternalModuleReference(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSExternalModuleReference") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSNonNullExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSNonNullExpression") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSExportAssignment(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSExportAssignment") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSNamespaceExportDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSNamespaceExportDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypeAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTypeAnnotation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypeParameterInstantiation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTypeParameterInstantiation") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypeParameterDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTypeParameterDeclaration") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypeParameter(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "TSTypeParameter") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isExpression(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Expression" ||
              "ArrayExpression" === nodeType ||
              "AssignmentExpression" === nodeType ||
              "BinaryExpression" === nodeType ||
              "CallExpression" === nodeType ||
              "ConditionalExpression" === nodeType ||
              "FunctionExpression" === nodeType ||
              "Identifier" === nodeType ||
              "StringLiteral" === nodeType ||
              "NumericLiteral" === nodeType ||
              "NullLiteral" === nodeType ||
              "BooleanLiteral" === nodeType ||
              "RegExpLiteral" === nodeType ||
              "LogicalExpression" === nodeType ||
              "MemberExpression" === nodeType ||
              "NewExpression" === nodeType ||
              "ObjectExpression" === nodeType ||
              "SequenceExpression" === nodeType ||
              "ThisExpression" === nodeType ||
              "UnaryExpression" === nodeType ||
              "UpdateExpression" === nodeType ||
              "ArrowFunctionExpression" === nodeType ||
              "ClassExpression" === nodeType ||
              "MetaProperty" === nodeType ||
              "Super" === nodeType ||
              "TaggedTemplateExpression" === nodeType ||
              "TemplateLiteral" === nodeType ||
              "YieldExpression" === nodeType ||
              "TypeCastExpression" === nodeType ||
              "JSXElement" === nodeType ||
              "JSXFragment" === nodeType ||
              "ParenthesizedExpression" === nodeType ||
              "AwaitExpression" === nodeType ||
              "BindExpression" === nodeType ||
              "OptionalMemberExpression" === nodeType ||
              "OptionalCallExpression" === nodeType ||
              "Import" === nodeType ||
              "DoExpression" === nodeType ||
              "BigIntLiteral" === nodeType ||
              "TSAsExpression" === nodeType ||
              "TSTypeAssertion" === nodeType ||
              "TSNonNullExpression" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isBinary(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Binary" ||
              "BinaryExpression" === nodeType ||
              "LogicalExpression" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isScopable(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Scopable" ||
              "BlockStatement" === nodeType ||
              "CatchClause" === nodeType ||
              "DoWhileStatement" === nodeType ||
              "ForInStatement" === nodeType ||
              "ForStatement" === nodeType ||
              "FunctionDeclaration" === nodeType ||
              "FunctionExpression" === nodeType ||
              "Program" === nodeType ||
              "ObjectMethod" === nodeType ||
              "SwitchStatement" === nodeType ||
              "WhileStatement" === nodeType ||
              "ArrowFunctionExpression" === nodeType ||
              "ClassDeclaration" === nodeType ||
              "ClassExpression" === nodeType ||
              "ForOfStatement" === nodeType ||
              "ClassMethod" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isBlockParent(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "BlockParent" ||
              "BlockStatement" === nodeType ||
              "CatchClause" === nodeType ||
              "DoWhileStatement" === nodeType ||
              "ForInStatement" === nodeType ||
              "ForStatement" === nodeType ||
              "FunctionDeclaration" === nodeType ||
              "FunctionExpression" === nodeType ||
              "Program" === nodeType ||
              "ObjectMethod" === nodeType ||
              "SwitchStatement" === nodeType ||
              "WhileStatement" === nodeType ||
              "ArrowFunctionExpression" === nodeType ||
              "ForOfStatement" === nodeType ||
              "ClassMethod" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isBlock(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Block" ||
              "BlockStatement" === nodeType ||
              "Program" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Statement" ||
              "BlockStatement" === nodeType ||
              "BreakStatement" === nodeType ||
              "ContinueStatement" === nodeType ||
              "DebuggerStatement" === nodeType ||
              "DoWhileStatement" === nodeType ||
              "EmptyStatement" === nodeType ||
              "ExpressionStatement" === nodeType ||
              "ForInStatement" === nodeType ||
              "ForStatement" === nodeType ||
              "FunctionDeclaration" === nodeType ||
              "IfStatement" === nodeType ||
              "LabeledStatement" === nodeType ||
              "ReturnStatement" === nodeType ||
              "SwitchStatement" === nodeType ||
              "ThrowStatement" === nodeType ||
              "TryStatement" === nodeType ||
              "VariableDeclaration" === nodeType ||
              "WhileStatement" === nodeType ||
              "WithStatement" === nodeType ||
              "ClassDeclaration" === nodeType ||
              "ExportAllDeclaration" === nodeType ||
              "ExportDefaultDeclaration" === nodeType ||
              "ExportNamedDeclaration" === nodeType ||
              "ForOfStatement" === nodeType ||
              "ImportDeclaration" === nodeType ||
              "DeclareClass" === nodeType ||
              "DeclareFunction" === nodeType ||
              "DeclareInterface" === nodeType ||
              "DeclareModule" === nodeType ||
              "DeclareModuleExports" === nodeType ||
              "DeclareTypeAlias" === nodeType ||
              "DeclareOpaqueType" === nodeType ||
              "DeclareVariable" === nodeType ||
              "DeclareExportDeclaration" === nodeType ||
              "DeclareExportAllDeclaration" === nodeType ||
              "InterfaceDeclaration" === nodeType ||
              "OpaqueType" === nodeType ||
              "TypeAlias" === nodeType ||
              "TSDeclareFunction" === nodeType ||
              "TSInterfaceDeclaration" === nodeType ||
              "TSTypeAliasDeclaration" === nodeType ||
              "TSEnumDeclaration" === nodeType ||
              "TSModuleDeclaration" === nodeType ||
              "TSImportEqualsDeclaration" === nodeType ||
              "TSExportAssignment" === nodeType ||
              "TSNamespaceExportDeclaration" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTerminatorless(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Terminatorless" ||
              "BreakStatement" === nodeType ||
              "ContinueStatement" === nodeType ||
              "ReturnStatement" === nodeType ||
              "ThrowStatement" === nodeType ||
              "YieldExpression" === nodeType ||
              "AwaitExpression" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isCompletionStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "CompletionStatement" ||
              "BreakStatement" === nodeType ||
              "ContinueStatement" === nodeType ||
              "ReturnStatement" === nodeType ||
              "ThrowStatement" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isConditional(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Conditional" ||
              "ConditionalExpression" === nodeType ||
              "IfStatement" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isLoop(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Loop" ||
              "DoWhileStatement" === nodeType ||
              "ForInStatement" === nodeType ||
              "ForStatement" === nodeType ||
              "WhileStatement" === nodeType ||
              "ForOfStatement" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isWhile(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "While" ||
              "DoWhileStatement" === nodeType ||
              "WhileStatement" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isExpressionWrapper(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "ExpressionWrapper" ||
              "ExpressionStatement" === nodeType ||
              "TypeCastExpression" === nodeType ||
              "ParenthesizedExpression" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFor(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "For" ||
              "ForInStatement" === nodeType ||
              "ForStatement" === nodeType ||
              "ForOfStatement" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isForXStatement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "ForXStatement" ||
              "ForInStatement" === nodeType ||
              "ForOfStatement" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFunction(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Function" ||
              "FunctionDeclaration" === nodeType ||
              "FunctionExpression" === nodeType ||
              "ObjectMethod" === nodeType ||
              "ArrowFunctionExpression" === nodeType ||
              "ClassMethod" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFunctionParent(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "FunctionParent" ||
              "FunctionDeclaration" === nodeType ||
              "FunctionExpression" === nodeType ||
              "ObjectMethod" === nodeType ||
              "ArrowFunctionExpression" === nodeType ||
              "ClassMethod" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isPureish(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Pureish" ||
              "FunctionDeclaration" === nodeType ||
              "FunctionExpression" === nodeType ||
              "StringLiteral" === nodeType ||
              "NumericLiteral" === nodeType ||
              "NullLiteral" === nodeType ||
              "BooleanLiteral" === nodeType ||
              "ArrowFunctionExpression" === nodeType ||
              "ClassDeclaration" === nodeType ||
              "ClassExpression" === nodeType ||
              "BigIntLiteral" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Declaration" ||
              "FunctionDeclaration" === nodeType ||
              "VariableDeclaration" === nodeType ||
              "ClassDeclaration" === nodeType ||
              "ExportAllDeclaration" === nodeType ||
              "ExportDefaultDeclaration" === nodeType ||
              "ExportNamedDeclaration" === nodeType ||
              "ImportDeclaration" === nodeType ||
              "DeclareClass" === nodeType ||
              "DeclareFunction" === nodeType ||
              "DeclareInterface" === nodeType ||
              "DeclareModule" === nodeType ||
              "DeclareModuleExports" === nodeType ||
              "DeclareTypeAlias" === nodeType ||
              "DeclareOpaqueType" === nodeType ||
              "DeclareVariable" === nodeType ||
              "DeclareExportDeclaration" === nodeType ||
              "DeclareExportAllDeclaration" === nodeType ||
              "InterfaceDeclaration" === nodeType ||
              "OpaqueType" === nodeType ||
              "TypeAlias" === nodeType ||
              "TSDeclareFunction" === nodeType ||
              "TSInterfaceDeclaration" === nodeType ||
              "TSTypeAliasDeclaration" === nodeType ||
              "TSEnumDeclaration" === nodeType ||
              "TSModuleDeclaration" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isPatternLike(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "PatternLike" ||
              "Identifier" === nodeType ||
              "RestElement" === nodeType ||
              "AssignmentPattern" === nodeType ||
              "ArrayPattern" === nodeType ||
              "ObjectPattern" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isLVal(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "LVal" ||
              "Identifier" === nodeType ||
              "MemberExpression" === nodeType ||
              "RestElement" === nodeType ||
              "AssignmentPattern" === nodeType ||
              "ArrayPattern" === nodeType ||
              "ObjectPattern" === nodeType ||
              "TSParameterProperty" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSEntityName(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "TSEntityName" ||
              "Identifier" === nodeType ||
              "TSQualifiedName" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isLiteral(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Literal" ||
              "StringLiteral" === nodeType ||
              "NumericLiteral" === nodeType ||
              "NullLiteral" === nodeType ||
              "BooleanLiteral" === nodeType ||
              "RegExpLiteral" === nodeType ||
              "TemplateLiteral" === nodeType ||
              "BigIntLiteral" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isImmutable(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Immutable" ||
              "StringLiteral" === nodeType ||
              "NumericLiteral" === nodeType ||
              "NullLiteral" === nodeType ||
              "BooleanLiteral" === nodeType ||
              "JSXAttribute" === nodeType ||
              "JSXClosingElement" === nodeType ||
              "JSXElement" === nodeType ||
              "JSXExpressionContainer" === nodeType ||
              "JSXSpreadChild" === nodeType ||
              "JSXOpeningElement" === nodeType ||
              "JSXText" === nodeType ||
              "JSXFragment" === nodeType ||
              "JSXOpeningFragment" === nodeType ||
              "JSXClosingFragment" === nodeType ||
              "BigIntLiteral" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isUserWhitespacable(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "UserWhitespacable" ||
              "ObjectMethod" === nodeType ||
              "ObjectProperty" === nodeType ||
              "ObjectTypeInternalSlot" === nodeType ||
              "ObjectTypeCallProperty" === nodeType ||
              "ObjectTypeIndexer" === nodeType ||
              "ObjectTypeProperty" === nodeType ||
              "ObjectTypeSpreadProperty" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isMethod(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Method" ||
              "ObjectMethod" === nodeType ||
              "ClassMethod" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isObjectMember(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "ObjectMember" ||
              "ObjectMethod" === nodeType ||
              "ObjectProperty" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isProperty(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Property" ||
              "ObjectProperty" === nodeType ||
              "ClassProperty" === nodeType ||
              "ClassPrivateProperty" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isUnaryLike(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "UnaryLike" ||
              "UnaryExpression" === nodeType ||
              "SpreadElement" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isPattern(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Pattern" ||
              "AssignmentPattern" === nodeType ||
              "ArrayPattern" === nodeType ||
              "ObjectPattern" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isClass(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Class" ||
              "ClassDeclaration" === nodeType ||
              "ClassExpression" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isModuleDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "ModuleDeclaration" ||
              "ExportAllDeclaration" === nodeType ||
              "ExportDefaultDeclaration" === nodeType ||
              "ExportNamedDeclaration" === nodeType ||
              "ImportDeclaration" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isExportDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "ExportDeclaration" ||
              "ExportAllDeclaration" === nodeType ||
              "ExportDefaultDeclaration" === nodeType ||
              "ExportNamedDeclaration" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isModuleSpecifier(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "ModuleSpecifier" ||
              "ExportSpecifier" === nodeType ||
              "ImportDefaultSpecifier" === nodeType ||
              "ImportNamespaceSpecifier" === nodeType ||
              "ImportSpecifier" === nodeType ||
              "ExportDefaultSpecifier" === nodeType ||
              "ExportNamespaceSpecifier" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFlow(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Flow" ||
              "AnyTypeAnnotation" === nodeType ||
              "ArrayTypeAnnotation" === nodeType ||
              "BooleanTypeAnnotation" === nodeType ||
              "BooleanLiteralTypeAnnotation" === nodeType ||
              "NullLiteralTypeAnnotation" === nodeType ||
              "ClassImplements" === nodeType ||
              "DeclareClass" === nodeType ||
              "DeclareFunction" === nodeType ||
              "DeclareInterface" === nodeType ||
              "DeclareModule" === nodeType ||
              "DeclareModuleExports" === nodeType ||
              "DeclareTypeAlias" === nodeType ||
              "DeclareOpaqueType" === nodeType ||
              "DeclareVariable" === nodeType ||
              "DeclareExportDeclaration" === nodeType ||
              "DeclareExportAllDeclaration" === nodeType ||
              "DeclaredPredicate" === nodeType ||
              "ExistsTypeAnnotation" === nodeType ||
              "FunctionTypeAnnotation" === nodeType ||
              "FunctionTypeParam" === nodeType ||
              "GenericTypeAnnotation" === nodeType ||
              "InferredPredicate" === nodeType ||
              "InterfaceExtends" === nodeType ||
              "InterfaceDeclaration" === nodeType ||
              "InterfaceTypeAnnotation" === nodeType ||
              "IntersectionTypeAnnotation" === nodeType ||
              "MixedTypeAnnotation" === nodeType ||
              "EmptyTypeAnnotation" === nodeType ||
              "NullableTypeAnnotation" === nodeType ||
              "NumberLiteralTypeAnnotation" === nodeType ||
              "NumberTypeAnnotation" === nodeType ||
              "ObjectTypeAnnotation" === nodeType ||
              "ObjectTypeInternalSlot" === nodeType ||
              "ObjectTypeCallProperty" === nodeType ||
              "ObjectTypeIndexer" === nodeType ||
              "ObjectTypeProperty" === nodeType ||
              "ObjectTypeSpreadProperty" === nodeType ||
              "OpaqueType" === nodeType ||
              "QualifiedTypeIdentifier" === nodeType ||
              "StringLiteralTypeAnnotation" === nodeType ||
              "StringTypeAnnotation" === nodeType ||
              "ThisTypeAnnotation" === nodeType ||
              "TupleTypeAnnotation" === nodeType ||
              "TypeofTypeAnnotation" === nodeType ||
              "TypeAlias" === nodeType ||
              "TypeAnnotation" === nodeType ||
              "TypeCastExpression" === nodeType ||
              "TypeParameter" === nodeType ||
              "TypeParameterDeclaration" === nodeType ||
              "TypeParameterInstantiation" === nodeType ||
              "UnionTypeAnnotation" === nodeType ||
              "Variance" === nodeType ||
              "VoidTypeAnnotation" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFlowType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "FlowType" ||
              "AnyTypeAnnotation" === nodeType ||
              "ArrayTypeAnnotation" === nodeType ||
              "BooleanTypeAnnotation" === nodeType ||
              "BooleanLiteralTypeAnnotation" === nodeType ||
              "NullLiteralTypeAnnotation" === nodeType ||
              "ExistsTypeAnnotation" === nodeType ||
              "FunctionTypeAnnotation" === nodeType ||
              "GenericTypeAnnotation" === nodeType ||
              "InterfaceTypeAnnotation" === nodeType ||
              "IntersectionTypeAnnotation" === nodeType ||
              "MixedTypeAnnotation" === nodeType ||
              "EmptyTypeAnnotation" === nodeType ||
              "NullableTypeAnnotation" === nodeType ||
              "NumberLiteralTypeAnnotation" === nodeType ||
              "NumberTypeAnnotation" === nodeType ||
              "ObjectTypeAnnotation" === nodeType ||
              "StringLiteralTypeAnnotation" === nodeType ||
              "StringTypeAnnotation" === nodeType ||
              "ThisTypeAnnotation" === nodeType ||
              "TupleTypeAnnotation" === nodeType ||
              "TypeofTypeAnnotation" === nodeType ||
              "UnionTypeAnnotation" === nodeType ||
              "VoidTypeAnnotation" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFlowBaseAnnotation(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "FlowBaseAnnotation" ||
              "AnyTypeAnnotation" === nodeType ||
              "BooleanTypeAnnotation" === nodeType ||
              "NullLiteralTypeAnnotation" === nodeType ||
              "MixedTypeAnnotation" === nodeType ||
              "EmptyTypeAnnotation" === nodeType ||
              "NumberTypeAnnotation" === nodeType ||
              "StringTypeAnnotation" === nodeType ||
              "ThisTypeAnnotation" === nodeType ||
              "VoidTypeAnnotation" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFlowDeclaration(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "FlowDeclaration" ||
              "DeclareClass" === nodeType ||
              "DeclareFunction" === nodeType ||
              "DeclareInterface" === nodeType ||
              "DeclareModule" === nodeType ||
              "DeclareModuleExports" === nodeType ||
              "DeclareTypeAlias" === nodeType ||
              "DeclareOpaqueType" === nodeType ||
              "DeclareVariable" === nodeType ||
              "DeclareExportDeclaration" === nodeType ||
              "DeclareExportAllDeclaration" === nodeType ||
              "InterfaceDeclaration" === nodeType ||
              "OpaqueType" === nodeType ||
              "TypeAlias" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isFlowPredicate(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "FlowPredicate" ||
              "DeclaredPredicate" === nodeType ||
              "InferredPredicate" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isJSX(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "JSX" ||
              "JSXAttribute" === nodeType ||
              "JSXClosingElement" === nodeType ||
              "JSXElement" === nodeType ||
              "JSXEmptyExpression" === nodeType ||
              "JSXExpressionContainer" === nodeType ||
              "JSXSpreadChild" === nodeType ||
              "JSXIdentifier" === nodeType ||
              "JSXMemberExpression" === nodeType ||
              "JSXNamespacedName" === nodeType ||
              "JSXOpeningElement" === nodeType ||
              "JSXSpreadAttribute" === nodeType ||
              "JSXText" === nodeType ||
              "JSXFragment" === nodeType ||
              "JSXOpeningFragment" === nodeType ||
              "JSXClosingFragment" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isPrivate(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "Private" ||
              "ClassPrivateProperty" === nodeType ||
              "PrivateName" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSTypeElement(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "TSTypeElement" ||
              "TSCallSignatureDeclaration" === nodeType ||
              "TSConstructSignatureDeclaration" === nodeType ||
              "TSPropertySignature" === nodeType ||
              "TSMethodSignature" === nodeType ||
              "TSIndexSignature" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isTSType(node, opts) {
            if (!node) return false;
            var nodeType = node.type;

            if (
              nodeType === "TSType" ||
              "TSAnyKeyword" === nodeType ||
              "TSNumberKeyword" === nodeType ||
              "TSObjectKeyword" === nodeType ||
              "TSBooleanKeyword" === nodeType ||
              "TSStringKeyword" === nodeType ||
              "TSSymbolKeyword" === nodeType ||
              "TSVoidKeyword" === nodeType ||
              "TSUndefinedKeyword" === nodeType ||
              "TSNullKeyword" === nodeType ||
              "TSNeverKeyword" === nodeType ||
              "TSThisType" === nodeType ||
              "TSFunctionType" === nodeType ||
              "TSConstructorType" === nodeType ||
              "TSTypeReference" === nodeType ||
              "TSTypePredicate" === nodeType ||
              "TSTypeQuery" === nodeType ||
              "TSTypeLiteral" === nodeType ||
              "TSArrayType" === nodeType ||
              "TSTupleType" === nodeType ||
              "TSUnionType" === nodeType ||
              "TSIntersectionType" === nodeType ||
              "TSConditionalType" === nodeType ||
              "TSInferType" === nodeType ||
              "TSParenthesizedType" === nodeType ||
              "TSTypeOperator" === nodeType ||
              "TSIndexedAccessType" === nodeType ||
              "TSMappedType" === nodeType ||
              "TSLiteralType" === nodeType ||
              "TSExpressionWithTypeArguments" === nodeType
            ) {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isNumberLiteral(node, opts) {
            console.trace(
              "The node type NumberLiteral has been renamed to NumericLiteral"
            );
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "NumberLiteral") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isRegexLiteral(node, opts) {
            console.trace(
              "The node type RegexLiteral has been renamed to RegExpLiteral"
            );
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "RegexLiteral") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isRestProperty(node, opts) {
            console.trace(
              "The node type RestProperty has been renamed to RestElement"
            );
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "RestProperty") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }

          function isSpreadProperty(node, opts) {
            console.trace(
              "The node type SpreadProperty has been renamed to SpreadElement"
            );
            if (!node) return false;
            var nodeType = node.type;

            if (nodeType === "SpreadProperty") {
              if (typeof opts === "undefined") {
                return true;
              } else {
                return (0, _shallowEqual.default)(node, opts);
              }
            }

            return false;
          }
        },
        /* 3 */
        function(module, exports) {
          var process = (module.exports = {});
          var cachedSetTimeout;
          var cachedClearTimeout;

          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }

          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }

          (function() {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }

            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();

          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }

            if (
              (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
              setTimeout
            ) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }

            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }

          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }

            if (
              (cachedClearTimeout === defaultClearTimeout ||
                !cachedClearTimeout) &&
              clearTimeout
            ) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }

            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }

          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;

          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }

            draining = false;

            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }

            if (queue.length) {
              drainQueue();
            }
          }

          function drainQueue() {
            if (draining) {
              return;
            }

            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;

            while (len) {
              currentQueue = queue;
              queue = [];

              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }

              queueIndex = -1;
              len = queue.length;
            }

            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }

          process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);

            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }

            queue.push(new Item(fun, args));

            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };

          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }

          Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          };

          process.title = "browser";
          process.browser = true;
          process.env = {};
          process.argv = [];
          process.version = "";
          process.versions = {};

          function noop() {}

          process.on = noop;
          process.addListener = noop;
          process.once = noop;
          process.off = noop;
          process.removeListener = noop;
          process.removeAllListeners = noop;
          process.emit = noop;
          process.prependListener = noop;
          process.prependOnceListener = noop;

          process.listeners = function(name) {
            return [];
          };

          process.binding = function(name) {
            throw new Error("process.binding is not supported");
          };

          process.cwd = function() {
            return "/";
          };

          process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          };

          process.umask = function() {
            return 0;
          };
        },
        /* 4 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.arrayExpression = exports.ArrayExpression = ArrayExpression;
          exports.assignmentExpression = exports.AssignmentExpression = AssignmentExpression;
          exports.binaryExpression = exports.BinaryExpression = BinaryExpression;
          exports.interpreterDirective = exports.InterpreterDirective = InterpreterDirective;
          exports.directive = exports.Directive = Directive;
          exports.directiveLiteral = exports.DirectiveLiteral = DirectiveLiteral;
          exports.blockStatement = exports.BlockStatement = BlockStatement;
          exports.breakStatement = exports.BreakStatement = BreakStatement;
          exports.callExpression = exports.CallExpression = CallExpression;
          exports.catchClause = exports.CatchClause = CatchClause;
          exports.conditionalExpression = exports.ConditionalExpression = ConditionalExpression;
          exports.continueStatement = exports.ContinueStatement = ContinueStatement;
          exports.debuggerStatement = exports.DebuggerStatement = DebuggerStatement;
          exports.doWhileStatement = exports.DoWhileStatement = DoWhileStatement;
          exports.emptyStatement = exports.EmptyStatement = EmptyStatement;
          exports.expressionStatement = exports.ExpressionStatement = ExpressionStatement;
          exports.file = exports.File = File;
          exports.forInStatement = exports.ForInStatement = ForInStatement;
          exports.forStatement = exports.ForStatement = ForStatement;
          exports.functionDeclaration = exports.FunctionDeclaration = FunctionDeclaration;
          exports.functionExpression = exports.FunctionExpression = FunctionExpression;
          exports.identifier = exports.Identifier = Identifier;
          exports.ifStatement = exports.IfStatement = IfStatement;
          exports.labeledStatement = exports.LabeledStatement = LabeledStatement;
          exports.stringLiteral = exports.StringLiteral = StringLiteral;
          exports.numericLiteral = exports.NumericLiteral = NumericLiteral;
          exports.nullLiteral = exports.NullLiteral = NullLiteral;
          exports.booleanLiteral = exports.BooleanLiteral = BooleanLiteral;
          exports.regExpLiteral = exports.RegExpLiteral = RegExpLiteral;
          exports.logicalExpression = exports.LogicalExpression = LogicalExpression;
          exports.memberExpression = exports.MemberExpression = MemberExpression;
          exports.newExpression = exports.NewExpression = NewExpression;
          exports.program = exports.Program = Program;
          exports.objectExpression = exports.ObjectExpression = ObjectExpression;
          exports.objectMethod = exports.ObjectMethod = ObjectMethod;
          exports.objectProperty = exports.ObjectProperty = ObjectProperty;
          exports.restElement = exports.RestElement = RestElement;
          exports.returnStatement = exports.ReturnStatement = ReturnStatement;
          exports.sequenceExpression = exports.SequenceExpression = SequenceExpression;
          exports.switchCase = exports.SwitchCase = SwitchCase;
          exports.switchStatement = exports.SwitchStatement = SwitchStatement;
          exports.thisExpression = exports.ThisExpression = ThisExpression;
          exports.throwStatement = exports.ThrowStatement = ThrowStatement;
          exports.tryStatement = exports.TryStatement = TryStatement;
          exports.unaryExpression = exports.UnaryExpression = UnaryExpression;
          exports.updateExpression = exports.UpdateExpression = UpdateExpression;
          exports.variableDeclaration = exports.VariableDeclaration = VariableDeclaration;
          exports.variableDeclarator = exports.VariableDeclarator = VariableDeclarator;
          exports.whileStatement = exports.WhileStatement = WhileStatement;
          exports.withStatement = exports.WithStatement = WithStatement;
          exports.assignmentPattern = exports.AssignmentPattern = AssignmentPattern;
          exports.arrayPattern = exports.ArrayPattern = ArrayPattern;
          exports.arrowFunctionExpression = exports.ArrowFunctionExpression = ArrowFunctionExpression;
          exports.classBody = exports.ClassBody = ClassBody;
          exports.classDeclaration = exports.ClassDeclaration = ClassDeclaration;
          exports.classExpression = exports.ClassExpression = ClassExpression;
          exports.exportAllDeclaration = exports.ExportAllDeclaration = ExportAllDeclaration;
          exports.exportDefaultDeclaration = exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
          exports.exportNamedDeclaration = exports.ExportNamedDeclaration = ExportNamedDeclaration;
          exports.exportSpecifier = exports.ExportSpecifier = ExportSpecifier;
          exports.forOfStatement = exports.ForOfStatement = ForOfStatement;
          exports.importDeclaration = exports.ImportDeclaration = ImportDeclaration;
          exports.importDefaultSpecifier = exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
          exports.importNamespaceSpecifier = exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
          exports.importSpecifier = exports.ImportSpecifier = ImportSpecifier;
          exports.metaProperty = exports.MetaProperty = MetaProperty;
          exports.classMethod = exports.ClassMethod = ClassMethod;
          exports.objectPattern = exports.ObjectPattern = ObjectPattern;
          exports.spreadElement = exports.SpreadElement = SpreadElement;
          exports.super = exports.Super = Super;
          exports.taggedTemplateExpression = exports.TaggedTemplateExpression = TaggedTemplateExpression;
          exports.templateElement = exports.TemplateElement = TemplateElement;
          exports.templateLiteral = exports.TemplateLiteral = TemplateLiteral;
          exports.yieldExpression = exports.YieldExpression = YieldExpression;
          exports.anyTypeAnnotation = exports.AnyTypeAnnotation = AnyTypeAnnotation;
          exports.arrayTypeAnnotation = exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
          exports.booleanTypeAnnotation = exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
          exports.booleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
          exports.nullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
          exports.classImplements = exports.ClassImplements = ClassImplements;
          exports.declareClass = exports.DeclareClass = DeclareClass;
          exports.declareFunction = exports.DeclareFunction = DeclareFunction;
          exports.declareInterface = exports.DeclareInterface = DeclareInterface;
          exports.declareModule = exports.DeclareModule = DeclareModule;
          exports.declareModuleExports = exports.DeclareModuleExports = DeclareModuleExports;
          exports.declareTypeAlias = exports.DeclareTypeAlias = DeclareTypeAlias;
          exports.declareOpaqueType = exports.DeclareOpaqueType = DeclareOpaqueType;
          exports.declareVariable = exports.DeclareVariable = DeclareVariable;
          exports.declareExportDeclaration = exports.DeclareExportDeclaration = DeclareExportDeclaration;
          exports.declareExportAllDeclaration = exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
          exports.declaredPredicate = exports.DeclaredPredicate = DeclaredPredicate;
          exports.existsTypeAnnotation = exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
          exports.functionTypeAnnotation = exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
          exports.functionTypeParam = exports.FunctionTypeParam = FunctionTypeParam;
          exports.genericTypeAnnotation = exports.GenericTypeAnnotation = GenericTypeAnnotation;
          exports.inferredPredicate = exports.InferredPredicate = InferredPredicate;
          exports.interfaceExtends = exports.InterfaceExtends = InterfaceExtends;
          exports.interfaceDeclaration = exports.InterfaceDeclaration = InterfaceDeclaration;
          exports.interfaceTypeAnnotation = exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
          exports.intersectionTypeAnnotation = exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
          exports.mixedTypeAnnotation = exports.MixedTypeAnnotation = MixedTypeAnnotation;
          exports.emptyTypeAnnotation = exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
          exports.nullableTypeAnnotation = exports.NullableTypeAnnotation = NullableTypeAnnotation;
          exports.numberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = NumberLiteralTypeAnnotation;
          exports.numberTypeAnnotation = exports.NumberTypeAnnotation = NumberTypeAnnotation;
          exports.objectTypeAnnotation = exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
          exports.objectTypeInternalSlot = exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
          exports.objectTypeCallProperty = exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
          exports.objectTypeIndexer = exports.ObjectTypeIndexer = ObjectTypeIndexer;
          exports.objectTypeProperty = exports.ObjectTypeProperty = ObjectTypeProperty;
          exports.objectTypeSpreadProperty = exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
          exports.opaqueType = exports.OpaqueType = OpaqueType;
          exports.qualifiedTypeIdentifier = exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
          exports.stringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotation = StringLiteralTypeAnnotation;
          exports.stringTypeAnnotation = exports.StringTypeAnnotation = StringTypeAnnotation;
          exports.thisTypeAnnotation = exports.ThisTypeAnnotation = ThisTypeAnnotation;
          exports.tupleTypeAnnotation = exports.TupleTypeAnnotation = TupleTypeAnnotation;
          exports.typeofTypeAnnotation = exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
          exports.typeAlias = exports.TypeAlias = TypeAlias;
          exports.typeAnnotation = exports.TypeAnnotation = TypeAnnotation;
          exports.typeCastExpression = exports.TypeCastExpression = TypeCastExpression;
          exports.typeParameter = exports.TypeParameter = TypeParameter;
          exports.typeParameterDeclaration = exports.TypeParameterDeclaration = TypeParameterDeclaration;
          exports.typeParameterInstantiation = exports.TypeParameterInstantiation = TypeParameterInstantiation;
          exports.unionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
          exports.variance = exports.Variance = Variance;
          exports.voidTypeAnnotation = exports.VoidTypeAnnotation = VoidTypeAnnotation;
          exports.jSXAttribute = exports.jsxAttribute = exports.JSXAttribute = JSXAttribute;
          exports.jSXClosingElement = exports.jsxClosingElement = exports.JSXClosingElement = JSXClosingElement;
          exports.jSXElement = exports.jsxElement = exports.JSXElement = JSXElement;
          exports.jSXEmptyExpression = exports.jsxEmptyExpression = exports.JSXEmptyExpression = JSXEmptyExpression;
          exports.jSXExpressionContainer = exports.jsxExpressionContainer = exports.JSXExpressionContainer = JSXExpressionContainer;
          exports.jSXSpreadChild = exports.jsxSpreadChild = exports.JSXSpreadChild = JSXSpreadChild;
          exports.jSXIdentifier = exports.jsxIdentifier = exports.JSXIdentifier = JSXIdentifier;
          exports.jSXMemberExpression = exports.jsxMemberExpression = exports.JSXMemberExpression = JSXMemberExpression;
          exports.jSXNamespacedName = exports.jsxNamespacedName = exports.JSXNamespacedName = JSXNamespacedName;
          exports.jSXOpeningElement = exports.jsxOpeningElement = exports.JSXOpeningElement = JSXOpeningElement;
          exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = exports.JSXSpreadAttribute = JSXSpreadAttribute;
          exports.jSXText = exports.jsxText = exports.JSXText = JSXText;
          exports.jSXFragment = exports.jsxFragment = exports.JSXFragment = JSXFragment;
          exports.jSXOpeningFragment = exports.jsxOpeningFragment = exports.JSXOpeningFragment = JSXOpeningFragment;
          exports.jSXClosingFragment = exports.jsxClosingFragment = exports.JSXClosingFragment = JSXClosingFragment;
          exports.noop = exports.Noop = Noop;
          exports.parenthesizedExpression = exports.ParenthesizedExpression = ParenthesizedExpression;
          exports.awaitExpression = exports.AwaitExpression = AwaitExpression;
          exports.bindExpression = exports.BindExpression = BindExpression;
          exports.classProperty = exports.ClassProperty = ClassProperty;
          exports.optionalMemberExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
          exports.optionalCallExpression = exports.OptionalCallExpression = OptionalCallExpression;
          exports.classPrivateProperty = exports.ClassPrivateProperty = ClassPrivateProperty;
          exports.import = exports.Import = Import;
          exports.decorator = exports.Decorator = Decorator;
          exports.doExpression = exports.DoExpression = DoExpression;
          exports.exportDefaultSpecifier = exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
          exports.exportNamespaceSpecifier = exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
          exports.privateName = exports.PrivateName = PrivateName;
          exports.bigIntLiteral = exports.BigIntLiteral = BigIntLiteral;
          exports.tSParameterProperty = exports.tsParameterProperty = exports.TSParameterProperty = TSParameterProperty;
          exports.tSDeclareFunction = exports.tsDeclareFunction = exports.TSDeclareFunction = TSDeclareFunction;
          exports.tSDeclareMethod = exports.tsDeclareMethod = exports.TSDeclareMethod = TSDeclareMethod;
          exports.tSQualifiedName = exports.tsQualifiedName = exports.TSQualifiedName = TSQualifiedName;
          exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
          exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
          exports.tSPropertySignature = exports.tsPropertySignature = exports.TSPropertySignature = TSPropertySignature;
          exports.tSMethodSignature = exports.tsMethodSignature = exports.TSMethodSignature = TSMethodSignature;
          exports.tSIndexSignature = exports.tsIndexSignature = exports.TSIndexSignature = TSIndexSignature;
          exports.tSAnyKeyword = exports.tsAnyKeyword = exports.TSAnyKeyword = TSAnyKeyword;
          exports.tSNumberKeyword = exports.tsNumberKeyword = exports.TSNumberKeyword = TSNumberKeyword;
          exports.tSObjectKeyword = exports.tsObjectKeyword = exports.TSObjectKeyword = TSObjectKeyword;
          exports.tSBooleanKeyword = exports.tsBooleanKeyword = exports.TSBooleanKeyword = TSBooleanKeyword;
          exports.tSStringKeyword = exports.tsStringKeyword = exports.TSStringKeyword = TSStringKeyword;
          exports.tSSymbolKeyword = exports.tsSymbolKeyword = exports.TSSymbolKeyword = TSSymbolKeyword;
          exports.tSVoidKeyword = exports.tsVoidKeyword = exports.TSVoidKeyword = TSVoidKeyword;
          exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = exports.TSUndefinedKeyword = TSUndefinedKeyword;
          exports.tSNullKeyword = exports.tsNullKeyword = exports.TSNullKeyword = TSNullKeyword;
          exports.tSNeverKeyword = exports.tsNeverKeyword = exports.TSNeverKeyword = TSNeverKeyword;
          exports.tSThisType = exports.tsThisType = exports.TSThisType = TSThisType;
          exports.tSFunctionType = exports.tsFunctionType = exports.TSFunctionType = TSFunctionType;
          exports.tSConstructorType = exports.tsConstructorType = exports.TSConstructorType = TSConstructorType;
          exports.tSTypeReference = exports.tsTypeReference = exports.TSTypeReference = TSTypeReference;
          exports.tSTypePredicate = exports.tsTypePredicate = exports.TSTypePredicate = TSTypePredicate;
          exports.tSTypeQuery = exports.tsTypeQuery = exports.TSTypeQuery = TSTypeQuery;
          exports.tSTypeLiteral = exports.tsTypeLiteral = exports.TSTypeLiteral = TSTypeLiteral;
          exports.tSArrayType = exports.tsArrayType = exports.TSArrayType = TSArrayType;
          exports.tSTupleType = exports.tsTupleType = exports.TSTupleType = TSTupleType;
          exports.tSUnionType = exports.tsUnionType = exports.TSUnionType = TSUnionType;
          exports.tSIntersectionType = exports.tsIntersectionType = exports.TSIntersectionType = TSIntersectionType;
          exports.tSConditionalType = exports.tsConditionalType = exports.TSConditionalType = TSConditionalType;
          exports.tSInferType = exports.tsInferType = exports.TSInferType = TSInferType;
          exports.tSParenthesizedType = exports.tsParenthesizedType = exports.TSParenthesizedType = TSParenthesizedType;
          exports.tSTypeOperator = exports.tsTypeOperator = exports.TSTypeOperator = TSTypeOperator;
          exports.tSIndexedAccessType = exports.tsIndexedAccessType = exports.TSIndexedAccessType = TSIndexedAccessType;
          exports.tSMappedType = exports.tsMappedType = exports.TSMappedType = TSMappedType;
          exports.tSLiteralType = exports.tsLiteralType = exports.TSLiteralType = TSLiteralType;
          exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
          exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
          exports.tSInterfaceBody = exports.tsInterfaceBody = exports.TSInterfaceBody = TSInterfaceBody;
          exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
          exports.tSAsExpression = exports.tsAsExpression = exports.TSAsExpression = TSAsExpression;
          exports.tSTypeAssertion = exports.tsTypeAssertion = exports.TSTypeAssertion = TSTypeAssertion;
          exports.tSEnumDeclaration = exports.tsEnumDeclaration = exports.TSEnumDeclaration = TSEnumDeclaration;
          exports.tSEnumMember = exports.tsEnumMember = exports.TSEnumMember = TSEnumMember;
          exports.tSModuleDeclaration = exports.tsModuleDeclaration = exports.TSModuleDeclaration = TSModuleDeclaration;
          exports.tSModuleBlock = exports.tsModuleBlock = exports.TSModuleBlock = TSModuleBlock;
          exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
          exports.tSExternalModuleReference = exports.tsExternalModuleReference = exports.TSExternalModuleReference = TSExternalModuleReference;
          exports.tSNonNullExpression = exports.tsNonNullExpression = exports.TSNonNullExpression = TSNonNullExpression;
          exports.tSExportAssignment = exports.tsExportAssignment = exports.TSExportAssignment = TSExportAssignment;
          exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
          exports.tSTypeAnnotation = exports.tsTypeAnnotation = exports.TSTypeAnnotation = TSTypeAnnotation;
          exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
          exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = exports.TSTypeParameterDeclaration = TSTypeParameterDeclaration;
          exports.tSTypeParameter = exports.tsTypeParameter = exports.TSTypeParameter = TSTypeParameter;
          exports.numberLiteral = exports.NumberLiteral = NumberLiteral;
          exports.regexLiteral = exports.RegexLiteral = RegexLiteral;
          exports.restProperty = exports.RestProperty = RestProperty;
          exports.spreadProperty = exports.SpreadProperty = SpreadProperty;

          var _builder = _interopRequireDefault(__webpack_require__(181));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function ArrayExpression() {
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ArrayExpression"].concat(args)
            );
          }

          function AssignmentExpression() {
            for (
              var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
              _key2 < _len2;
              _key2++
            ) {
              args[_key2] = arguments[_key2];
            }

            return (0, _builder.default).apply(
              void 0,
              ["AssignmentExpression"].concat(args)
            );
          }

          function BinaryExpression() {
            for (
              var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;
              _key3 < _len3;
              _key3++
            ) {
              args[_key3] = arguments[_key3];
            }

            return (0, _builder.default).apply(
              void 0,
              ["BinaryExpression"].concat(args)
            );
          }

          function InterpreterDirective() {
            for (
              var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;
              _key4 < _len4;
              _key4++
            ) {
              args[_key4] = arguments[_key4];
            }

            return (0, _builder.default).apply(
              void 0,
              ["InterpreterDirective"].concat(args)
            );
          }

          function Directive() {
            for (
              var _len5 = arguments.length, args = new Array(_len5), _key5 = 0;
              _key5 < _len5;
              _key5++
            ) {
              args[_key5] = arguments[_key5];
            }

            return (0, _builder.default).apply(
              void 0,
              ["Directive"].concat(args)
            );
          }

          function DirectiveLiteral() {
            for (
              var _len6 = arguments.length, args = new Array(_len6), _key6 = 0;
              _key6 < _len6;
              _key6++
            ) {
              args[_key6] = arguments[_key6];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DirectiveLiteral"].concat(args)
            );
          }

          function BlockStatement() {
            for (
              var _len7 = arguments.length, args = new Array(_len7), _key7 = 0;
              _key7 < _len7;
              _key7++
            ) {
              args[_key7] = arguments[_key7];
            }

            return (0, _builder.default).apply(
              void 0,
              ["BlockStatement"].concat(args)
            );
          }

          function BreakStatement() {
            for (
              var _len8 = arguments.length, args = new Array(_len8), _key8 = 0;
              _key8 < _len8;
              _key8++
            ) {
              args[_key8] = arguments[_key8];
            }

            return (0, _builder.default).apply(
              void 0,
              ["BreakStatement"].concat(args)
            );
          }

          function CallExpression() {
            for (
              var _len9 = arguments.length, args = new Array(_len9), _key9 = 0;
              _key9 < _len9;
              _key9++
            ) {
              args[_key9] = arguments[_key9];
            }

            return (0, _builder.default).apply(
              void 0,
              ["CallExpression"].concat(args)
            );
          }

          function CatchClause() {
            for (
              var _len10 = arguments.length,
                args = new Array(_len10),
                _key10 = 0;
              _key10 < _len10;
              _key10++
            ) {
              args[_key10] = arguments[_key10];
            }

            return (0, _builder.default).apply(
              void 0,
              ["CatchClause"].concat(args)
            );
          }

          function ConditionalExpression() {
            for (
              var _len11 = arguments.length,
                args = new Array(_len11),
                _key11 = 0;
              _key11 < _len11;
              _key11++
            ) {
              args[_key11] = arguments[_key11];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ConditionalExpression"].concat(args)
            );
          }

          function ContinueStatement() {
            for (
              var _len12 = arguments.length,
                args = new Array(_len12),
                _key12 = 0;
              _key12 < _len12;
              _key12++
            ) {
              args[_key12] = arguments[_key12];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ContinueStatement"].concat(args)
            );
          }

          function DebuggerStatement() {
            for (
              var _len13 = arguments.length,
                args = new Array(_len13),
                _key13 = 0;
              _key13 < _len13;
              _key13++
            ) {
              args[_key13] = arguments[_key13];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DebuggerStatement"].concat(args)
            );
          }

          function DoWhileStatement() {
            for (
              var _len14 = arguments.length,
                args = new Array(_len14),
                _key14 = 0;
              _key14 < _len14;
              _key14++
            ) {
              args[_key14] = arguments[_key14];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DoWhileStatement"].concat(args)
            );
          }

          function EmptyStatement() {
            for (
              var _len15 = arguments.length,
                args = new Array(_len15),
                _key15 = 0;
              _key15 < _len15;
              _key15++
            ) {
              args[_key15] = arguments[_key15];
            }

            return (0, _builder.default).apply(
              void 0,
              ["EmptyStatement"].concat(args)
            );
          }

          function ExpressionStatement() {
            for (
              var _len16 = arguments.length,
                args = new Array(_len16),
                _key16 = 0;
              _key16 < _len16;
              _key16++
            ) {
              args[_key16] = arguments[_key16];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ExpressionStatement"].concat(args)
            );
          }

          function File() {
            for (
              var _len17 = arguments.length,
                args = new Array(_len17),
                _key17 = 0;
              _key17 < _len17;
              _key17++
            ) {
              args[_key17] = arguments[_key17];
            }

            return (0, _builder.default).apply(void 0, ["File"].concat(args));
          }

          function ForInStatement() {
            for (
              var _len18 = arguments.length,
                args = new Array(_len18),
                _key18 = 0;
              _key18 < _len18;
              _key18++
            ) {
              args[_key18] = arguments[_key18];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ForInStatement"].concat(args)
            );
          }

          function ForStatement() {
            for (
              var _len19 = arguments.length,
                args = new Array(_len19),
                _key19 = 0;
              _key19 < _len19;
              _key19++
            ) {
              args[_key19] = arguments[_key19];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ForStatement"].concat(args)
            );
          }

          function FunctionDeclaration() {
            for (
              var _len20 = arguments.length,
                args = new Array(_len20),
                _key20 = 0;
              _key20 < _len20;
              _key20++
            ) {
              args[_key20] = arguments[_key20];
            }

            return (0, _builder.default).apply(
              void 0,
              ["FunctionDeclaration"].concat(args)
            );
          }

          function FunctionExpression() {
            for (
              var _len21 = arguments.length,
                args = new Array(_len21),
                _key21 = 0;
              _key21 < _len21;
              _key21++
            ) {
              args[_key21] = arguments[_key21];
            }

            return (0, _builder.default).apply(
              void 0,
              ["FunctionExpression"].concat(args)
            );
          }

          function Identifier() {
            for (
              var _len22 = arguments.length,
                args = new Array(_len22),
                _key22 = 0;
              _key22 < _len22;
              _key22++
            ) {
              args[_key22] = arguments[_key22];
            }

            return (0, _builder.default).apply(
              void 0,
              ["Identifier"].concat(args)
            );
          }

          function IfStatement() {
            for (
              var _len23 = arguments.length,
                args = new Array(_len23),
                _key23 = 0;
              _key23 < _len23;
              _key23++
            ) {
              args[_key23] = arguments[_key23];
            }

            return (0, _builder.default).apply(
              void 0,
              ["IfStatement"].concat(args)
            );
          }

          function LabeledStatement() {
            for (
              var _len24 = arguments.length,
                args = new Array(_len24),
                _key24 = 0;
              _key24 < _len24;
              _key24++
            ) {
              args[_key24] = arguments[_key24];
            }

            return (0, _builder.default).apply(
              void 0,
              ["LabeledStatement"].concat(args)
            );
          }

          function StringLiteral() {
            for (
              var _len25 = arguments.length,
                args = new Array(_len25),
                _key25 = 0;
              _key25 < _len25;
              _key25++
            ) {
              args[_key25] = arguments[_key25];
            }

            return (0, _builder.default).apply(
              void 0,
              ["StringLiteral"].concat(args)
            );
          }

          function NumericLiteral() {
            for (
              var _len26 = arguments.length,
                args = new Array(_len26),
                _key26 = 0;
              _key26 < _len26;
              _key26++
            ) {
              args[_key26] = arguments[_key26];
            }

            return (0, _builder.default).apply(
              void 0,
              ["NumericLiteral"].concat(args)
            );
          }

          function NullLiteral() {
            for (
              var _len27 = arguments.length,
                args = new Array(_len27),
                _key27 = 0;
              _key27 < _len27;
              _key27++
            ) {
              args[_key27] = arguments[_key27];
            }

            return (0, _builder.default).apply(
              void 0,
              ["NullLiteral"].concat(args)
            );
          }

          function BooleanLiteral() {
            for (
              var _len28 = arguments.length,
                args = new Array(_len28),
                _key28 = 0;
              _key28 < _len28;
              _key28++
            ) {
              args[_key28] = arguments[_key28];
            }

            return (0, _builder.default).apply(
              void 0,
              ["BooleanLiteral"].concat(args)
            );
          }

          function RegExpLiteral() {
            for (
              var _len29 = arguments.length,
                args = new Array(_len29),
                _key29 = 0;
              _key29 < _len29;
              _key29++
            ) {
              args[_key29] = arguments[_key29];
            }

            return (0, _builder.default).apply(
              void 0,
              ["RegExpLiteral"].concat(args)
            );
          }

          function LogicalExpression() {
            for (
              var _len30 = arguments.length,
                args = new Array(_len30),
                _key30 = 0;
              _key30 < _len30;
              _key30++
            ) {
              args[_key30] = arguments[_key30];
            }

            return (0, _builder.default).apply(
              void 0,
              ["LogicalExpression"].concat(args)
            );
          }

          function MemberExpression() {
            for (
              var _len31 = arguments.length,
                args = new Array(_len31),
                _key31 = 0;
              _key31 < _len31;
              _key31++
            ) {
              args[_key31] = arguments[_key31];
            }

            return (0, _builder.default).apply(
              void 0,
              ["MemberExpression"].concat(args)
            );
          }

          function NewExpression() {
            for (
              var _len32 = arguments.length,
                args = new Array(_len32),
                _key32 = 0;
              _key32 < _len32;
              _key32++
            ) {
              args[_key32] = arguments[_key32];
            }

            return (0, _builder.default).apply(
              void 0,
              ["NewExpression"].concat(args)
            );
          }

          function Program() {
            for (
              var _len33 = arguments.length,
                args = new Array(_len33),
                _key33 = 0;
              _key33 < _len33;
              _key33++
            ) {
              args[_key33] = arguments[_key33];
            }

            return (0, _builder.default).apply(
              void 0,
              ["Program"].concat(args)
            );
          }

          function ObjectExpression() {
            for (
              var _len34 = arguments.length,
                args = new Array(_len34),
                _key34 = 0;
              _key34 < _len34;
              _key34++
            ) {
              args[_key34] = arguments[_key34];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ObjectExpression"].concat(args)
            );
          }

          function ObjectMethod() {
            for (
              var _len35 = arguments.length,
                args = new Array(_len35),
                _key35 = 0;
              _key35 < _len35;
              _key35++
            ) {
              args[_key35] = arguments[_key35];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ObjectMethod"].concat(args)
            );
          }

          function ObjectProperty() {
            for (
              var _len36 = arguments.length,
                args = new Array(_len36),
                _key36 = 0;
              _key36 < _len36;
              _key36++
            ) {
              args[_key36] = arguments[_key36];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ObjectProperty"].concat(args)
            );
          }

          function RestElement() {
            for (
              var _len37 = arguments.length,
                args = new Array(_len37),
                _key37 = 0;
              _key37 < _len37;
              _key37++
            ) {
              args[_key37] = arguments[_key37];
            }

            return (0, _builder.default).apply(
              void 0,
              ["RestElement"].concat(args)
            );
          }

          function ReturnStatement() {
            for (
              var _len38 = arguments.length,
                args = new Array(_len38),
                _key38 = 0;
              _key38 < _len38;
              _key38++
            ) {
              args[_key38] = arguments[_key38];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ReturnStatement"].concat(args)
            );
          }

          function SequenceExpression() {
            for (
              var _len39 = arguments.length,
                args = new Array(_len39),
                _key39 = 0;
              _key39 < _len39;
              _key39++
            ) {
              args[_key39] = arguments[_key39];
            }

            return (0, _builder.default).apply(
              void 0,
              ["SequenceExpression"].concat(args)
            );
          }

          function SwitchCase() {
            for (
              var _len40 = arguments.length,
                args = new Array(_len40),
                _key40 = 0;
              _key40 < _len40;
              _key40++
            ) {
              args[_key40] = arguments[_key40];
            }

            return (0, _builder.default).apply(
              void 0,
              ["SwitchCase"].concat(args)
            );
          }

          function SwitchStatement() {
            for (
              var _len41 = arguments.length,
                args = new Array(_len41),
                _key41 = 0;
              _key41 < _len41;
              _key41++
            ) {
              args[_key41] = arguments[_key41];
            }

            return (0, _builder.default).apply(
              void 0,
              ["SwitchStatement"].concat(args)
            );
          }

          function ThisExpression() {
            for (
              var _len42 = arguments.length,
                args = new Array(_len42),
                _key42 = 0;
              _key42 < _len42;
              _key42++
            ) {
              args[_key42] = arguments[_key42];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ThisExpression"].concat(args)
            );
          }

          function ThrowStatement() {
            for (
              var _len43 = arguments.length,
                args = new Array(_len43),
                _key43 = 0;
              _key43 < _len43;
              _key43++
            ) {
              args[_key43] = arguments[_key43];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ThrowStatement"].concat(args)
            );
          }

          function TryStatement() {
            for (
              var _len44 = arguments.length,
                args = new Array(_len44),
                _key44 = 0;
              _key44 < _len44;
              _key44++
            ) {
              args[_key44] = arguments[_key44];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TryStatement"].concat(args)
            );
          }

          function UnaryExpression() {
            for (
              var _len45 = arguments.length,
                args = new Array(_len45),
                _key45 = 0;
              _key45 < _len45;
              _key45++
            ) {
              args[_key45] = arguments[_key45];
            }

            return (0, _builder.default).apply(
              void 0,
              ["UnaryExpression"].concat(args)
            );
          }

          function UpdateExpression() {
            for (
              var _len46 = arguments.length,
                args = new Array(_len46),
                _key46 = 0;
              _key46 < _len46;
              _key46++
            ) {
              args[_key46] = arguments[_key46];
            }

            return (0, _builder.default).apply(
              void 0,
              ["UpdateExpression"].concat(args)
            );
          }

          function VariableDeclaration() {
            for (
              var _len47 = arguments.length,
                args = new Array(_len47),
                _key47 = 0;
              _key47 < _len47;
              _key47++
            ) {
              args[_key47] = arguments[_key47];
            }

            return (0, _builder.default).apply(
              void 0,
              ["VariableDeclaration"].concat(args)
            );
          }

          function VariableDeclarator() {
            for (
              var _len48 = arguments.length,
                args = new Array(_len48),
                _key48 = 0;
              _key48 < _len48;
              _key48++
            ) {
              args[_key48] = arguments[_key48];
            }

            return (0, _builder.default).apply(
              void 0,
              ["VariableDeclarator"].concat(args)
            );
          }

          function WhileStatement() {
            for (
              var _len49 = arguments.length,
                args = new Array(_len49),
                _key49 = 0;
              _key49 < _len49;
              _key49++
            ) {
              args[_key49] = arguments[_key49];
            }

            return (0, _builder.default).apply(
              void 0,
              ["WhileStatement"].concat(args)
            );
          }

          function WithStatement() {
            for (
              var _len50 = arguments.length,
                args = new Array(_len50),
                _key50 = 0;
              _key50 < _len50;
              _key50++
            ) {
              args[_key50] = arguments[_key50];
            }

            return (0, _builder.default).apply(
              void 0,
              ["WithStatement"].concat(args)
            );
          }

          function AssignmentPattern() {
            for (
              var _len51 = arguments.length,
                args = new Array(_len51),
                _key51 = 0;
              _key51 < _len51;
              _key51++
            ) {
              args[_key51] = arguments[_key51];
            }

            return (0, _builder.default).apply(
              void 0,
              ["AssignmentPattern"].concat(args)
            );
          }

          function ArrayPattern() {
            for (
              var _len52 = arguments.length,
                args = new Array(_len52),
                _key52 = 0;
              _key52 < _len52;
              _key52++
            ) {
              args[_key52] = arguments[_key52];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ArrayPattern"].concat(args)
            );
          }

          function ArrowFunctionExpression() {
            for (
              var _len53 = arguments.length,
                args = new Array(_len53),
                _key53 = 0;
              _key53 < _len53;
              _key53++
            ) {
              args[_key53] = arguments[_key53];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ArrowFunctionExpression"].concat(args)
            );
          }

          function ClassBody() {
            for (
              var _len54 = arguments.length,
                args = new Array(_len54),
                _key54 = 0;
              _key54 < _len54;
              _key54++
            ) {
              args[_key54] = arguments[_key54];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ClassBody"].concat(args)
            );
          }

          function ClassDeclaration() {
            for (
              var _len55 = arguments.length,
                args = new Array(_len55),
                _key55 = 0;
              _key55 < _len55;
              _key55++
            ) {
              args[_key55] = arguments[_key55];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ClassDeclaration"].concat(args)
            );
          }

          function ClassExpression() {
            for (
              var _len56 = arguments.length,
                args = new Array(_len56),
                _key56 = 0;
              _key56 < _len56;
              _key56++
            ) {
              args[_key56] = arguments[_key56];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ClassExpression"].concat(args)
            );
          }

          function ExportAllDeclaration() {
            for (
              var _len57 = arguments.length,
                args = new Array(_len57),
                _key57 = 0;
              _key57 < _len57;
              _key57++
            ) {
              args[_key57] = arguments[_key57];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ExportAllDeclaration"].concat(args)
            );
          }

          function ExportDefaultDeclaration() {
            for (
              var _len58 = arguments.length,
                args = new Array(_len58),
                _key58 = 0;
              _key58 < _len58;
              _key58++
            ) {
              args[_key58] = arguments[_key58];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ExportDefaultDeclaration"].concat(args)
            );
          }

          function ExportNamedDeclaration() {
            for (
              var _len59 = arguments.length,
                args = new Array(_len59),
                _key59 = 0;
              _key59 < _len59;
              _key59++
            ) {
              args[_key59] = arguments[_key59];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ExportNamedDeclaration"].concat(args)
            );
          }

          function ExportSpecifier() {
            for (
              var _len60 = arguments.length,
                args = new Array(_len60),
                _key60 = 0;
              _key60 < _len60;
              _key60++
            ) {
              args[_key60] = arguments[_key60];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ExportSpecifier"].concat(args)
            );
          }

          function ForOfStatement() {
            for (
              var _len61 = arguments.length,
                args = new Array(_len61),
                _key61 = 0;
              _key61 < _len61;
              _key61++
            ) {
              args[_key61] = arguments[_key61];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ForOfStatement"].concat(args)
            );
          }

          function ImportDeclaration() {
            for (
              var _len62 = arguments.length,
                args = new Array(_len62),
                _key62 = 0;
              _key62 < _len62;
              _key62++
            ) {
              args[_key62] = arguments[_key62];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ImportDeclaration"].concat(args)
            );
          }

          function ImportDefaultSpecifier() {
            for (
              var _len63 = arguments.length,
                args = new Array(_len63),
                _key63 = 0;
              _key63 < _len63;
              _key63++
            ) {
              args[_key63] = arguments[_key63];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ImportDefaultSpecifier"].concat(args)
            );
          }

          function ImportNamespaceSpecifier() {
            for (
              var _len64 = arguments.length,
                args = new Array(_len64),
                _key64 = 0;
              _key64 < _len64;
              _key64++
            ) {
              args[_key64] = arguments[_key64];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ImportNamespaceSpecifier"].concat(args)
            );
          }

          function ImportSpecifier() {
            for (
              var _len65 = arguments.length,
                args = new Array(_len65),
                _key65 = 0;
              _key65 < _len65;
              _key65++
            ) {
              args[_key65] = arguments[_key65];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ImportSpecifier"].concat(args)
            );
          }

          function MetaProperty() {
            for (
              var _len66 = arguments.length,
                args = new Array(_len66),
                _key66 = 0;
              _key66 < _len66;
              _key66++
            ) {
              args[_key66] = arguments[_key66];
            }

            return (0, _builder.default).apply(
              void 0,
              ["MetaProperty"].concat(args)
            );
          }

          function ClassMethod() {
            for (
              var _len67 = arguments.length,
                args = new Array(_len67),
                _key67 = 0;
              _key67 < _len67;
              _key67++
            ) {
              args[_key67] = arguments[_key67];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ClassMethod"].concat(args)
            );
          }

          function ObjectPattern() {
            for (
              var _len68 = arguments.length,
                args = new Array(_len68),
                _key68 = 0;
              _key68 < _len68;
              _key68++
            ) {
              args[_key68] = arguments[_key68];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ObjectPattern"].concat(args)
            );
          }

          function SpreadElement() {
            for (
              var _len69 = arguments.length,
                args = new Array(_len69),
                _key69 = 0;
              _key69 < _len69;
              _key69++
            ) {
              args[_key69] = arguments[_key69];
            }

            return (0, _builder.default).apply(
              void 0,
              ["SpreadElement"].concat(args)
            );
          }

          function Super() {
            for (
              var _len70 = arguments.length,
                args = new Array(_len70),
                _key70 = 0;
              _key70 < _len70;
              _key70++
            ) {
              args[_key70] = arguments[_key70];
            }

            return (0, _builder.default).apply(void 0, ["Super"].concat(args));
          }

          function TaggedTemplateExpression() {
            for (
              var _len71 = arguments.length,
                args = new Array(_len71),
                _key71 = 0;
              _key71 < _len71;
              _key71++
            ) {
              args[_key71] = arguments[_key71];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TaggedTemplateExpression"].concat(args)
            );
          }

          function TemplateElement() {
            for (
              var _len72 = arguments.length,
                args = new Array(_len72),
                _key72 = 0;
              _key72 < _len72;
              _key72++
            ) {
              args[_key72] = arguments[_key72];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TemplateElement"].concat(args)
            );
          }

          function TemplateLiteral() {
            for (
              var _len73 = arguments.length,
                args = new Array(_len73),
                _key73 = 0;
              _key73 < _len73;
              _key73++
            ) {
              args[_key73] = arguments[_key73];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TemplateLiteral"].concat(args)
            );
          }

          function YieldExpression() {
            for (
              var _len74 = arguments.length,
                args = new Array(_len74),
                _key74 = 0;
              _key74 < _len74;
              _key74++
            ) {
              args[_key74] = arguments[_key74];
            }

            return (0, _builder.default).apply(
              void 0,
              ["YieldExpression"].concat(args)
            );
          }

          function AnyTypeAnnotation() {
            for (
              var _len75 = arguments.length,
                args = new Array(_len75),
                _key75 = 0;
              _key75 < _len75;
              _key75++
            ) {
              args[_key75] = arguments[_key75];
            }

            return (0, _builder.default).apply(
              void 0,
              ["AnyTypeAnnotation"].concat(args)
            );
          }

          function ArrayTypeAnnotation() {
            for (
              var _len76 = arguments.length,
                args = new Array(_len76),
                _key76 = 0;
              _key76 < _len76;
              _key76++
            ) {
              args[_key76] = arguments[_key76];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ArrayTypeAnnotation"].concat(args)
            );
          }

          function BooleanTypeAnnotation() {
            for (
              var _len77 = arguments.length,
                args = new Array(_len77),
                _key77 = 0;
              _key77 < _len77;
              _key77++
            ) {
              args[_key77] = arguments[_key77];
            }

            return (0, _builder.default).apply(
              void 0,
              ["BooleanTypeAnnotation"].concat(args)
            );
          }

          function BooleanLiteralTypeAnnotation() {
            for (
              var _len78 = arguments.length,
                args = new Array(_len78),
                _key78 = 0;
              _key78 < _len78;
              _key78++
            ) {
              args[_key78] = arguments[_key78];
            }

            return (0, _builder.default).apply(
              void 0,
              ["BooleanLiteralTypeAnnotation"].concat(args)
            );
          }

          function NullLiteralTypeAnnotation() {
            for (
              var _len79 = arguments.length,
                args = new Array(_len79),
                _key79 = 0;
              _key79 < _len79;
              _key79++
            ) {
              args[_key79] = arguments[_key79];
            }

            return (0, _builder.default).apply(
              void 0,
              ["NullLiteralTypeAnnotation"].concat(args)
            );
          }

          function ClassImplements() {
            for (
              var _len80 = arguments.length,
                args = new Array(_len80),
                _key80 = 0;
              _key80 < _len80;
              _key80++
            ) {
              args[_key80] = arguments[_key80];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ClassImplements"].concat(args)
            );
          }

          function DeclareClass() {
            for (
              var _len81 = arguments.length,
                args = new Array(_len81),
                _key81 = 0;
              _key81 < _len81;
              _key81++
            ) {
              args[_key81] = arguments[_key81];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DeclareClass"].concat(args)
            );
          }

          function DeclareFunction() {
            for (
              var _len82 = arguments.length,
                args = new Array(_len82),
                _key82 = 0;
              _key82 < _len82;
              _key82++
            ) {
              args[_key82] = arguments[_key82];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DeclareFunction"].concat(args)
            );
          }

          function DeclareInterface() {
            for (
              var _len83 = arguments.length,
                args = new Array(_len83),
                _key83 = 0;
              _key83 < _len83;
              _key83++
            ) {
              args[_key83] = arguments[_key83];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DeclareInterface"].concat(args)
            );
          }

          function DeclareModule() {
            for (
              var _len84 = arguments.length,
                args = new Array(_len84),
                _key84 = 0;
              _key84 < _len84;
              _key84++
            ) {
              args[_key84] = arguments[_key84];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DeclareModule"].concat(args)
            );
          }

          function DeclareModuleExports() {
            for (
              var _len85 = arguments.length,
                args = new Array(_len85),
                _key85 = 0;
              _key85 < _len85;
              _key85++
            ) {
              args[_key85] = arguments[_key85];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DeclareModuleExports"].concat(args)
            );
          }

          function DeclareTypeAlias() {
            for (
              var _len86 = arguments.length,
                args = new Array(_len86),
                _key86 = 0;
              _key86 < _len86;
              _key86++
            ) {
              args[_key86] = arguments[_key86];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DeclareTypeAlias"].concat(args)
            );
          }

          function DeclareOpaqueType() {
            for (
              var _len87 = arguments.length,
                args = new Array(_len87),
                _key87 = 0;
              _key87 < _len87;
              _key87++
            ) {
              args[_key87] = arguments[_key87];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DeclareOpaqueType"].concat(args)
            );
          }

          function DeclareVariable() {
            for (
              var _len88 = arguments.length,
                args = new Array(_len88),
                _key88 = 0;
              _key88 < _len88;
              _key88++
            ) {
              args[_key88] = arguments[_key88];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DeclareVariable"].concat(args)
            );
          }

          function DeclareExportDeclaration() {
            for (
              var _len89 = arguments.length,
                args = new Array(_len89),
                _key89 = 0;
              _key89 < _len89;
              _key89++
            ) {
              args[_key89] = arguments[_key89];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DeclareExportDeclaration"].concat(args)
            );
          }

          function DeclareExportAllDeclaration() {
            for (
              var _len90 = arguments.length,
                args = new Array(_len90),
                _key90 = 0;
              _key90 < _len90;
              _key90++
            ) {
              args[_key90] = arguments[_key90];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DeclareExportAllDeclaration"].concat(args)
            );
          }

          function DeclaredPredicate() {
            for (
              var _len91 = arguments.length,
                args = new Array(_len91),
                _key91 = 0;
              _key91 < _len91;
              _key91++
            ) {
              args[_key91] = arguments[_key91];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DeclaredPredicate"].concat(args)
            );
          }

          function ExistsTypeAnnotation() {
            for (
              var _len92 = arguments.length,
                args = new Array(_len92),
                _key92 = 0;
              _key92 < _len92;
              _key92++
            ) {
              args[_key92] = arguments[_key92];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ExistsTypeAnnotation"].concat(args)
            );
          }

          function FunctionTypeAnnotation() {
            for (
              var _len93 = arguments.length,
                args = new Array(_len93),
                _key93 = 0;
              _key93 < _len93;
              _key93++
            ) {
              args[_key93] = arguments[_key93];
            }

            return (0, _builder.default).apply(
              void 0,
              ["FunctionTypeAnnotation"].concat(args)
            );
          }

          function FunctionTypeParam() {
            for (
              var _len94 = arguments.length,
                args = new Array(_len94),
                _key94 = 0;
              _key94 < _len94;
              _key94++
            ) {
              args[_key94] = arguments[_key94];
            }

            return (0, _builder.default).apply(
              void 0,
              ["FunctionTypeParam"].concat(args)
            );
          }

          function GenericTypeAnnotation() {
            for (
              var _len95 = arguments.length,
                args = new Array(_len95),
                _key95 = 0;
              _key95 < _len95;
              _key95++
            ) {
              args[_key95] = arguments[_key95];
            }

            return (0, _builder.default).apply(
              void 0,
              ["GenericTypeAnnotation"].concat(args)
            );
          }

          function InferredPredicate() {
            for (
              var _len96 = arguments.length,
                args = new Array(_len96),
                _key96 = 0;
              _key96 < _len96;
              _key96++
            ) {
              args[_key96] = arguments[_key96];
            }

            return (0, _builder.default).apply(
              void 0,
              ["InferredPredicate"].concat(args)
            );
          }

          function InterfaceExtends() {
            for (
              var _len97 = arguments.length,
                args = new Array(_len97),
                _key97 = 0;
              _key97 < _len97;
              _key97++
            ) {
              args[_key97] = arguments[_key97];
            }

            return (0, _builder.default).apply(
              void 0,
              ["InterfaceExtends"].concat(args)
            );
          }

          function InterfaceDeclaration() {
            for (
              var _len98 = arguments.length,
                args = new Array(_len98),
                _key98 = 0;
              _key98 < _len98;
              _key98++
            ) {
              args[_key98] = arguments[_key98];
            }

            return (0, _builder.default).apply(
              void 0,
              ["InterfaceDeclaration"].concat(args)
            );
          }

          function InterfaceTypeAnnotation() {
            for (
              var _len99 = arguments.length,
                args = new Array(_len99),
                _key99 = 0;
              _key99 < _len99;
              _key99++
            ) {
              args[_key99] = arguments[_key99];
            }

            return (0, _builder.default).apply(
              void 0,
              ["InterfaceTypeAnnotation"].concat(args)
            );
          }

          function IntersectionTypeAnnotation() {
            for (
              var _len100 = arguments.length,
                args = new Array(_len100),
                _key100 = 0;
              _key100 < _len100;
              _key100++
            ) {
              args[_key100] = arguments[_key100];
            }

            return (0, _builder.default).apply(
              void 0,
              ["IntersectionTypeAnnotation"].concat(args)
            );
          }

          function MixedTypeAnnotation() {
            for (
              var _len101 = arguments.length,
                args = new Array(_len101),
                _key101 = 0;
              _key101 < _len101;
              _key101++
            ) {
              args[_key101] = arguments[_key101];
            }

            return (0, _builder.default).apply(
              void 0,
              ["MixedTypeAnnotation"].concat(args)
            );
          }

          function EmptyTypeAnnotation() {
            for (
              var _len102 = arguments.length,
                args = new Array(_len102),
                _key102 = 0;
              _key102 < _len102;
              _key102++
            ) {
              args[_key102] = arguments[_key102];
            }

            return (0, _builder.default).apply(
              void 0,
              ["EmptyTypeAnnotation"].concat(args)
            );
          }

          function NullableTypeAnnotation() {
            for (
              var _len103 = arguments.length,
                args = new Array(_len103),
                _key103 = 0;
              _key103 < _len103;
              _key103++
            ) {
              args[_key103] = arguments[_key103];
            }

            return (0, _builder.default).apply(
              void 0,
              ["NullableTypeAnnotation"].concat(args)
            );
          }

          function NumberLiteralTypeAnnotation() {
            for (
              var _len104 = arguments.length,
                args = new Array(_len104),
                _key104 = 0;
              _key104 < _len104;
              _key104++
            ) {
              args[_key104] = arguments[_key104];
            }

            return (0, _builder.default).apply(
              void 0,
              ["NumberLiteralTypeAnnotation"].concat(args)
            );
          }

          function NumberTypeAnnotation() {
            for (
              var _len105 = arguments.length,
                args = new Array(_len105),
                _key105 = 0;
              _key105 < _len105;
              _key105++
            ) {
              args[_key105] = arguments[_key105];
            }

            return (0, _builder.default).apply(
              void 0,
              ["NumberTypeAnnotation"].concat(args)
            );
          }

          function ObjectTypeAnnotation() {
            for (
              var _len106 = arguments.length,
                args = new Array(_len106),
                _key106 = 0;
              _key106 < _len106;
              _key106++
            ) {
              args[_key106] = arguments[_key106];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ObjectTypeAnnotation"].concat(args)
            );
          }

          function ObjectTypeInternalSlot() {
            for (
              var _len107 = arguments.length,
                args = new Array(_len107),
                _key107 = 0;
              _key107 < _len107;
              _key107++
            ) {
              args[_key107] = arguments[_key107];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ObjectTypeInternalSlot"].concat(args)
            );
          }

          function ObjectTypeCallProperty() {
            for (
              var _len108 = arguments.length,
                args = new Array(_len108),
                _key108 = 0;
              _key108 < _len108;
              _key108++
            ) {
              args[_key108] = arguments[_key108];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ObjectTypeCallProperty"].concat(args)
            );
          }

          function ObjectTypeIndexer() {
            for (
              var _len109 = arguments.length,
                args = new Array(_len109),
                _key109 = 0;
              _key109 < _len109;
              _key109++
            ) {
              args[_key109] = arguments[_key109];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ObjectTypeIndexer"].concat(args)
            );
          }

          function ObjectTypeProperty() {
            for (
              var _len110 = arguments.length,
                args = new Array(_len110),
                _key110 = 0;
              _key110 < _len110;
              _key110++
            ) {
              args[_key110] = arguments[_key110];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ObjectTypeProperty"].concat(args)
            );
          }

          function ObjectTypeSpreadProperty() {
            for (
              var _len111 = arguments.length,
                args = new Array(_len111),
                _key111 = 0;
              _key111 < _len111;
              _key111++
            ) {
              args[_key111] = arguments[_key111];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ObjectTypeSpreadProperty"].concat(args)
            );
          }

          function OpaqueType() {
            for (
              var _len112 = arguments.length,
                args = new Array(_len112),
                _key112 = 0;
              _key112 < _len112;
              _key112++
            ) {
              args[_key112] = arguments[_key112];
            }

            return (0, _builder.default).apply(
              void 0,
              ["OpaqueType"].concat(args)
            );
          }

          function QualifiedTypeIdentifier() {
            for (
              var _len113 = arguments.length,
                args = new Array(_len113),
                _key113 = 0;
              _key113 < _len113;
              _key113++
            ) {
              args[_key113] = arguments[_key113];
            }

            return (0, _builder.default).apply(
              void 0,
              ["QualifiedTypeIdentifier"].concat(args)
            );
          }

          function StringLiteralTypeAnnotation() {
            for (
              var _len114 = arguments.length,
                args = new Array(_len114),
                _key114 = 0;
              _key114 < _len114;
              _key114++
            ) {
              args[_key114] = arguments[_key114];
            }

            return (0, _builder.default).apply(
              void 0,
              ["StringLiteralTypeAnnotation"].concat(args)
            );
          }

          function StringTypeAnnotation() {
            for (
              var _len115 = arguments.length,
                args = new Array(_len115),
                _key115 = 0;
              _key115 < _len115;
              _key115++
            ) {
              args[_key115] = arguments[_key115];
            }

            return (0, _builder.default).apply(
              void 0,
              ["StringTypeAnnotation"].concat(args)
            );
          }

          function ThisTypeAnnotation() {
            for (
              var _len116 = arguments.length,
                args = new Array(_len116),
                _key116 = 0;
              _key116 < _len116;
              _key116++
            ) {
              args[_key116] = arguments[_key116];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ThisTypeAnnotation"].concat(args)
            );
          }

          function TupleTypeAnnotation() {
            for (
              var _len117 = arguments.length,
                args = new Array(_len117),
                _key117 = 0;
              _key117 < _len117;
              _key117++
            ) {
              args[_key117] = arguments[_key117];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TupleTypeAnnotation"].concat(args)
            );
          }

          function TypeofTypeAnnotation() {
            for (
              var _len118 = arguments.length,
                args = new Array(_len118),
                _key118 = 0;
              _key118 < _len118;
              _key118++
            ) {
              args[_key118] = arguments[_key118];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TypeofTypeAnnotation"].concat(args)
            );
          }

          function TypeAlias() {
            for (
              var _len119 = arguments.length,
                args = new Array(_len119),
                _key119 = 0;
              _key119 < _len119;
              _key119++
            ) {
              args[_key119] = arguments[_key119];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TypeAlias"].concat(args)
            );
          }

          function TypeAnnotation() {
            for (
              var _len120 = arguments.length,
                args = new Array(_len120),
                _key120 = 0;
              _key120 < _len120;
              _key120++
            ) {
              args[_key120] = arguments[_key120];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TypeAnnotation"].concat(args)
            );
          }

          function TypeCastExpression() {
            for (
              var _len121 = arguments.length,
                args = new Array(_len121),
                _key121 = 0;
              _key121 < _len121;
              _key121++
            ) {
              args[_key121] = arguments[_key121];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TypeCastExpression"].concat(args)
            );
          }

          function TypeParameter() {
            for (
              var _len122 = arguments.length,
                args = new Array(_len122),
                _key122 = 0;
              _key122 < _len122;
              _key122++
            ) {
              args[_key122] = arguments[_key122];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TypeParameter"].concat(args)
            );
          }

          function TypeParameterDeclaration() {
            for (
              var _len123 = arguments.length,
                args = new Array(_len123),
                _key123 = 0;
              _key123 < _len123;
              _key123++
            ) {
              args[_key123] = arguments[_key123];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TypeParameterDeclaration"].concat(args)
            );
          }

          function TypeParameterInstantiation() {
            for (
              var _len124 = arguments.length,
                args = new Array(_len124),
                _key124 = 0;
              _key124 < _len124;
              _key124++
            ) {
              args[_key124] = arguments[_key124];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TypeParameterInstantiation"].concat(args)
            );
          }

          function UnionTypeAnnotation() {
            for (
              var _len125 = arguments.length,
                args = new Array(_len125),
                _key125 = 0;
              _key125 < _len125;
              _key125++
            ) {
              args[_key125] = arguments[_key125];
            }

            return (0, _builder.default).apply(
              void 0,
              ["UnionTypeAnnotation"].concat(args)
            );
          }

          function Variance() {
            for (
              var _len126 = arguments.length,
                args = new Array(_len126),
                _key126 = 0;
              _key126 < _len126;
              _key126++
            ) {
              args[_key126] = arguments[_key126];
            }

            return (0, _builder.default).apply(
              void 0,
              ["Variance"].concat(args)
            );
          }

          function VoidTypeAnnotation() {
            for (
              var _len127 = arguments.length,
                args = new Array(_len127),
                _key127 = 0;
              _key127 < _len127;
              _key127++
            ) {
              args[_key127] = arguments[_key127];
            }

            return (0, _builder.default).apply(
              void 0,
              ["VoidTypeAnnotation"].concat(args)
            );
          }

          function JSXAttribute() {
            for (
              var _len128 = arguments.length,
                args = new Array(_len128),
                _key128 = 0;
              _key128 < _len128;
              _key128++
            ) {
              args[_key128] = arguments[_key128];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXAttribute"].concat(args)
            );
          }

          function JSXClosingElement() {
            for (
              var _len129 = arguments.length,
                args = new Array(_len129),
                _key129 = 0;
              _key129 < _len129;
              _key129++
            ) {
              args[_key129] = arguments[_key129];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXClosingElement"].concat(args)
            );
          }

          function JSXElement() {
            for (
              var _len130 = arguments.length,
                args = new Array(_len130),
                _key130 = 0;
              _key130 < _len130;
              _key130++
            ) {
              args[_key130] = arguments[_key130];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXElement"].concat(args)
            );
          }

          function JSXEmptyExpression() {
            for (
              var _len131 = arguments.length,
                args = new Array(_len131),
                _key131 = 0;
              _key131 < _len131;
              _key131++
            ) {
              args[_key131] = arguments[_key131];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXEmptyExpression"].concat(args)
            );
          }

          function JSXExpressionContainer() {
            for (
              var _len132 = arguments.length,
                args = new Array(_len132),
                _key132 = 0;
              _key132 < _len132;
              _key132++
            ) {
              args[_key132] = arguments[_key132];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXExpressionContainer"].concat(args)
            );
          }

          function JSXSpreadChild() {
            for (
              var _len133 = arguments.length,
                args = new Array(_len133),
                _key133 = 0;
              _key133 < _len133;
              _key133++
            ) {
              args[_key133] = arguments[_key133];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXSpreadChild"].concat(args)
            );
          }

          function JSXIdentifier() {
            for (
              var _len134 = arguments.length,
                args = new Array(_len134),
                _key134 = 0;
              _key134 < _len134;
              _key134++
            ) {
              args[_key134] = arguments[_key134];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXIdentifier"].concat(args)
            );
          }

          function JSXMemberExpression() {
            for (
              var _len135 = arguments.length,
                args = new Array(_len135),
                _key135 = 0;
              _key135 < _len135;
              _key135++
            ) {
              args[_key135] = arguments[_key135];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXMemberExpression"].concat(args)
            );
          }

          function JSXNamespacedName() {
            for (
              var _len136 = arguments.length,
                args = new Array(_len136),
                _key136 = 0;
              _key136 < _len136;
              _key136++
            ) {
              args[_key136] = arguments[_key136];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXNamespacedName"].concat(args)
            );
          }

          function JSXOpeningElement() {
            for (
              var _len137 = arguments.length,
                args = new Array(_len137),
                _key137 = 0;
              _key137 < _len137;
              _key137++
            ) {
              args[_key137] = arguments[_key137];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXOpeningElement"].concat(args)
            );
          }

          function JSXSpreadAttribute() {
            for (
              var _len138 = arguments.length,
                args = new Array(_len138),
                _key138 = 0;
              _key138 < _len138;
              _key138++
            ) {
              args[_key138] = arguments[_key138];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXSpreadAttribute"].concat(args)
            );
          }

          function JSXText() {
            for (
              var _len139 = arguments.length,
                args = new Array(_len139),
                _key139 = 0;
              _key139 < _len139;
              _key139++
            ) {
              args[_key139] = arguments[_key139];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXText"].concat(args)
            );
          }

          function JSXFragment() {
            for (
              var _len140 = arguments.length,
                args = new Array(_len140),
                _key140 = 0;
              _key140 < _len140;
              _key140++
            ) {
              args[_key140] = arguments[_key140];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXFragment"].concat(args)
            );
          }

          function JSXOpeningFragment() {
            for (
              var _len141 = arguments.length,
                args = new Array(_len141),
                _key141 = 0;
              _key141 < _len141;
              _key141++
            ) {
              args[_key141] = arguments[_key141];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXOpeningFragment"].concat(args)
            );
          }

          function JSXClosingFragment() {
            for (
              var _len142 = arguments.length,
                args = new Array(_len142),
                _key142 = 0;
              _key142 < _len142;
              _key142++
            ) {
              args[_key142] = arguments[_key142];
            }

            return (0, _builder.default).apply(
              void 0,
              ["JSXClosingFragment"].concat(args)
            );
          }

          function Noop() {
            for (
              var _len143 = arguments.length,
                args = new Array(_len143),
                _key143 = 0;
              _key143 < _len143;
              _key143++
            ) {
              args[_key143] = arguments[_key143];
            }

            return (0, _builder.default).apply(void 0, ["Noop"].concat(args));
          }

          function ParenthesizedExpression() {
            for (
              var _len144 = arguments.length,
                args = new Array(_len144),
                _key144 = 0;
              _key144 < _len144;
              _key144++
            ) {
              args[_key144] = arguments[_key144];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ParenthesizedExpression"].concat(args)
            );
          }

          function AwaitExpression() {
            for (
              var _len145 = arguments.length,
                args = new Array(_len145),
                _key145 = 0;
              _key145 < _len145;
              _key145++
            ) {
              args[_key145] = arguments[_key145];
            }

            return (0, _builder.default).apply(
              void 0,
              ["AwaitExpression"].concat(args)
            );
          }

          function BindExpression() {
            for (
              var _len146 = arguments.length,
                args = new Array(_len146),
                _key146 = 0;
              _key146 < _len146;
              _key146++
            ) {
              args[_key146] = arguments[_key146];
            }

            return (0, _builder.default).apply(
              void 0,
              ["BindExpression"].concat(args)
            );
          }

          function ClassProperty() {
            for (
              var _len147 = arguments.length,
                args = new Array(_len147),
                _key147 = 0;
              _key147 < _len147;
              _key147++
            ) {
              args[_key147] = arguments[_key147];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ClassProperty"].concat(args)
            );
          }

          function OptionalMemberExpression() {
            for (
              var _len148 = arguments.length,
                args = new Array(_len148),
                _key148 = 0;
              _key148 < _len148;
              _key148++
            ) {
              args[_key148] = arguments[_key148];
            }

            return (0, _builder.default).apply(
              void 0,
              ["OptionalMemberExpression"].concat(args)
            );
          }

          function OptionalCallExpression() {
            for (
              var _len149 = arguments.length,
                args = new Array(_len149),
                _key149 = 0;
              _key149 < _len149;
              _key149++
            ) {
              args[_key149] = arguments[_key149];
            }

            return (0, _builder.default).apply(
              void 0,
              ["OptionalCallExpression"].concat(args)
            );
          }

          function ClassPrivateProperty() {
            for (
              var _len150 = arguments.length,
                args = new Array(_len150),
                _key150 = 0;
              _key150 < _len150;
              _key150++
            ) {
              args[_key150] = arguments[_key150];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ClassPrivateProperty"].concat(args)
            );
          }

          function Import() {
            for (
              var _len151 = arguments.length,
                args = new Array(_len151),
                _key151 = 0;
              _key151 < _len151;
              _key151++
            ) {
              args[_key151] = arguments[_key151];
            }

            return (0, _builder.default).apply(void 0, ["Import"].concat(args));
          }

          function Decorator() {
            for (
              var _len152 = arguments.length,
                args = new Array(_len152),
                _key152 = 0;
              _key152 < _len152;
              _key152++
            ) {
              args[_key152] = arguments[_key152];
            }

            return (0, _builder.default).apply(
              void 0,
              ["Decorator"].concat(args)
            );
          }

          function DoExpression() {
            for (
              var _len153 = arguments.length,
                args = new Array(_len153),
                _key153 = 0;
              _key153 < _len153;
              _key153++
            ) {
              args[_key153] = arguments[_key153];
            }

            return (0, _builder.default).apply(
              void 0,
              ["DoExpression"].concat(args)
            );
          }

          function ExportDefaultSpecifier() {
            for (
              var _len154 = arguments.length,
                args = new Array(_len154),
                _key154 = 0;
              _key154 < _len154;
              _key154++
            ) {
              args[_key154] = arguments[_key154];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ExportDefaultSpecifier"].concat(args)
            );
          }

          function ExportNamespaceSpecifier() {
            for (
              var _len155 = arguments.length,
                args = new Array(_len155),
                _key155 = 0;
              _key155 < _len155;
              _key155++
            ) {
              args[_key155] = arguments[_key155];
            }

            return (0, _builder.default).apply(
              void 0,
              ["ExportNamespaceSpecifier"].concat(args)
            );
          }

          function PrivateName() {
            for (
              var _len156 = arguments.length,
                args = new Array(_len156),
                _key156 = 0;
              _key156 < _len156;
              _key156++
            ) {
              args[_key156] = arguments[_key156];
            }

            return (0, _builder.default).apply(
              void 0,
              ["PrivateName"].concat(args)
            );
          }

          function BigIntLiteral() {
            for (
              var _len157 = arguments.length,
                args = new Array(_len157),
                _key157 = 0;
              _key157 < _len157;
              _key157++
            ) {
              args[_key157] = arguments[_key157];
            }

            return (0, _builder.default).apply(
              void 0,
              ["BigIntLiteral"].concat(args)
            );
          }

          function TSParameterProperty() {
            for (
              var _len158 = arguments.length,
                args = new Array(_len158),
                _key158 = 0;
              _key158 < _len158;
              _key158++
            ) {
              args[_key158] = arguments[_key158];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSParameterProperty"].concat(args)
            );
          }

          function TSDeclareFunction() {
            for (
              var _len159 = arguments.length,
                args = new Array(_len159),
                _key159 = 0;
              _key159 < _len159;
              _key159++
            ) {
              args[_key159] = arguments[_key159];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSDeclareFunction"].concat(args)
            );
          }

          function TSDeclareMethod() {
            for (
              var _len160 = arguments.length,
                args = new Array(_len160),
                _key160 = 0;
              _key160 < _len160;
              _key160++
            ) {
              args[_key160] = arguments[_key160];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSDeclareMethod"].concat(args)
            );
          }

          function TSQualifiedName() {
            for (
              var _len161 = arguments.length,
                args = new Array(_len161),
                _key161 = 0;
              _key161 < _len161;
              _key161++
            ) {
              args[_key161] = arguments[_key161];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSQualifiedName"].concat(args)
            );
          }

          function TSCallSignatureDeclaration() {
            for (
              var _len162 = arguments.length,
                args = new Array(_len162),
                _key162 = 0;
              _key162 < _len162;
              _key162++
            ) {
              args[_key162] = arguments[_key162];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSCallSignatureDeclaration"].concat(args)
            );
          }

          function TSConstructSignatureDeclaration() {
            for (
              var _len163 = arguments.length,
                args = new Array(_len163),
                _key163 = 0;
              _key163 < _len163;
              _key163++
            ) {
              args[_key163] = arguments[_key163];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSConstructSignatureDeclaration"].concat(args)
            );
          }

          function TSPropertySignature() {
            for (
              var _len164 = arguments.length,
                args = new Array(_len164),
                _key164 = 0;
              _key164 < _len164;
              _key164++
            ) {
              args[_key164] = arguments[_key164];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSPropertySignature"].concat(args)
            );
          }

          function TSMethodSignature() {
            for (
              var _len165 = arguments.length,
                args = new Array(_len165),
                _key165 = 0;
              _key165 < _len165;
              _key165++
            ) {
              args[_key165] = arguments[_key165];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSMethodSignature"].concat(args)
            );
          }

          function TSIndexSignature() {
            for (
              var _len166 = arguments.length,
                args = new Array(_len166),
                _key166 = 0;
              _key166 < _len166;
              _key166++
            ) {
              args[_key166] = arguments[_key166];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSIndexSignature"].concat(args)
            );
          }

          function TSAnyKeyword() {
            for (
              var _len167 = arguments.length,
                args = new Array(_len167),
                _key167 = 0;
              _key167 < _len167;
              _key167++
            ) {
              args[_key167] = arguments[_key167];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSAnyKeyword"].concat(args)
            );
          }

          function TSNumberKeyword() {
            for (
              var _len168 = arguments.length,
                args = new Array(_len168),
                _key168 = 0;
              _key168 < _len168;
              _key168++
            ) {
              args[_key168] = arguments[_key168];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSNumberKeyword"].concat(args)
            );
          }

          function TSObjectKeyword() {
            for (
              var _len169 = arguments.length,
                args = new Array(_len169),
                _key169 = 0;
              _key169 < _len169;
              _key169++
            ) {
              args[_key169] = arguments[_key169];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSObjectKeyword"].concat(args)
            );
          }

          function TSBooleanKeyword() {
            for (
              var _len170 = arguments.length,
                args = new Array(_len170),
                _key170 = 0;
              _key170 < _len170;
              _key170++
            ) {
              args[_key170] = arguments[_key170];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSBooleanKeyword"].concat(args)
            );
          }

          function TSStringKeyword() {
            for (
              var _len171 = arguments.length,
                args = new Array(_len171),
                _key171 = 0;
              _key171 < _len171;
              _key171++
            ) {
              args[_key171] = arguments[_key171];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSStringKeyword"].concat(args)
            );
          }

          function TSSymbolKeyword() {
            for (
              var _len172 = arguments.length,
                args = new Array(_len172),
                _key172 = 0;
              _key172 < _len172;
              _key172++
            ) {
              args[_key172] = arguments[_key172];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSSymbolKeyword"].concat(args)
            );
          }

          function TSVoidKeyword() {
            for (
              var _len173 = arguments.length,
                args = new Array(_len173),
                _key173 = 0;
              _key173 < _len173;
              _key173++
            ) {
              args[_key173] = arguments[_key173];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSVoidKeyword"].concat(args)
            );
          }

          function TSUndefinedKeyword() {
            for (
              var _len174 = arguments.length,
                args = new Array(_len174),
                _key174 = 0;
              _key174 < _len174;
              _key174++
            ) {
              args[_key174] = arguments[_key174];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSUndefinedKeyword"].concat(args)
            );
          }

          function TSNullKeyword() {
            for (
              var _len175 = arguments.length,
                args = new Array(_len175),
                _key175 = 0;
              _key175 < _len175;
              _key175++
            ) {
              args[_key175] = arguments[_key175];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSNullKeyword"].concat(args)
            );
          }

          function TSNeverKeyword() {
            for (
              var _len176 = arguments.length,
                args = new Array(_len176),
                _key176 = 0;
              _key176 < _len176;
              _key176++
            ) {
              args[_key176] = arguments[_key176];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSNeverKeyword"].concat(args)
            );
          }

          function TSThisType() {
            for (
              var _len177 = arguments.length,
                args = new Array(_len177),
                _key177 = 0;
              _key177 < _len177;
              _key177++
            ) {
              args[_key177] = arguments[_key177];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSThisType"].concat(args)
            );
          }

          function TSFunctionType() {
            for (
              var _len178 = arguments.length,
                args = new Array(_len178),
                _key178 = 0;
              _key178 < _len178;
              _key178++
            ) {
              args[_key178] = arguments[_key178];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSFunctionType"].concat(args)
            );
          }

          function TSConstructorType() {
            for (
              var _len179 = arguments.length,
                args = new Array(_len179),
                _key179 = 0;
              _key179 < _len179;
              _key179++
            ) {
              args[_key179] = arguments[_key179];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSConstructorType"].concat(args)
            );
          }

          function TSTypeReference() {
            for (
              var _len180 = arguments.length,
                args = new Array(_len180),
                _key180 = 0;
              _key180 < _len180;
              _key180++
            ) {
              args[_key180] = arguments[_key180];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTypeReference"].concat(args)
            );
          }

          function TSTypePredicate() {
            for (
              var _len181 = arguments.length,
                args = new Array(_len181),
                _key181 = 0;
              _key181 < _len181;
              _key181++
            ) {
              args[_key181] = arguments[_key181];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTypePredicate"].concat(args)
            );
          }

          function TSTypeQuery() {
            for (
              var _len182 = arguments.length,
                args = new Array(_len182),
                _key182 = 0;
              _key182 < _len182;
              _key182++
            ) {
              args[_key182] = arguments[_key182];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTypeQuery"].concat(args)
            );
          }

          function TSTypeLiteral() {
            for (
              var _len183 = arguments.length,
                args = new Array(_len183),
                _key183 = 0;
              _key183 < _len183;
              _key183++
            ) {
              args[_key183] = arguments[_key183];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTypeLiteral"].concat(args)
            );
          }

          function TSArrayType() {
            for (
              var _len184 = arguments.length,
                args = new Array(_len184),
                _key184 = 0;
              _key184 < _len184;
              _key184++
            ) {
              args[_key184] = arguments[_key184];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSArrayType"].concat(args)
            );
          }

          function TSTupleType() {
            for (
              var _len185 = arguments.length,
                args = new Array(_len185),
                _key185 = 0;
              _key185 < _len185;
              _key185++
            ) {
              args[_key185] = arguments[_key185];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTupleType"].concat(args)
            );
          }

          function TSUnionType() {
            for (
              var _len186 = arguments.length,
                args = new Array(_len186),
                _key186 = 0;
              _key186 < _len186;
              _key186++
            ) {
              args[_key186] = arguments[_key186];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSUnionType"].concat(args)
            );
          }

          function TSIntersectionType() {
            for (
              var _len187 = arguments.length,
                args = new Array(_len187),
                _key187 = 0;
              _key187 < _len187;
              _key187++
            ) {
              args[_key187] = arguments[_key187];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSIntersectionType"].concat(args)
            );
          }

          function TSConditionalType() {
            for (
              var _len188 = arguments.length,
                args = new Array(_len188),
                _key188 = 0;
              _key188 < _len188;
              _key188++
            ) {
              args[_key188] = arguments[_key188];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSConditionalType"].concat(args)
            );
          }

          function TSInferType() {
            for (
              var _len189 = arguments.length,
                args = new Array(_len189),
                _key189 = 0;
              _key189 < _len189;
              _key189++
            ) {
              args[_key189] = arguments[_key189];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSInferType"].concat(args)
            );
          }

          function TSParenthesizedType() {
            for (
              var _len190 = arguments.length,
                args = new Array(_len190),
                _key190 = 0;
              _key190 < _len190;
              _key190++
            ) {
              args[_key190] = arguments[_key190];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSParenthesizedType"].concat(args)
            );
          }

          function TSTypeOperator() {
            for (
              var _len191 = arguments.length,
                args = new Array(_len191),
                _key191 = 0;
              _key191 < _len191;
              _key191++
            ) {
              args[_key191] = arguments[_key191];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTypeOperator"].concat(args)
            );
          }

          function TSIndexedAccessType() {
            for (
              var _len192 = arguments.length,
                args = new Array(_len192),
                _key192 = 0;
              _key192 < _len192;
              _key192++
            ) {
              args[_key192] = arguments[_key192];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSIndexedAccessType"].concat(args)
            );
          }

          function TSMappedType() {
            for (
              var _len193 = arguments.length,
                args = new Array(_len193),
                _key193 = 0;
              _key193 < _len193;
              _key193++
            ) {
              args[_key193] = arguments[_key193];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSMappedType"].concat(args)
            );
          }

          function TSLiteralType() {
            for (
              var _len194 = arguments.length,
                args = new Array(_len194),
                _key194 = 0;
              _key194 < _len194;
              _key194++
            ) {
              args[_key194] = arguments[_key194];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSLiteralType"].concat(args)
            );
          }

          function TSExpressionWithTypeArguments() {
            for (
              var _len195 = arguments.length,
                args = new Array(_len195),
                _key195 = 0;
              _key195 < _len195;
              _key195++
            ) {
              args[_key195] = arguments[_key195];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSExpressionWithTypeArguments"].concat(args)
            );
          }

          function TSInterfaceDeclaration() {
            for (
              var _len196 = arguments.length,
                args = new Array(_len196),
                _key196 = 0;
              _key196 < _len196;
              _key196++
            ) {
              args[_key196] = arguments[_key196];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSInterfaceDeclaration"].concat(args)
            );
          }

          function TSInterfaceBody() {
            for (
              var _len197 = arguments.length,
                args = new Array(_len197),
                _key197 = 0;
              _key197 < _len197;
              _key197++
            ) {
              args[_key197] = arguments[_key197];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSInterfaceBody"].concat(args)
            );
          }

          function TSTypeAliasDeclaration() {
            for (
              var _len198 = arguments.length,
                args = new Array(_len198),
                _key198 = 0;
              _key198 < _len198;
              _key198++
            ) {
              args[_key198] = arguments[_key198];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTypeAliasDeclaration"].concat(args)
            );
          }

          function TSAsExpression() {
            for (
              var _len199 = arguments.length,
                args = new Array(_len199),
                _key199 = 0;
              _key199 < _len199;
              _key199++
            ) {
              args[_key199] = arguments[_key199];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSAsExpression"].concat(args)
            );
          }

          function TSTypeAssertion() {
            for (
              var _len200 = arguments.length,
                args = new Array(_len200),
                _key200 = 0;
              _key200 < _len200;
              _key200++
            ) {
              args[_key200] = arguments[_key200];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTypeAssertion"].concat(args)
            );
          }

          function TSEnumDeclaration() {
            for (
              var _len201 = arguments.length,
                args = new Array(_len201),
                _key201 = 0;
              _key201 < _len201;
              _key201++
            ) {
              args[_key201] = arguments[_key201];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSEnumDeclaration"].concat(args)
            );
          }

          function TSEnumMember() {
            for (
              var _len202 = arguments.length,
                args = new Array(_len202),
                _key202 = 0;
              _key202 < _len202;
              _key202++
            ) {
              args[_key202] = arguments[_key202];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSEnumMember"].concat(args)
            );
          }

          function TSModuleDeclaration() {
            for (
              var _len203 = arguments.length,
                args = new Array(_len203),
                _key203 = 0;
              _key203 < _len203;
              _key203++
            ) {
              args[_key203] = arguments[_key203];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSModuleDeclaration"].concat(args)
            );
          }

          function TSModuleBlock() {
            for (
              var _len204 = arguments.length,
                args = new Array(_len204),
                _key204 = 0;
              _key204 < _len204;
              _key204++
            ) {
              args[_key204] = arguments[_key204];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSModuleBlock"].concat(args)
            );
          }

          function TSImportEqualsDeclaration() {
            for (
              var _len205 = arguments.length,
                args = new Array(_len205),
                _key205 = 0;
              _key205 < _len205;
              _key205++
            ) {
              args[_key205] = arguments[_key205];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSImportEqualsDeclaration"].concat(args)
            );
          }

          function TSExternalModuleReference() {
            for (
              var _len206 = arguments.length,
                args = new Array(_len206),
                _key206 = 0;
              _key206 < _len206;
              _key206++
            ) {
              args[_key206] = arguments[_key206];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSExternalModuleReference"].concat(args)
            );
          }

          function TSNonNullExpression() {
            for (
              var _len207 = arguments.length,
                args = new Array(_len207),
                _key207 = 0;
              _key207 < _len207;
              _key207++
            ) {
              args[_key207] = arguments[_key207];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSNonNullExpression"].concat(args)
            );
          }

          function TSExportAssignment() {
            for (
              var _len208 = arguments.length,
                args = new Array(_len208),
                _key208 = 0;
              _key208 < _len208;
              _key208++
            ) {
              args[_key208] = arguments[_key208];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSExportAssignment"].concat(args)
            );
          }

          function TSNamespaceExportDeclaration() {
            for (
              var _len209 = arguments.length,
                args = new Array(_len209),
                _key209 = 0;
              _key209 < _len209;
              _key209++
            ) {
              args[_key209] = arguments[_key209];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSNamespaceExportDeclaration"].concat(args)
            );
          }

          function TSTypeAnnotation() {
            for (
              var _len210 = arguments.length,
                args = new Array(_len210),
                _key210 = 0;
              _key210 < _len210;
              _key210++
            ) {
              args[_key210] = arguments[_key210];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTypeAnnotation"].concat(args)
            );
          }

          function TSTypeParameterInstantiation() {
            for (
              var _len211 = arguments.length,
                args = new Array(_len211),
                _key211 = 0;
              _key211 < _len211;
              _key211++
            ) {
              args[_key211] = arguments[_key211];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTypeParameterInstantiation"].concat(args)
            );
          }

          function TSTypeParameterDeclaration() {
            for (
              var _len212 = arguments.length,
                args = new Array(_len212),
                _key212 = 0;
              _key212 < _len212;
              _key212++
            ) {
              args[_key212] = arguments[_key212];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTypeParameterDeclaration"].concat(args)
            );
          }

          function TSTypeParameter() {
            for (
              var _len213 = arguments.length,
                args = new Array(_len213),
                _key213 = 0;
              _key213 < _len213;
              _key213++
            ) {
              args[_key213] = arguments[_key213];
            }

            return (0, _builder.default).apply(
              void 0,
              ["TSTypeParameter"].concat(args)
            );
          }

          function NumberLiteral() {
            console.trace(
              "The node type NumberLiteral has been renamed to NumericLiteral"
            );

            for (
              var _len214 = arguments.length,
                args = new Array(_len214),
                _key214 = 0;
              _key214 < _len214;
              _key214++
            ) {
              args[_key214] = arguments[_key214];
            }

            return NumberLiteral.apply(void 0, ["NumberLiteral"].concat(args));
          }

          function RegexLiteral() {
            console.trace(
              "The node type RegexLiteral has been renamed to RegExpLiteral"
            );

            for (
              var _len215 = arguments.length,
                args = new Array(_len215),
                _key215 = 0;
              _key215 < _len215;
              _key215++
            ) {
              args[_key215] = arguments[_key215];
            }

            return RegexLiteral.apply(void 0, ["RegexLiteral"].concat(args));
          }

          function RestProperty() {
            console.trace(
              "The node type RestProperty has been renamed to RestElement"
            );

            for (
              var _len216 = arguments.length,
                args = new Array(_len216),
                _key216 = 0;
              _key216 < _len216;
              _key216++
            ) {
              args[_key216] = arguments[_key216];
            }

            return RestProperty.apply(void 0, ["RestProperty"].concat(args));
          }

          function SpreadProperty() {
            console.trace(
              "The node type SpreadProperty has been renamed to SpreadElement"
            );

            for (
              var _len217 = arguments.length,
                args = new Array(_len217),
                _key217 = 0;
              _key217 < _len217;
              _key217++
            ) {
              args[_key217] = arguments[_key217];
            }

            return SpreadProperty.apply(
              void 0,
              ["SpreadProperty"].concat(args)
            );
          }
        },
        /* 5 */
        function(module, exports) {
          var isArray = Array.isArray;
          module.exports = isArray;
        },
        /* 6 */
        function(module, exports, __webpack_require__) {
          var freeGlobal = __webpack_require__(92);

          var freeSelf =
            typeof self == "object" && self && self.Object === Object && self;
          var root = freeGlobal || freeSelf || Function("return this")();
          module.exports = root;
        },
        /* 7 */
        function(module, exports) {
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }

          module.exports = isObjectLike;
        },
        /* 8 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          Object.defineProperty(exports, "VISITOR_KEYS", {
            enumerable: true,
            get: function get() {
              return _utils.VISITOR_KEYS;
            },
          });
          Object.defineProperty(exports, "ALIAS_KEYS", {
            enumerable: true,
            get: function get() {
              return _utils.ALIAS_KEYS;
            },
          });
          Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
            enumerable: true,
            get: function get() {
              return _utils.FLIPPED_ALIAS_KEYS;
            },
          });
          Object.defineProperty(exports, "NODE_FIELDS", {
            enumerable: true,
            get: function get() {
              return _utils.NODE_FIELDS;
            },
          });
          Object.defineProperty(exports, "BUILDER_KEYS", {
            enumerable: true,
            get: function get() {
              return _utils.BUILDER_KEYS;
            },
          });
          Object.defineProperty(exports, "DEPRECATED_KEYS", {
            enumerable: true,
            get: function get() {
              return _utils.DEPRECATED_KEYS;
            },
          });
          exports.TYPES = void 0;

          function _toFastProperties() {
            var data = _interopRequireDefault(__webpack_require__(242));

            _toFastProperties = function _toFastProperties() {
              return data;
            };

            return data;
          }

          __webpack_require__(65);

          __webpack_require__(68);

          __webpack_require__(245);

          __webpack_require__(246);

          __webpack_require__(247);

          __webpack_require__(248);

          __webpack_require__(249);

          var _utils = __webpack_require__(12);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          (0, _toFastProperties().default)(_utils.VISITOR_KEYS);
          (0, _toFastProperties().default)(_utils.ALIAS_KEYS);
          (0, _toFastProperties().default)(_utils.FLIPPED_ALIAS_KEYS);
          (0, _toFastProperties().default)(_utils.NODE_FIELDS);
          (0, _toFastProperties().default)(_utils.BUILDER_KEYS);
          (0, _toFastProperties().default)(_utils.DEPRECATED_KEYS);
          var TYPES = Object.keys(_utils.VISITOR_KEYS)
            .concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS))
            .concat(Object.keys(_utils.DEPRECATED_KEYS));
          exports.TYPES = TYPES;
        },
        /* 9 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = traverse;
          Object.defineProperty(exports, "NodePath", {
            enumerable: true,
            get: function get() {
              return _path.default;
            },
          });
          Object.defineProperty(exports, "Scope", {
            enumerable: true,
            get: function get() {
              return _scope.default;
            },
          });
          Object.defineProperty(exports, "Hub", {
            enumerable: true,
            get: function get() {
              return _hub.default;
            },
          });
          exports.visitors = void 0;

          var _context = _interopRequireDefault(__webpack_require__(318));

          var visitors = _interopRequireWildcard(__webpack_require__(397));

          exports.visitors = visitors;

          function _includes() {
            var data = _interopRequireDefault(__webpack_require__(73));

            _includes = function _includes() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          var cache = _interopRequireWildcard(__webpack_require__(43));

          var _path = _interopRequireDefault(__webpack_require__(21));

          var _scope = _interopRequireDefault(__webpack_require__(137));

          var _hub = _interopRequireDefault(__webpack_require__(398));

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function traverse(parent, opts, scope, state, parentPath) {
            if (!parent) return;
            if (!opts) opts = {};

            if (!opts.noScope && !scope) {
              if (parent.type !== "Program" && parent.type !== "File") {
                throw new Error(
                  "You must pass a scope and parentPath unless traversing a Program/File. " +
                    ("Instead of that you tried to traverse a " +
                      parent.type +
                      " node without ") +
                    "passing scope and parentPath."
                );
              }
            }

            visitors.explode(opts);
            traverse.node(parent, opts, scope, state, parentPath);
          }

          traverse.visitors = visitors;
          traverse.verify = visitors.verify;
          traverse.explode = visitors.explode;

          traverse.cheap = function(node, enter) {
            return t().traverseFast(node, enter);
          };

          traverse.node = function(
            node,
            opts,
            scope,
            state,
            parentPath,
            skipKeys
          ) {
            var keys = t().VISITOR_KEYS[node.type];
            if (!keys) return;
            var context = new _context.default(scope, opts, state, parentPath);

            for (
              var _iterator = keys,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var key = _ref;
              if (skipKeys && skipKeys[key]) continue;
              if (context.visit(node, key)) return;
            }
          };

          traverse.clearNode = function(node, opts) {
            t().removeProperties(node, opts);
            cache.path.delete(node);
          };

          traverse.removeProperties = function(tree, opts) {
            t().traverseFast(tree, traverse.clearNode, opts);
            return tree;
          };

          function hasBlacklistedType(path, state) {
            if (path.node.type === state.type) {
              state.has = true;
              path.stop();
            }
          }

          traverse.hasType = function(tree, type, blacklistTypes) {
            if ((0, _includes().default)(blacklistTypes, tree.type))
              return false;
            if (tree.type === type) return true;
            var state = {
              has: false,
              type: type,
            };
            traverse(
              tree,
              {
                noScope: true,
                blacklist: blacklistTypes,
                enter: hasBlacklistedType,
              },
              null,
              state
            );
            return state.has;
          };

          traverse.cache = cache;
        },
        /* 10 */
        function(module, exports, __webpack_require__) {
          var Symbol = __webpack_require__(18),
            getRawTag = __webpack_require__(193),
            objectToString = __webpack_require__(194);

          var nullTag = "[object Null]",
            undefinedTag = "[object Undefined]";
          var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

          function baseGetTag(value) {
            if (value == null) {
              return value === undefined ? undefinedTag : nullTag;
            }

            return symToStringTag && symToStringTag in Object(value)
              ? getRawTag(value)
              : objectToString(value);
          }

          module.exports = baseGetTag;
        },
        /* 11 */
        function(module, exports) {
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }

          module.exports = isObject;
        },
        /* 12 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.validate = validate;
          exports.typeIs = typeIs;
          exports.validateType = validateType;
          exports.validateOptional = validateOptional;
          exports.validateOptionalType = validateOptionalType;
          exports.arrayOf = arrayOf;
          exports.arrayOfType = arrayOfType;
          exports.validateArrayOfType = validateArrayOfType;
          exports.assertEach = assertEach;
          exports.assertOneOf = assertOneOf;
          exports.assertNodeType = assertNodeType;
          exports.assertNodeOrValueType = assertNodeOrValueType;
          exports.assertValueType = assertValueType;
          exports.chain = chain;
          exports.default = defineType;
          exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;

          var _is = _interopRequireDefault(__webpack_require__(66));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var VISITOR_KEYS = {};
          exports.VISITOR_KEYS = VISITOR_KEYS;
          var ALIAS_KEYS = {};
          exports.ALIAS_KEYS = ALIAS_KEYS;
          var FLIPPED_ALIAS_KEYS = {};
          exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
          var NODE_FIELDS = {};
          exports.NODE_FIELDS = NODE_FIELDS;
          var BUILDER_KEYS = {};
          exports.BUILDER_KEYS = BUILDER_KEYS;
          var DEPRECATED_KEYS = {};
          exports.DEPRECATED_KEYS = DEPRECATED_KEYS;

          function getType(val) {
            if (Array.isArray(val)) {
              return "array";
            } else if (val === null) {
              return "null";
            } else if (val === undefined) {
              return "undefined";
            } else {
              return typeof val;
            }
          }

          function validate(validate) {
            return {
              validate: validate,
            };
          }

          function typeIs(typeName) {
            return typeof typeName === "string"
              ? assertNodeType(typeName)
              : assertNodeType.apply(void 0, typeName);
          }

          function validateType(typeName) {
            return validate(typeIs(typeName));
          }

          function validateOptional(validate) {
            return {
              validate: validate,
              optional: true,
            };
          }

          function validateOptionalType(typeName) {
            return {
              validate: typeIs(typeName),
              optional: true,
            };
          }

          function arrayOf(elementType) {
            return chain(assertValueType("array"), assertEach(elementType));
          }

          function arrayOfType(typeName) {
            return arrayOf(typeIs(typeName));
          }

          function validateArrayOfType(typeName) {
            return validate(arrayOfType(typeName));
          }

          function assertEach(callback) {
            function validator(node, key, val) {
              if (!Array.isArray(val)) return;

              for (var i = 0; i < val.length; i++) {
                callback(node, key + "[" + i + "]", val[i]);
              }
            }

            validator.each = callback;
            return validator;
          }

          function assertOneOf() {
            for (
              var _len = arguments.length, values = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              values[_key] = arguments[_key];
            }

            function validate(node, key, val) {
              if (values.indexOf(val) < 0) {
                throw new TypeError(
                  "Property " +
                    key +
                    " expected value to be one of " +
                    JSON.stringify(values) +
                    " but got " +
                    JSON.stringify(val)
                );
              }
            }

            validate.oneOf = values;
            return validate;
          }

          function assertNodeType() {
            for (
              var _len2 = arguments.length, types = new Array(_len2), _key2 = 0;
              _key2 < _len2;
              _key2++
            ) {
              types[_key2] = arguments[_key2];
            }

            function validate(node, key, val) {
              var valid = false;

              for (var _i = 0; _i < types.length; _i++) {
                var type = types[_i];

                if ((0, _is.default)(type, val)) {
                  valid = true;
                  break;
                }
              }

              if (!valid) {
                throw new TypeError(
                  "Property " +
                    key +
                    " of " +
                    node.type +
                    " expected node to be of a type " +
                    JSON.stringify(types) +
                    " " +
                    ("but instead got " + JSON.stringify(val && val.type))
                );
              }
            }

            validate.oneOfNodeTypes = types;
            return validate;
          }

          function assertNodeOrValueType() {
            for (
              var _len3 = arguments.length, types = new Array(_len3), _key3 = 0;
              _key3 < _len3;
              _key3++
            ) {
              types[_key3] = arguments[_key3];
            }

            function validate(node, key, val) {
              var valid = false;

              for (var _i2 = 0; _i2 < types.length; _i2++) {
                var type = types[_i2];

                if (getType(val) === type || (0, _is.default)(type, val)) {
                  valid = true;
                  break;
                }
              }

              if (!valid) {
                throw new TypeError(
                  "Property " +
                    key +
                    " of " +
                    node.type +
                    " expected node to be of a type " +
                    JSON.stringify(types) +
                    " " +
                    ("but instead got " + JSON.stringify(val && val.type))
                );
              }
            }

            validate.oneOfNodeOrValueTypes = types;
            return validate;
          }

          function assertValueType(type) {
            function validate(node, key, val) {
              var valid = getType(val) === type;

              if (!valid) {
                throw new TypeError(
                  "Property " +
                    key +
                    " expected type of " +
                    type +
                    " but got " +
                    getType(val)
                );
              }
            }

            validate.type = type;
            return validate;
          }

          function chain() {
            for (
              var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0;
              _key4 < _len4;
              _key4++
            ) {
              fns[_key4] = arguments[_key4];
            }

            function validate() {
              for (var _i3 = 0; _i3 < fns.length; _i3++) {
                var fn = fns[_i3];
                fn.apply(void 0, arguments);
              }
            }

            validate.chainOf = fns;
            return validate;
          }

          function defineType(type, opts) {
            if (opts === void 0) {
              opts = {};
            }

            var inherits = (opts.inherits && store[opts.inherits]) || {};
            var fields = opts.fields || inherits.fields || {};
            var visitor = opts.visitor || inherits.visitor || [];
            var aliases = opts.aliases || inherits.aliases || [];
            var builder =
              opts.builder || inherits.builder || opts.visitor || [];

            if (opts.deprecatedAlias) {
              DEPRECATED_KEYS[opts.deprecatedAlias] = type;
            }

            for (
              var _iterator = visitor.concat(builder),
                _isArray = Array.isArray(_iterator),
                _i4 = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i4 >= _iterator.length) break;
                _ref = _iterator[_i4++];
              } else {
                _i4 = _iterator.next();
                if (_i4.done) break;
                _ref = _i4.value;
              }

              var _key5 = _ref;
              fields[_key5] = fields[_key5] || {};
            }

            for (var key in fields) {
              var field = fields[key];

              if (builder.indexOf(key) === -1) {
                field.optional = true;
              }

              if (field.default === undefined) {
                field.default = null;
              } else if (!field.validate) {
                field.validate = assertValueType(getType(field.default));
              }
            }

            VISITOR_KEYS[type] = opts.visitor = visitor;
            BUILDER_KEYS[type] = opts.builder = builder;
            NODE_FIELDS[type] = opts.fields = fields;
            ALIAS_KEYS[type] = opts.aliases = aliases;
            aliases.forEach(function(alias) {
              FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
              FLIPPED_ALIAS_KEYS[alias].push(type);
            });
            store[type] = opts;
          }

          var store = {};
        },
        /* 13 */
        function(module, exports, __webpack_require__) {
          var baseIsNative = __webpack_require__(192),
            getValue = __webpack_require__(197);

          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }

          module.exports = getNative;
        },
        /* 14 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;
          var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
          exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
          var FLATTENABLE_KEYS = ["body", "expressions"];
          exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
          var FOR_INIT_KEYS = ["left", "init"];
          exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
          var COMMENT_KEYS = [
            "leadingComments",
            "trailingComments",
            "innerComments",
          ];
          exports.COMMENT_KEYS = COMMENT_KEYS;
          var LOGICAL_OPERATORS = ["||", "&&", "??"];
          exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
          var UPDATE_OPERATORS = ["++", "--"];
          exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
          var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
          exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
          var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
          exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
          var COMPARISON_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS.concat([
            "in",
            "instanceof",
          ]);
          exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
          var BOOLEAN_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS.concat(
            BOOLEAN_NUMBER_BINARY_OPERATORS
          );
          exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
          var NUMBER_BINARY_OPERATORS = [
            "-",
            "/",
            "%",
            "*",
            "**",
            "&",
            "|",
            ">>",
            ">>>",
            "<<",
            "^",
          ];
          exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
          var BINARY_OPERATORS = ["+"].concat(
            NUMBER_BINARY_OPERATORS,
            BOOLEAN_BINARY_OPERATORS
          );
          exports.BINARY_OPERATORS = BINARY_OPERATORS;
          var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
          exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
          var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
          exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
          var STRING_UNARY_OPERATORS = ["typeof"];
          exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
          var UNARY_OPERATORS = ["void", "throw"].concat(
            BOOLEAN_UNARY_OPERATORS,
            NUMBER_UNARY_OPERATORS,
            STRING_UNARY_OPERATORS
          );
          exports.UNARY_OPERATORS = UNARY_OPERATORS;
          var INHERIT_KEYS = {
            optional: ["typeAnnotation", "typeParameters", "returnType"],
            force: ["start", "loc", "end"],
          };
          exports.INHERIT_KEYS = INHERIT_KEYS;
          var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
          exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
          var NOT_LOCAL_BINDING = Symbol.for(
            "should not be considered a local binding"
          );
          exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
        },
        /* 15 */
        function(module, exports, __webpack_require__) {
          /* WEBPACK VAR INJECTION */ (function(process) {
            function normalizeArray(parts, allowAboveRoot) {
              var up = 0;

              for (var i = parts.length - 1; i >= 0; i--) {
                var last = parts[i];

                if (last === ".") {
                  parts.splice(i, 1);
                } else if (last === "..") {
                  parts.splice(i, 1);
                  up++;
                } else if (up) {
                  parts.splice(i, 1);
                  up--;
                }
              }

              if (allowAboveRoot) {
                for (; up--; up) {
                  parts.unshift("..");
                }
              }

              return parts;
            }

            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;

            var splitPath = function splitPath(filename) {
              return splitPathRe.exec(filename).slice(1);
            };

            exports.resolve = function() {
              var resolvedPath = "",
                resolvedAbsolute = false;

              for (
                var i = arguments.length - 1;
                i >= -1 && !resolvedAbsolute;
                i--
              ) {
                var path = i >= 0 ? arguments[i] : process.cwd();

                if (typeof path !== "string") {
                  throw new TypeError(
                    "Arguments to path.resolve must be strings"
                  );
                } else if (!path) {
                  continue;
                }

                resolvedPath = path + "/" + resolvedPath;
                resolvedAbsolute = path.charAt(0) === "/";
              }

              resolvedPath = normalizeArray(
                filter(resolvedPath.split("/"), function(p) {
                  return !!p;
                }),
                !resolvedAbsolute
              ).join("/");
              return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
            };

            exports.normalize = function(path) {
              var isAbsolute = exports.isAbsolute(path),
                trailingSlash = substr(path, -1) === "/";
              path = normalizeArray(
                filter(path.split("/"), function(p) {
                  return !!p;
                }),
                !isAbsolute
              ).join("/");

              if (!path && !isAbsolute) {
                path = ".";
              }

              if (path && trailingSlash) {
                path += "/";
              }

              return (isAbsolute ? "/" : "") + path;
            };

            exports.isAbsolute = function(path) {
              return path.charAt(0) === "/";
            };

            exports.join = function() {
              var paths = Array.prototype.slice.call(arguments, 0);
              return exports.normalize(
                filter(paths, function(p, index) {
                  if (typeof p !== "string") {
                    throw new TypeError(
                      "Arguments to path.join must be strings"
                    );
                  }

                  return p;
                }).join("/")
              );
            };

            exports.relative = function(from, to) {
              from = exports.resolve(from).substr(1);
              to = exports.resolve(to).substr(1);

              function trim(arr) {
                var start = 0;

                for (; start < arr.length; start++) {
                  if (arr[start] !== "") break;
                }

                var end = arr.length - 1;

                for (; end >= 0; end--) {
                  if (arr[end] !== "") break;
                }

                if (start > end) return [];
                return arr.slice(start, end - start + 1);
              }

              var fromParts = trim(from.split("/"));
              var toParts = trim(to.split("/"));
              var length = Math.min(fromParts.length, toParts.length);
              var samePartsLength = length;

              for (var i = 0; i < length; i++) {
                if (fromParts[i] !== toParts[i]) {
                  samePartsLength = i;
                  break;
                }
              }

              var outputParts = [];

              for (var i = samePartsLength; i < fromParts.length; i++) {
                outputParts.push("..");
              }

              outputParts = outputParts.concat(toParts.slice(samePartsLength));
              return outputParts.join("/");
            };

            exports.sep = "/";
            exports.delimiter = ":";

            exports.dirname = function(path) {
              var result = splitPath(path),
                root = result[0],
                dir = result[1];

              if (!root && !dir) {
                return ".";
              }

              if (dir) {
                dir = dir.substr(0, dir.length - 1);
              }

              return root + dir;
            };

            exports.basename = function(path, ext) {
              var f = splitPath(path)[2];

              if (ext && f.substr(-1 * ext.length) === ext) {
                f = f.substr(0, f.length - ext.length);
              }

              return f;
            };

            exports.extname = function(path) {
              return splitPath(path)[3];
            };

            function filter(xs, f) {
              if (xs.filter) return xs.filter(f);
              var res = [];

              for (var i = 0; i < xs.length; i++) {
                if (f(xs[i], i, xs)) res.push(xs[i]);
              }

              return res;
            }

            var substr =
              "ab".substr(-1) === "b"
                ? function(str, start, len) {
                    return str.substr(start, len);
                  }
                : function(str, start, len) {
                    if (start < 0) start = str.length + start;
                    return str.substr(start, len);
                  };
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(3)));
        },
        /* 16 */
        function(module, exports, __webpack_require__) {
          /* WEBPACK VAR INJECTION */ (function(process) {
            exports = module.exports = SemVer;
            var debug;
            if (
              typeof process === "object" &&
              process.env &&
              undefined &&
              /\bsemver\b/i.test(undefined)
            )
              debug = function debug() {
                var args = Array.prototype.slice.call(arguments, 0);
                args.unshift("SEMVER");
                console.log.apply(console, args);
              };
            else debug = function debug() {};
            exports.SEMVER_SPEC_VERSION = "2.0.0";
            var MAX_LENGTH = 256;
            var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
            var MAX_SAFE_COMPONENT_LENGTH = 16;
            var re = (exports.re = []);
            var src = (exports.src = []);
            var R = 0;
            var NUMERICIDENTIFIER = R++;
            src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
            var NUMERICIDENTIFIERLOOSE = R++;
            src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
            var NONNUMERICIDENTIFIER = R++;
            src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
            var MAINVERSION = R++;
            src[MAINVERSION] =
              "(" +
              src[NUMERICIDENTIFIER] +
              ")\\." +
              "(" +
              src[NUMERICIDENTIFIER] +
              ")\\." +
              "(" +
              src[NUMERICIDENTIFIER] +
              ")";
            var MAINVERSIONLOOSE = R++;
            src[MAINVERSIONLOOSE] =
              "(" +
              src[NUMERICIDENTIFIERLOOSE] +
              ")\\." +
              "(" +
              src[NUMERICIDENTIFIERLOOSE] +
              ")\\." +
              "(" +
              src[NUMERICIDENTIFIERLOOSE] +
              ")";
            var PRERELEASEIDENTIFIER = R++;
            src[PRERELEASEIDENTIFIER] =
              "(?:" +
              src[NUMERICIDENTIFIER] +
              "|" +
              src[NONNUMERICIDENTIFIER] +
              ")";
            var PRERELEASEIDENTIFIERLOOSE = R++;
            src[PRERELEASEIDENTIFIERLOOSE] =
              "(?:" +
              src[NUMERICIDENTIFIERLOOSE] +
              "|" +
              src[NONNUMERICIDENTIFIER] +
              ")";
            var PRERELEASE = R++;
            src[PRERELEASE] =
              "(?:-(" +
              src[PRERELEASEIDENTIFIER] +
              "(?:\\." +
              src[PRERELEASEIDENTIFIER] +
              ")*))";
            var PRERELEASELOOSE = R++;
            src[PRERELEASELOOSE] =
              "(?:-?(" +
              src[PRERELEASEIDENTIFIERLOOSE] +
              "(?:\\." +
              src[PRERELEASEIDENTIFIERLOOSE] +
              ")*))";
            var BUILDIDENTIFIER = R++;
            src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
            var BUILD = R++;
            src[BUILD] =
              "(?:\\+(" +
              src[BUILDIDENTIFIER] +
              "(?:\\." +
              src[BUILDIDENTIFIER] +
              ")*))";
            var FULL = R++;
            var FULLPLAIN =
              "v?" +
              src[MAINVERSION] +
              src[PRERELEASE] +
              "?" +
              src[BUILD] +
              "?";
            src[FULL] = "^" + FULLPLAIN + "$";
            var LOOSEPLAIN =
              "[v=\\s]*" +
              src[MAINVERSIONLOOSE] +
              src[PRERELEASELOOSE] +
              "?" +
              src[BUILD] +
              "?";
            var LOOSE = R++;
            src[LOOSE] = "^" + LOOSEPLAIN + "$";
            var GTLT = R++;
            src[GTLT] = "((?:<|>)?=?)";
            var XRANGEIDENTIFIERLOOSE = R++;
            src[XRANGEIDENTIFIERLOOSE] =
              src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
            var XRANGEIDENTIFIER = R++;
            src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
            var XRANGEPLAIN = R++;
            src[XRANGEPLAIN] =
              "[v=\\s]*(" +
              src[XRANGEIDENTIFIER] +
              ")" +
              "(?:\\.(" +
              src[XRANGEIDENTIFIER] +
              ")" +
              "(?:\\.(" +
              src[XRANGEIDENTIFIER] +
              ")" +
              "(?:" +
              src[PRERELEASE] +
              ")?" +
              src[BUILD] +
              "?" +
              ")?)?";
            var XRANGEPLAINLOOSE = R++;
            src[XRANGEPLAINLOOSE] =
              "[v=\\s]*(" +
              src[XRANGEIDENTIFIERLOOSE] +
              ")" +
              "(?:\\.(" +
              src[XRANGEIDENTIFIERLOOSE] +
              ")" +
              "(?:\\.(" +
              src[XRANGEIDENTIFIERLOOSE] +
              ")" +
              "(?:" +
              src[PRERELEASELOOSE] +
              ")?" +
              src[BUILD] +
              "?" +
              ")?)?";
            var XRANGE = R++;
            src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
            var XRANGELOOSE = R++;
            src[XRANGELOOSE] =
              "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
            var COERCE = R++;
            src[COERCE] =
              "(?:^|[^\\d])" +
              "(\\d{1," +
              MAX_SAFE_COMPONENT_LENGTH +
              "})" +
              "(?:\\.(\\d{1," +
              MAX_SAFE_COMPONENT_LENGTH +
              "}))?" +
              "(?:\\.(\\d{1," +
              MAX_SAFE_COMPONENT_LENGTH +
              "}))?" +
              "(?:$|[^\\d])";
            var LONETILDE = R++;
            src[LONETILDE] = "(?:~>?)";
            var TILDETRIM = R++;
            src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
            re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
            var tildeTrimReplace = "$1~";
            var TILDE = R++;
            src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
            var TILDELOOSE = R++;
            src[TILDELOOSE] =
              "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
            var LONECARET = R++;
            src[LONECARET] = "(?:\\^)";
            var CARETTRIM = R++;
            src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
            re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
            var caretTrimReplace = "$1^";
            var CARET = R++;
            src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
            var CARETLOOSE = R++;
            src[CARETLOOSE] =
              "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
            var COMPARATORLOOSE = R++;
            src[COMPARATORLOOSE] =
              "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
            var COMPARATOR = R++;
            src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
            var COMPARATORTRIM = R++;
            src[COMPARATORTRIM] =
              "(\\s*)" +
              src[GTLT] +
              "\\s*(" +
              LOOSEPLAIN +
              "|" +
              src[XRANGEPLAIN] +
              ")";
            re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
            var comparatorTrimReplace = "$1$2$3";
            var HYPHENRANGE = R++;
            src[HYPHENRANGE] =
              "^\\s*(" +
              src[XRANGEPLAIN] +
              ")" +
              "\\s+-\\s+" +
              "(" +
              src[XRANGEPLAIN] +
              ")" +
              "\\s*$";
            var HYPHENRANGELOOSE = R++;
            src[HYPHENRANGELOOSE] =
              "^\\s*(" +
              src[XRANGEPLAINLOOSE] +
              ")" +
              "\\s+-\\s+" +
              "(" +
              src[XRANGEPLAINLOOSE] +
              ")" +
              "\\s*$";
            var STAR = R++;
            src[STAR] = "(<|>)?=?\\s*\\*";

            for (var i = 0; i < R; i++) {
              debug(i, src[i]);
              if (!re[i]) re[i] = new RegExp(src[i]);
            }

            exports.parse = parse;

            function parse(version, loose) {
              if (version instanceof SemVer) return version;
              if (typeof version !== "string") return null;
              if (version.length > MAX_LENGTH) return null;
              var r = loose ? re[LOOSE] : re[FULL];
              if (!r.test(version)) return null;

              try {
                return new SemVer(version, loose);
              } catch (er) {
                return null;
              }
            }

            exports.valid = valid;

            function valid(version, loose) {
              var v = parse(version, loose);
              return v ? v.version : null;
            }

            exports.clean = clean;

            function clean(version, loose) {
              var s = parse(version.trim().replace(/^[=v]+/, ""), loose);
              return s ? s.version : null;
            }

            exports.SemVer = SemVer;

            function SemVer(version, loose) {
              if (version instanceof SemVer) {
                if (version.loose === loose) return version;
                else version = version.version;
              } else if (typeof version !== "string") {
                throw new TypeError("Invalid Version: " + version);
              }

              if (version.length > MAX_LENGTH)
                throw new TypeError(
                  "version is longer than " + MAX_LENGTH + " characters"
                );
              if (!(this instanceof SemVer)) return new SemVer(version, loose);
              debug("SemVer", version, loose);
              this.loose = loose;
              var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
              if (!m) throw new TypeError("Invalid Version: " + version);
              this.raw = version;
              this.major = +m[1];
              this.minor = +m[2];
              this.patch = +m[3];
              if (this.major > MAX_SAFE_INTEGER || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
                throw new TypeError("Invalid patch version");
              if (!m[4]) this.prerelease = [];
              else
                this.prerelease = m[4].split(".").map(function(id) {
                  if (/^[0-9]+$/.test(id)) {
                    var num = +id;
                    if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
                  }

                  return id;
                });
              this.build = m[5] ? m[5].split(".") : [];
              this.format();
            }

            SemVer.prototype.format = function() {
              this.version = this.major + "." + this.minor + "." + this.patch;
              if (this.prerelease.length)
                this.version += "-" + this.prerelease.join(".");
              return this.version;
            };

            SemVer.prototype.toString = function() {
              return this.version;
            };

            SemVer.prototype.compare = function(other) {
              debug("SemVer.compare", this.version, this.loose, other);
              if (!(other instanceof SemVer))
                other = new SemVer(other, this.loose);
              return this.compareMain(other) || this.comparePre(other);
            };

            SemVer.prototype.compareMain = function(other) {
              if (!(other instanceof SemVer))
                other = new SemVer(other, this.loose);
              return (
                compareIdentifiers(this.major, other.major) ||
                compareIdentifiers(this.minor, other.minor) ||
                compareIdentifiers(this.patch, other.patch)
              );
            };

            SemVer.prototype.comparePre = function(other) {
              if (!(other instanceof SemVer))
                other = new SemVer(other, this.loose);
              if (this.prerelease.length && !other.prerelease.length) return -1;
              else if (!this.prerelease.length && other.prerelease.length)
                return 1;
              else if (!this.prerelease.length && !other.prerelease.length)
                return 0;
              var i = 0;

              do {
                var a = this.prerelease[i];
                var b = other.prerelease[i];
                debug("prerelease compare", i, a, b);
                if (a === undefined && b === undefined) return 0;
                else if (b === undefined) return 1;
                else if (a === undefined) return -1;
                else if (a === b) continue;
                else return compareIdentifiers(a, b);
              } while (++i);
            };

            SemVer.prototype.inc = function(release, identifier) {
              switch (release) {
                case "premajor":
                  this.prerelease.length = 0;
                  this.patch = 0;
                  this.minor = 0;
                  this.major++;
                  this.inc("pre", identifier);
                  break;

                case "preminor":
                  this.prerelease.length = 0;
                  this.patch = 0;
                  this.minor++;
                  this.inc("pre", identifier);
                  break;

                case "prepatch":
                  this.prerelease.length = 0;
                  this.inc("patch", identifier);
                  this.inc("pre", identifier);
                  break;

                case "prerelease":
                  if (this.prerelease.length === 0)
                    this.inc("patch", identifier);
                  this.inc("pre", identifier);
                  break;

                case "major":
                  if (
                    this.minor !== 0 ||
                    this.patch !== 0 ||
                    this.prerelease.length === 0
                  )
                    this.major++;
                  this.minor = 0;
                  this.patch = 0;
                  this.prerelease = [];
                  break;

                case "minor":
                  if (this.patch !== 0 || this.prerelease.length === 0)
                    this.minor++;
                  this.patch = 0;
                  this.prerelease = [];
                  break;

                case "patch":
                  if (this.prerelease.length === 0) this.patch++;
                  this.prerelease = [];
                  break;

                case "pre":
                  if (this.prerelease.length === 0) this.prerelease = [0];
                  else {
                    var i = this.prerelease.length;

                    while (--i >= 0) {
                      if (typeof this.prerelease[i] === "number") {
                        this.prerelease[i]++;
                        i = -2;
                      }
                    }

                    if (i === -1) this.prerelease.push(0);
                  }

                  if (identifier) {
                    if (this.prerelease[0] === identifier) {
                      if (isNaN(this.prerelease[1]))
                        this.prerelease = [identifier, 0];
                    } else this.prerelease = [identifier, 0];
                  }

                  break;

                default:
                  throw new Error("invalid increment argument: " + release);
              }

              this.format();
              this.raw = this.version;
              return this;
            };

            exports.inc = inc;

            function inc(version, release, loose, identifier) {
              if (typeof loose === "string") {
                identifier = loose;
                loose = undefined;
              }

              try {
                return new SemVer(version, loose).inc(release, identifier)
                  .version;
              } catch (er) {
                return null;
              }
            }

            exports.diff = diff;

            function diff(version1, version2) {
              if (eq(version1, version2)) {
                return null;
              } else {
                var v1 = parse(version1);
                var v2 = parse(version2);

                if (v1.prerelease.length || v2.prerelease.length) {
                  for (var key in v1) {
                    if (key === "major" || key === "minor" || key === "patch") {
                      if (v1[key] !== v2[key]) {
                        return "pre" + key;
                      }
                    }
                  }

                  return "prerelease";
                }

                for (var key in v1) {
                  if (key === "major" || key === "minor" || key === "patch") {
                    if (v1[key] !== v2[key]) {
                      return key;
                    }
                  }
                }
              }
            }

            exports.compareIdentifiers = compareIdentifiers;
            var numeric = /^[0-9]+$/;

            function compareIdentifiers(a, b) {
              var anum = numeric.test(a);
              var bnum = numeric.test(b);

              if (anum && bnum) {
                a = +a;
                b = +b;
              }

              return anum && !bnum
                ? -1
                : bnum && !anum
                  ? 1
                  : a < b
                    ? -1
                    : a > b
                      ? 1
                      : 0;
            }

            exports.rcompareIdentifiers = rcompareIdentifiers;

            function rcompareIdentifiers(a, b) {
              return compareIdentifiers(b, a);
            }

            exports.major = major;

            function major(a, loose) {
              return new SemVer(a, loose).major;
            }

            exports.minor = minor;

            function minor(a, loose) {
              return new SemVer(a, loose).minor;
            }

            exports.patch = patch;

            function patch(a, loose) {
              return new SemVer(a, loose).patch;
            }

            exports.compare = compare;

            function compare(a, b, loose) {
              return new SemVer(a, loose).compare(new SemVer(b, loose));
            }

            exports.compareLoose = compareLoose;

            function compareLoose(a, b) {
              return compare(a, b, true);
            }

            exports.rcompare = rcompare;

            function rcompare(a, b, loose) {
              return compare(b, a, loose);
            }

            exports.sort = sort;

            function sort(list, loose) {
              return list.sort(function(a, b) {
                return exports.compare(a, b, loose);
              });
            }

            exports.rsort = rsort;

            function rsort(list, loose) {
              return list.sort(function(a, b) {
                return exports.rcompare(a, b, loose);
              });
            }

            exports.gt = gt;

            function gt(a, b, loose) {
              return compare(a, b, loose) > 0;
            }

            exports.lt = lt;

            function lt(a, b, loose) {
              return compare(a, b, loose) < 0;
            }

            exports.eq = eq;

            function eq(a, b, loose) {
              return compare(a, b, loose) === 0;
            }

            exports.neq = neq;

            function neq(a, b, loose) {
              return compare(a, b, loose) !== 0;
            }

            exports.gte = gte;

            function gte(a, b, loose) {
              return compare(a, b, loose) >= 0;
            }

            exports.lte = lte;

            function lte(a, b, loose) {
              return compare(a, b, loose) <= 0;
            }

            exports.cmp = cmp;

            function cmp(a, op, b, loose) {
              var ret;

              switch (op) {
                case "===":
                  if (typeof a === "object") a = a.version;
                  if (typeof b === "object") b = b.version;
                  ret = a === b;
                  break;

                case "!==":
                  if (typeof a === "object") a = a.version;
                  if (typeof b === "object") b = b.version;
                  ret = a !== b;
                  break;

                case "":
                case "=":
                case "==":
                  ret = eq(a, b, loose);
                  break;

                case "!=":
                  ret = neq(a, b, loose);
                  break;

                case ">":
                  ret = gt(a, b, loose);
                  break;

                case ">=":
                  ret = gte(a, b, loose);
                  break;

                case "<":
                  ret = lt(a, b, loose);
                  break;

                case "<=":
                  ret = lte(a, b, loose);
                  break;

                default:
                  throw new TypeError("Invalid operator: " + op);
              }

              return ret;
            }

            exports.Comparator = Comparator;

            function Comparator(comp, loose) {
              if (comp instanceof Comparator) {
                if (comp.loose === loose) return comp;
                else comp = comp.value;
              }

              if (!(this instanceof Comparator))
                return new Comparator(comp, loose);
              debug("comparator", comp, loose);
              this.loose = loose;
              this.parse(comp);
              if (this.semver === ANY) this.value = "";
              else this.value = this.operator + this.semver.version;
              debug("comp", this);
            }

            var ANY = {};

            Comparator.prototype.parse = function(comp) {
              var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
              var m = comp.match(r);
              if (!m) throw new TypeError("Invalid comparator: " + comp);
              this.operator = m[1];
              if (this.operator === "=") this.operator = "";
              if (!m[2]) this.semver = ANY;
              else this.semver = new SemVer(m[2], this.loose);
            };

            Comparator.prototype.toString = function() {
              return this.value;
            };

            Comparator.prototype.test = function(version) {
              debug("Comparator.test", version, this.loose);
              if (this.semver === ANY) return true;
              if (typeof version === "string")
                version = new SemVer(version, this.loose);
              return cmp(version, this.operator, this.semver, this.loose);
            };

            Comparator.prototype.intersects = function(comp, loose) {
              if (!(comp instanceof Comparator)) {
                throw new TypeError("a Comparator is required");
              }

              var rangeTmp;

              if (this.operator === "") {
                rangeTmp = new Range(comp.value, loose);
                return satisfies(this.value, rangeTmp, loose);
              } else if (comp.operator === "") {
                rangeTmp = new Range(this.value, loose);
                return satisfies(comp.semver, rangeTmp, loose);
              }

              var sameDirectionIncreasing =
                (this.operator === ">=" || this.operator === ">") &&
                (comp.operator === ">=" || comp.operator === ">");
              var sameDirectionDecreasing =
                (this.operator === "<=" || this.operator === "<") &&
                (comp.operator === "<=" || comp.operator === "<");
              var sameSemVer = this.semver.version === comp.semver.version;
              var differentDirectionsInclusive =
                (this.operator === ">=" || this.operator === "<=") &&
                (comp.operator === ">=" || comp.operator === "<=");
              var oppositeDirectionsLessThan =
                cmp(this.semver, "<", comp.semver, loose) &&
                (this.operator === ">=" || this.operator === ">") &&
                (comp.operator === "<=" || comp.operator === "<");
              var oppositeDirectionsGreaterThan =
                cmp(this.semver, ">", comp.semver, loose) &&
                (this.operator === "<=" || this.operator === "<") &&
                (comp.operator === ">=" || comp.operator === ">");
              return (
                sameDirectionIncreasing ||
                sameDirectionDecreasing ||
                (sameSemVer && differentDirectionsInclusive) ||
                oppositeDirectionsLessThan ||
                oppositeDirectionsGreaterThan
              );
            };

            exports.Range = Range;

            function Range(range, loose) {
              if (range instanceof Range) {
                if (range.loose === loose) {
                  return range;
                } else {
                  return new Range(range.raw, loose);
                }
              }

              if (range instanceof Comparator) {
                return new Range(range.value, loose);
              }

              if (!(this instanceof Range)) return new Range(range, loose);
              this.loose = loose;
              this.raw = range;
              this.set = range
                .split(/\s*\|\|\s*/)
                .map(function(range) {
                  return this.parseRange(range.trim());
                }, this)
                .filter(function(c) {
                  return c.length;
                });

              if (!this.set.length) {
                throw new TypeError("Invalid SemVer Range: " + range);
              }

              this.format();
            }

            Range.prototype.format = function() {
              this.range = this.set
                .map(function(comps) {
                  return comps.join(" ").trim();
                })
                .join("||")
                .trim();
              return this.range;
            };

            Range.prototype.toString = function() {
              return this.range;
            };

            Range.prototype.parseRange = function(range) {
              var loose = this.loose;
              range = range.trim();
              debug("range", range, loose);
              var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
              range = range.replace(hr, hyphenReplace);
              debug("hyphen replace", range);
              range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
              debug("comparator trim", range, re[COMPARATORTRIM]);
              range = range.replace(re[TILDETRIM], tildeTrimReplace);
              range = range.replace(re[CARETTRIM], caretTrimReplace);
              range = range.split(/\s+/).join(" ");
              var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
              var set = range
                .split(" ")
                .map(function(comp) {
                  return parseComparator(comp, loose);
                })
                .join(" ")
                .split(/\s+/);

              if (this.loose) {
                set = set.filter(function(comp) {
                  return !!comp.match(compRe);
                });
              }

              set = set.map(function(comp) {
                return new Comparator(comp, loose);
              });
              return set;
            };

            Range.prototype.intersects = function(range, loose) {
              if (!(range instanceof Range)) {
                throw new TypeError("a Range is required");
              }

              return this.set.some(function(thisComparators) {
                return thisComparators.every(function(thisComparator) {
                  return range.set.some(function(rangeComparators) {
                    return rangeComparators.every(function(rangeComparator) {
                      return thisComparator.intersects(rangeComparator, loose);
                    });
                  });
                });
              });
            };

            exports.toComparators = toComparators;

            function toComparators(range, loose) {
              return new Range(range, loose).set.map(function(comp) {
                return comp
                  .map(function(c) {
                    return c.value;
                  })
                  .join(" ")
                  .trim()
                  .split(" ");
              });
            }

            function parseComparator(comp, loose) {
              debug("comp", comp);
              comp = replaceCarets(comp, loose);
              debug("caret", comp);
              comp = replaceTildes(comp, loose);
              debug("tildes", comp);
              comp = replaceXRanges(comp, loose);
              debug("xrange", comp);
              comp = replaceStars(comp, loose);
              debug("stars", comp);
              return comp;
            }

            function isX(id) {
              return !id || id.toLowerCase() === "x" || id === "*";
            }

            function replaceTildes(comp, loose) {
              return comp
                .trim()
                .split(/\s+/)
                .map(function(comp) {
                  return replaceTilde(comp, loose);
                })
                .join(" ");
            }

            function replaceTilde(comp, loose) {
              var r = loose ? re[TILDELOOSE] : re[TILDE];
              return comp.replace(r, function(_, M, m, p, pr) {
                debug("tilde", comp, _, M, m, p, pr);
                var ret;
                if (isX(M)) ret = "";
                else if (isX(m)) ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
                else if (isX(p))
                  ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
                else if (pr) {
                  debug("replaceTilde pr", pr);
                  if (pr.charAt(0) !== "-") pr = "-" + pr;
                  ret =
                    ">=" +
                    M +
                    "." +
                    m +
                    "." +
                    p +
                    pr +
                    " <" +
                    M +
                    "." +
                    (+m + 1) +
                    ".0";
                } else
                  ret =
                    ">=" +
                    M +
                    "." +
                    m +
                    "." +
                    p +
                    " <" +
                    M +
                    "." +
                    (+m + 1) +
                    ".0";
                debug("tilde return", ret);
                return ret;
              });
            }

            function replaceCarets(comp, loose) {
              return comp
                .trim()
                .split(/\s+/)
                .map(function(comp) {
                  return replaceCaret(comp, loose);
                })
                .join(" ");
            }

            function replaceCaret(comp, loose) {
              debug("caret", comp, loose);
              var r = loose ? re[CARETLOOSE] : re[CARET];
              return comp.replace(r, function(_, M, m, p, pr) {
                debug("caret", comp, _, M, m, p, pr);
                var ret;
                if (isX(M)) ret = "";
                else if (isX(m)) ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
                else if (isX(p)) {
                  if (M === "0")
                    ret =
                      ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
                  else ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
                } else if (pr) {
                  debug("replaceCaret pr", pr);
                  if (pr.charAt(0) !== "-") pr = "-" + pr;

                  if (M === "0") {
                    if (m === "0")
                      ret =
                        ">=" +
                        M +
                        "." +
                        m +
                        "." +
                        p +
                        pr +
                        " <" +
                        M +
                        "." +
                        m +
                        "." +
                        (+p + 1);
                    else
                      ret =
                        ">=" +
                        M +
                        "." +
                        m +
                        "." +
                        p +
                        pr +
                        " <" +
                        M +
                        "." +
                        (+m + 1) +
                        ".0";
                  } else
                    ret =
                      ">=" +
                      M +
                      "." +
                      m +
                      "." +
                      p +
                      pr +
                      " <" +
                      (+M + 1) +
                      ".0.0";
                } else {
                  debug("no pr");

                  if (M === "0") {
                    if (m === "0")
                      ret =
                        ">=" +
                        M +
                        "." +
                        m +
                        "." +
                        p +
                        " <" +
                        M +
                        "." +
                        m +
                        "." +
                        (+p + 1);
                    else
                      ret =
                        ">=" +
                        M +
                        "." +
                        m +
                        "." +
                        p +
                        " <" +
                        M +
                        "." +
                        (+m + 1) +
                        ".0";
                  } else
                    ret =
                      ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
                }
                debug("caret return", ret);
                return ret;
              });
            }

            function replaceXRanges(comp, loose) {
              debug("replaceXRanges", comp, loose);
              return comp
                .split(/\s+/)
                .map(function(comp) {
                  return replaceXRange(comp, loose);
                })
                .join(" ");
            }

            function replaceXRange(comp, loose) {
              comp = comp.trim();
              var r = loose ? re[XRANGELOOSE] : re[XRANGE];
              return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
                debug("xRange", comp, ret, gtlt, M, m, p, pr);
                var xM = isX(M);
                var xm = xM || isX(m);
                var xp = xm || isX(p);
                var anyX = xp;
                if (gtlt === "=" && anyX) gtlt = "";

                if (xM) {
                  if (gtlt === ">" || gtlt === "<") {
                    ret = "<0.0.0";
                  } else {
                    ret = "*";
                  }
                } else if (gtlt && anyX) {
                  if (xm) m = 0;
                  if (xp) p = 0;

                  if (gtlt === ">") {
                    gtlt = ">=";

                    if (xm) {
                      M = +M + 1;
                      m = 0;
                      p = 0;
                    } else if (xp) {
                      m = +m + 1;
                      p = 0;
                    }
                  } else if (gtlt === "<=") {
                    gtlt = "<";
                    if (xm) M = +M + 1;
                    else m = +m + 1;
                  }

                  ret = gtlt + M + "." + m + "." + p;
                } else if (xm) {
                  ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
                } else if (xp) {
                  ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
                }

                debug("xRange return", ret);
                return ret;
              });
            }

            function replaceStars(comp, loose) {
              debug("replaceStars", comp, loose);
              return comp.trim().replace(re[STAR], "");
            }

            function hyphenReplace(
              $0,
              from,
              fM,
              fm,
              fp,
              fpr,
              fb,
              to,
              tM,
              tm,
              tp,
              tpr,
              tb
            ) {
              if (isX(fM)) from = "";
              else if (isX(fm)) from = ">=" + fM + ".0.0";
              else if (isX(fp)) from = ">=" + fM + "." + fm + ".0";
              else from = ">=" + from;
              if (isX(tM)) to = "";
              else if (isX(tm)) to = "<" + (+tM + 1) + ".0.0";
              else if (isX(tp)) to = "<" + tM + "." + (+tm + 1) + ".0";
              else if (tpr) to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
              else to = "<=" + to;
              return (from + " " + to).trim();
            }

            Range.prototype.test = function(version) {
              if (!version) return false;
              if (typeof version === "string")
                version = new SemVer(version, this.loose);

              for (var i = 0; i < this.set.length; i++) {
                if (testSet(this.set[i], version)) return true;
              }

              return false;
            };

            function testSet(set, version) {
              for (var i = 0; i < set.length; i++) {
                if (!set[i].test(version)) return false;
              }

              if (version.prerelease.length) {
                for (var i = 0; i < set.length; i++) {
                  debug(set[i].semver);
                  if (set[i].semver === ANY) continue;

                  if (set[i].semver.prerelease.length > 0) {
                    var allowed = set[i].semver;
                    if (
                      allowed.major === version.major &&
                      allowed.minor === version.minor &&
                      allowed.patch === version.patch
                    )
                      return true;
                  }
                }

                return false;
              }

              return true;
            }

            exports.satisfies = satisfies;

            function satisfies(version, range, loose) {
              try {
                range = new Range(range, loose);
              } catch (er) {
                return false;
              }

              return range.test(version);
            }

            exports.maxSatisfying = maxSatisfying;

            function maxSatisfying(versions, range, loose) {
              var max = null;
              var maxSV = null;

              try {
                var rangeObj = new Range(range, loose);
              } catch (er) {
                return null;
              }

              versions.forEach(function(v) {
                if (rangeObj.test(v)) {
                  if (!max || maxSV.compare(v) === -1) {
                    max = v;
                    maxSV = new SemVer(max, loose);
                  }
                }
              });
              return max;
            }

            exports.minSatisfying = minSatisfying;

            function minSatisfying(versions, range, loose) {
              var min = null;
              var minSV = null;

              try {
                var rangeObj = new Range(range, loose);
              } catch (er) {
                return null;
              }

              versions.forEach(function(v) {
                if (rangeObj.test(v)) {
                  if (!min || minSV.compare(v) === 1) {
                    min = v;
                    minSV = new SemVer(min, loose);
                  }
                }
              });
              return min;
            }

            exports.validRange = validRange;

            function validRange(range, loose) {
              try {
                return new Range(range, loose).range || "*";
              } catch (er) {
                return null;
              }
            }

            exports.ltr = ltr;

            function ltr(version, range, loose) {
              return outside(version, range, "<", loose);
            }

            exports.gtr = gtr;

            function gtr(version, range, loose) {
              return outside(version, range, ">", loose);
            }

            exports.outside = outside;

            function outside(version, range, hilo, loose) {
              version = new SemVer(version, loose);
              range = new Range(range, loose);
              var gtfn, ltefn, ltfn, comp, ecomp;

              switch (hilo) {
                case ">":
                  gtfn = gt;
                  ltefn = lte;
                  ltfn = lt;
                  comp = ">";
                  ecomp = ">=";
                  break;

                case "<":
                  gtfn = lt;
                  ltefn = gte;
                  ltfn = gt;
                  comp = "<";
                  ecomp = "<=";
                  break;

                default:
                  throw new TypeError('Must provide a hilo val of "<" or ">"');
              }

              if (satisfies(version, range, loose)) {
                return false;
              }

              for (var i = 0; i < range.set.length; ++i) {
                var comparators = range.set[i];
                var high = null;
                var low = null;
                comparators.forEach(function(comparator) {
                  if (comparator.semver === ANY) {
                    comparator = new Comparator(">=0.0.0");
                  }

                  high = high || comparator;
                  low = low || comparator;

                  if (gtfn(comparator.semver, high.semver, loose)) {
                    high = comparator;
                  } else if (ltfn(comparator.semver, low.semver, loose)) {
                    low = comparator;
                  }
                });

                if (high.operator === comp || high.operator === ecomp) {
                  return false;
                }

                if (
                  (!low.operator || low.operator === comp) &&
                  ltefn(version, low.semver)
                ) {
                  return false;
                } else if (
                  low.operator === ecomp &&
                  ltfn(version, low.semver)
                ) {
                  return false;
                }
              }

              return true;
            }

            exports.prerelease = prerelease;

            function prerelease(version, loose) {
              var parsed = parse(version, loose);
              return parsed && parsed.prerelease.length
                ? parsed.prerelease
                : null;
            }

            exports.intersects = intersects;

            function intersects(r1, r2, loose) {
              r1 = new Range(r1, loose);
              r2 = new Range(r2, loose);
              return r1.intersects(r2);
            }

            exports.coerce = coerce;

            function coerce(version) {
              if (version instanceof SemVer) return version;
              if (typeof version !== "string") return null;
              var match = version.match(re[COERCE]);
              if (match == null) return null;
              return parse(
                (match[1] || "0") +
                  "." +
                  (match[2] || "0") +
                  "." +
                  (match[3] || "0")
              );
            }
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(3)));
        },
        /* 17 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.isRequire = exports.createImport = exports.getModulePath = exports.isPolyfillSource = exports.filterStageFromList = exports.getLowestUnreleased = exports.isUnreleasedVersion = exports.prettifyTargets = exports.prettifyVersion = exports.findSuggestion = exports.getValues = exports.roundToMinor = exports.semverify = void 0;

          function _assert() {
            var data = _interopRequireDefault(__webpack_require__(23));

            _assert = function _assert() {
              return data;
            };

            return data;
          }

          function _semver() {
            var data = _interopRequireDefault(__webpack_require__(16));

            _semver = function _semver() {
              return data;
            };

            return data;
          }

          function _jsLevenshtein() {
            var data = _interopRequireDefault(__webpack_require__(174));

            _jsLevenshtein = function _jsLevenshtein() {
              return data;
            };

            return data;
          }

          function _babelHelperModuleImports() {
            var data = __webpack_require__(175);

            _babelHelperModuleImports = function _babelHelperModuleImports() {
              return data;
            };

            return data;
          }

          var _unreleasedLabels = _interopRequireDefault(
            __webpack_require__(297)
          );

          var _targetsParser = __webpack_require__(71);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var versionRegExp = /^(\d+|\d+.\d+)$/;

          var semverify = function semverify(version) {
            if (
              typeof version === "string" &&
              _semver().default.valid(version)
            ) {
              return version;
            }

            (0, _assert().default)(
              typeof version === "number" ||
                (typeof version === "string" && versionRegExp.test(version)),
              "'" + version + "' is not a valid version"
            );
            var split = version.toString().split(".");

            while (split.length < 3) {
              split.push("0");
            }

            return split.join(".");
          };

          exports.semverify = semverify;

          var roundToMinor = function roundToMinor(version) {
            return (
              _semver().default.major(version) +
              "." +
              _semver().default.minor(version) +
              ".0"
            );
          };

          exports.roundToMinor = roundToMinor;

          var getValues = function getValues(object) {
            return Object.keys(object).map(function(key) {
              return object[key];
            });
          };

          exports.getValues = getValues;

          var findSuggestion = function findSuggestion(options, option) {
            var levenshteinValue = Infinity;
            return options.reduce(function(suggestion, validOption) {
              var value = (0, _jsLevenshtein().default)(validOption, option);

              if (value < levenshteinValue) {
                levenshteinValue = value;
                return validOption;
              }

              return suggestion;
            }, undefined);
          };

          exports.findSuggestion = findSuggestion;

          var prettifyVersion = function prettifyVersion(version) {
            if (typeof version !== "string") {
              return version;
            }

            var parts = [_semver().default.major(version)];

            var minor = _semver().default.minor(version);

            var patch = _semver().default.patch(version);

            if (minor || patch) {
              parts.push(minor);
            }

            if (patch) {
              parts.push(patch);
            }

            return parts.join(".");
          };

          exports.prettifyVersion = prettifyVersion;

          var prettifyTargets = function prettifyTargets(targets) {
            return Object.keys(targets).reduce(function(results, target) {
              var value = targets[target];
              var unreleasedLabel = _unreleasedLabels.default[target];

              if (typeof value === "string" && unreleasedLabel !== value) {
                value = prettifyVersion(value);
              }

              results[target] = value;
              return results;
            }, {});
          };

          exports.prettifyTargets = prettifyTargets;

          var isUnreleasedVersion = function isUnreleasedVersion(version, env) {
            var unreleasedLabel = _unreleasedLabels.default[env];
            return (
              !!unreleasedLabel &&
              unreleasedLabel === version.toString().toLowerCase()
            );
          };

          exports.isUnreleasedVersion = isUnreleasedVersion;

          var getLowestUnreleased = function getLowestUnreleased(a, b, env) {
            var unreleasedLabel = _unreleasedLabels.default[env];
            var hasUnreleased = [a, b].some(function(item) {
              return item === unreleasedLabel;
            });

            if (hasUnreleased) {
              return a === hasUnreleased ? b : a || b;
            }

            return (0, _targetsParser.semverMin)(a, b);
          };

          exports.getLowestUnreleased = getLowestUnreleased;

          var filterStageFromList = function filterStageFromList(
            list,
            stageList
          ) {
            return Object.keys(list).reduce(function(result, item) {
              if (!stageList[item]) {
                result[item] = list[item];
              }

              return result;
            }, {});
          };

          exports.filterStageFromList = filterStageFromList;

          var isPolyfillSource = function isPolyfillSource(source) {
            return (
              source === "@gerhobbelt/babel-polyfill" || source === "core-js"
            );
          };

          exports.isPolyfillSource = isPolyfillSource;
          var modulePathMap = {
            "regenerator-runtime": "regenerator-runtime/runtime",
          };

          var getModulePath = function getModulePath(mod) {
            return modulePathMap[mod] || "core-js/modules/" + mod;
          };

          exports.getModulePath = getModulePath;

          var createImport = function createImport(path, mod) {
            return (0, _babelHelperModuleImports().addSideEffect)(
              path,
              getModulePath(mod)
            );
          };

          exports.createImport = createImport;

          var isRequire = function isRequire(t, path) {
            return (
              t.isExpressionStatement(path.node) &&
              t.isCallExpression(path.node.expression) &&
              t.isIdentifier(path.node.expression.callee) &&
              path.node.expression.callee.name === "require" &&
              path.node.expression.arguments.length === 1 &&
              t.isStringLiteral(path.node.expression.arguments[0]) &&
              isPolyfillSource(path.node.expression.arguments[0].value)
            );
          };

          exports.isRequire = isRequire;
        },
        /* 18 */
        function(module, exports, __webpack_require__) {
          var root = __webpack_require__(6);

          var Symbol = root.Symbol;
          module.exports = Symbol;
        },
        /* 19 */
        function(module, exports, __webpack_require__) {
          var arrayLikeKeys = __webpack_require__(97),
            baseKeys = __webpack_require__(216),
            isArrayLike = __webpack_require__(20);

          function keys(object) {
            return isArrayLike(object)
              ? arrayLikeKeys(object)
              : baseKeys(object);
          }

          module.exports = keys;
        },
        /* 20 */
        function(module, exports, __webpack_require__) {
          var isFunction = __webpack_require__(91),
            isLength = __webpack_require__(58);

          function isArrayLike(value) {
            return (
              value != null && isLength(value.length) && !isFunction(value)
            );
          }

          module.exports = isArrayLike;
        },
        /* 21 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          var virtualTypes = _interopRequireWildcard(__webpack_require__(135));

          function _debug() {
            var data = _interopRequireDefault(__webpack_require__(319));

            _debug = function _debug() {
              return data;
            };

            return data;
          }

          var _index = _interopRequireDefault(__webpack_require__(9));

          var _scope = _interopRequireDefault(__webpack_require__(137));

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          var _cache = __webpack_require__(43);

          function _babelGenerator() {
            var data = _interopRequireDefault(__webpack_require__(78));

            _babelGenerator = function _babelGenerator() {
              return data;
            };

            return data;
          }

          var NodePath_ancestry = _interopRequireWildcard(
            __webpack_require__(366)
          );

          var NodePath_inference = _interopRequireWildcard(
            __webpack_require__(367)
          );

          var NodePath_replacement = _interopRequireWildcard(
            __webpack_require__(370)
          );

          var NodePath_evaluation = _interopRequireWildcard(
            __webpack_require__(381)
          );

          var NodePath_conversion = _interopRequireWildcard(
            __webpack_require__(382)
          );

          var NodePath_introspection = _interopRequireWildcard(
            __webpack_require__(389)
          );

          var NodePath_context = _interopRequireWildcard(
            __webpack_require__(390)
          );

          var NodePath_removal = _interopRequireWildcard(
            __webpack_require__(391)
          );

          var NodePath_modification = _interopRequireWildcard(
            __webpack_require__(393)
          );

          var NodePath_family = _interopRequireWildcard(
            __webpack_require__(395)
          );

          var NodePath_comments = _interopRequireWildcard(
            __webpack_require__(396)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          var _debug2 = (0, _debug().default)("babel");

          var NodePath = (function() {
            function NodePath(hub, parent) {
              this.parent = parent;
              this.hub = hub;
              this.contexts = [];
              this.data = {};
              this.shouldSkip = false;
              this.shouldStop = false;
              this.removed = false;
              this.state = null;
              this.opts = null;
              this.skipKeys = null;
              this.parentPath = null;
              this.context = null;
              this.container = null;
              this.listKey = null;
              this.inList = false;
              this.parentKey = null;
              this.key = null;
              this.node = null;
              this.scope = null;
              this.type = null;
              this.typeAnnotation = null;
            }

            NodePath.get = function get(_ref) {
              var hub = _ref.hub,
                parentPath = _ref.parentPath,
                parent = _ref.parent,
                container = _ref.container,
                listKey = _ref.listKey,
                key = _ref.key;

              if (!hub && parentPath) {
                hub = parentPath.hub;
              }

              if (!parent) {
                throw new Error("To get a node path the parent needs to exist");
              }

              var targetNode = container[key];
              var paths = _cache.path.get(parent) || [];

              if (!_cache.path.has(parent)) {
                _cache.path.set(parent, paths);
              }

              var path;

              for (var i = 0; i < paths.length; i++) {
                var pathCheck = paths[i];

                if (pathCheck.node === targetNode) {
                  path = pathCheck;
                  break;
                }
              }

              if (!path) {
                path = new NodePath(hub, parent);
                paths.push(path);
              }

              path.setup(parentPath, container, listKey, key);
              return path;
            };

            var _proto = NodePath.prototype;

            _proto.getScope = function getScope(scope) {
              return this.isScope() ? new _scope.default(this) : scope;
            };

            _proto.setData = function setData(key, val) {
              return (this.data[key] = val);
            };

            _proto.getData = function getData(key, def) {
              var val = this.data[key];
              if (!val && def) val = this.data[key] = def;
              return val;
            };

            _proto.buildCodeFrameError = function buildCodeFrameError(
              msg,
              Error
            ) {
              if (Error === void 0) {
                Error = SyntaxError;
              }

              return this.hub.buildError(this.node, msg, Error);
            };

            _proto.traverse = function traverse(visitor, state) {
              (0, _index.default)(this.node, visitor, this.scope, state, this);
            };

            _proto.set = function set(key, node) {
              t().validate(this.node, key, node);
              this.node[key] = node;
            };

            _proto.getPathLocation = function getPathLocation() {
              var parts = [];
              var path = this;

              do {
                var key = path.key;
                if (path.inList) key = path.listKey + "[" + key + "]";
                parts.unshift(key);
              } while ((path = path.parentPath));

              return parts.join(".");
            };

            _proto.debug = function debug(message) {
              if (!_debug2.enabled) return;

              _debug2(
                this.getPathLocation() + " " + this.type + ": " + message
              );
            };

            _proto.toString = function toString() {
              return (0, _babelGenerator().default)(this.node).code;
            };

            return NodePath;
          })();

          exports.default = NodePath;
          Object.assign(
            NodePath.prototype,
            NodePath_ancestry,
            NodePath_inference,
            NodePath_replacement,
            NodePath_evaluation,
            NodePath_conversion,
            NodePath_introspection,
            NodePath_context,
            NodePath_removal,
            NodePath_modification,
            NodePath_family,
            NodePath_comments
          );

          var _loop2 = function _loop2() {
            if (_isArray) {
              if (_i >= _iterator.length) return "break";
              _ref2 = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) return "break";
              _ref2 = _i.value;
            }

            var type = _ref2;
            var typeKey = "is" + type;
            var fn = t()[typeKey];

            NodePath.prototype[typeKey] = function(opts) {
              return fn(this.node, opts);
            };

            NodePath.prototype["assert" + type] = function(opts) {
              if (!fn(this.node, opts)) {
                throw new TypeError("Expected node path of type " + type);
              }
            };
          };

          for (
            var _iterator = t().TYPES,
              _isArray = Array.isArray(_iterator),
              _i = 0,
              _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
            ;

          ) {
            var _ref2;

            var _ret2 = _loop2();

            if (_ret2 === "break") break;
          }

          var _loop = function _loop(type) {
            if (type[0] === "_") return "continue";
            if (t().TYPES.indexOf(type) < 0) t().TYPES.push(type);
            var virtualType = virtualTypes[type];

            NodePath.prototype["is" + type] = function(opts) {
              return virtualType.checkPath(this, opts);
            };
          };

          for (var type in virtualTypes) {
            var _ret = _loop(type);

            if (_ret === "continue") continue;
          }
        },
        /* 22 */
        function(module, exports) {
          module.exports = __WEBPACK_EXTERNAL_MODULE__22__;
        },
        /* 23 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(global) {
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

            function compare(a, b) {
              if (a === b) {
                return 0;
              }

              var x = a.length;
              var y = b.length;

              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break;
                }
              }

              if (x < y) {
                return -1;
              }

              if (y < x) {
                return 1;
              }

              return 0;
            }

            function isBuffer(b) {
              if (
                global.Buffer &&
                typeof global.Buffer.isBuffer === "function"
              ) {
                return global.Buffer.isBuffer(b);
              }

              return !!(b != null && b._isBuffer);
            }

            var util = __webpack_require__(171);

            var hasOwn = Object.prototype.hasOwnProperty;
            var pSlice = Array.prototype.slice;

            var functionsHaveNames = (function() {
              return function foo() {}.name === "foo";
            })();

            function pToString(obj) {
              return Object.prototype.toString.call(obj);
            }

            function isView(arrbuf) {
              if (isBuffer(arrbuf)) {
                return false;
              }

              if (typeof global.ArrayBuffer !== "function") {
                return false;
              }

              if (typeof ArrayBuffer.isView === "function") {
                return ArrayBuffer.isView(arrbuf);
              }

              if (!arrbuf) {
                return false;
              }

              if (arrbuf instanceof DataView) {
                return true;
              }

              if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
                return true;
              }

              return false;
            }

            var assert = (module.exports = ok);
            var regex = /\s*function\s+([^\(\s]*)\s*/;

            function getName(func) {
              if (!util.isFunction(func)) {
                return;
              }

              if (functionsHaveNames) {
                return func.name;
              }

              var str = func.toString();
              var match = str.match(regex);
              return match && match[1];
            }

            assert.AssertionError = function AssertionError(options) {
              this.name = "AssertionError";
              this.actual = options.actual;
              this.expected = options.expected;
              this.operator = options.operator;

              if (options.message) {
                this.message = options.message;
                this.generatedMessage = false;
              } else {
                this.message = getMessage(this);
                this.generatedMessage = true;
              }

              var stackStartFunction = options.stackStartFunction || fail;

              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, stackStartFunction);
              } else {
                var err = new Error();

                if (err.stack) {
                  var out = err.stack;
                  var fn_name = getName(stackStartFunction);
                  var idx = out.indexOf("\n" + fn_name);

                  if (idx >= 0) {
                    var next_line = out.indexOf("\n", idx + 1);
                    out = out.substring(next_line + 1);
                  }

                  this.stack = out;
                }
              }
            };

            util.inherits(assert.AssertionError, Error);

            function truncate(s, n) {
              if (typeof s === "string") {
                return s.length < n ? s : s.slice(0, n);
              } else {
                return s;
              }
            }

            function inspect(something) {
              if (functionsHaveNames || !util.isFunction(something)) {
                return util.inspect(something);
              }

              var rawname = getName(something);
              var name = rawname ? ": " + rawname : "";
              return "[Function" + name + "]";
            }

            function getMessage(self) {
              return (
                truncate(inspect(self.actual), 128) +
                " " +
                self.operator +
                " " +
                truncate(inspect(self.expected), 128)
              );
            }

            function fail(
              actual,
              expected,
              message,
              operator,
              stackStartFunction
            ) {
              throw new assert.AssertionError({
                message: message,
                actual: actual,
                expected: expected,
                operator: operator,
                stackStartFunction: stackStartFunction,
              });
            }

            assert.fail = fail;

            function ok(value, message) {
              if (!value) fail(value, true, message, "==", assert.ok);
            }

            assert.ok = ok;

            assert.equal = function equal(actual, expected, message) {
              if (actual != expected)
                fail(actual, expected, message, "==", assert.equal);
            };

            assert.notEqual = function notEqual(actual, expected, message) {
              if (actual == expected) {
                fail(actual, expected, message, "!=", assert.notEqual);
              }
            };

            assert.deepEqual = function deepEqual(actual, expected, message) {
              if (!_deepEqual(actual, expected, false)) {
                fail(actual, expected, message, "deepEqual", assert.deepEqual);
              }
            };

            assert.deepStrictEqual = function deepStrictEqual(
              actual,
              expected,
              message
            ) {
              if (!_deepEqual(actual, expected, true)) {
                fail(
                  actual,
                  expected,
                  message,
                  "deepStrictEqual",
                  assert.deepStrictEqual
                );
              }
            };

            function _deepEqual(actual, expected, strict, memos) {
              if (actual === expected) {
                return true;
              } else if (isBuffer(actual) && isBuffer(expected)) {
                return compare(actual, expected) === 0;
              } else if (util.isDate(actual) && util.isDate(expected)) {
                return actual.getTime() === expected.getTime();
              } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                return (
                  actual.source === expected.source &&
                  actual.global === expected.global &&
                  actual.multiline === expected.multiline &&
                  actual.lastIndex === expected.lastIndex &&
                  actual.ignoreCase === expected.ignoreCase
                );
              } else if (
                (actual === null || typeof actual !== "object") &&
                (expected === null || typeof expected !== "object")
              ) {
                return strict ? actual === expected : actual == expected;
              } else if (
                isView(actual) &&
                isView(expected) &&
                pToString(actual) === pToString(expected) &&
                !(
                  actual instanceof Float32Array ||
                  actual instanceof Float64Array
                )
              ) {
                return (
                  compare(
                    new Uint8Array(actual.buffer),
                    new Uint8Array(expected.buffer)
                  ) === 0
                );
              } else if (isBuffer(actual) !== isBuffer(expected)) {
                return false;
              } else {
                memos = memos || {
                  actual: [],
                  expected: [],
                };
                var actualIndex = memos.actual.indexOf(actual);

                if (actualIndex !== -1) {
                  if (actualIndex === memos.expected.indexOf(expected)) {
                    return true;
                  }
                }

                memos.actual.push(actual);
                memos.expected.push(expected);
                return objEquiv(actual, expected, strict, memos);
              }
            }

            function isArguments(object) {
              return (
                Object.prototype.toString.call(object) == "[object Arguments]"
              );
            }

            function objEquiv(a, b, strict, actualVisitedObjects) {
              if (
                a === null ||
                a === undefined ||
                b === null ||
                b === undefined
              )
                return false;
              if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
              if (
                strict &&
                Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)
              )
                return false;
              var aIsArgs = isArguments(a);
              var bIsArgs = isArguments(b);
              if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs)) return false;

              if (aIsArgs) {
                a = pSlice.call(a);
                b = pSlice.call(b);
                return _deepEqual(a, b, strict);
              }

              var ka = objectKeys(a);
              var kb = objectKeys(b);
              var key, i;
              if (ka.length !== kb.length) return false;
              ka.sort();
              kb.sort();

              for (i = ka.length - 1; i >= 0; i--) {
                if (ka[i] !== kb[i]) return false;
              }

              for (i = ka.length - 1; i >= 0; i--) {
                key = ka[i];
                if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
                  return false;
              }

              return true;
            }

            assert.notDeepEqual = function notDeepEqual(
              actual,
              expected,
              message
            ) {
              if (_deepEqual(actual, expected, false)) {
                fail(
                  actual,
                  expected,
                  message,
                  "notDeepEqual",
                  assert.notDeepEqual
                );
              }
            };

            assert.notDeepStrictEqual = notDeepStrictEqual;

            function notDeepStrictEqual(actual, expected, message) {
              if (_deepEqual(actual, expected, true)) {
                fail(
                  actual,
                  expected,
                  message,
                  "notDeepStrictEqual",
                  notDeepStrictEqual
                );
              }
            }

            assert.strictEqual = function strictEqual(
              actual,
              expected,
              message
            ) {
              if (actual !== expected) {
                fail(actual, expected, message, "===", assert.strictEqual);
              }
            };

            assert.notStrictEqual = function notStrictEqual(
              actual,
              expected,
              message
            ) {
              if (actual === expected) {
                fail(actual, expected, message, "!==", assert.notStrictEqual);
              }
            };

            function expectedException(actual, expected) {
              if (!actual || !expected) {
                return false;
              }

              if (
                Object.prototype.toString.call(expected) == "[object RegExp]"
              ) {
                return expected.test(actual);
              }

              try {
                if (actual instanceof expected) {
                  return true;
                }
              } catch (e) {}

              if (Error.isPrototypeOf(expected)) {
                return false;
              }

              return expected.call({}, actual) === true;
            }

            function _tryBlock(block) {
              var error;

              try {
                block();
              } catch (e) {
                error = e;
              }

              return error;
            }

            function _throws(shouldThrow, block, expected, message) {
              var actual;

              if (typeof block !== "function") {
                throw new TypeError('"block" argument must be a function');
              }

              if (typeof expected === "string") {
                message = expected;
                expected = null;
              }

              actual = _tryBlock(block);
              message =
                (expected && expected.name
                  ? " (" + expected.name + ")."
                  : ".") + (message ? " " + message : ".");

              if (shouldThrow && !actual) {
                fail(actual, expected, "Missing expected exception" + message);
              }

              var userProvidedMessage = typeof message === "string";
              var isUnwantedException = !shouldThrow && util.isError(actual);
              var isUnexpectedException = !shouldThrow && actual && !expected;

              if (
                (isUnwantedException &&
                  userProvidedMessage &&
                  expectedException(actual, expected)) ||
                isUnexpectedException
              ) {
                fail(actual, expected, "Got unwanted exception" + message);
              }

              if (
                (shouldThrow &&
                  actual &&
                  expected &&
                  !expectedException(actual, expected)) ||
                (!shouldThrow && actual)
              ) {
                throw actual;
              }
            }

            assert.throws = function(block, error, message) {
              _throws(true, block, error, message);
            };

            assert.doesNotThrow = function(block, error, message) {
              _throws(false, block, error, message);
            };

            assert.ifError = function(err) {
              if (err) throw err;
            };

            var objectKeys =
              Object.keys ||
              function(obj) {
                var keys = [];

                for (var key in obj) {
                  if (hasOwn.call(obj, key)) keys.push(key);
                }

                return keys;
              };
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(24)));
        },
        /* 24 */
        function(module, exports) {
          var g;

          g = (function() {
            return this;
          })();

          try {
            g = g || Function("return this")() || (1, eval)("this");
          } catch (e) {
            if (typeof window === "object") g = window;
          }

          module.exports = g;
        },
        /* 25 */
        function(module, exports) {
          function eq(value, other) {
            return value === other || (value !== value && other !== other);
          }

          module.exports = eq;
        },
        /* 26 */
        function(module, exports) {
          function baseUnary(func) {
            return function(value) {
              return func(value);
            };
          }

          module.exports = baseUnary;
        },
        /* 27 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isValidIdentifier;

          function _esutils() {
            var data = _interopRequireDefault(__webpack_require__(106));

            _esutils = function _esutils() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function isValidIdentifier(name) {
            if (
              typeof name !== "string" ||
              _esutils().default.keyword.isReservedWordES6(name, true)
            ) {
              return false;
            } else if (name === "await") {
              return false;
            } else {
              return _esutils().default.keyword.isIdentifierNameES6(name);
            }
          }
        },
        /* 28 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = cloneNode;

          var _definitions = __webpack_require__(8);

          var has = Function.call.bind(Object.prototype.hasOwnProperty);

          function cloneIfNode(obj, deep) {
            if (
              obj &&
              typeof obj.type === "string" &&
              obj.type !== "CommentLine" &&
              obj.type !== "CommentBlock"
            ) {
              return cloneNode(obj, deep);
            }

            return obj;
          }

          function cloneIfNodeOrArray(obj, deep) {
            if (Array.isArray(obj)) {
              return obj.map(function(node) {
                return cloneIfNode(node, deep);
              });
            }

            return cloneIfNode(obj, deep);
          }

          function cloneNode(node, deep) {
            if (deep === void 0) {
              deep = true;
            }

            if (!node) return node;
            var type = node.type;
            var newNode = {
              type: type,
            };

            if (type === "Identifier") {
              newNode.name = node.name;
            } else if (!has(_definitions.NODE_FIELDS, type)) {
              throw new Error('Unknown node type: "' + type + '"');
            } else {
              var _arr = Object.keys(_definitions.NODE_FIELDS[type]);

              for (var _i = 0; _i < _arr.length; _i++) {
                var field = _arr[_i];

                if (has(node, field)) {
                  newNode[field] = deep
                    ? cloneIfNodeOrArray(node[field], true)
                    : node[field];
                }
              }
            }

            if (has(node, "loc")) {
              newNode.loc = node.loc;
            }

            if (has(node, "leadingComments")) {
              newNode.leadingComments = node.leadingComments;
            }

            if (has(node, "innerComments")) {
              newNode.innerComments = node.innerCmments;
            }

            if (has(node, "trailingComments")) {
              newNode.trailingComments = node.trailingComments;
            }

            if (has(node, "extra")) {
              newNode.extra = Object.assign({}, node.extra);
            }

            return newNode;
          }
        },
        /* 29 */
        function(module, exports, __webpack_require__) {
          var baseGetTag = __webpack_require__(10),
            isObjectLike = __webpack_require__(7);

          var symbolTag = "[object Symbol]";

          function isSymbol(value) {
            return (
              typeof value == "symbol" ||
              (isObjectLike(value) && baseGetTag(value) == symbolTag)
            );
          }

          module.exports = isSymbol;
        },
        /* 30 */
        function(module, exports) {
          function getArg(aArgs, aName, aDefaultValue) {
            if (aName in aArgs) {
              return aArgs[aName];
            } else if (arguments.length === 3) {
              return aDefaultValue;
            } else {
              throw new Error('"' + aName + '" is a required argument.');
            }
          }

          exports.getArg = getArg;
          var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
          var dataUrlRegexp = /^data:.+\,.+$/;

          function urlParse(aUrl) {
            var match = aUrl.match(urlRegexp);

            if (!match) {
              return null;
            }

            return {
              scheme: match[1],
              auth: match[2],
              host: match[3],
              port: match[4],
              path: match[5],
            };
          }

          exports.urlParse = urlParse;

          function urlGenerate(aParsedUrl) {
            var url = "";

            if (aParsedUrl.scheme) {
              url += aParsedUrl.scheme + ":";
            }

            url += "//";

            if (aParsedUrl.auth) {
              url += aParsedUrl.auth + "@";
            }

            if (aParsedUrl.host) {
              url += aParsedUrl.host;
            }

            if (aParsedUrl.port) {
              url += ":" + aParsedUrl.port;
            }

            if (aParsedUrl.path) {
              url += aParsedUrl.path;
            }

            return url;
          }

          exports.urlGenerate = urlGenerate;

          function normalize(aPath) {
            var path = aPath;
            var url = urlParse(aPath);

            if (url) {
              if (!url.path) {
                return aPath;
              }

              path = url.path;
            }

            var isAbsolute = exports.isAbsolute(path);
            var parts = path.split(/\/+/);

            for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
              part = parts[i];

              if (part === ".") {
                parts.splice(i, 1);
              } else if (part === "..") {
                up++;
              } else if (up > 0) {
                if (part === "") {
                  parts.splice(i + 1, up);
                  up = 0;
                } else {
                  parts.splice(i, 2);
                  up--;
                }
              }
            }

            path = parts.join("/");

            if (path === "") {
              path = isAbsolute ? "/" : ".";
            }

            if (url) {
              url.path = path;
              return urlGenerate(url);
            }

            return path;
          }

          exports.normalize = normalize;

          function join(aRoot, aPath) {
            if (aRoot === "") {
              aRoot = ".";
            }

            if (aPath === "") {
              aPath = ".";
            }

            var aPathUrl = urlParse(aPath);
            var aRootUrl = urlParse(aRoot);

            if (aRootUrl) {
              aRoot = aRootUrl.path || "/";
            }

            if (aPathUrl && !aPathUrl.scheme) {
              if (aRootUrl) {
                aPathUrl.scheme = aRootUrl.scheme;
              }

              return urlGenerate(aPathUrl);
            }

            if (aPathUrl || aPath.match(dataUrlRegexp)) {
              return aPath;
            }

            if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
              aRootUrl.host = aPath;
              return urlGenerate(aRootUrl);
            }

            var joined =
              aPath.charAt(0) === "/"
                ? aPath
                : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);

            if (aRootUrl) {
              aRootUrl.path = joined;
              return urlGenerate(aRootUrl);
            }

            return joined;
          }

          exports.join = join;

          exports.isAbsolute = function(aPath) {
            return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
          };

          function relative(aRoot, aPath) {
            if (aRoot === "") {
              aRoot = ".";
            }

            aRoot = aRoot.replace(/\/$/, "");
            var level = 0;

            while (aPath.indexOf(aRoot + "/") !== 0) {
              var index = aRoot.lastIndexOf("/");

              if (index < 0) {
                return aPath;
              }

              aRoot = aRoot.slice(0, index);

              if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                return aPath;
              }

              ++level;
            }

            return (
              Array(level + 1).join("../") + aPath.substr(aRoot.length + 1)
            );
          }

          exports.relative = relative;

          var supportsNullProto = (function() {
            var obj = Object.create(null);
            return !("__proto__" in obj);
          })();

          function identity(s) {
            return s;
          }

          function toSetString(aStr) {
            if (isProtoString(aStr)) {
              return "$" + aStr;
            }

            return aStr;
          }

          exports.toSetString = supportsNullProto ? identity : toSetString;

          function fromSetString(aStr) {
            if (isProtoString(aStr)) {
              return aStr.slice(1);
            }

            return aStr;
          }

          exports.fromSetString = supportsNullProto ? identity : fromSetString;

          function isProtoString(s) {
            if (!s) {
              return false;
            }

            var length = s.length;

            if (length < 9) {
              return false;
            }

            if (
              s.charCodeAt(length - 1) !== 95 ||
              s.charCodeAt(length - 2) !== 95 ||
              s.charCodeAt(length - 3) !== 111 ||
              s.charCodeAt(length - 4) !== 116 ||
              s.charCodeAt(length - 5) !== 111 ||
              s.charCodeAt(length - 6) !== 114 ||
              s.charCodeAt(length - 7) !== 112 ||
              s.charCodeAt(length - 8) !== 95 ||
              s.charCodeAt(length - 9) !== 95
            ) {
              return false;
            }

            for (var i = length - 10; i >= 0; i--) {
              if (s.charCodeAt(i) !== 36) {
                return false;
              }
            }

            return true;
          }

          function compareByOriginalPositions(
            mappingA,
            mappingB,
            onlyCompareOriginal
          ) {
            var cmp = strcmp(mappingA.source, mappingB.source);

            if (cmp !== 0) {
              return cmp;
            }

            cmp = mappingA.originalLine - mappingB.originalLine;

            if (cmp !== 0) {
              return cmp;
            }

            cmp = mappingA.originalColumn - mappingB.originalColumn;

            if (cmp !== 0 || onlyCompareOriginal) {
              return cmp;
            }

            cmp = mappingA.generatedColumn - mappingB.generatedColumn;

            if (cmp !== 0) {
              return cmp;
            }

            cmp = mappingA.generatedLine - mappingB.generatedLine;

            if (cmp !== 0) {
              return cmp;
            }

            return strcmp(mappingA.name, mappingB.name);
          }

          exports.compareByOriginalPositions = compareByOriginalPositions;

          function compareByGeneratedPositionsDeflated(
            mappingA,
            mappingB,
            onlyCompareGenerated
          ) {
            var cmp = mappingA.generatedLine - mappingB.generatedLine;

            if (cmp !== 0) {
              return cmp;
            }

            cmp = mappingA.generatedColumn - mappingB.generatedColumn;

            if (cmp !== 0 || onlyCompareGenerated) {
              return cmp;
            }

            cmp = strcmp(mappingA.source, mappingB.source);

            if (cmp !== 0) {
              return cmp;
            }

            cmp = mappingA.originalLine - mappingB.originalLine;

            if (cmp !== 0) {
              return cmp;
            }

            cmp = mappingA.originalColumn - mappingB.originalColumn;

            if (cmp !== 0) {
              return cmp;
            }

            return strcmp(mappingA.name, mappingB.name);
          }

          exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

          function strcmp(aStr1, aStr2) {
            if (aStr1 === aStr2) {
              return 0;
            }

            if (aStr1 === null) {
              return 1;
            }

            if (aStr2 === null) {
              return -1;
            }

            if (aStr1 > aStr2) {
              return 1;
            }

            return -1;
          }

          function compareByGeneratedPositionsInflated(mappingA, mappingB) {
            var cmp = mappingA.generatedLine - mappingB.generatedLine;

            if (cmp !== 0) {
              return cmp;
            }

            cmp = mappingA.generatedColumn - mappingB.generatedColumn;

            if (cmp !== 0) {
              return cmp;
            }

            cmp = strcmp(mappingA.source, mappingB.source);

            if (cmp !== 0) {
              return cmp;
            }

            cmp = mappingA.originalLine - mappingB.originalLine;

            if (cmp !== 0) {
              return cmp;
            }

            cmp = mappingA.originalColumn - mappingB.originalColumn;

            if (cmp !== 0) {
              return cmp;
            }

            return strcmp(mappingA.name, mappingB.name);
          }

          exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

          function parseSourceMapInput(str) {
            return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
          }

          exports.parseSourceMapInput = parseSourceMapInput;

          function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
            sourceURL = sourceURL || "";

            if (sourceRoot) {
              if (
                sourceRoot[sourceRoot.length - 1] !== "/" &&
                sourceURL[0] !== "/"
              ) {
                sourceRoot += "/";
              }

              sourceURL = sourceRoot + sourceURL;
            }

            if (sourceMapURL) {
              var parsed = urlParse(sourceMapURL);

              if (!parsed) {
                throw new Error("sourceMapURL could not be parsed");
              }

              if (parsed.path) {
                var index = parsed.path.lastIndexOf("/");

                if (index >= 0) {
                  parsed.path = parsed.path.substring(0, index + 1);
                }
              }

              sourceURL = join(urlGenerate(parsed), sourceURL);
            }

            return normalize(sourceURL);
          }

          exports.computeSourceURL = computeSourceURL;
        },
        /* 31 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.loadOptions = loadOptions;
          Object.defineProperty(exports, "default", {
            enumerable: true,
            get: function get() {
              return _full.default;
            },
          });
          Object.defineProperty(exports, "loadPartialConfig", {
            enumerable: true,
            get: function get() {
              return _partial.loadPartialConfig;
            },
          });

          var _full = _interopRequireDefault(__webpack_require__(402));

          var _partial = __webpack_require__(157);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function loadOptions(opts) {
            var config = (0, _full.default)(opts);
            return config ? config.options : null;
          }
        },
        /* 32 */
        function(module, exports, __webpack_require__) {
          var listCacheClear = __webpack_require__(182),
            listCacheDelete = __webpack_require__(183),
            listCacheGet = __webpack_require__(184),
            listCacheHas = __webpack_require__(185),
            listCacheSet = __webpack_require__(186);

          function ListCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();

            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          module.exports = ListCache;
        },
        /* 33 */
        function(module, exports, __webpack_require__) {
          var eq = __webpack_require__(25);

          function assocIndexOf(array, key) {
            var length = array.length;

            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }

            return -1;
          }

          module.exports = assocIndexOf;
        },
        /* 34 */
        function(module, exports, __webpack_require__) {
          var getNative = __webpack_require__(13);

          var nativeCreate = getNative(Object, "create");
          module.exports = nativeCreate;
        },
        /* 35 */
        function(module, exports, __webpack_require__) {
          var isKeyable = __webpack_require__(206);

          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key)
              ? data[typeof key == "string" ? "string" : "hash"]
              : data.map;
          }

          module.exports = getMapData;
        },
        /* 36 */
        function(module, exports, __webpack_require__) {
          var assignValue = __webpack_require__(94),
            baseAssignValue = __webpack_require__(95);

          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1,
              length = props.length;

            while (++index < length) {
              var key = props[index];
              var newValue = customizer
                ? customizer(object[key], source[key], key, object, source)
                : undefined;

              if (newValue === undefined) {
                newValue = source[key];
              }

              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }

            return object;
          }

          module.exports = copyObject;
        },
        /* 37 */
        function(module, exports) {
          module.exports = function(module) {
            if (!module.webpackPolyfill) {
              module.deprecate = function() {};

              module.paths = [];
              if (!module.children) module.children = [];
              Object.defineProperty(module, "loaded", {
                enumerable: true,
                get: function get() {
                  return module.l;
                },
              });
              Object.defineProperty(module, "id", {
                enumerable: true,
                get: function get() {
                  return module.i;
                },
              });
              module.webpackPolyfill = 1;
            }

            return module;
          };
        },
        /* 38 */
        function(module, exports, __webpack_require__) {
          /* WEBPACK VAR INJECTION */ (function(module) {
            var freeGlobal = __webpack_require__(92);

            var freeExports =
              typeof exports == "object" &&
              exports &&
              !exports.nodeType &&
              exports;
            var freeModule =
              freeExports &&
              typeof module == "object" &&
              module &&
              !module.nodeType &&
              module;
            var moduleExports =
              freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;

            var nodeUtil = (function() {
              try {
                var types =
                  freeModule &&
                  freeModule.require &&
                  freeModule.require("util").types;

                if (types) {
                  return types;
                }

                return (
                  freeProcess &&
                  freeProcess.binding &&
                  freeProcess.binding("util")
                );
              } catch (e) {}
            })();

            module.exports = nodeUtil;
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(37)(module)));
        },
        /* 39 */
        function(module, exports, __webpack_require__) {
          var DataView = __webpack_require__(227),
            Map = __webpack_require__(53),
            Promise = __webpack_require__(228),
            Set = __webpack_require__(104),
            WeakMap = __webpack_require__(229),
            baseGetTag = __webpack_require__(10),
            toSource = __webpack_require__(93);

          var mapTag = "[object Map]",
            objectTag = "[object Object]",
            promiseTag = "[object Promise]",
            setTag = "[object Set]",
            weakMapTag = "[object WeakMap]";
          var dataViewTag = "[object DataView]";
          var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap);
          var getTag = baseGetTag;

          if (
            (DataView &&
              getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
            (Map && getTag(new Map()) != mapTag) ||
            (Promise && getTag(Promise.resolve()) != promiseTag) ||
            (Set && getTag(new Set()) != setTag) ||
            (WeakMap && getTag(new WeakMap()) != weakMapTag)
          ) {
            getTag = function getTag(value) {
              var result = baseGetTag(value),
                Ctor = result == objectTag ? value.constructor : undefined,
                ctorString = Ctor ? toSource(Ctor) : "";

              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;

                  case mapCtorString:
                    return mapTag;

                  case promiseCtorString:
                    return promiseTag;

                  case setCtorString:
                    return setTag;

                  case weakMapCtorString:
                    return weakMapTag;
                }
              }

              return result;
            };
          }

          module.exports = getTag;
        },
        /* 40 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = getBindingIdentifiers;

          var _generated = __webpack_require__(2);

          function getBindingIdentifiers(node, duplicates, outerOnly) {
            var search = [].concat(node);
            var ids = Object.create(null);

            while (search.length) {
              var id = search.shift();
              if (!id) continue;
              var keys = getBindingIdentifiers.keys[id.type];

              if ((0, _generated.isIdentifier)(id)) {
                if (duplicates) {
                  var _ids = (ids[id.name] = ids[id.name] || []);

                  _ids.push(id);
                } else {
                  ids[id.name] = id;
                }

                continue;
              }

              if ((0, _generated.isExportDeclaration)(id)) {
                if ((0, _generated.isDeclaration)(id.declaration)) {
                  search.push(id.declaration);
                }

                continue;
              }

              if (outerOnly) {
                if ((0, _generated.isFunctionDeclaration)(id)) {
                  search.push(id.id);
                  continue;
                }

                if ((0, _generated.isFunctionExpression)(id)) {
                  continue;
                }
              }

              if (keys) {
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];

                  if (id[key]) {
                    search = search.concat(id[key]);
                  }
                }
              }
            }

            return ids;
          }

          getBindingIdentifiers.keys = {
            DeclareClass: ["id"],
            DeclareFunction: ["id"],
            DeclareModule: ["id"],
            DeclareVariable: ["id"],
            DeclareInterface: ["id"],
            DeclareTypeAlias: ["id"],
            DeclareOpaqueType: ["id"],
            InterfaceDeclaration: ["id"],
            TypeAlias: ["id"],
            OpaqueType: ["id"],
            CatchClause: ["param"],
            LabeledStatement: ["label"],
            UnaryExpression: ["argument"],
            AssignmentExpression: ["left"],
            ImportSpecifier: ["local"],
            ImportNamespaceSpecifier: ["local"],
            ImportDefaultSpecifier: ["local"],
            ImportDeclaration: ["specifiers"],
            ExportSpecifier: ["exported"],
            ExportNamespaceSpecifier: ["exported"],
            ExportDefaultSpecifier: ["exported"],
            FunctionDeclaration: ["id", "params"],
            FunctionExpression: ["id", "params"],
            ArrowFunctionExpression: ["params"],
            ObjectMethod: ["params"],
            ClassMethod: ["params"],
            ForInStatement: ["left"],
            ForOfStatement: ["left"],
            ClassDeclaration: ["id"],
            ClassExpression: ["id"],
            RestElement: ["argument"],
            UpdateExpression: ["argument"],
            ObjectProperty: ["value"],
            AssignmentPattern: ["left"],
            ArrayPattern: ["elements"],
            ObjectPattern: ["properties"],
            VariableDeclaration: ["declarations"],
            VariableDeclarator: ["id"],
          };
        },
        /* 41 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.declare = declare;

          function declare(builder) {
            return function(api, options, dirname) {
              if (!api.assertVersion) {
                api = Object.assign(copyApiObject(api), {
                  assertVersion: function assertVersion(range) {
                    throwVersionError(range, api.version);
                  },
                });
              }

              return builder(api, options || {}, dirname);
            };
          }

          function copyApiObject(api) {
            var proto = null;

            if (typeof api.version === "string" && /^7\./.test(api.version)) {
              proto = Object.getPrototypeOf(api);

              if (
                proto &&
                (!has(proto, "version") ||
                  !has(proto, "transform") ||
                  !has(proto, "template") ||
                  !has(proto, "types"))
              ) {
                proto = null;
              }
            }

            return Object.assign({}, proto, api);
          }

          function has(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key);
          }

          function throwVersionError(range, version) {
            if (typeof range === "number") {
              if (!Number.isInteger(range)) {
                throw new Error("Expected string or integer value.");
              }

              range = "^" + range + ".0.0-0";
            }

            if (typeof range !== "string") {
              throw new Error("Expected string or integer value.");
            }

            var limit = Error.stackTraceLimit;

            if (typeof limit === "number" && limit < 25) {
              Error.stackTraceLimit = 25;
            }

            var err;

            if (version.slice(0, 2) === "7.") {
              err = new Error(
                'Requires Babel "^7.0.0-beta.41", but was loaded with "' +
                  version +
                  '". ' +
                  "You'll need to update your @gerhobbelt/babel-core version."
              );
            } else {
              err = new Error(
                'Requires Babel "' +
                  range +
                  '", but was loaded with "' +
                  version +
                  '". ' +
                  "If you are sure you have a compatible version of @gerhobbelt/babel-core, " +
                  "it is likely that something in your build process is loading the " +
                  "wrong version. Inspect the stack trace of this error to look for " +
                  'the first entry that doesn\'t mention "@gerhobbelt/babel-core" or "babel-core" ' +
                  "to see what is calling Babel."
              );
            }

            if (typeof limit === "number") {
              Error.stackTraceLimit = limit;
            }

            throw Object.assign(err, {
              code: "BABEL_VERSION_UNSUPPORTED",
              version: version,
              range: range,
            });
          }
        },
        /* 42 */
        function(module, exports) {
          function identity(value) {
            return value;
          }

          module.exports = identity;
        },
        /* 43 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.clear = clear;
          exports.clearPath = clearPath;
          exports.clearScope = clearScope;
          exports.scope = exports.path = void 0;
          var path = new WeakMap();
          exports.path = path;
          var scope = new WeakMap();
          exports.scope = scope;

          function clear() {
            clearPath();
            clearScope();
          }

          function clearPath() {
            exports.path = path = new WeakMap();
          }

          function clearScope() {
            exports.scope = scope = new WeakMap();
          }
        },
        /* 44 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(process) {
            Object.defineProperty(exports, "__esModule", {
              value: true,
            });
            exports.codeFrameColumns = codeFrameColumns;
            exports.default = _default;

            function _babelHighlight() {
              var data = _interopRequireWildcard(__webpack_require__(371));

              _babelHighlight = function _babelHighlight() {
                return data;
              };

              return data;
            }

            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) {
                return obj;
              } else {
                var newObj = {};

                if (obj != null) {
                  for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                      var desc =
                        Object.defineProperty && Object.getOwnPropertyDescriptor
                          ? Object.getOwnPropertyDescriptor(obj, key)
                          : {};

                      if (desc.get || desc.set) {
                        Object.defineProperty(newObj, key, desc);
                      } else {
                        newObj[key] = obj[key];
                      }
                    }
                  }
                }

                newObj.default = obj;
                return newObj;
              }
            }

            var deprecationWarningShown = false;

            function getDefs(chalk) {
              return {
                gutter: chalk.grey,
                marker: chalk.red.bold,
                message: chalk.red.bold,
              };
            }

            var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

            function getMarkerLines(loc, source, opts) {
              var startLoc = Object.assign(
                {
                  column: 0,
                  line: -1,
                },
                loc.start
              );
              var endLoc = Object.assign({}, startLoc, loc.end);

              var _ref = opts || {},
                _ref$linesAbove = _ref.linesAbove,
                linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
                _ref$linesBelow = _ref.linesBelow,
                linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;

              var startLine = startLoc.line;
              var startColumn = startLoc.column;
              var endLine = endLoc.line;
              var endColumn = endLoc.column;
              var start = Math.max(startLine - (linesAbove + 1), 0);
              var end = Math.min(source.length, endLine + linesBelow);

              if (startLine === -1) {
                start = 0;
              }

              if (endLine === -1) {
                end = source.length;
              }

              var lineDiff = endLine - startLine;
              var markerLines = {};

              if (lineDiff) {
                for (var i = 0; i <= lineDiff; i++) {
                  var lineNumber = i + startLine;

                  if (!startColumn) {
                    markerLines[lineNumber] = true;
                  } else if (i === 0) {
                    var sourceLength = source[lineNumber - 1].length;
                    markerLines[lineNumber] = [
                      startColumn,
                      sourceLength - startColumn,
                    ];
                  } else if (i === lineDiff) {
                    markerLines[lineNumber] = [0, endColumn];
                  } else {
                    var _sourceLength = source[lineNumber - i].length;
                    markerLines[lineNumber] = [0, _sourceLength];
                  }
                }
              } else {
                if (startColumn === endColumn) {
                  if (startColumn) {
                    markerLines[startLine] = [startColumn, 0];
                  } else {
                    markerLines[startLine] = true;
                  }
                } else {
                  markerLines[startLine] = [
                    startColumn,
                    endColumn - startColumn,
                  ];
                }
              }

              return {
                start: start,
                end: end,
                markerLines: markerLines,
              };
            }

            function codeFrameColumns(rawLines, loc, opts) {
              if (opts === void 0) {
                opts = {};
              }

              var highlighted =
                (opts.highlightCode || opts.forceColor) &&
                (0, _babelHighlight().shouldHighlight)(opts);
              var chalk = (0, _babelHighlight().getChalk)(opts);
              var defs = getDefs(chalk);

              var maybeHighlight = function maybeHighlight(chalkFn, string) {
                return highlighted ? chalkFn(string) : string;
              };

              if (highlighted)
                rawLines = (0, _babelHighlight().default)(rawLines, opts);
              var lines = rawLines.split(NEWLINE);

              var _getMarkerLines = getMarkerLines(loc, lines, opts),
                start = _getMarkerLines.start,
                end = _getMarkerLines.end,
                markerLines = _getMarkerLines.markerLines;

              var hasColumns =
                loc.start && typeof loc.start.column === "number";
              var numberMaxWidth = String(end).length;
              var frame = lines
                .slice(start, end)
                .map(function(line, index) {
                  var number = start + 1 + index;
                  var paddedNumber = (" " + number).slice(-numberMaxWidth);
                  var gutter = " " + paddedNumber + " | ";
                  var hasMarker = markerLines[number];
                  var lastMarkerLine = !markerLines[number + 1];

                  if (hasMarker) {
                    var markerLine = "";

                    if (Array.isArray(hasMarker)) {
                      var markerSpacing = line
                        .slice(0, Math.max(hasMarker[0] - 1, 0))
                        .replace(/[^\t]/g, " ");
                      var numberOfMarkers = hasMarker[1] || 1;
                      markerLine = [
                        "\n ",
                        maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")),
                        markerSpacing,
                        maybeHighlight(defs.marker, "^").repeat(
                          numberOfMarkers
                        ),
                      ].join("");

                      if (lastMarkerLine && opts.message) {
                        markerLine +=
                          " " + maybeHighlight(defs.message, opts.message);
                      }
                    }

                    return [
                      maybeHighlight(defs.marker, ">"),
                      maybeHighlight(defs.gutter, gutter),
                      line,
                      markerLine,
                    ].join("");
                  } else {
                    return " " + maybeHighlight(defs.gutter, gutter) + line;
                  }
                })
                .join("\n");

              if (opts.message && !hasColumns) {
                frame =
                  "" +
                  " ".repeat(numberMaxWidth + 1) +
                  opts.message +
                  "\n" +
                  frame;
              }

              if (highlighted) {
                return chalk.reset(frame);
              } else {
                return frame;
              }
            }

            function _default(rawLines, lineNumber, colNumber, opts) {
              if (opts === void 0) {
                opts = {};
              }

              if (!deprecationWarningShown) {
                deprecationWarningShown = true;
                var message =
                  "Passing lineNumber and colNumber is deprecated to @gerhobbelt/babel-code-frame. Please use `codeFrameColumns`.";

                if (process.emitWarning) {
                  process.emitWarning(message, "DeprecationWarning");
                } else {
                  var deprecationError = new Error(message);
                  deprecationError.name = "DeprecationWarning";
                  console.warn(new Error(message));
                }
              }

              colNumber = Math.max(colNumber, 0);
              var location = {
                start: {
                  column: colNumber,
                  line: lineNumber,
                },
              };
              return codeFrameColumns(rawLines, location, opts);
            }
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(3)));
        },
        /* 45 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = exports.program = exports.expression = exports.statements = exports.statement = exports.smart = void 0;

          var formatters = _interopRequireWildcard(__webpack_require__(385));

          var _builder = _interopRequireDefault(__webpack_require__(386));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          var smart = (0, _builder.default)(formatters.smart);
          exports.smart = smart;
          var statement = (0, _builder.default)(formatters.statement);
          exports.statement = statement;
          var statements = (0, _builder.default)(formatters.statements);
          exports.statements = statements;
          var expression = (0, _builder.default)(formatters.expression);
          exports.expression = expression;
          var program = (0, _builder.default)(formatters.program);
          exports.program = program;

          var _default = Object.assign(smart.bind(undefined), {
            smart: smart,
            statement: statement,
            statements: statements,
            expression: expression,
            program: program,
            ast: smart.ast,
          });

          exports.default = _default;
        },
        /* 46 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.createItemFromDescriptor = createItemFromDescriptor;
          exports.createConfigItem = createConfigItem;
          exports.getItemDescriptor = getItemDescriptor;

          function _path() {
            var data = _interopRequireDefault(__webpack_require__(15));

            _path = function _path() {
              return data;
            };

            return data;
          }

          var _configDescriptors = __webpack_require__(152);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function createItemFromDescriptor(desc) {
            return new ConfigItem(desc);
          }

          function createConfigItem(value, _temp) {
            var _ref = _temp === void 0 ? {} : _temp,
              _ref$dirname = _ref.dirname,
              dirname = _ref$dirname === void 0 ? "." : _ref$dirname,
              type = _ref.type;

            var descriptor = (0, _configDescriptors.createDescriptor)(
              value,
              _path().default.resolve(dirname),
              {
                type: type,
                alias: "programmatic item",
              }
            );
            return createItemFromDescriptor(descriptor);
          }

          function getItemDescriptor(item) {
            if (item instanceof ConfigItem) {
              return item._descriptor;
            }

            return undefined;
          }

          var ConfigItem = function ConfigItem(descriptor) {
            this._descriptor = descriptor;
            Object.defineProperty(this, "_descriptor", {
              enumerable: false,
            });
            this.value = this._descriptor.value;
            this.options = this._descriptor.options;
            this.dirname = this._descriptor.dirname;
            this.name = this._descriptor.name;
            this.file = this._descriptor.file
              ? {
                  request: this._descriptor.file.request,
                  resolved: this._descriptor.file.resolved,
                }
              : undefined;
            Object.freeze(this);
          };

          Object.freeze(ConfigItem.prototype);
        },
        /* 47 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.makeStrongCache = makeStrongCache;
          exports.makeWeakCache = makeWeakCache;
          exports.assertSimpleType = assertSimpleType;

          function makeStrongCache(handler) {
            return makeCachedFunction(new Map(), handler);
          }

          function makeWeakCache(handler) {
            return makeCachedFunction(new WeakMap(), handler);
          }

          function makeCachedFunction(callCache, handler) {
            return function cachedFunction(arg, data) {
              var cachedValue = callCache.get(arg);

              if (cachedValue) {
                for (
                  var _iterator = cachedValue,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray
                      ? _iterator
                      : _iterator[Symbol.iterator]();
                  ;

                ) {
                  var _ref2;

                  if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref2 = _iterator[_i++];
                  } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref2 = _i.value;
                  }

                  var _ref = _ref2;
                  var _value = _ref.value,
                    valid = _ref.valid;
                  if (valid(data)) return _value;
                }
              }

              var cache = new CacheConfigurator(data);
              var value = handler(arg, cache);
              if (!cache.configured()) cache.forever();
              cache.deactivate();

              switch (cache.mode()) {
                case "forever":
                  cachedValue = [
                    {
                      value: value,
                      valid: function valid() {
                        return true;
                      },
                    },
                  ];
                  callCache.set(arg, cachedValue);
                  break;

                case "invalidate":
                  cachedValue = [
                    {
                      value: value,
                      valid: cache.validator(),
                    },
                  ];
                  callCache.set(arg, cachedValue);
                  break;

                case "valid":
                  if (cachedValue) {
                    cachedValue.push({
                      value: value,
                      valid: cache.validator(),
                    });
                  } else {
                    cachedValue = [
                      {
                        value: value,
                        valid: cache.validator(),
                      },
                    ];
                    callCache.set(arg, cachedValue);
                  }
              }

              return value;
            };
          }

          var CacheConfigurator = (function() {
            function CacheConfigurator(data) {
              this._active = true;
              this._never = false;
              this._forever = false;
              this._invalidate = false;
              this._configured = false;
              this._pairs = [];
              this._data = data;
            }

            var _proto = CacheConfigurator.prototype;

            _proto.simple = function simple() {
              return makeSimpleConfigurator(this);
            };

            _proto.mode = function mode() {
              if (this._never) return "never";
              if (this._forever) return "forever";
              if (this._invalidate) return "invalidate";
              return "valid";
            };

            _proto.forever = function forever() {
              if (!this._active) {
                throw new Error(
                  "Cannot change caching after evaluation has completed."
                );
              }

              if (this._never) {
                throw new Error(
                  "Caching has already been configured with .never()"
                );
              }

              this._forever = true;
              this._configured = true;
            };

            _proto.never = function never() {
              if (!this._active) {
                throw new Error(
                  "Cannot change caching after evaluation has completed."
                );
              }

              if (this._forever) {
                throw new Error(
                  "Caching has already been configured with .forever()"
                );
              }

              this._never = true;
              this._configured = true;
            };

            _proto.using = function using(handler) {
              if (!this._active) {
                throw new Error(
                  "Cannot change caching after evaluation has completed."
                );
              }

              if (this._never || this._forever) {
                throw new Error(
                  "Caching has already been configured with .never or .forever()"
                );
              }

              this._configured = true;
              var key = handler(this._data);

              this._pairs.push([key, handler]);

              return key;
            };

            _proto.invalidate = function invalidate(handler) {
              if (!this._active) {
                throw new Error(
                  "Cannot change caching after evaluation has completed."
                );
              }

              if (this._never || this._forever) {
                throw new Error(
                  "Caching has already been configured with .never or .forever()"
                );
              }

              this._invalidate = true;
              this._configured = true;
              var key = handler(this._data);

              this._pairs.push([key, handler]);

              return key;
            };

            _proto.validator = function validator() {
              var pairs = this._pairs;
              return function(data) {
                return pairs.every(function(_ref3) {
                  var key = _ref3[0],
                    fn = _ref3[1];
                  return key === fn(data);
                });
              };
            };

            _proto.deactivate = function deactivate() {
              this._active = false;
            };

            _proto.configured = function configured() {
              return this._configured;
            };

            return CacheConfigurator;
          })();

          function makeSimpleConfigurator(cache) {
            function cacheFn(val) {
              if (typeof val === "boolean") {
                if (val) cache.forever();
                else cache.never();
                return;
              }

              return cache.using(function() {
                return assertSimpleType(val());
              });
            }

            cacheFn.forever = function() {
              return cache.forever();
            };

            cacheFn.never = function() {
              return cache.never();
            };

            cacheFn.using = function(cb) {
              return cache.using(function() {
                return assertSimpleType(cb());
              });
            };

            cacheFn.invalidate = function(cb) {
              return cache.invalidate(function() {
                return assertSimpleType(cb());
              });
            };

            return cacheFn;
          }

          function assertSimpleType(value) {
            if (
              value != null &&
              typeof value !== "string" &&
              typeof value !== "boolean" &&
              typeof value !== "number"
            ) {
              throw new Error(
                "Cache keys must be either string, boolean, number, null, or undefined."
              );
            }

            return value;
          }
        },
        /* 48 */
        function(module, exports, __webpack_require__) {
          var isSymbol = __webpack_require__(29);

          var INFINITY = 1 / 0;

          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }

            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }

          module.exports = toKey;
        },
        /* 49 */
        function(module, exports) {
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          module.exports = _createClass;
        },
        /* 50 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.logUsagePolyfills = exports.logEntryPolyfills = exports.logPlugin = exports.logMessage = void 0;

          function _semver() {
            var data = _interopRequireDefault(__webpack_require__(16));

            _semver = function _semver() {
              return data;
            };

            return data;
          }

          var _utils = __webpack_require__(17);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var wordEnds = function wordEnds(size) {
            return size > 1 ? "s" : "";
          };

          var logMessage = function logMessage(message, context) {
            var pre = context ? "[" + context + "] " : "";
            var logStr = "  " + pre + message;
            console.log(logStr);
          };

          exports.logMessage = logMessage;

          var logPlugin = function logPlugin(
            item,
            targetVersions,
            list,
            context
          ) {
            var minVersions = list[item] || {};
            var filteredList = Object.keys(targetVersions).reduce(function(
              result,
              env
            ) {
              var minVersion = minVersions[env];
              var targetVersion = targetVersions[env];

              if (!minVersion) {
                result[env] = (0, _utils.prettifyVersion)(targetVersion);
              } else {
                var minIsUnreleased = (0, _utils.isUnreleasedVersion)(
                  minVersion,
                  env
                );
                var targetIsUnreleased = (0, _utils.isUnreleasedVersion)(
                  targetVersion,
                  env
                );

                if (
                  !targetIsUnreleased &&
                  (minIsUnreleased ||
                    _semver().default.lt(
                      targetVersion,
                      (0, _utils.semverify)(minVersion)
                    ))
                ) {
                  result[env] = (0, _utils.prettifyVersion)(targetVersion);
                }
              }

              return result;
            },
            {});
            var formattedTargets = JSON.stringify(filteredList)
              .replace(/,/g, ", ")
              .replace(/^\{"/, '{ "')
              .replace(/"\}$/, '" }');
            logMessage(item + " " + formattedTargets, context);
          };

          exports.logPlugin = logPlugin;

          var logEntryPolyfills = function logEntryPolyfills(
            importPolyfillIncluded,
            polyfills,
            filename,
            onDebug
          ) {
            if (!importPolyfillIncluded) {
              console.log(
                "\n[" +
                  filename +
                  "] `import '@gerhobbelt/babel-polyfill'` was not found."
              );
              return;
            }

            if (!polyfills.size) {
              console.log(
                "\n[" + filename + "] Based on your targets, none were added."
              );
              return;
            }

            console.log(
              "\n[" +
                filename +
                "] Replaced `@gerhobbelt/babel-polyfill` with the following polyfill" +
                wordEnds(polyfills.size) +
                ":"
            );
            onDebug(polyfills);
          };

          exports.logEntryPolyfills = logEntryPolyfills;

          var logUsagePolyfills = function logUsagePolyfills(
            polyfills,
            filename,
            onDebug
          ) {
            if (!polyfills.size) {
              console.log(
                "\n[" +
                  filename +
                  "] Based on your code and targets, none were added."
              );
              return;
            }

            console.log(
              "\n[" +
                filename +
                "] Added following polyfill" +
                wordEnds(polyfills.size) +
                ":"
            );
            onDebug(polyfills);
          };

          exports.logUsagePolyfills = logUsagePolyfills;
        },
        /* 51 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = shallowEqual;

          function shallowEqual(actual, expected) {
            var keys = Object.keys(expected);

            for (var _i = 0; _i < keys.length; _i++) {
              var key = keys[_i];

              if (actual[key] !== expected[key]) {
                return false;
              }
            }

            return true;
          }
        },
        /* 52 */
        function(module, exports, __webpack_require__) {
          var ListCache = __webpack_require__(32),
            stackClear = __webpack_require__(187),
            stackDelete = __webpack_require__(188),
            stackGet = __webpack_require__(189),
            stackHas = __webpack_require__(190),
            stackSet = __webpack_require__(191);

          function Stack(entries) {
            var data = (this.__data__ = new ListCache(entries));
            this.size = data.size;
          }

          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          module.exports = Stack;
        },
        /* 53 */
        function(module, exports, __webpack_require__) {
          var getNative = __webpack_require__(13),
            root = __webpack_require__(6);

          var Map = getNative(root, "Map");
          module.exports = Map;
        },
        /* 54 */
        function(module, exports, __webpack_require__) {
          var mapCacheClear = __webpack_require__(198),
            mapCacheDelete = __webpack_require__(205),
            mapCacheGet = __webpack_require__(207),
            mapCacheHas = __webpack_require__(208),
            mapCacheSet = __webpack_require__(209);

          function MapCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();

            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          module.exports = MapCache;
        },
        /* 55 */
        function(module, exports, __webpack_require__) {
          var baseIsArguments = __webpack_require__(213),
            isObjectLike = __webpack_require__(7);

          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var propertyIsEnumerable = objectProto.propertyIsEnumerable;
          var isArguments = baseIsArguments(
            (function() {
              return arguments;
            })()
          )
            ? baseIsArguments
            : function(value) {
                return (
                  isObjectLike(value) &&
                  hasOwnProperty.call(value, "callee") &&
                  !propertyIsEnumerable.call(value, "callee")
                );
              };
          module.exports = isArguments;
        },
        /* 56 */
        function(module, exports, __webpack_require__) {
          /* WEBPACK VAR INJECTION */ (function(module) {
            var root = __webpack_require__(6),
              stubFalse = __webpack_require__(214);

            var freeExports =
              typeof exports == "object" &&
              exports &&
              !exports.nodeType &&
              exports;
            var freeModule =
              freeExports &&
              typeof module == "object" &&
              module &&
              !module.nodeType &&
              module;
            var moduleExports =
              freeModule && freeModule.exports === freeExports;
            var Buffer = moduleExports ? root.Buffer : undefined;
            var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
            var isBuffer = nativeIsBuffer || stubFalse;
            module.exports = isBuffer;
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(37)(module)));
        },
        /* 57 */
        function(module, exports) {
          var MAX_SAFE_INTEGER = 9007199254740991;
          var reIsUint = /^(?:0|[1-9]\d*)$/;

          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return (
              !!length &&
              (type == "number" ||
                (type != "symbol" && reIsUint.test(value))) &&
              value > -1 &&
              value % 1 == 0 &&
              value < length
            );
          }

          module.exports = isIndex;
        },
        /* 58 */
        function(module, exports) {
          var MAX_SAFE_INTEGER = 9007199254740991;

          function isLength(value) {
            return (
              typeof value == "number" &&
              value > -1 &&
              value % 1 == 0 &&
              value <= MAX_SAFE_INTEGER
            );
          }

          module.exports = isLength;
        },
        /* 59 */
        function(module, exports) {
          var objectProto = Object.prototype;

          function isPrototype(value) {
            var Ctor = value && value.constructor,
              proto =
                (typeof Ctor == "function" && Ctor.prototype) || objectProto;
            return value === proto;
          }

          module.exports = isPrototype;
        },
        /* 60 */
        function(module, exports, __webpack_require__) {
          var arrayLikeKeys = __webpack_require__(97),
            baseKeysIn = __webpack_require__(219),
            isArrayLike = __webpack_require__(20);

          function keysIn(object) {
            return isArrayLike(object)
              ? arrayLikeKeys(object, true)
              : baseKeysIn(object);
          }

          module.exports = keysIn;
        },
        /* 61 */
        function(module, exports, __webpack_require__) {
          var arrayFilter = __webpack_require__(224),
            stubArray = __webpack_require__(100);

          var objectProto = Object.prototype;
          var propertyIsEnumerable = objectProto.propertyIsEnumerable;
          var nativeGetSymbols = Object.getOwnPropertySymbols;
          var getSymbols = !nativeGetSymbols
            ? stubArray
            : function(object) {
                if (object == null) {
                  return [];
                }

                object = Object(object);
                return arrayFilter(nativeGetSymbols(object), function(symbol) {
                  return propertyIsEnumerable.call(object, symbol);
                });
              };
          module.exports = getSymbols;
        },
        /* 62 */
        function(module, exports) {
          function arrayPush(array, values) {
            var index = -1,
              length = values.length,
              offset = array.length;

            while (++index < length) {
              array[offset + index] = values[index];
            }

            return array;
          }

          module.exports = arrayPush;
        },
        /* 63 */
        function(module, exports, __webpack_require__) {
          var overArg = __webpack_require__(99);

          var getPrototype = overArg(Object.getPrototypeOf, Object);
          module.exports = getPrototype;
        },
        /* 64 */
        function(module, exports, __webpack_require__) {
          var Uint8Array = __webpack_require__(105);

          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
          }

          module.exports = cloneArrayBuffer;
        },
        /* 65 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;

          var _isValidIdentifier = _interopRequireDefault(
            __webpack_require__(27)
          );

          var _constants = __webpack_require__(14);

          var _utils = _interopRequireWildcard(__webpack_require__(12));

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          (0, _utils.default)("ArrayExpression", {
            fields: {
              elements: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeOrValueType)(
                      "null",
                      "Expression",
                      "SpreadElement"
                    )
                  )
                ),
                default: [],
              },
            },
            visitor: ["elements"],
            aliases: ["Expression"],
          });
          (0, _utils.default)("AssignmentExpression", {
            fields: {
              operator: {
                validate: (0, _utils.assertValueType)("string"),
              },
              left: {
                validate: (0, _utils.assertNodeType)("LVal"),
              },
              right: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
            builder: ["operator", "left", "right"],
            visitor: ["left", "right"],
            aliases: ["Expression"],
          });
          (0, _utils.default)("BinaryExpression", {
            builder: ["operator", "left", "right"],
            fields: {
              operator: {
                validate: (0, _utils.assertOneOf).apply(
                  void 0,
                  _constants.BINARY_OPERATORS
                ),
              },
              left: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              right: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
            visitor: ["left", "right"],
            aliases: ["Binary", "Expression"],
          });
          (0, _utils.default)("InterpreterDirective", {
            builder: ["value"],
            fields: {
              value: {
                validate: (0, _utils.assertValueType)("string"),
              },
            },
          });
          (0, _utils.default)("Directive", {
            visitor: ["value"],
            fields: {
              value: {
                validate: (0, _utils.assertNodeType)("DirectiveLiteral"),
              },
            },
          });
          (0, _utils.default)("DirectiveLiteral", {
            builder: ["value"],
            fields: {
              value: {
                validate: (0, _utils.assertValueType)("string"),
              },
            },
          });
          (0, _utils.default)("BlockStatement", {
            builder: ["body", "directives"],
            visitor: ["directives", "body"],
            fields: {
              directives: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Directive")
                  )
                ),
                default: [],
              },
              body: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Statement")
                  )
                ),
              },
            },
            aliases: ["Scopable", "BlockParent", "Block", "Statement"],
          });
          (0, _utils.default)("BreakStatement", {
            visitor: ["label"],
            fields: {
              label: {
                validate: (0, _utils.assertNodeType)("Identifier"),
                optional: true,
              },
            },
            aliases: ["Statement", "Terminatorless", "CompletionStatement"],
          });
          (0, _utils.default)("CallExpression", {
            visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
            builder: ["callee", "arguments"],
            aliases: ["Expression"],
            fields: {
              callee: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              arguments: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)(
                      "Expression",
                      "SpreadElement",
                      "JSXNamespacedName"
                    )
                  )
                ),
              },
              optional: {
                validate: (0, _utils.assertOneOf)(true, false),
                optional: true,
              },
              typeArguments: {
                validate: (0, _utils.assertNodeType)(
                  "TypeParameterInstantiation"
                ),
                optional: true,
              },
              typeParameters: {
                validate: (0, _utils.assertNodeType)(
                  "TSTypeParameterInstantiation"
                ),
                optional: true,
              },
            },
          });
          (0, _utils.default)("CatchClause", {
            visitor: ["param", "body"],
            fields: {
              param: {
                validate: (0, _utils.assertNodeType)("Identifier"),
                optional: true,
              },
              body: {
                validate: (0, _utils.assertNodeType)("BlockStatement"),
              },
            },
            aliases: ["Scopable", "BlockParent"],
          });
          (0, _utils.default)("ConditionalExpression", {
            visitor: ["test", "consequent", "alternate"],
            fields: {
              test: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              consequent: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              alternate: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
            aliases: ["Expression", "Conditional"],
          });
          (0, _utils.default)("ContinueStatement", {
            visitor: ["label"],
            fields: {
              label: {
                validate: (0, _utils.assertNodeType)("Identifier"),
                optional: true,
              },
            },
            aliases: ["Statement", "Terminatorless", "CompletionStatement"],
          });
          (0, _utils.default)("DebuggerStatement", {
            aliases: ["Statement"],
          });
          (0, _utils.default)("DoWhileStatement", {
            visitor: ["test", "body"],
            fields: {
              test: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              body: {
                validate: (0, _utils.assertNodeType)("Statement"),
              },
            },
            aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
          });
          (0, _utils.default)("EmptyStatement", {
            aliases: ["Statement"],
          });
          (0, _utils.default)("ExpressionStatement", {
            visitor: ["expression"],
            fields: {
              expression: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
            aliases: ["Statement", "ExpressionWrapper"],
          });
          (0, _utils.default)("File", {
            builder: ["program", "comments", "tokens"],
            visitor: ["program"],
            fields: {
              program: {
                validate: (0, _utils.assertNodeType)("Program"),
              },
            },
          });
          (0, _utils.default)("ForInStatement", {
            visitor: ["left", "right", "body"],
            aliases: [
              "Scopable",
              "Statement",
              "For",
              "BlockParent",
              "Loop",
              "ForXStatement",
            ],
            fields: {
              left: {
                validate: (0, _utils.assertNodeType)(
                  "VariableDeclaration",
                  "LVal"
                ),
              },
              right: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              body: {
                validate: (0, _utils.assertNodeType)("Statement"),
              },
            },
          });
          (0, _utils.default)("ForStatement", {
            visitor: ["init", "test", "update", "body"],
            aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
            fields: {
              init: {
                validate: (0, _utils.assertNodeType)(
                  "VariableDeclaration",
                  "Expression"
                ),
                optional: true,
              },
              test: {
                validate: (0, _utils.assertNodeType)("Expression"),
                optional: true,
              },
              update: {
                validate: (0, _utils.assertNodeType)("Expression"),
                optional: true,
              },
              body: {
                validate: (0, _utils.assertNodeType)("Statement"),
              },
            },
          });
          var functionCommon = {
            params: {
              validate: (0, _utils.chain)(
                (0, _utils.assertValueType)("array"),
                (0, _utils.assertEach)((0, _utils.assertNodeType)("LVal"))
              ),
            },
            generator: {
              default: false,
              validate: (0, _utils.assertValueType)("boolean"),
            },
            async: {
              validate: (0, _utils.assertValueType)("boolean"),
              default: false,
            },
          };
          exports.functionCommon = functionCommon;
          var functionTypeAnnotationCommon = {
            returnType: {
              validate: (0, _utils.assertNodeType)(
                "TypeAnnotation",
                "TSTypeAnnotation",
                "Noop"
              ),
              optional: true,
            },
            typeParameters: {
              validate: (0, _utils.assertNodeType)(
                "TypeParameterDeclaration",
                "TSTypeParameterDeclaration",
                "Noop"
              ),
              optional: true,
            },
          };
          exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
          var functionDeclarationCommon = Object.assign({}, functionCommon, {
            declare: {
              validate: (0, _utils.assertValueType)("boolean"),
              optional: true,
            },
            id: {
              validate: (0, _utils.assertNodeType)("Identifier"),
              optional: true,
            },
          });
          exports.functionDeclarationCommon = functionDeclarationCommon;
          (0, _utils.default)("FunctionDeclaration", {
            builder: ["id", "params", "body", "generator", "async"],
            visitor: ["id", "params", "body", "returnType", "typeParameters"],
            fields: Object.assign(
              {},
              functionDeclarationCommon,
              functionTypeAnnotationCommon,
              {
                body: {
                  validate: (0, _utils.assertNodeType)("BlockStatement"),
                },
              }
            ),
            aliases: [
              "Scopable",
              "Function",
              "BlockParent",
              "FunctionParent",
              "Statement",
              "Pureish",
              "Declaration",
            ],
          });
          (0, _utils.default)("FunctionExpression", {
            inherits: "FunctionDeclaration",
            aliases: [
              "Scopable",
              "Function",
              "BlockParent",
              "FunctionParent",
              "Expression",
              "Pureish",
            ],
            fields: Object.assign(
              {},
              functionCommon,
              functionTypeAnnotationCommon,
              {
                id: {
                  validate: (0, _utils.assertNodeType)("Identifier"),
                  optional: true,
                },
                body: {
                  validate: (0, _utils.assertNodeType)("BlockStatement"),
                },
              }
            ),
          });
          var patternLikeCommon = {
            typeAnnotation: {
              validate: (0, _utils.assertNodeType)(
                "TypeAnnotation",
                "TSTypeAnnotation",
                "Noop"
              ),
              optional: true,
            },
            decorators: {
              validate: (0, _utils.chain)(
                (0, _utils.assertValueType)("array"),
                (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
              ),
            },
          };
          exports.patternLikeCommon = patternLikeCommon;
          (0, _utils.default)("Identifier", {
            builder: ["name"],
            visitor: ["typeAnnotation"],
            aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
            fields: Object.assign({}, patternLikeCommon, {
              name: {
                validate: (0, _utils.chain)(function(node, key, val) {
                  if (!(0, _isValidIdentifier.default)(val)) {
                  }
                }, (0, _utils.assertValueType)("string")),
              },
              optional: {
                validate: (0, _utils.assertValueType)("boolean"),
                optional: true,
              },
            }),
          });
          (0, _utils.default)("IfStatement", {
            visitor: ["test", "consequent", "alternate"],
            aliases: ["Statement", "Conditional"],
            fields: {
              test: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              consequent: {
                validate: (0, _utils.assertNodeType)("Statement"),
              },
              alternate: {
                optional: true,
                validate: (0, _utils.assertNodeType)("Statement"),
              },
            },
          });
          (0, _utils.default)("LabeledStatement", {
            visitor: ["label", "body"],
            aliases: ["Statement"],
            fields: {
              label: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
              body: {
                validate: (0, _utils.assertNodeType)("Statement"),
              },
            },
          });
          (0, _utils.default)("StringLiteral", {
            builder: ["value"],
            fields: {
              value: {
                validate: (0, _utils.assertValueType)("string"),
              },
            },
            aliases: ["Expression", "Pureish", "Literal", "Immutable"],
          });
          (0, _utils.default)("NumericLiteral", {
            builder: ["value"],
            deprecatedAlias: "NumberLiteral",
            fields: {
              value: {
                validate: (0, _utils.assertValueType)("number"),
              },
            },
            aliases: ["Expression", "Pureish", "Literal", "Immutable"],
          });
          (0, _utils.default)("NullLiteral", {
            aliases: ["Expression", "Pureish", "Literal", "Immutable"],
          });
          (0, _utils.default)("BooleanLiteral", {
            builder: ["value"],
            fields: {
              value: {
                validate: (0, _utils.assertValueType)("boolean"),
              },
            },
            aliases: ["Expression", "Pureish", "Literal", "Immutable"],
          });
          (0, _utils.default)("RegExpLiteral", {
            builder: ["pattern", "flags"],
            deprecatedAlias: "RegexLiteral",
            aliases: ["Expression", "Literal"],
            fields: {
              pattern: {
                validate: (0, _utils.assertValueType)("string"),
              },
              flags: {
                validate: (0, _utils.assertValueType)("string"),
                default: "",
              },
            },
          });
          (0, _utils.default)("LogicalExpression", {
            builder: ["operator", "left", "right"],
            visitor: ["left", "right"],
            aliases: ["Binary", "Expression"],
            fields: {
              operator: {
                validate: (0, _utils.assertOneOf).apply(
                  void 0,
                  _constants.LOGICAL_OPERATORS
                ),
              },
              left: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              right: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
          });
          (0, _utils.default)("MemberExpression", {
            builder: ["object", "property", "computed", "optional"],
            visitor: ["object", "property"],
            aliases: ["Expression", "LVal"],
            fields: {
              object: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              property: {
                validate: (function() {
                  var normal = (0, _utils.assertNodeType)(
                    "Identifier",
                    "PrivateName"
                  );
                  var computed = (0, _utils.assertNodeType)("Expression");
                  return function(node, key, val) {
                    var validator = node.computed ? computed : normal;
                    validator(node, key, val);
                  };
                })(),
              },
              computed: {
                default: false,
              },
              optional: {
                validate: (0, _utils.assertOneOf)(true, false),
                optional: true,
              },
            },
          });
          (0, _utils.default)("NewExpression", {
            inherits: "CallExpression",
          });
          (0, _utils.default)("Program", {
            visitor: ["directives", "body"],
            builder: ["body", "directives", "sourceType", "interpreter"],
            fields: {
              sourceFile: {
                validate: (0, _utils.assertValueType)("string"),
              },
              sourceType: {
                validate: (0, _utils.assertOneOf)("script", "module"),
                default: "script",
              },
              interpreter: {
                validate: (0, _utils.assertNodeType)("InterpreterDirective"),
                default: null,
                optional: true,
              },
              directives: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Directive")
                  )
                ),
                default: [],
              },
              body: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Statement")
                  )
                ),
              },
            },
            aliases: ["Scopable", "BlockParent", "Block"],
          });
          (0, _utils.default)("ObjectExpression", {
            visitor: ["properties"],
            aliases: ["Expression"],
            fields: {
              properties: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)(
                      "ObjectMethod",
                      "ObjectProperty",
                      "SpreadElement"
                    )
                  )
                ),
              },
            },
          });
          (0, _utils.default)("ObjectMethod", {
            builder: ["kind", "key", "params", "body", "computed"],
            fields: Object.assign(
              {},
              functionCommon,
              functionTypeAnnotationCommon,
              {
                kind: {
                  validate: (0, _utils.chain)(
                    (0, _utils.assertValueType)("string"),
                    (0, _utils.assertOneOf)("method", "get", "set")
                  ),
                  default: "method",
                },
                computed: {
                  validate: (0, _utils.assertValueType)("boolean"),
                  default: false,
                },
                key: {
                  validate: (function() {
                    var normal = (0, _utils.assertNodeType)(
                      "Identifier",
                      "StringLiteral",
                      "NumericLiteral"
                    );
                    var computed = (0, _utils.assertNodeType)("Expression");
                    return function(node, key, val) {
                      var validator = node.computed ? computed : normal;
                      validator(node, key, val);
                    };
                  })(),
                },
                decorators: {
                  validate: (0, _utils.chain)(
                    (0, _utils.assertValueType)("array"),
                    (0, _utils.assertEach)(
                      (0, _utils.assertNodeType)("Decorator")
                    )
                  ),
                },
                body: {
                  validate: (0, _utils.assertNodeType)("BlockStatement"),
                },
              }
            ),
            visitor: [
              "key",
              "params",
              "body",
              "decorators",
              "returnType",
              "typeParameters",
            ],
            aliases: [
              "UserWhitespacable",
              "Function",
              "Scopable",
              "BlockParent",
              "FunctionParent",
              "Method",
              "ObjectMember",
            ],
          });
          (0, _utils.default)("ObjectProperty", {
            builder: ["key", "value", "computed", "shorthand", "decorators"],
            fields: {
              computed: {
                validate: (0, _utils.assertValueType)("boolean"),
                default: false,
              },
              key: {
                validate: (function() {
                  var normal = (0, _utils.assertNodeType)(
                    "Identifier",
                    "StringLiteral",
                    "NumericLiteral"
                  );
                  var computed = (0, _utils.assertNodeType)("Expression");
                  return function(node, key, val) {
                    var validator = node.computed ? computed : normal;
                    validator(node, key, val);
                  };
                })(),
              },
              value: {
                validate: (0, _utils.assertNodeType)(
                  "Expression",
                  "PatternLike"
                ),
              },
              shorthand: {
                validate: (0, _utils.assertValueType)("boolean"),
                default: false,
              },
              decorators: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Decorator")
                  )
                ),
                optional: true,
              },
            },
            visitor: ["key", "value", "decorators"],
            aliases: ["UserWhitespacable", "Property", "ObjectMember"],
          });
          (0, _utils.default)("RestElement", {
            visitor: ["argument", "typeAnnotation"],
            builder: ["argument"],
            aliases: ["LVal", "PatternLike"],
            deprecatedAlias: "RestProperty",
            fields: Object.assign({}, patternLikeCommon, {
              argument: {
                validate: (0, _utils.assertNodeType)("LVal"),
              },
            }),
          });
          (0, _utils.default)("ReturnStatement", {
            visitor: ["argument"],
            aliases: ["Statement", "Terminatorless", "CompletionStatement"],
            fields: {
              argument: {
                validate: (0, _utils.assertNodeType)("Expression"),
                optional: true,
              },
            },
          });
          (0, _utils.default)("SequenceExpression", {
            visitor: ["expressions"],
            fields: {
              expressions: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Expression")
                  )
                ),
              },
            },
            aliases: ["Expression"],
          });
          (0, _utils.default)("SwitchCase", {
            visitor: ["test", "consequent"],
            fields: {
              test: {
                validate: (0, _utils.assertNodeType)("Expression"),
                optional: true,
              },
              consequent: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Statement")
                  )
                ),
              },
            },
          });
          (0, _utils.default)("SwitchStatement", {
            visitor: ["discriminant", "cases"],
            aliases: ["Statement", "BlockParent", "Scopable"],
            fields: {
              discriminant: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              cases: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("SwitchCase")
                  )
                ),
              },
            },
          });
          (0, _utils.default)("ThisExpression", {
            aliases: ["Expression"],
          });
          (0, _utils.default)("ThrowStatement", {
            visitor: ["argument"],
            aliases: ["Statement", "Terminatorless", "CompletionStatement"],
            fields: {
              argument: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
          });
          (0, _utils.default)("TryStatement", {
            visitor: ["block", "handler", "finalizer"],
            aliases: ["Statement"],
            fields: {
              block: {
                validate: (0, _utils.assertNodeType)("BlockStatement"),
              },
              handler: {
                optional: true,
                validate: (0, _utils.assertNodeType)("CatchClause"),
              },
              finalizer: {
                optional: true,
                validate: (0, _utils.assertNodeType)("BlockStatement"),
              },
            },
          });
          (0, _utils.default)("UnaryExpression", {
            builder: ["operator", "argument", "prefix"],
            fields: {
              prefix: {
                default: true,
              },
              argument: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              operator: {
                validate: (0, _utils.assertOneOf).apply(
                  void 0,
                  _constants.UNARY_OPERATORS
                ),
              },
            },
            visitor: ["argument"],
            aliases: ["UnaryLike", "Expression"],
          });
          (0, _utils.default)("UpdateExpression", {
            builder: ["operator", "argument", "prefix"],
            fields: {
              prefix: {
                default: false,
              },
              argument: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              operator: {
                validate: (0, _utils.assertOneOf).apply(
                  void 0,
                  _constants.UPDATE_OPERATORS
                ),
              },
            },
            visitor: ["argument"],
            aliases: ["Expression"],
          });
          (0, _utils.default)("VariableDeclaration", {
            builder: ["kind", "declarations"],
            visitor: ["declarations"],
            aliases: ["Statement", "Declaration"],
            fields: {
              declare: {
                validate: (0, _utils.assertValueType)("boolean"),
                optional: true,
              },
              kind: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("string"),
                  (0, _utils.assertOneOf)("var", "let", "const")
                ),
              },
              declarations: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("VariableDeclarator")
                  )
                ),
              },
            },
          });
          (0, _utils.default)("VariableDeclarator", {
            visitor: ["id", "init"],
            fields: {
              id: {
                validate: (0, _utils.assertNodeType)("LVal"),
              },
              definite: {
                optional: true,
                validate: (0, _utils.assertValueType)("boolean"),
              },
              init: {
                optional: true,
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
          });
          (0, _utils.default)("WhileStatement", {
            visitor: ["test", "body"],
            aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
            fields: {
              test: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              body: {
                validate: (0, _utils.assertNodeType)(
                  "BlockStatement",
                  "Statement"
                ),
              },
            },
          });
          (0, _utils.default)("WithStatement", {
            visitor: ["object", "body"],
            aliases: ["Statement"],
            fields: {
              object: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              body: {
                validate: (0, _utils.assertNodeType)(
                  "BlockStatement",
                  "Statement"
                ),
              },
            },
          });
        },
        /* 66 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = is;

          var _shallowEqual = _interopRequireDefault(__webpack_require__(51));

          var _isType = _interopRequireDefault(__webpack_require__(67));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function is(type, node, opts) {
            if (!node) return false;
            var matches = (0, _isType.default)(node.type, type);
            if (!matches) return false;

            if (typeof opts === "undefined") {
              return true;
            } else {
              return (0, _shallowEqual.default)(node, opts);
            }
          }
        },
        /* 67 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isType;

          var _definitions = __webpack_require__(8);

          function isType(nodeType, targetType) {
            if (nodeType === targetType) return true;
            if (_definitions.ALIAS_KEYS[targetType]) return false;
            var aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];

            if (aliases) {
              if (aliases[0] === nodeType) return true;

              for (
                var _iterator = aliases,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var alias = _ref;
                if (nodeType === alias) return true;
              }
            }

            return false;
          }
        },
        /* 68 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = void 0;

          var _utils = _interopRequireWildcard(__webpack_require__(12));

          var _core = __webpack_require__(65);

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          (0, _utils.default)("AssignmentPattern", {
            visitor: ["left", "right"],
            builder: ["left", "right"],
            aliases: ["Pattern", "PatternLike", "LVal"],
            fields: Object.assign({}, _core.patternLikeCommon, {
              left: {
                validate: (0, _utils.assertNodeType)(
                  "Identifier",
                  "ObjectPattern",
                  "ArrayPattern"
                ),
              },
              right: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              decorators: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Decorator")
                  )
                ),
              },
            }),
          });
          (0, _utils.default)("ArrayPattern", {
            visitor: ["elements", "typeAnnotation"],
            builder: ["elements"],
            aliases: ["Pattern", "PatternLike", "LVal"],
            fields: Object.assign({}, _core.patternLikeCommon, {
              elements: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("PatternLike")
                  )
                ),
              },
              decorators: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Decorator")
                  )
                ),
              },
            }),
          });
          (0, _utils.default)("ArrowFunctionExpression", {
            builder: ["params", "body", "async"],
            visitor: ["params", "body", "returnType", "typeParameters"],
            aliases: [
              "Scopable",
              "Function",
              "BlockParent",
              "FunctionParent",
              "Expression",
              "Pureish",
            ],
            fields: Object.assign(
              {},
              _core.functionCommon,
              _core.functionTypeAnnotationCommon,
              {
                expression: {
                  validate: (0, _utils.assertValueType)("boolean"),
                },
                body: {
                  validate: (0, _utils.assertNodeType)(
                    "BlockStatement",
                    "Expression"
                  ),
                },
              }
            ),
          });
          (0, _utils.default)("ClassBody", {
            visitor: ["body"],
            fields: {
              body: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)(
                      "ClassMethod",
                      "ClassProperty",
                      "ClassPrivateProperty",
                      "TSDeclareMethod",
                      "TSIndexSignature"
                    )
                  )
                ),
              },
            },
          });
          var classCommon = {
            typeParameters: {
              validate: (0, _utils.assertNodeType)(
                "TypeParameterDeclaration",
                "TSTypeParameterDeclaration",
                "Noop"
              ),
              optional: true,
            },
            body: {
              validate: (0, _utils.assertNodeType)("ClassBody"),
            },
            superClass: {
              optional: true,
              validate: (0, _utils.assertNodeType)("Expression"),
            },
            superTypeParameters: {
              validate: (0, _utils.assertNodeType)(
                "TypeParameterInstantiation",
                "TSTypeParameterInstantiation"
              ),
              optional: true,
            },
            implements: {
              validate: (0, _utils.chain)(
                (0, _utils.assertValueType)("array"),
                (0, _utils.assertEach)(
                  (0, _utils.assertNodeType)(
                    "TSExpressionWithTypeArguments",
                    "ClassImplements"
                  )
                )
              ),
              optional: true,
            },
          };
          (0, _utils.default)("ClassDeclaration", {
            builder: ["id", "superClass", "body", "decorators"],
            visitor: [
              "id",
              "body",
              "superClass",
              "mixins",
              "typeParameters",
              "superTypeParameters",
              "implements",
              "decorators",
            ],
            aliases: [
              "Scopable",
              "Class",
              "Statement",
              "Declaration",
              "Pureish",
            ],
            fields: Object.assign({}, classCommon, {
              declare: {
                validate: (0, _utils.assertValueType)("boolean"),
                optional: true,
              },
              abstract: {
                validate: (0, _utils.assertValueType)("boolean"),
                optional: true,
              },
              id: {
                validate: (0, _utils.assertNodeType)("Identifier"),
                optional: true,
              },
              decorators: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Decorator")
                  )
                ),
                optional: true,
              },
            }),
          });
          (0, _utils.default)("ClassExpression", {
            inherits: "ClassDeclaration",
            aliases: ["Scopable", "Class", "Expression", "Pureish"],
            fields: Object.assign({}, classCommon, {
              id: {
                optional: true,
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
              body: {
                validate: (0, _utils.assertNodeType)("ClassBody"),
              },
              superClass: {
                optional: true,
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              decorators: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Decorator")
                  )
                ),
                optional: true,
              },
            }),
          });
          (0, _utils.default)("ExportAllDeclaration", {
            visitor: ["source"],
            aliases: [
              "Statement",
              "Declaration",
              "ModuleDeclaration",
              "ExportDeclaration",
            ],
            fields: {
              source: {
                validate: (0, _utils.assertNodeType)("StringLiteral"),
              },
            },
          });
          (0, _utils.default)("ExportDefaultDeclaration", {
            visitor: ["declaration"],
            aliases: [
              "Statement",
              "Declaration",
              "ModuleDeclaration",
              "ExportDeclaration",
            ],
            fields: {
              declaration: {
                validate: (0, _utils.assertNodeType)(
                  "FunctionDeclaration",
                  "TSDeclareFunction",
                  "ClassDeclaration",
                  "Expression"
                ),
              },
            },
          });
          (0, _utils.default)("ExportNamedDeclaration", {
            visitor: ["declaration", "specifiers", "source"],
            aliases: [
              "Statement",
              "Declaration",
              "ModuleDeclaration",
              "ExportDeclaration",
            ],
            fields: {
              declaration: {
                validate: (0, _utils.assertNodeType)("Declaration"),
                optional: true,
              },
              specifiers: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)(
                      "ExportSpecifier",
                      "ExportDefaultSpecifier",
                      "ExportNamespaceSpecifier"
                    )
                  )
                ),
              },
              source: {
                validate: (0, _utils.assertNodeType)("StringLiteral"),
                optional: true,
              },
            },
          });
          (0, _utils.default)("ExportSpecifier", {
            visitor: ["local", "exported"],
            aliases: ["ModuleSpecifier"],
            fields: {
              local: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
              exported: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
            },
          });
          (0, _utils.default)("ForOfStatement", {
            visitor: ["left", "right", "body"],
            aliases: [
              "Scopable",
              "Statement",
              "For",
              "BlockParent",
              "Loop",
              "ForXStatement",
            ],
            fields: {
              left: {
                validate: (0, _utils.assertNodeType)(
                  "VariableDeclaration",
                  "LVal"
                ),
              },
              right: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              body: {
                validate: (0, _utils.assertNodeType)("Statement"),
              },
              await: {
                default: false,
                validate: (0, _utils.assertValueType)("boolean"),
              },
            },
          });
          (0, _utils.default)("ImportDeclaration", {
            visitor: ["specifiers", "source"],
            aliases: ["Statement", "Declaration", "ModuleDeclaration"],
            fields: {
              specifiers: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)(
                      "ImportSpecifier",
                      "ImportDefaultSpecifier",
                      "ImportNamespaceSpecifier"
                    )
                  )
                ),
              },
              source: {
                validate: (0, _utils.assertNodeType)("StringLiteral"),
              },
            },
          });
          (0, _utils.default)("ImportDefaultSpecifier", {
            visitor: ["local"],
            aliases: ["ModuleSpecifier"],
            fields: {
              local: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
            },
          });
          (0, _utils.default)("ImportNamespaceSpecifier", {
            visitor: ["local"],
            aliases: ["ModuleSpecifier"],
            fields: {
              local: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
            },
          });
          (0, _utils.default)("ImportSpecifier", {
            visitor: ["local", "imported"],
            aliases: ["ModuleSpecifier"],
            fields: {
              local: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
              imported: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
              importKind: {
                validate: (0, _utils.assertOneOf)(null, "type", "typeof"),
              },
            },
          });
          (0, _utils.default)("MetaProperty", {
            visitor: ["meta", "property"],
            aliases: ["Expression"],
            fields: {
              meta: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
              property: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
            },
          });
          var classMethodOrPropertyCommon = {
            abstract: {
              validate: (0, _utils.assertValueType)("boolean"),
              optional: true,
            },
            accessibility: {
              validate: (0, _utils.chain)(
                (0, _utils.assertValueType)("string"),
                (0, _utils.assertOneOf)("public", "private", "protected")
              ),
              optional: true,
            },
            static: {
              validate: (0, _utils.assertValueType)("boolean"),
              optional: true,
            },
            computed: {
              default: false,
              validate: (0, _utils.assertValueType)("boolean"),
            },
            optional: {
              validate: (0, _utils.assertValueType)("boolean"),
              optional: true,
            },
            key: {
              validate: (0, _utils.chain)(
                (function() {
                  var normal = (0, _utils.assertNodeType)(
                    "Identifier",
                    "StringLiteral",
                    "NumericLiteral"
                  );
                  var computed = (0, _utils.assertNodeType)("Expression");
                  return function(node, key, val) {
                    var validator = node.computed ? computed : normal;
                    validator(node, key, val);
                  };
                })(),
                (0, _utils.assertNodeType)(
                  "Identifier",
                  "StringLiteral",
                  "NumericLiteral",
                  "Expression"
                )
              ),
            },
          };
          exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
          var classMethodOrDeclareMethodCommon = Object.assign(
            {},
            _core.functionCommon,
            classMethodOrPropertyCommon,
            {
              kind: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("string"),
                  (0, _utils.assertOneOf)("get", "set", "method", "constructor")
                ),
                default: "method",
              },
              access: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("string"),
                  (0, _utils.assertOneOf)("public", "private", "protected")
                ),
                optional: true,
              },
              decorators: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Decorator")
                  )
                ),
                optional: true,
              },
            }
          );
          exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
          (0, _utils.default)("ClassMethod", {
            aliases: [
              "Function",
              "Scopable",
              "BlockParent",
              "FunctionParent",
              "Method",
            ],
            builder: ["kind", "key", "params", "body", "computed", "static"],
            visitor: [
              "key",
              "params",
              "body",
              "decorators",
              "returnType",
              "typeParameters",
            ],
            fields: Object.assign(
              {},
              classMethodOrDeclareMethodCommon,
              _core.functionTypeAnnotationCommon,
              {
                body: {
                  validate: (0, _utils.assertNodeType)("BlockStatement"),
                },
              }
            ),
          });
          (0, _utils.default)("ObjectPattern", {
            visitor: ["properties", "typeAnnotation"],
            builder: ["properties"],
            aliases: ["Pattern", "PatternLike", "LVal"],
            fields: Object.assign({}, _core.patternLikeCommon, {
              properties: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("RestElement", "ObjectProperty")
                  )
                ),
              },
            }),
          });
          (0, _utils.default)("SpreadElement", {
            visitor: ["argument"],
            aliases: ["UnaryLike"],
            deprecatedAlias: "SpreadProperty",
            fields: {
              argument: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
          });
          (0, _utils.default)("Super", {
            aliases: ["Expression"],
          });
          (0, _utils.default)("TaggedTemplateExpression", {
            visitor: ["tag", "quasi"],
            aliases: ["Expression"],
            fields: {
              tag: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              quasi: {
                validate: (0, _utils.assertNodeType)("TemplateLiteral"),
              },
              typeParameters: {
                validate: (0, _utils.assertNodeType)(
                  "TypeParameterInstantiation",
                  "TSTypeParameterInstantiation"
                ),
                optional: true,
              },
            },
          });
          (0, _utils.default)("TemplateElement", {
            builder: ["value", "tail"],
            fields: {
              value: {},
              tail: {
                validate: (0, _utils.assertValueType)("boolean"),
                default: false,
              },
            },
          });
          (0, _utils.default)("TemplateLiteral", {
            visitor: ["quasis", "expressions"],
            aliases: ["Expression", "Literal"],
            fields: {
              quasis: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("TemplateElement")
                  )
                ),
              },
              expressions: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Expression")
                  )
                ),
              },
            },
          });
          (0, _utils.default)("YieldExpression", {
            builder: ["argument", "delegate"],
            visitor: ["argument"],
            aliases: ["Expression", "Terminatorless"],
            fields: {
              delegate: {
                validate: (0, _utils.assertValueType)("boolean"),
                default: false,
              },
              argument: {
                optional: true,
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
          });
        },
        /* 69 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = inherit;

          function _uniq() {
            var data = _interopRequireDefault(__webpack_require__(257));

            _uniq = function _uniq() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function inherit(key, child, parent) {
            if (child && parent) {
              child[key] = (0, _uniq().default)(
                [].concat(child[key], parent[key]).filter(Boolean)
              );
            }
          }
        },
        /* 70 */
        function(module, exports) {
          function setToArray(set) {
            var index = -1,
              result = Array(set.size);
            set.forEach(function(value) {
              result[++index] = value;
            });
            return result;
          }

          module.exports = setToArray;
        },
        /* 71 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(process) {
            Object.defineProperty(exports, "__esModule", {
              value: true,
            });
            exports.default = exports.semverMin = exports.isBrowsersQueryValid = void 0;

            function _browserslist() {
              var data = _interopRequireDefault(__webpack_require__(127));

              _browserslist = function _browserslist() {
                return data;
              };

              return data;
            }

            function _assert() {
              var data = _interopRequireDefault(__webpack_require__(23));

              _assert = function _assert() {
                return data;
              };

              return data;
            }

            function _semver() {
              var data = _interopRequireDefault(__webpack_require__(16));

              _semver = function _semver() {
                return data;
              };

              return data;
            }

            var _utils = __webpack_require__(17);

            var _normalizeOptions = __webpack_require__(129);

            var _builtInModules = _interopRequireDefault(
              __webpack_require__(310)
            );

            var _options = __webpack_require__(132);

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule
                ? obj
                : {
                    default: obj,
                  };
            }

            var browserslistDefaults = _browserslist().default.defaults;

            var validateTargetNames = function validateTargetNames(
              validTargets,
              targets
            ) {
              for (var target in targets) {
                if (!_options.TargetNames[target]) {
                  var validOptions = (0, _utils.getValues)(
                    _options.TargetNames
                  );
                  throw new Error(
                    "Invalid Option: '" +
                      target +
                      "' is not a valid target\n        Maybe you meant to use '" +
                      (0, _utils.findSuggestion)(validOptions, target) +
                      "'?"
                  );
                }
              }
            };

            var browserNameMap = {
              android: "android",
              chrome: "chrome",
              and_chr: "chrome",
              edge: "edge",
              firefox: "firefox",
              ie: "ie",
              ios_saf: "ios",
              safari: "safari",
              node: "node",
            };

            var isBrowsersQueryValid = function isBrowsersQueryValid(browsers) {
              return typeof browsers === "string" || Array.isArray(browsers);
            };

            exports.isBrowsersQueryValid = isBrowsersQueryValid;

            var validateBrowsers = function validateBrowsers(browsers) {
              (0, _assert().default)(
                typeof browsers === "undefined" ||
                  isBrowsersQueryValid(browsers),
                "Invalid Option: '" +
                  browsers +
                  "' is not a valid browserslist query"
              );
              return browsers;
            };

            var semverMin = function semverMin(first, second) {
              return first && _semver().default.lt(first, second)
                ? first
                : second;
            };

            exports.semverMin = semverMin;

            var mergeBrowsers = function mergeBrowsers(fromQuery, fromTarget) {
              return Object.keys(fromTarget).reduce(function(
                queryObj,
                targKey
              ) {
                if (targKey !== _options.TargetNames.browsers) {
                  queryObj[targKey] = fromTarget[targKey];
                }

                return queryObj;
              },
              fromQuery);
            };

            var injectCurrentNodeVersion = function injectCurrentNodeVersion(
              browser
            ) {
              return browser.replace(
                /(current node)|(node current)/,
                "node " + (0, _utils.roundToMinor)(process.versions.node)
              );
            };

            var normalizeBrowsers = function normalizeBrowsers(browsers) {
              if (!browsers) return browsers;

              if (typeof browsers === "string") {
                return injectCurrentNodeVersion(browsers);
              }

              return browsers.map(injectCurrentNodeVersion);
            };

            var getLowestVersions = function getLowestVersions(browsers) {
              return browsers.reduce(function(all, browser) {
                var _browser$split = browser.split(" "),
                  browserName = _browser$split[0],
                  browserVersion = _browser$split[1];

                var normalizedBrowserName = browserNameMap[browserName];

                if (!normalizedBrowserName) {
                  return all;
                }

                try {
                  var splitVersion = browserVersion.split("-")[0].toLowerCase();
                  var isSplitUnreleased = (0, _utils.isUnreleasedVersion)(
                    splitVersion,
                    browserName
                  );

                  if (!all[normalizedBrowserName]) {
                    all[normalizedBrowserName] = isSplitUnreleased
                      ? splitVersion
                      : (0, _utils.semverify)(splitVersion);
                    return all;
                  }

                  var version = all[normalizedBrowserName];
                  var isUnreleased = (0, _utils.isUnreleasedVersion)(
                    version,
                    browserName
                  );

                  if (isUnreleased && isSplitUnreleased) {
                    all[normalizedBrowserName] = (0,
                    _utils.getLowestUnreleased)(
                      version,
                      splitVersion,
                      browserName
                    );
                  } else if (isUnreleased) {
                    all[normalizedBrowserName] = (0, _utils.semverify)(
                      splitVersion
                    );
                  } else if (!isUnreleased && !isSplitUnreleased) {
                    var parsedBrowserVersion = (0, _utils.semverify)(
                      splitVersion
                    );
                    all[normalizedBrowserName] = semverMin(
                      version,
                      parsedBrowserVersion
                    );
                  }
                } catch (e) {}

                return all;
              }, {});
            };

            var outputDecimalWarning = function outputDecimalWarning(
              decimalTargets
            ) {
              if (!decimalTargets || !decimalTargets.length) {
                return;
              }

              console.log(
                "Warning, the following targets are using a decimal version:"
              );
              console.log("");
              decimalTargets.forEach(function(_ref) {
                var target = _ref.target,
                  value = _ref.value;
                return console.log("  " + target + ": " + value);
              });
              console.log("");
              console.log(
                "We recommend using a string for minor/patch versions to avoid numbers like 6.10"
              );
              console.log(
                "getting parsed as 6.1, which can lead to unexpected behavior."
              );
              console.log("");
            };

            var semverifyTarget = function semverifyTarget(target, value) {
              try {
                return (0, _utils.semverify)(value);
              } catch (error) {
                throw new Error(
                  "Invalid Option: '" +
                    value +
                    "' is not a valid value for 'targets." +
                    target +
                    "'."
                );
              }
            };

            var targetParserMap = {
              __default: function __default(target, value) {
                var version = (0, _utils.isUnreleasedVersion)(value, target)
                  ? value.toLowerCase()
                  : semverifyTarget(target, value);
                return [target, version];
              },
              node: function node(target, value) {
                var parsed =
                  value === true || value === "current"
                    ? process.versions.node
                    : semverifyTarget(target, value);
                return [target, parsed];
              },
            };

            var getTargets = function getTargets(targets, options) {
              if (targets === void 0) {
                targets = {};
              }

              if (options === void 0) {
                options = {};
              }

              var targetOpts = {};
              validateTargetNames(targets);

              if (targets.esmodules) {
                var supportsESModules = _builtInModules.default["es6.module"];
                targets.browsers = Object.keys(supportsESModules)
                  .map(function(browser) {
                    return browser + " " + supportsESModules[browser];
                  })
                  .join(", ");
              }

              var browsersquery = validateBrowsers(targets.browsers);
              browsersquery = normalizeBrowsers(targets.browsers);
              var shouldParseBrowsers = !!targets.browsers;
              var shouldSearchForConfig =
                !options.ignoreBrowserslistConfig &&
                !Object.keys(targets).length;

              if (shouldParseBrowsers || shouldSearchForConfig) {
                _browserslist().default.defaults = (0,
                _normalizeOptions.objectToBrowserslist)(targets);
                var browsers = (0, _browserslist().default)(browsersquery, {
                  path: options.configPath,
                  ignoreUnknownVersions: true,
                });
                var queryBrowsers = getLowestVersions(browsers);
                targets = mergeBrowsers(queryBrowsers, targets);
                _browserslist().default.defaults = browserslistDefaults;
              }

              var parsed = Object.keys(targets)
                .filter(function(value) {
                  return value !== _options.TargetNames.esmodules;
                })
                .sort()
                .reduce(
                  function(results, target) {
                    if (target !== _options.TargetNames.browsers) {
                      var value = targets[target];

                      if (typeof value === "number" && value % 1 !== 0) {
                        results.decimalWarnings.push({
                          target: target,
                          value: value,
                        });
                      }

                      var parser =
                        targetParserMap[target] || targetParserMap.__default;

                      var _parser = parser(target, value),
                        parsedTarget = _parser[0],
                        parsedValue = _parser[1];

                      if (parsedValue) {
                        results.targets[parsedTarget] = parsedValue;
                      }
                    }

                    return results;
                  },
                  {
                    targets: targetOpts,
                    decimalWarnings: [],
                  }
                );
              outputDecimalWarning(parsed.decimalWarnings);
              return parsed.targets;
            };

            var _default = getTargets;
            exports.default = _default;
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(3)));
        },
        /* 72 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.Plugin = Plugin;
          Object.defineProperty(exports, "File", {
            enumerable: true,
            get: function get() {
              return _file.default;
            },
          });
          Object.defineProperty(exports, "buildExternalHelpers", {
            enumerable: true,
            get: function get() {
              return _buildExternalHelpers.default;
            },
          });
          Object.defineProperty(exports, "resolvePlugin", {
            enumerable: true,
            get: function get() {
              return _files.resolvePlugin;
            },
          });
          Object.defineProperty(exports, "resolvePreset", {
            enumerable: true,
            get: function get() {
              return _files.resolvePreset;
            },
          });
          Object.defineProperty(exports, "version", {
            enumerable: true,
            get: function get() {
              return _package.version;
            },
          });
          Object.defineProperty(exports, "getEnv", {
            enumerable: true,
            get: function get() {
              return _environment.getEnv;
            },
          });
          Object.defineProperty(exports, "traverse", {
            enumerable: true,
            get: function get() {
              return _babelTraverse().default;
            },
          });
          Object.defineProperty(exports, "template", {
            enumerable: true,
            get: function get() {
              return _babelTemplate().default;
            },
          });
          Object.defineProperty(exports, "createConfigItem", {
            enumerable: true,
            get: function get() {
              return _item.createConfigItem;
            },
          });
          Object.defineProperty(exports, "loadPartialConfig", {
            enumerable: true,
            get: function get() {
              return _config.loadPartialConfig;
            },
          });
          Object.defineProperty(exports, "loadOptions", {
            enumerable: true,
            get: function get() {
              return _config.loadOptions;
            },
          });
          Object.defineProperty(exports, "transform", {
            enumerable: true,
            get: function get() {
              return _transform.transform;
            },
          });
          Object.defineProperty(exports, "transformSync", {
            enumerable: true,
            get: function get() {
              return _transform.transformSync;
            },
          });
          Object.defineProperty(exports, "transformAsync", {
            enumerable: true,
            get: function get() {
              return _transform.transformAsync;
            },
          });
          Object.defineProperty(exports, "transformFile", {
            enumerable: true,
            get: function get() {
              return _transformFile.transformFile;
            },
          });
          Object.defineProperty(exports, "transformFileSync", {
            enumerable: true,
            get: function get() {
              return _transformFile.transformFileSync;
            },
          });
          Object.defineProperty(exports, "transformFileAsync", {
            enumerable: true,
            get: function get() {
              return _transformFile.transformFileAsync;
            },
          });
          Object.defineProperty(exports, "transformFromAst", {
            enumerable: true,
            get: function get() {
              return _transformAst.transformFromAst;
            },
          });
          Object.defineProperty(exports, "transformFromAstSync", {
            enumerable: true,
            get: function get() {
              return _transformAst.transformFromAstSync;
            },
          });
          Object.defineProperty(exports, "transformFromAstAsync", {
            enumerable: true,
            get: function get() {
              return _transformAst.transformFromAstAsync;
            },
          });
          Object.defineProperty(exports, "parse", {
            enumerable: true,
            get: function get() {
              return _parse.parse;
            },
          });
          Object.defineProperty(exports, "parseSync", {
            enumerable: true,
            get: function get() {
              return _parse.parseSync;
            },
          });
          Object.defineProperty(exports, "parseAsync", {
            enumerable: true,
            get: function get() {
              return _parse.parseAsync;
            },
          });
          exports.types = exports.OptionManager = exports.DEFAULT_EXTENSIONS = void 0;

          var _file = _interopRequireDefault(__webpack_require__(133));

          var _buildExternalHelpers = _interopRequireDefault(
            __webpack_require__(400)
          );

          var _files = __webpack_require__(82);

          var _package = __webpack_require__(401);

          var _environment = __webpack_require__(151);

          function _types() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            _types = function _types() {
              return data;
            };

            return data;
          }

          Object.defineProperty(exports, "types", {
            enumerable: true,
            get: function get() {
              return _types();
            },
          });

          function _babelTraverse() {
            var data = _interopRequireDefault(__webpack_require__(9));

            _babelTraverse = function _babelTraverse() {
              return data;
            };

            return data;
          }

          function _babelTemplate() {
            var data = _interopRequireDefault(__webpack_require__(45));

            _babelTemplate = function _babelTemplate() {
              return data;
            };

            return data;
          }

          var _item = __webpack_require__(46);

          var _config = __webpack_require__(31);

          var _transform = __webpack_require__(409);

          var _transformFile = __webpack_require__(451);

          var _transformAst = __webpack_require__(452);

          var _parse = __webpack_require__(453);

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var DEFAULT_EXTENSIONS = Object.freeze([
            ".js",
            ".jsx",
            ".es6",
            ".es",
            ".mjs",
          ]);
          exports.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS;

          var OptionManager = (function() {
            function OptionManager() {}

            var _proto = OptionManager.prototype;

            _proto.init = function init(opts) {
              return (0, _config.loadOptions)(opts);
            };

            return OptionManager;
          })();

          exports.OptionManager = OptionManager;

          function Plugin(alias) {
            throw new Error(
              "The (" +
                alias +
                ") Babel 5 plugin is being run with an unsupported Babel version."
            );
          }
        },
        /* 73 */
        function(module, exports, __webpack_require__) {
          var baseIndexOf = __webpack_require__(115),
            isArrayLike = __webpack_require__(20),
            isString = __webpack_require__(321),
            toInteger = __webpack_require__(74),
            values = __webpack_require__(324);

          var nativeMax = Math.max;

          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection)
              ? collection
              : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;

            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }

            return isString(collection)
              ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1
              : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }

          module.exports = includes;
        },
        /* 74 */
        function(module, exports, __webpack_require__) {
          var toFinite = __webpack_require__(322);

          function toInteger(value) {
            var result = toFinite(value),
              remainder = result % 1;
            return result === result
              ? remainder
                ? result - remainder
                : result
              : 0;
          }

          module.exports = toInteger;
        },
        /* 75 */
        function(module, exports) {
          function arrayMap(array, iteratee) {
            var index = -1,
              length = array == null ? 0 : array.length,
              result = Array(length);

            while (++index < length) {
              result[index] = iteratee(array[index], index, array);
            }

            return result;
          }

          module.exports = arrayMap;
        },
        /* 76 */
        function(module, exports, __webpack_require__) {
          var eq = __webpack_require__(25),
            isArrayLike = __webpack_require__(20),
            isIndex = __webpack_require__(57),
            isObject = __webpack_require__(11);

          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }

            var type = typeof index;

            if (
              type == "number"
                ? isArrayLike(object) && isIndex(index, object.length)
                : type == "string" && index in object
            ) {
              return eq(object[index], value);
            }

            return false;
          }

          module.exports = isIterateeCall;
        },
        /* 77 */
        function(module, exports, __webpack_require__) {
          var baseToString = __webpack_require__(327);

          function toString(value) {
            return value == null ? "" : baseToString(value);
          }

          module.exports = toString;
        },
        /* 78 */
        function(module, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _gerhobbelt_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            169
          );
          /* harmony import */ var _gerhobbelt_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
            _gerhobbelt_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__
          );

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = _default;
          exports.CodeGenerator = void 0;

          var _sourceMap = _interopRequireDefault(__webpack_require__(339));

          var _printer = _interopRequireDefault(__webpack_require__(346));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var Generator = (function(_printer$default) {
            _gerhobbelt_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              Generator,
              _printer$default
            );

            function Generator(ast, opts, code) {
              var _this;

              if (opts === void 0) {
                opts = {};
              }

              var format = normalizeOptions(code, opts);
              var map = opts.sourceMaps
                ? new _sourceMap.default(opts, code)
                : null;
              _this = _printer$default.call(this, format, map) || this;
              _this.ast = ast;
              return _this;
            }

            var _proto = Generator.prototype;

            _proto.generate = function generate() {
              return _printer$default.prototype.generate.call(this, this.ast);
            };

            return Generator;
          })(_printer.default);

          function normalizeOptions(code, opts) {
            var format = {
              auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
              auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
              shouldPrintComment: opts.shouldPrintComment,
              retainLines: opts.retainLines,
              retainFunctionParens: opts.retainFunctionParens,
              comments: opts.comments == null || opts.comments,
              compact: opts.compact,
              minified: opts.minified,
              concise: opts.concise,
              jsonCompatibleStrings: opts.jsonCompatibleStrings,
              indent: {
                adjustMultilineComment: true,
                style: "  ",
                base: 0,
              },
              decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
              jsescOption: Object.assign(
                {
                  quotes: "double",
                  wrap: true,
                },
                opts.jsescOption
              ),
            };

            if (format.minified) {
              format.compact = true;

              format.shouldPrintComment =
                format.shouldPrintComment ||
                function() {
                  return format.comments;
                };
            } else {
              format.shouldPrintComment =
                format.shouldPrintComment ||
                function(value) {
                  return (
                    format.comments ||
                    value.indexOf("@license") >= 0 ||
                    value.indexOf("@preserve") >= 0
                  );
                };
            }

            if (format.compact === "auto") {
              format.compact = code.length > 500000;

              if (format.compact) {
                console.error(
                  "[BABEL] Note: The code generator has deoptimised the styling of " +
                    (opts.filename +
                      " as it exceeds the max of " +
                      "500KB" +
                      ".")
                );
              }
            }

            if (format.compact) {
              format.indent.adjustMultilineComment = false;
            }

            return format;
          }

          var CodeGenerator = (function() {
            function CodeGenerator(ast, opts, code) {
              this._generator = new Generator(ast, opts, code);
            }

            var _proto2 = CodeGenerator.prototype;

            _proto2.generate = function generate() {
              return this._generator.generate();
            };

            return CodeGenerator;
          })();

          exports.CodeGenerator = CodeGenerator;

          function _default(ast, opts, code) {
            var gen = new Generator(ast, opts, code);
            return gen.generate();
          }
        },
        /* 79 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.Identifier = Identifier;
          exports.SpreadElement = exports.RestElement = RestElement;
          exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
          exports.ObjectMethod = ObjectMethod;
          exports.ObjectProperty = ObjectProperty;
          exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
          exports.RegExpLiteral = RegExpLiteral;
          exports.BooleanLiteral = BooleanLiteral;
          exports.NullLiteral = NullLiteral;
          exports.NumericLiteral = NumericLiteral;
          exports.StringLiteral = StringLiteral;
          exports.BigIntLiteral = BigIntLiteral;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _jsesc() {
            var data = _interopRequireDefault(__webpack_require__(358));

            _jsesc = function _jsesc() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function Identifier(node) {
            var _this = this;

            this.exactSource(node.loc, function() {
              _this.word(node.name);
            });
          }

          function RestElement(node) {
            this.token("...");
            this.print(node.argument, node);
          }

          function ObjectExpression(node) {
            var props = node.properties;
            this.token("{");
            this.printInnerComments(node);

            if (props.length) {
              this.space();
              this.printList(props, node, {
                indent: true,
                statement: true,
              });
              this.space();
            }

            this.token("}");
          }

          function ObjectMethod(node) {
            this.printJoin(node.decorators, node);

            this._methodHead(node);

            this.space();
            this.print(node.body, node);
          }

          function ObjectProperty(node) {
            this.printJoin(node.decorators, node);

            if (node.computed) {
              this.token("[");
              this.print(node.key, node);
              this.token("]");
            } else {
              if (
                t().isAssignmentPattern(node.value) &&
                t().isIdentifier(node.key) &&
                node.key.name === node.value.left.name
              ) {
                this.print(node.value, node);
                return;
              }

              this.print(node.key, node);

              if (
                node.shorthand &&
                t().isIdentifier(node.key) &&
                t().isIdentifier(node.value) &&
                node.key.name === node.value.name
              ) {
                return;
              }
            }

            this.token(":");
            this.space();
            this.print(node.value, node);
          }

          function ArrayExpression(node) {
            var elems = node.elements;
            var len = elems.length;
            this.token("[");
            this.printInnerComments(node);

            for (var i = 0; i < elems.length; i++) {
              var elem = elems[i];

              if (elem) {
                if (i > 0) this.space();
                this.print(elem, node);
                if (i < len - 1) this.token(",");
              } else {
                this.token(",");
              }
            }

            this.token("]");
          }

          function RegExpLiteral(node) {
            this.word("/" + node.pattern + "/" + node.flags);
          }

          function BooleanLiteral(node) {
            this.word(node.value ? "true" : "false");
          }

          function NullLiteral() {
            this.word("null");
          }

          function NumericLiteral(node) {
            var raw = this.getPossibleRaw(node);
            var value = node.value + "";

            if (raw == null) {
              this.number(value);
            } else if (this.format.minified) {
              this.number(raw.length < value.length ? raw : value);
            } else {
              this.number(raw);
            }
          }

          function StringLiteral(node) {
            var raw = this.getPossibleRaw(node);

            if (!this.format.minified && raw != null) {
              this.token(raw);
              return;
            }

            var opts = this.format.jsescOption;

            if (this.format.jsonCompatibleStrings) {
              opts.json = true;
            }

            var val = (0, _jsesc().default)(node.value, opts);
            return this.token(val);
          }

          function BigIntLiteral(node) {
            var raw = this.getPossibleRaw(node);

            if (!this.format.minified && raw != null) {
              this.token(raw);
              return;
            }

            this.token(node.value);
          }
        },
        /* 80 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });

          function _AwaitValue(value) {
            this.wrapped = value;
          }

          function _AsyncGenerator(gen) {
            var front, back;

            function send(key, arg) {
              return new Promise(function(resolve, reject) {
                var request = {
                  key: key,
                  arg: arg,
                  resolve: resolve,
                  reject: reject,
                  next: null,
                };

                if (back) {
                  back = back.next = request;
                } else {
                  front = back = request;
                  resume(key, arg);
                }
              });
            }

            function resume(key, arg) {
              try {
                var result = gen[key](arg);
                var value = result.value;
                var wrappedAwait = value instanceof _AwaitValue;
                Promise.resolve(wrappedAwait ? value.wrapped : value).then(
                  function(arg) {
                    if (wrappedAwait) {
                      resume("next", arg);
                      return;
                    }

                    settle(result.done ? "return" : "normal", arg);
                  },
                  function(err) {
                    resume("throw", err);
                  }
                );
              } catch (err) {
                settle("throw", err);
              }
            }

            function settle(type, value) {
              switch (type) {
                case "return":
                  front.resolve({
                    value: value,
                    done: true,
                  });
                  break;

                case "throw":
                  front.reject(value);
                  break;

                default:
                  front.resolve({
                    value: value,
                    done: false,
                  });
                  break;
              }

              front = front.next;

              if (front) {
                resume(front.key, front.arg);
              } else {
                back = null;
              }
            }

            this._invoke = send;

            if (typeof gen.return !== "function") {
              this.return = undefined;
            }
          }

          if (typeof Symbol === "function" && Symbol.asyncIterator) {
            _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
              return this;
            };
          }

          _AsyncGenerator.prototype.next = function(arg) {
            return this._invoke("next", arg);
          };

          _AsyncGenerator.prototype.throw = function(arg) {
            return this._invoke("throw", arg);
          };

          _AsyncGenerator.prototype.return = function(arg) {
            return this._invoke("return", arg);
          };

          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          var beforeExpr = true;
          var startsExpr = true;
          var isLoop = true;
          var isAssign = true;
          var prefix = true;
          var postfix = true;

          var TokenType = function TokenType(label, conf) {
            if (conf === void 0) {
              conf = {};
            }

            this.label = label;
            this.keyword = conf.keyword;
            this.beforeExpr = !!conf.beforeExpr;
            this.startsExpr = !!conf.startsExpr;
            this.rightAssociative = !!conf.rightAssociative;
            this.isLoop = !!conf.isLoop;
            this.isAssign = !!conf.isAssign;
            this.prefix = !!conf.prefix;
            this.postfix = !!conf.postfix;
            this.binop = conf.binop === 0 ? 0 : conf.binop || null;
            this.updateContext = null;
          };

          function KeywordTokenType(keyword, options) {
            if (options === void 0) {
              options = {};
            }

            return new TokenType(
              keyword,
              Object.assign({}, options, {
                keyword: keyword,
              })
            );
          }

          function BinopTokenType(name, binop) {
            return new TokenType(name, {
              beforeExpr: beforeExpr,
              binop: binop,
            });
          }

          var types = {
            num: new TokenType("num", {
              startsExpr: startsExpr,
            }),
            bigint: new TokenType("bigint", {
              startsExpr: startsExpr,
            }),
            regexp: new TokenType("regexp", {
              startsExpr: startsExpr,
            }),
            string: new TokenType("string", {
              startsExpr: startsExpr,
            }),
            name: new TokenType("name", {
              startsExpr: startsExpr,
            }),
            eof: new TokenType("eof"),
            bracketL: new TokenType("[", {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            bracketR: new TokenType("]"),
            braceL: new TokenType("{", {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            braceBarL: new TokenType("{|", {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            braceR: new TokenType("}"),
            braceBarR: new TokenType("|}"),
            parenL: new TokenType("(", {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            parenR: new TokenType(")"),
            comma: new TokenType(",", {
              beforeExpr: beforeExpr,
            }),
            semi: new TokenType(";", {
              beforeExpr: beforeExpr,
            }),
            colon: new TokenType(":", {
              beforeExpr: beforeExpr,
            }),
            doubleColon: new TokenType("::", {
              beforeExpr: beforeExpr,
            }),
            dot: new TokenType("."),
            question: new TokenType("?", {
              beforeExpr: beforeExpr,
            }),
            questionDot: new TokenType("?."),
            arrow: new TokenType("=>", {
              beforeExpr: beforeExpr,
            }),
            template: new TokenType("template"),
            ellipsis: new TokenType("...", {
              beforeExpr: beforeExpr,
            }),
            backQuote: new TokenType("`", {
              startsExpr: startsExpr,
            }),
            dollarBraceL: new TokenType("${", {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            at: new TokenType("@"),
            hash: new TokenType("#"),
            interpreterDirective: new TokenType("#!..."),
            eq: new TokenType("=", {
              beforeExpr: beforeExpr,
              isAssign: isAssign,
            }),
            assign: new TokenType("_=", {
              beforeExpr: beforeExpr,
              isAssign: isAssign,
            }),
            incDec: new TokenType("++/--", {
              prefix: prefix,
              postfix: postfix,
              startsExpr: startsExpr,
            }),
            bang: new TokenType("!", {
              beforeExpr: beforeExpr,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
            tilde: new TokenType("~", {
              beforeExpr: beforeExpr,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
            pipeline: new BinopTokenType("|>", 0),
            nullishCoalescing: new BinopTokenType("??", 1),
            logicalOR: new BinopTokenType("||", 1),
            logicalAND: new BinopTokenType("&&", 2),
            bitwiseOR: new BinopTokenType("|", 3),
            bitwiseXOR: new BinopTokenType("^", 4),
            bitwiseAND: new BinopTokenType("&", 5),
            equality: new BinopTokenType("==/!=", 6),
            relational: new BinopTokenType("</>", 7),
            bitShift: new BinopTokenType("<</>>", 8),
            plusMin: new TokenType("+/-", {
              beforeExpr: beforeExpr,
              binop: 9,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
            modulo: new BinopTokenType("%", 10),
            star: new BinopTokenType("*", 10),
            slash: new BinopTokenType("/", 10),
            exponent: new TokenType("**", {
              beforeExpr: beforeExpr,
              binop: 11,
              rightAssociative: true,
            }),
          };
          var keywords = {
            break: new KeywordTokenType("break"),
            case: new KeywordTokenType("case", {
              beforeExpr: beforeExpr,
            }),
            catch: new KeywordTokenType("catch"),
            continue: new KeywordTokenType("continue"),
            debugger: new KeywordTokenType("debugger"),
            default: new KeywordTokenType("default", {
              beforeExpr: beforeExpr,
            }),
            do: new KeywordTokenType("do", {
              isLoop: isLoop,
              beforeExpr: beforeExpr,
            }),
            else: new KeywordTokenType("else", {
              beforeExpr: beforeExpr,
            }),
            finally: new KeywordTokenType("finally"),
            for: new KeywordTokenType("for", {
              isLoop: isLoop,
            }),
            function: new KeywordTokenType("function", {
              startsExpr: startsExpr,
            }),
            if: new KeywordTokenType("if"),
            return: new KeywordTokenType("return", {
              beforeExpr: beforeExpr,
            }),
            switch: new KeywordTokenType("switch"),
            throw: new KeywordTokenType("throw", {
              beforeExpr: beforeExpr,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
            try: new KeywordTokenType("try"),
            var: new KeywordTokenType("var"),
            let: new KeywordTokenType("let"),
            const: new KeywordTokenType("const"),
            while: new KeywordTokenType("while", {
              isLoop: isLoop,
            }),
            with: new KeywordTokenType("with"),
            new: new KeywordTokenType("new", {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            this: new KeywordTokenType("this", {
              startsExpr: startsExpr,
            }),
            super: new KeywordTokenType("super", {
              startsExpr: startsExpr,
            }),
            class: new KeywordTokenType("class"),
            extends: new KeywordTokenType("extends", {
              beforeExpr: beforeExpr,
            }),
            export: new KeywordTokenType("export"),
            import: new KeywordTokenType("import", {
              startsExpr: startsExpr,
            }),
            yield: new KeywordTokenType("yield", {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            null: new KeywordTokenType("null", {
              startsExpr: startsExpr,
            }),
            true: new KeywordTokenType("true", {
              startsExpr: startsExpr,
            }),
            false: new KeywordTokenType("false", {
              startsExpr: startsExpr,
            }),
            in: new KeywordTokenType("in", {
              beforeExpr: beforeExpr,
              binop: 7,
            }),
            instanceof: new KeywordTokenType("instanceof", {
              beforeExpr: beforeExpr,
              binop: 7,
            }),
            typeof: new KeywordTokenType("typeof", {
              beforeExpr: beforeExpr,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
            void: new KeywordTokenType("void", {
              beforeExpr: beforeExpr,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
            delete: new KeywordTokenType("delete", {
              beforeExpr: beforeExpr,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
          };
          Object.keys(keywords).forEach(function(name) {
            types["_" + name] = keywords[name];
          });

          function isSimpleProperty(node) {
            return (
              node != null &&
              node.type === "Property" &&
              node.kind === "init" &&
              node.method === false
            );
          }

          var estree = function estree(superClass) {
            return (function(_superClass) {
              _inheritsLoose(_class, _superClass);

              function _class() {
                return _superClass.apply(this, arguments) || this;
              }

              var _proto = _class.prototype;

              _proto.estreeParseRegExpLiteral = function estreeParseRegExpLiteral(
                _ref
              ) {
                var pattern = _ref.pattern,
                  flags = _ref.flags;
                var regex = null;

                try {
                  regex = new RegExp(pattern, flags);
                } catch (e) {}

                var node = this.estreeParseLiteral(regex);
                node.regex = {
                  pattern: pattern,
                  flags: flags,
                };
                return node;
              };

              _proto.estreeParseLiteral = function estreeParseLiteral(value) {
                return this.parseLiteral(value, "Literal");
              };

              _proto.directiveToStmt = function directiveToStmt(directive) {
                var directiveLiteral = directive.value;
                var stmt = this.startNodeAt(
                  directive.start,
                  directive.loc.start
                );
                var expression = this.startNodeAt(
                  directiveLiteral.start,
                  directiveLiteral.loc.start
                );
                expression.value = directiveLiteral.value;
                expression.raw = directiveLiteral.extra.raw;
                stmt.expression = this.finishNodeAt(
                  expression,
                  "Literal",
                  directiveLiteral.end,
                  directiveLiteral.loc.end
                );
                stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
                return this.finishNodeAt(
                  stmt,
                  "ExpressionStatement",
                  directive.end,
                  directive.loc.end
                );
              };

              _proto.initFunction = function initFunction(node, isAsync) {
                _superClass.prototype.initFunction.call(this, node, isAsync);

                node.expression = false;
              };

              _proto.checkDeclaration = function checkDeclaration(node) {
                if (isSimpleProperty(node)) {
                  this.checkDeclaration(node.value);
                } else {
                  _superClass.prototype.checkDeclaration.call(this, node);
                }
              };

              _proto.checkGetterSetterParams = function checkGetterSetterParams(
                method
              ) {
                var prop = method;
                var paramCount = prop.kind === "get" ? 0 : 1;
                var start = prop.start;

                if (prop.value.params.length !== paramCount) {
                  if (prop.kind === "get") {
                    this.raise(
                      start,
                      "getter must not have any formal parameters"
                    );
                  } else {
                    this.raise(
                      start,
                      "setter must have exactly one formal parameter"
                    );
                  }
                }

                if (
                  prop.kind === "set" &&
                  prop.value.params[0].type === "RestElement"
                ) {
                  this.raise(
                    start,
                    "setter function argument must not be a rest parameter"
                  );
                }
              };

              _proto.checkLVal = function checkLVal(
                expr,
                isBinding,
                checkClashes,
                contextDescription
              ) {
                var _this = this;

                switch (expr.type) {
                  case "ObjectPattern":
                    expr.properties.forEach(function(prop) {
                      _this.checkLVal(
                        prop.type === "Property" ? prop.value : prop,
                        isBinding,
                        checkClashes,
                        "object destructuring pattern"
                      );
                    });
                    break;

                  default:
                    _superClass.prototype.checkLVal.call(
                      this,
                      expr,
                      isBinding,
                      checkClashes,
                      contextDescription
                    );
                }
              };

              _proto.checkPropClash = function checkPropClash(prop, propHash) {
                if (prop.computed || !isSimpleProperty(prop)) return;
                var key = prop.key;
                var name =
                  key.type === "Identifier" ? key.name : String(key.value);

                if (name === "__proto__") {
                  if (propHash.proto) {
                    this.raise(key.start, "Redefinition of __proto__ property");
                  }

                  propHash.proto = true;
                }
              };

              _proto.isStrictBody = function isStrictBody(node) {
                var isBlockStatement = node.body.type === "BlockStatement";

                if (isBlockStatement && node.body.body.length > 0) {
                  for (
                    var _i2 = 0, _node$body$body2 = node.body.body;
                    _i2 < _node$body$body2.length;
                    _i2++
                  ) {
                    var directive = _node$body$body2[_i2];

                    if (
                      directive.type === "ExpressionStatement" &&
                      directive.expression.type === "Literal"
                    ) {
                      if (directive.expression.value === "use strict")
                        return true;
                    } else {
                      break;
                    }
                  }
                }

                return false;
              };

              _proto.isValidDirective = function isValidDirective(stmt) {
                return (
                  stmt.type === "ExpressionStatement" &&
                  stmt.expression.type === "Literal" &&
                  typeof stmt.expression.value === "string" &&
                  (!stmt.expression.extra ||
                    !stmt.expression.extra.parenthesized)
                );
              };

              _proto.stmtToDirective = function stmtToDirective(stmt) {
                var directive = _superClass.prototype.stmtToDirective.call(
                  this,
                  stmt
                );

                var value = stmt.expression.value;
                directive.value.value = value;
                return directive;
              };

              _proto.parseBlockBody = function parseBlockBody(
                node,
                allowDirectives,
                topLevel,
                end
              ) {
                var _this2 = this;

                _superClass.prototype.parseBlockBody.call(
                  this,
                  node,
                  allowDirectives,
                  topLevel,
                  end
                );

                var directiveStatements = node.directives.map(function(d) {
                  return _this2.directiveToStmt(d);
                });
                node.body = directiveStatements.concat(node.body);
                delete node.directives;
              };

              _proto.pushClassMethod = function pushClassMethod(
                classBody,
                method,
                isGenerator,
                isAsync,
                isConstructor
              ) {
                this.parseMethod(
                  method,
                  isGenerator,
                  isAsync,
                  isConstructor,
                  "MethodDefinition"
                );

                if (method.typeParameters) {
                  method.value.typeParameters = method.typeParameters;
                  delete method.typeParameters;
                }

                classBody.body.push(method);
              };

              _proto.parseExprAtom = function parseExprAtom(
                refShorthandDefaultPos
              ) {
                switch (this.state.type) {
                  case types.regexp:
                    return this.estreeParseRegExpLiteral(this.state.value);

                  case types.num:
                  case types.string:
                    return this.estreeParseLiteral(this.state.value);

                  case types._null:
                    return this.estreeParseLiteral(null);

                  case types._true:
                    return this.estreeParseLiteral(true);

                  case types._false:
                    return this.estreeParseLiteral(false);

                  default:
                    return _superClass.prototype.parseExprAtom.call(
                      this,
                      refShorthandDefaultPos
                    );
                }
              };

              _proto.parseLiteral = function parseLiteral(
                value,
                type,
                startPos,
                startLoc
              ) {
                var node = _superClass.prototype.parseLiteral.call(
                  this,
                  value,
                  type,
                  startPos,
                  startLoc
                );

                node.raw = node.extra.raw;
                delete node.extra;
                return node;
              };

              _proto.parseFunctionBody = function parseFunctionBody(
                node,
                allowExpression
              ) {
                _superClass.prototype.parseFunctionBody.call(
                  this,
                  node,
                  allowExpression
                );

                node.expression = node.body.type !== "BlockStatement";
              };

              _proto.parseMethod = function parseMethod(
                node,
                isGenerator,
                isAsync,
                isConstructor,
                type
              ) {
                var funcNode = this.startNode();
                funcNode.kind = node.kind;
                funcNode = _superClass.prototype.parseMethod.call(
                  this,
                  funcNode,
                  isGenerator,
                  isAsync,
                  isConstructor,
                  "FunctionExpression"
                );
                delete funcNode.kind;
                node.value = funcNode;
                return this.finishNode(node, type);
              };

              _proto.parseObjectMethod = function parseObjectMethod(
                prop,
                isGenerator,
                isAsync,
                isPattern,
                containsEsc
              ) {
                var node = _superClass.prototype.parseObjectMethod.call(
                  this,
                  prop,
                  isGenerator,
                  isAsync,
                  isPattern,
                  containsEsc
                );

                if (node) {
                  node.type = "Property";
                  if (node.kind === "method") node.kind = "init";
                  node.shorthand = false;
                }

                return node;
              };

              _proto.parseObjectProperty = function parseObjectProperty(
                prop,
                startPos,
                startLoc,
                isPattern,
                refShorthandDefaultPos
              ) {
                var node = _superClass.prototype.parseObjectProperty.call(
                  this,
                  prop,
                  startPos,
                  startLoc,
                  isPattern,
                  refShorthandDefaultPos
                );

                if (node) {
                  node.kind = "init";
                  node.type = "Property";
                }

                return node;
              };

              _proto.toAssignable = function toAssignable(
                node,
                isBinding,
                contextDescription
              ) {
                if (isSimpleProperty(node)) {
                  this.toAssignable(node.value, isBinding, contextDescription);
                  return node;
                }

                return _superClass.prototype.toAssignable.call(
                  this,
                  node,
                  isBinding,
                  contextDescription
                );
              };

              _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(
                prop,
                isBinding,
                isLast
              ) {
                if (prop.kind === "get" || prop.kind === "set") {
                  this.raise(
                    prop.key.start,
                    "Object pattern can't contain getter or setter"
                  );
                } else if (prop.method) {
                  this.raise(
                    prop.key.start,
                    "Object pattern can't contain methods"
                  );
                } else {
                  _superClass.prototype.toAssignableObjectExpressionProp.call(
                    this,
                    prop,
                    isBinding,
                    isLast
                  );
                }
              };

              return _class;
            })(superClass);
          };

          function makePredicate(words) {
            var wordsArr = words.split(" ");
            return function(str) {
              return wordsArr.indexOf(str) >= 0;
            };
          }

          var reservedWords = {
            "6": makePredicate("enum await"),
            strict: makePredicate(
              "implements interface let package private protected public static yield"
            ),
            strictBind: makePredicate("eval arguments"),
          };
          var isKeyword = makePredicate(
            "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super"
          );
          var nonASCIIidentifierStartChars =
            "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
          var nonASCIIidentifierChars =
            "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
          var nonASCIIidentifierStart = new RegExp(
            "[" + nonASCIIidentifierStartChars + "]"
          );
          var nonASCIIidentifier = new RegExp(
            "[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]"
          );
          nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
          var astralIdentifierStartCodes = [
            0,
            11,
            2,
            25,
            2,
            18,
            2,
            1,
            2,
            14,
            3,
            13,
            35,
            122,
            70,
            52,
            268,
            28,
            4,
            48,
            48,
            31,
            14,
            29,
            6,
            37,
            11,
            29,
            3,
            35,
            5,
            7,
            2,
            4,
            43,
            157,
            19,
            35,
            5,
            35,
            5,
            39,
            9,
            51,
            157,
            310,
            10,
            21,
            11,
            7,
            153,
            5,
            3,
            0,
            2,
            43,
            2,
            1,
            4,
            0,
            3,
            22,
            11,
            22,
            10,
            30,
            66,
            18,
            2,
            1,
            11,
            21,
            11,
            25,
            71,
            55,
            7,
            1,
            65,
            0,
            16,
            3,
            2,
            2,
            2,
            28,
            43,
            28,
            4,
            28,
            36,
            7,
            2,
            27,
            28,
            53,
            11,
            21,
            11,
            18,
            14,
            17,
            111,
            72,
            56,
            50,
            14,
            50,
            14,
            35,
            477,
            28,
            11,
            0,
            9,
            21,
            190,
            52,
            76,
            44,
            33,
            24,
            27,
            35,
            30,
            0,
            12,
            34,
            4,
            0,
            13,
            47,
            15,
            3,
            22,
            0,
            2,
            0,
            36,
            17,
            2,
            24,
            85,
            6,
            2,
            0,
            2,
            3,
            2,
            14,
            2,
            9,
            8,
            46,
            39,
            7,
            3,
            1,
            3,
            21,
            2,
            6,
            2,
            1,
            2,
            4,
            4,
            0,
            19,
            0,
            13,
            4,
            159,
            52,
            19,
            3,
            54,
            47,
            21,
            1,
            2,
            0,
            185,
            46,
            42,
            3,
            37,
            47,
            21,
            0,
            60,
            42,
            86,
            26,
            230,
            43,
            117,
            63,
            32,
            0,
            257,
            0,
            11,
            39,
            8,
            0,
            22,
            0,
            12,
            39,
            3,
            3,
            20,
            0,
            35,
            56,
            264,
            8,
            2,
            36,
            18,
            0,
            50,
            29,
            113,
            6,
            2,
            1,
            2,
            37,
            22,
            0,
            26,
            5,
            2,
            1,
            2,
            31,
            15,
            0,
            328,
            18,
            270,
            921,
            103,
            110,
            18,
            195,
            2749,
            1070,
            4050,
            582,
            8634,
            568,
            8,
            30,
            114,
            29,
            19,
            47,
            17,
            3,
            32,
            20,
            6,
            18,
            689,
            63,
            129,
            68,
            12,
            0,
            67,
            12,
            65,
            1,
            31,
            6129,
            15,
            754,
            9486,
            286,
            82,
            395,
            2309,
            106,
            6,
            12,
            4,
            8,
            8,
            9,
            5991,
            84,
            2,
            70,
            2,
            1,
            3,
            0,
            3,
            1,
            3,
            3,
            2,
            11,
            2,
            0,
            2,
            6,
            2,
            64,
            2,
            3,
            3,
            7,
            2,
            6,
            2,
            27,
            2,
            3,
            2,
            4,
            2,
            0,
            4,
            6,
            2,
            339,
            3,
            24,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            7,
            4149,
            196,
            60,
            67,
            1213,
            3,
            2,
            26,
            2,
            1,
            2,
            0,
            3,
            0,
            2,
            9,
            2,
            3,
            2,
            0,
            2,
            0,
            7,
            0,
            5,
            0,
            2,
            0,
            2,
            0,
            2,
            2,
            2,
            1,
            2,
            0,
            3,
            0,
            2,
            0,
            2,
            0,
            2,
            0,
            2,
            0,
            2,
            1,
            2,
            0,
            3,
            3,
            2,
            6,
            2,
            3,
            2,
            3,
            2,
            0,
            2,
            9,
            2,
            16,
            6,
            2,
            2,
            4,
            2,
            16,
            4421,
            42710,
            42,
            4148,
            12,
            221,
            3,
            5761,
            15,
            7472,
            3104,
            541,
          ];
          var astralIdentifierCodes = [
            509,
            0,
            227,
            0,
            150,
            4,
            294,
            9,
            1368,
            2,
            2,
            1,
            6,
            3,
            41,
            2,
            5,
            0,
            166,
            1,
            574,
            3,
            9,
            9,
            525,
            10,
            176,
            2,
            54,
            14,
            32,
            9,
            16,
            3,
            46,
            10,
            54,
            9,
            7,
            2,
            37,
            13,
            2,
            9,
            6,
            1,
            45,
            0,
            13,
            2,
            49,
            13,
            9,
            3,
            4,
            9,
            83,
            11,
            7,
            0,
            161,
            11,
            6,
            9,
            7,
            3,
            56,
            1,
            2,
            6,
            3,
            1,
            3,
            2,
            10,
            0,
            11,
            1,
            3,
            6,
            4,
            4,
            193,
            17,
            10,
            9,
            5,
            0,
            82,
            19,
            13,
            9,
            214,
            6,
            3,
            8,
            28,
            1,
            83,
            16,
            16,
            9,
            82,
            12,
            9,
            9,
            84,
            14,
            5,
            9,
            243,
            14,
            166,
            9,
            280,
            9,
            41,
            6,
            2,
            3,
            9,
            0,
            10,
            10,
            47,
            15,
            406,
            7,
            2,
            7,
            17,
            9,
            57,
            21,
            2,
            13,
            123,
            5,
            4,
            0,
            2,
            1,
            2,
            6,
            2,
            0,
            9,
            9,
            49,
            4,
            2,
            1,
            2,
            4,
            9,
            9,
            330,
            3,
            19306,
            9,
            135,
            4,
            60,
            6,
            26,
            9,
            1016,
            45,
            17,
            3,
            19723,
            1,
            5319,
            4,
            4,
            5,
            9,
            7,
            3,
            6,
            31,
            3,
            149,
            2,
            1418,
            49,
            513,
            54,
            5,
            49,
            9,
            0,
            15,
            0,
            23,
            4,
            2,
            14,
            1361,
            6,
            2,
            16,
            3,
            6,
            2,
            1,
            2,
            4,
            2214,
            6,
            110,
            6,
            6,
            9,
            792487,
            239,
          ];

          function isInAstralSet(code, set) {
            var pos = 0x10000;

            for (var i = 0; i < set.length; i += 2) {
              pos += set[i];
              if (pos > code) return false;
              pos += set[i + 1];
              if (pos >= code) return true;
            }

            return false;
          }

          function isIdentifierStart(code) {
            if (code < 65) return code === 36;
            if (code <= 90) return true;
            if (code < 97) return code === 95;
            if (code <= 122) return true;

            if (code <= 0xffff) {
              return (
                code >= 0xaa &&
                nonASCIIidentifierStart.test(String.fromCharCode(code))
              );
            }

            return isInAstralSet(code, astralIdentifierStartCodes);
          }

          function isIteratorStart(current, next) {
            return current === 64 && next === 64;
          }

          function isIdentifierChar(code) {
            if (code < 48) return code === 36;
            if (code < 58) return true;
            if (code < 65) return false;
            if (code <= 90) return true;
            if (code < 97) return code === 95;
            if (code <= 122) return true;

            if (code <= 0xffff) {
              return (
                code >= 0xaa &&
                nonASCIIidentifier.test(String.fromCharCode(code))
              );
            }

            return (
              isInAstralSet(code, astralIdentifierStartCodes) ||
              isInAstralSet(code, astralIdentifierCodes)
            );
          }

          var primitiveTypes = [
            "any",
            "bool",
            "boolean",
            "empty",
            "false",
            "mixed",
            "null",
            "number",
            "static",
            "string",
            "true",
            "typeof",
            "void",
          ];

          function isEsModuleType(bodyElement) {
            return (
              bodyElement.type === "DeclareExportAllDeclaration" ||
              (bodyElement.type === "DeclareExportDeclaration" &&
                (!bodyElement.declaration ||
                  (bodyElement.declaration.type !== "TypeAlias" &&
                    bodyElement.declaration.type !== "InterfaceDeclaration")))
            );
          }

          function hasTypeImportKind(node) {
            return node.importKind === "type" || node.importKind === "typeof";
          }

          function isMaybeDefaultImport(state) {
            return (
              (state.type === types.name || !!state.type.keyword) &&
              state.value !== "from"
            );
          }

          var exportSuggestions = {
            const: "declare export var",
            let: "declare export var",
            type: "export type",
            interface: "export interface",
          };

          function partition(list, test) {
            var list1 = [];
            var list2 = [];

            for (var i = 0; i < list.length; i++) {
              (test(list[i], i, list) ? list1 : list2).push(list[i]);
            }

            return [list1, list2];
          }

          var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;

          var flow = function flow(superClass) {
            return (function(_superClass) {
              _inheritsLoose(_class, _superClass);

              function _class(options, input) {
                var _this;

                _this = _superClass.call(this, options, input) || this;
                _this.flowPragma = undefined;
                return _this;
              }

              var _proto = _class.prototype;

              _proto.shouldParseTypes = function shouldParseTypes() {
                return (
                  this.getPluginOption("flow", "all") ||
                  this.flowPragma === "flow"
                );
              };

              _proto.addComment = function addComment(comment) {
                if (this.flowPragma === undefined) {
                  var matches = FLOW_PRAGMA_REGEX.exec(comment.value);

                  if (!matches) {
                    this.flowPragma = null;
                  } else if (matches[1] === "flow") {
                    this.flowPragma = "flow";
                  } else if (matches[1] === "noflow") {
                    this.flowPragma = "noflow";
                  } else {
                    throw new Error("Unexpected flow pragma");
                  }
                }

                return _superClass.prototype.addComment.call(this, comment);
              };

              _proto.flowParseTypeInitialiser = function flowParseTypeInitialiser(
                tok
              ) {
                var oldInType = this.state.inType;
                this.state.inType = true;
                this.expect(tok || types.colon);
                var type = this.flowParseType();
                this.state.inType = oldInType;
                return type;
              };

              _proto.flowParsePredicate = function flowParsePredicate() {
                var node = this.startNode();
                var moduloLoc = this.state.startLoc;
                var moduloPos = this.state.start;
                this.expect(types.modulo);
                var checksLoc = this.state.startLoc;
                this.expectContextual("checks");

                if (
                  moduloLoc.line !== checksLoc.line ||
                  moduloLoc.column !== checksLoc.column - 1
                ) {
                  this.raise(
                    moduloPos,
                    "Spaces between % and checks are not allowed here."
                  );
                }

                if (this.eat(types.parenL)) {
                  node.value = this.parseExpression();
                  this.expect(types.parenR);
                  return this.finishNode(node, "DeclaredPredicate");
                } else {
                  return this.finishNode(node, "InferredPredicate");
                }
              };

              _proto.flowParseTypeAndPredicateInitialiser = function flowParseTypeAndPredicateInitialiser() {
                var oldInType = this.state.inType;
                this.state.inType = true;
                this.expect(types.colon);
                var type = null;
                var predicate = null;

                if (this.match(types.modulo)) {
                  this.state.inType = oldInType;
                  predicate = this.flowParsePredicate();
                } else {
                  type = this.flowParseType();
                  this.state.inType = oldInType;

                  if (this.match(types.modulo)) {
                    predicate = this.flowParsePredicate();
                  }
                }

                return [type, predicate];
              };

              _proto.flowParseDeclareClass = function flowParseDeclareClass(
                node
              ) {
                this.next();
                this.flowParseInterfaceish(node, true);
                return this.finishNode(node, "DeclareClass");
              };

              _proto.flowParseDeclareFunction = function flowParseDeclareFunction(
                node
              ) {
                this.next();
                var id = (node.id = this.parseIdentifier());
                var typeNode = this.startNode();
                var typeContainer = this.startNode();

                if (this.isRelational("<")) {
                  typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
                } else {
                  typeNode.typeParameters = null;
                }

                this.expect(types.parenL);
                var tmp = this.flowParseFunctionTypeParams();
                typeNode.params = tmp.params;
                typeNode.rest = tmp.rest;
                this.expect(types.parenR);

                var _this$flowParseTypeAn = this.flowParseTypeAndPredicateInitialiser();

                typeNode.returnType = _this$flowParseTypeAn[0];
                node.predicate = _this$flowParseTypeAn[1];
                typeContainer.typeAnnotation = this.finishNode(
                  typeNode,
                  "FunctionTypeAnnotation"
                );
                id.typeAnnotation = this.finishNode(
                  typeContainer,
                  "TypeAnnotation"
                );
                this.finishNode(id, id.type);
                this.semicolon();
                return this.finishNode(node, "DeclareFunction");
              };

              _proto.flowParseDeclare = function flowParseDeclare(
                node,
                insideModule
              ) {
                if (this.match(types._class)) {
                  return this.flowParseDeclareClass(node);
                } else if (this.match(types._function)) {
                  return this.flowParseDeclareFunction(node);
                } else if (this.match(types._var)) {
                  return this.flowParseDeclareVariable(node);
                } else if (this.isContextual("module")) {
                  if (this.lookahead().type === types.dot) {
                    return this.flowParseDeclareModuleExports(node);
                  } else {
                    if (insideModule) {
                      this.unexpected(
                        null,
                        "`declare module` cannot be used inside another `declare module`"
                      );
                    }

                    return this.flowParseDeclareModule(node);
                  }
                } else if (this.isContextual("type")) {
                  return this.flowParseDeclareTypeAlias(node);
                } else if (this.isContextual("opaque")) {
                  return this.flowParseDeclareOpaqueType(node);
                } else if (this.isContextual("interface")) {
                  return this.flowParseDeclareInterface(node);
                } else if (this.match(types._export)) {
                  return this.flowParseDeclareExportDeclaration(
                    node,
                    insideModule
                  );
                } else {
                  throw this.unexpected();
                }
              };

              _proto.flowParseDeclareVariable = function flowParseDeclareVariable(
                node
              ) {
                this.next();
                node.id = this.flowParseTypeAnnotatableIdentifier(true);
                this.semicolon();
                return this.finishNode(node, "DeclareVariable");
              };

              _proto.flowParseDeclareModule = function flowParseDeclareModule(
                node
              ) {
                var _this2 = this;

                this.next();

                if (this.match(types.string)) {
                  node.id = this.parseExprAtom();
                } else {
                  node.id = this.parseIdentifier();
                }

                var bodyNode = (node.body = this.startNode());
                var body = (bodyNode.body = []);
                this.expect(types.braceL);

                while (!this.match(types.braceR)) {
                  var _bodyNode = this.startNode();

                  if (this.match(types._import)) {
                    var lookahead = this.lookahead();

                    if (
                      lookahead.value !== "type" &&
                      lookahead.value !== "typeof"
                    ) {
                      this.unexpected(
                        null,
                        "Imports within a `declare module` body must always be `import type` or `import typeof`"
                      );
                    }

                    this.next();
                    this.parseImport(_bodyNode);
                  } else {
                    this.expectContextual(
                      "declare",
                      "Only declares and type imports are allowed inside declare module"
                    );
                    _bodyNode = this.flowParseDeclare(_bodyNode, true);
                  }

                  body.push(_bodyNode);
                }

                this.expect(types.braceR);
                this.finishNode(bodyNode, "BlockStatement");
                var kind = null;
                var hasModuleExport = false;
                var errorMessage =
                  "Found both `declare module.exports` and `declare export` in the same module. " +
                  "Modules can only have 1 since they are either an ES module or they are a CommonJS module";
                body.forEach(function(bodyElement) {
                  if (isEsModuleType(bodyElement)) {
                    if (kind === "CommonJS") {
                      _this2.unexpected(bodyElement.start, errorMessage);
                    }

                    kind = "ES";
                  } else if (bodyElement.type === "DeclareModuleExports") {
                    if (hasModuleExport) {
                      _this2.unexpected(
                        bodyElement.start,
                        "Duplicate `declare module.exports` statement"
                      );
                    }

                    if (kind === "ES")
                      _this2.unexpected(bodyElement.start, errorMessage);
                    kind = "CommonJS";
                    hasModuleExport = true;
                  }
                });
                node.kind = kind || "CommonJS";
                return this.finishNode(node, "DeclareModule");
              };

              _proto.flowParseDeclareExportDeclaration = function flowParseDeclareExportDeclaration(
                node,
                insideModule
              ) {
                this.expect(types._export);

                if (this.eat(types._default)) {
                  if (this.match(types._function) || this.match(types._class)) {
                    node.declaration = this.flowParseDeclare(this.startNode());
                  } else {
                    node.declaration = this.flowParseType();
                    this.semicolon();
                  }

                  node.default = true;
                  return this.finishNode(node, "DeclareExportDeclaration");
                } else {
                  if (
                    this.match(types._const) ||
                    this.match(types._let) ||
                    ((this.isContextual("type") ||
                      this.isContextual("interface")) &&
                      !insideModule)
                  ) {
                    var label = this.state.value;
                    var suggestion = exportSuggestions[label];
                    this.unexpected(
                      this.state.start,
                      "`declare export " +
                        label +
                        "` is not supported. Use `" +
                        suggestion +
                        "` instead"
                    );
                  }

                  if (
                    this.match(types._var) ||
                    this.match(types._function) ||
                    this.match(types._class) ||
                    this.isContextual("opaque")
                  ) {
                    node.declaration = this.flowParseDeclare(this.startNode());
                    node.default = false;
                    return this.finishNode(node, "DeclareExportDeclaration");
                  } else if (
                    this.match(types.star) ||
                    this.match(types.braceL) ||
                    this.isContextual("interface") ||
                    this.isContextual("type") ||
                    this.isContextual("opaque")
                  ) {
                    node = this.parseExport(node);

                    if (node.type === "ExportNamedDeclaration") {
                      node.type = "ExportDeclaration";
                      node.default = false;
                      delete node.exportKind;
                    }

                    node.type = "Declare" + node.type;
                    return node;
                  }
                }

                throw this.unexpected();
              };

              _proto.flowParseDeclareModuleExports = function flowParseDeclareModuleExports(
                node
              ) {
                this.expectContextual("module");
                this.expect(types.dot);
                this.expectContextual("exports");
                node.typeAnnotation = this.flowParseTypeAnnotation();
                this.semicolon();
                return this.finishNode(node, "DeclareModuleExports");
              };

              _proto.flowParseDeclareTypeAlias = function flowParseDeclareTypeAlias(
                node
              ) {
                this.next();
                this.flowParseTypeAlias(node);
                return this.finishNode(node, "DeclareTypeAlias");
              };

              _proto.flowParseDeclareOpaqueType = function flowParseDeclareOpaqueType(
                node
              ) {
                this.next();
                this.flowParseOpaqueType(node, true);
                return this.finishNode(node, "DeclareOpaqueType");
              };

              _proto.flowParseDeclareInterface = function flowParseDeclareInterface(
                node
              ) {
                this.next();
                this.flowParseInterfaceish(node);
                return this.finishNode(node, "DeclareInterface");
              };

              _proto.flowParseInterfaceish = function flowParseInterfaceish(
                node,
                isClass
              ) {
                if (isClass === void 0) {
                  isClass = false;
                }

                node.id = this.flowParseRestrictedIdentifier(!isClass);

                if (this.isRelational("<")) {
                  node.typeParameters = this.flowParseTypeParameterDeclaration();
                } else {
                  node.typeParameters = null;
                }

                node.extends = [];
                node.implements = [];
                node.mixins = [];

                if (this.eat(types._extends)) {
                  do {
                    node.extends.push(this.flowParseInterfaceExtends());
                  } while (!isClass && this.eat(types.comma));
                }

                if (this.isContextual("mixins")) {
                  this.next();

                  do {
                    node.mixins.push(this.flowParseInterfaceExtends());
                  } while (this.eat(types.comma));
                }

                if (this.isContextual("implements")) {
                  this.next();

                  do {
                    node.implements.push(this.flowParseInterfaceExtends());
                  } while (this.eat(types.comma));
                }

                node.body = this.flowParseObjectType(
                  isClass,
                  false,
                  false,
                  isClass
                );
              };

              _proto.flowParseInterfaceExtends = function flowParseInterfaceExtends() {
                var node = this.startNode();
                node.id = this.flowParseQualifiedTypeIdentifier();

                if (this.isRelational("<")) {
                  node.typeParameters = this.flowParseTypeParameterInstantiation();
                } else {
                  node.typeParameters = null;
                }

                return this.finishNode(node, "InterfaceExtends");
              };

              _proto.flowParseInterface = function flowParseInterface(node) {
                this.flowParseInterfaceish(node);
                return this.finishNode(node, "InterfaceDeclaration");
              };

              _proto.checkReservedType = function checkReservedType(
                word,
                startLoc
              ) {
                if (primitiveTypes.indexOf(word) > -1) {
                  this.raise(
                    startLoc,
                    "Cannot overwrite primitive type " + word
                  );
                }
              };

              _proto.flowParseRestrictedIdentifier = function flowParseRestrictedIdentifier(
                liberal
              ) {
                this.checkReservedType(this.state.value, this.state.start);
                return this.parseIdentifier(liberal);
              };

              _proto.flowParseTypeAlias = function flowParseTypeAlias(node) {
                node.id = this.flowParseRestrictedIdentifier();

                if (this.isRelational("<")) {
                  node.typeParameters = this.flowParseTypeParameterDeclaration();
                } else {
                  node.typeParameters = null;
                }

                node.right = this.flowParseTypeInitialiser(types.eq);
                this.semicolon();
                return this.finishNode(node, "TypeAlias");
              };

              _proto.flowParseOpaqueType = function flowParseOpaqueType(
                node,
                declare
              ) {
                this.expectContextual("type");
                node.id = this.flowParseRestrictedIdentifier(true);

                if (this.isRelational("<")) {
                  node.typeParameters = this.flowParseTypeParameterDeclaration();
                } else {
                  node.typeParameters = null;
                }

                node.supertype = null;

                if (this.match(types.colon)) {
                  node.supertype = this.flowParseTypeInitialiser(types.colon);
                }

                node.impltype = null;

                if (!declare) {
                  node.impltype = this.flowParseTypeInitialiser(types.eq);
                }

                this.semicolon();
                return this.finishNode(node, "OpaqueType");
              };

              _proto.flowParseTypeParameter = function flowParseTypeParameter(
                allowDefault,
                requireDefault
              ) {
                if (allowDefault === void 0) {
                  allowDefault = true;
                }

                if (requireDefault === void 0) {
                  requireDefault = false;
                }

                if (!allowDefault && requireDefault) {
                  throw new Error(
                    "Cannot disallow a default value (`allowDefault`) while also requiring it (`requireDefault`)."
                  );
                }

                var nodeStart = this.state.start;
                var node = this.startNode();
                var variance = this.flowParseVariance();
                var ident = this.flowParseTypeAnnotatableIdentifier();
                node.name = ident.name;
                node.variance = variance;
                node.bound = ident.typeAnnotation;

                if (this.match(types.eq)) {
                  if (allowDefault) {
                    this.eat(types.eq);
                    node.default = this.flowParseType();
                  } else {
                    this.unexpected();
                  }
                } else {
                  if (requireDefault) {
                    this.unexpected(
                      nodeStart,
                      "Type parameter declaration needs a default, since a preceding type parameter declaration has a default."
                    );
                  }
                }

                return this.finishNode(node, "TypeParameter");
              };

              _proto.flowParseTypeParameterDeclaration = function flowParseTypeParameterDeclaration(
                allowDefault
              ) {
                if (allowDefault === void 0) {
                  allowDefault = true;
                }

                var oldInType = this.state.inType;
                var node = this.startNode();
                node.params = [];
                this.state.inType = true;

                if (this.isRelational("<") || this.match(types.jsxTagStart)) {
                  this.next();
                } else {
                  this.unexpected();
                }

                var defaultRequired = false;

                do {
                  var typeParameter = this.flowParseTypeParameter(
                    allowDefault,
                    defaultRequired
                  );
                  node.params.push(typeParameter);

                  if (typeParameter.default) {
                    defaultRequired = true;
                  }

                  if (!this.isRelational(">")) {
                    this.expect(types.comma);
                  }
                } while (!this.isRelational(">"));

                this.expectRelational(">");
                this.state.inType = oldInType;
                return this.finishNode(node, "TypeParameterDeclaration");
              };

              _proto.flowParseTypeParameterInstantiation = function flowParseTypeParameterInstantiation() {
                var node = this.startNode();
                var oldInType = this.state.inType;
                node.params = [];
                this.state.inType = true;
                this.expectRelational("<");

                while (!this.isRelational(">")) {
                  node.params.push(this.flowParseType());

                  if (!this.isRelational(">")) {
                    this.expect(types.comma);
                  }
                }

                this.expectRelational(">");
                this.state.inType = oldInType;
                return this.finishNode(node, "TypeParameterInstantiation");
              };

              _proto.flowParseInterfaceType = function flowParseInterfaceType() {
                var node = this.startNode();
                this.expectContextual("interface");
                node.extends = [];

                if (this.eat(types._extends)) {
                  do {
                    node.extends.push(this.flowParseInterfaceExtends());
                  } while (this.eat(types.comma));
                }

                node.body = this.flowParseObjectType(
                  false,
                  false,
                  false,
                  false
                );
                return this.finishNode(node, "InterfaceTypeAnnotation");
              };

              _proto.flowParseObjectPropertyKey = function flowParseObjectPropertyKey() {
                return this.match(types.num) || this.match(types.string)
                  ? this.parseExprAtom()
                  : this.parseIdentifier(true);
              };

              _proto.flowParseObjectTypeIndexer = function flowParseObjectTypeIndexer(
                node,
                isStatic,
                variance
              ) {
                node.static = isStatic;

                if (this.lookahead().type === types.colon) {
                  node.id = this.flowParseObjectPropertyKey();
                  node.key = this.flowParseTypeInitialiser();
                } else {
                  node.id = null;
                  node.key = this.flowParseType();
                }

                this.expect(types.bracketR);
                node.value = this.flowParseTypeInitialiser();
                node.variance = variance;
                return this.finishNode(node, "ObjectTypeIndexer");
              };

              _proto.flowParseObjectTypeInternalSlot = function flowParseObjectTypeInternalSlot(
                node,
                isStatic
              ) {
                node.static = isStatic;
                node.id = this.flowParseObjectPropertyKey();
                this.expect(types.bracketR);
                this.expect(types.bracketR);

                if (this.isRelational("<") || this.match(types.parenL)) {
                  node.method = true;
                  node.optional = false;
                  node.value = this.flowParseObjectTypeMethodish(
                    this.startNodeAt(node.start, node.loc.start)
                  );
                } else {
                  node.method = false;

                  if (this.eat(types.question)) {
                    node.optional = true;
                  }

                  node.value = this.flowParseTypeInitialiser();
                }

                return this.finishNode(node, "ObjectTypeInternalSlot");
              };

              _proto.flowParseObjectTypeMethodish = function flowParseObjectTypeMethodish(
                node
              ) {
                node.params = [];
                node.rest = null;
                node.typeParameters = null;

                if (this.isRelational("<")) {
                  node.typeParameters = this.flowParseTypeParameterDeclaration(
                    false
                  );
                }

                this.expect(types.parenL);

                while (
                  !this.match(types.parenR) &&
                  !this.match(types.ellipsis)
                ) {
                  node.params.push(this.flowParseFunctionTypeParam());

                  if (!this.match(types.parenR)) {
                    this.expect(types.comma);
                  }
                }

                if (this.eat(types.ellipsis)) {
                  node.rest = this.flowParseFunctionTypeParam();
                }

                this.expect(types.parenR);
                node.returnType = this.flowParseTypeInitialiser();
                return this.finishNode(node, "FunctionTypeAnnotation");
              };

              _proto.flowParseObjectTypeCallProperty = function flowParseObjectTypeCallProperty(
                node,
                isStatic
              ) {
                var valueNode = this.startNode();
                node.static = isStatic;
                node.value = this.flowParseObjectTypeMethodish(valueNode);
                return this.finishNode(node, "ObjectTypeCallProperty");
              };

              _proto.flowParseObjectType = function flowParseObjectType(
                allowStatic,
                allowExact,
                allowSpread,
                allowProto
              ) {
                var oldInType = this.state.inType;
                this.state.inType = true;
                var nodeStart = this.startNode();
                nodeStart.callProperties = [];
                nodeStart.properties = [];
                nodeStart.indexers = [];
                nodeStart.internalSlots = [];
                var endDelim;
                var exact;

                if (allowExact && this.match(types.braceBarL)) {
                  this.expect(types.braceBarL);
                  endDelim = types.braceBarR;
                  exact = true;
                } else {
                  this.expect(types.braceL);
                  endDelim = types.braceR;
                  exact = false;
                }

                nodeStart.exact = exact;

                while (!this.match(endDelim)) {
                  var isStatic = false;
                  var protoStart = null;
                  var node = this.startNode();

                  if (allowProto && this.isContextual("proto")) {
                    var lookahead = this.lookahead();

                    if (
                      lookahead.type !== types.colon &&
                      lookahead.type !== types.question
                    ) {
                      this.next();
                      protoStart = this.state.start;
                      allowStatic = false;
                    }
                  }

                  if (allowStatic && this.isContextual("static")) {
                    var _lookahead = this.lookahead();

                    if (
                      _lookahead.type !== types.colon &&
                      _lookahead.type !== types.question
                    ) {
                      this.next();
                      isStatic = true;
                    }
                  }

                  var variance = this.flowParseVariance();

                  if (this.eat(types.bracketL)) {
                    if (protoStart != null) {
                      this.unexpected(protoStart);
                    }

                    if (this.eat(types.bracketL)) {
                      if (variance) {
                        this.unexpected(variance.start);
                      }

                      nodeStart.internalSlots.push(
                        this.flowParseObjectTypeInternalSlot(node, isStatic)
                      );
                    } else {
                      nodeStart.indexers.push(
                        this.flowParseObjectTypeIndexer(
                          node,
                          isStatic,
                          variance
                        )
                      );
                    }
                  } else if (
                    this.match(types.parenL) ||
                    this.isRelational("<")
                  ) {
                    if (protoStart != null) {
                      this.unexpected(protoStart);
                    }

                    if (variance) {
                      this.unexpected(variance.start);
                    }

                    nodeStart.callProperties.push(
                      this.flowParseObjectTypeCallProperty(node, isStatic)
                    );
                  } else {
                    var kind = "init";

                    if (this.isContextual("get") || this.isContextual("set")) {
                      var _lookahead2 = this.lookahead();

                      if (
                        _lookahead2.type === types.name ||
                        _lookahead2.type === types.string ||
                        _lookahead2.type === types.num
                      ) {
                        kind = this.state.value;
                        this.next();
                      }
                    }

                    nodeStart.properties.push(
                      this.flowParseObjectTypeProperty(
                        node,
                        isStatic,
                        protoStart,
                        variance,
                        kind,
                        allowSpread
                      )
                    );
                  }

                  this.flowObjectTypeSemicolon();
                }

                this.expect(endDelim);
                var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
                this.state.inType = oldInType;
                return out;
              };

              _proto.flowParseObjectTypeProperty = function flowParseObjectTypeProperty(
                node,
                isStatic,
                protoStart,
                variance,
                kind,
                allowSpread
              ) {
                if (this.match(types.ellipsis)) {
                  if (!allowSpread) {
                    this.unexpected(
                      null,
                      "Spread operator cannot appear in class or interface definitions"
                    );
                  }

                  if (protoStart != null) {
                    this.unexpected(protoStart);
                  }

                  if (variance) {
                    this.unexpected(
                      variance.start,
                      "Spread properties cannot have variance"
                    );
                  }

                  this.expect(types.ellipsis);
                  node.argument = this.flowParseType();
                  return this.finishNode(node, "ObjectTypeSpreadProperty");
                } else {
                  node.key = this.flowParseObjectPropertyKey();
                  node.static = isStatic;
                  node.proto = protoStart != null;
                  node.kind = kind;
                  var optional = false;

                  if (this.isRelational("<") || this.match(types.parenL)) {
                    node.method = true;

                    if (protoStart != null) {
                      this.unexpected(protoStart);
                    }

                    if (variance) {
                      this.unexpected(variance.start);
                    }

                    node.value = this.flowParseObjectTypeMethodish(
                      this.startNodeAt(node.start, node.loc.start)
                    );

                    if (kind === "get" || kind === "set") {
                      this.flowCheckGetterSetterParams(node);
                    }
                  } else {
                    if (kind !== "init") this.unexpected();
                    node.method = false;

                    if (this.eat(types.question)) {
                      optional = true;
                    }

                    node.value = this.flowParseTypeInitialiser();
                    node.variance = variance;
                  }

                  node.optional = optional;
                  return this.finishNode(node, "ObjectTypeProperty");
                }
              };

              _proto.flowCheckGetterSetterParams = function flowCheckGetterSetterParams(
                property
              ) {
                var paramCount = property.kind === "get" ? 0 : 1;
                var start = property.start;
                var length =
                  property.value.params.length + (property.value.rest ? 1 : 0);

                if (length !== paramCount) {
                  if (property.kind === "get") {
                    this.raise(
                      start,
                      "getter must not have any formal parameters"
                    );
                  } else {
                    this.raise(
                      start,
                      "setter must have exactly one formal parameter"
                    );
                  }
                }

                if (property.kind === "set" && property.value.rest) {
                  this.raise(
                    start,
                    "setter function argument must not be a rest parameter"
                  );
                }
              };

              _proto.flowObjectTypeSemicolon = function flowObjectTypeSemicolon() {
                if (
                  !this.eat(types.semi) &&
                  !this.eat(types.comma) &&
                  !this.match(types.braceR) &&
                  !this.match(types.braceBarR)
                ) {
                  this.unexpected();
                }
              };

              _proto.flowParseQualifiedTypeIdentifier = function flowParseQualifiedTypeIdentifier(
                startPos,
                startLoc,
                id
              ) {
                startPos = startPos || this.state.start;
                startLoc = startLoc || this.state.startLoc;
                var node = id || this.parseIdentifier();

                while (this.eat(types.dot)) {
                  var node2 = this.startNodeAt(startPos, startLoc);
                  node2.qualification = node;
                  node2.id = this.parseIdentifier();
                  node = this.finishNode(node2, "QualifiedTypeIdentifier");
                }

                return node;
              };

              _proto.flowParseGenericType = function flowParseGenericType(
                startPos,
                startLoc,
                id
              ) {
                var node = this.startNodeAt(startPos, startLoc);
                node.typeParameters = null;
                node.id = this.flowParseQualifiedTypeIdentifier(
                  startPos,
                  startLoc,
                  id
                );

                if (this.isRelational("<")) {
                  node.typeParameters = this.flowParseTypeParameterInstantiation();
                }

                return this.finishNode(node, "GenericTypeAnnotation");
              };

              _proto.flowParseTypeofType = function flowParseTypeofType() {
                var node = this.startNode();
                this.expect(types._typeof);
                node.argument = this.flowParsePrimaryType();
                return this.finishNode(node, "TypeofTypeAnnotation");
              };

              _proto.flowParseTupleType = function flowParseTupleType() {
                var node = this.startNode();
                node.types = [];
                this.expect(types.bracketL);

                while (
                  this.state.pos < this.input.length &&
                  !this.match(types.bracketR)
                ) {
                  node.types.push(this.flowParseType());
                  if (this.match(types.bracketR)) break;
                  this.expect(types.comma);
                }

                this.expect(types.bracketR);
                return this.finishNode(node, "TupleTypeAnnotation");
              };

              _proto.flowParseFunctionTypeParam = function flowParseFunctionTypeParam() {
                var name = null;
                var optional = false;
                var typeAnnotation = null;
                var node = this.startNode();
                var lh = this.lookahead();

                if (lh.type === types.colon || lh.type === types.question) {
                  name = this.parseIdentifier();

                  if (this.eat(types.question)) {
                    optional = true;
                  }

                  typeAnnotation = this.flowParseTypeInitialiser();
                } else {
                  typeAnnotation = this.flowParseType();
                }

                node.name = name;
                node.optional = optional;
                node.typeAnnotation = typeAnnotation;
                return this.finishNode(node, "FunctionTypeParam");
              };

              _proto.reinterpretTypeAsFunctionTypeParam = function reinterpretTypeAsFunctionTypeParam(
                type
              ) {
                var node = this.startNodeAt(type.start, type.loc.start);
                node.name = null;
                node.optional = false;
                node.typeAnnotation = type;
                return this.finishNode(node, "FunctionTypeParam");
              };

              _proto.flowParseFunctionTypeParams = function flowParseFunctionTypeParams(
                params
              ) {
                if (params === void 0) {
                  params = [];
                }

                var rest = null;

                while (
                  !this.match(types.parenR) &&
                  !this.match(types.ellipsis)
                ) {
                  params.push(this.flowParseFunctionTypeParam());

                  if (!this.match(types.parenR)) {
                    this.expect(types.comma);
                  }
                }

                if (this.eat(types.ellipsis)) {
                  rest = this.flowParseFunctionTypeParam();
                }

                return {
                  params: params,
                  rest: rest,
                };
              };

              _proto.flowIdentToTypeAnnotation = function flowIdentToTypeAnnotation(
                startPos,
                startLoc,
                node,
                id
              ) {
                switch (id.name) {
                  case "any":
                    return this.finishNode(node, "AnyTypeAnnotation");

                  case "void":
                    return this.finishNode(node, "VoidTypeAnnotation");

                  case "bool":
                  case "boolean":
                    return this.finishNode(node, "BooleanTypeAnnotation");

                  case "mixed":
                    return this.finishNode(node, "MixedTypeAnnotation");

                  case "empty":
                    return this.finishNode(node, "EmptyTypeAnnotation");

                  case "number":
                    return this.finishNode(node, "NumberTypeAnnotation");

                  case "string":
                    return this.finishNode(node, "StringTypeAnnotation");

                  default:
                    return this.flowParseGenericType(startPos, startLoc, id);
                }
              };

              _proto.flowParsePrimaryType = function flowParsePrimaryType() {
                var startPos = this.state.start;
                var startLoc = this.state.startLoc;
                var node = this.startNode();
                var tmp;
                var type;
                var isGroupedType = false;
                var oldNoAnonFunctionType = this.state.noAnonFunctionType;

                switch (this.state.type) {
                  case types.name:
                    if (this.isContextual("interface")) {
                      return this.flowParseInterfaceType();
                    }

                    return this.flowIdentToTypeAnnotation(
                      startPos,
                      startLoc,
                      node,
                      this.parseIdentifier()
                    );

                  case types.braceL:
                    return this.flowParseObjectType(false, false, true, false);

                  case types.braceBarL:
                    return this.flowParseObjectType(false, true, true, false);

                  case types.bracketL:
                    return this.flowParseTupleType();

                  case types.relational:
                    if (this.state.value === "<") {
                      node.typeParameters = this.flowParseTypeParameterDeclaration(
                        false
                      );
                      this.expect(types.parenL);
                      tmp = this.flowParseFunctionTypeParams();
                      node.params = tmp.params;
                      node.rest = tmp.rest;
                      this.expect(types.parenR);
                      this.expect(types.arrow);
                      node.returnType = this.flowParseType();
                      return this.finishNode(node, "FunctionTypeAnnotation");
                    }

                    break;

                  case types.parenL:
                    this.next();

                    if (
                      !this.match(types.parenR) &&
                      !this.match(types.ellipsis)
                    ) {
                      if (this.match(types.name)) {
                        var token = this.lookahead().type;
                        isGroupedType =
                          token !== types.question && token !== types.colon;
                      } else {
                        isGroupedType = true;
                      }
                    }

                    if (isGroupedType) {
                      this.state.noAnonFunctionType = false;
                      type = this.flowParseType();
                      this.state.noAnonFunctionType = oldNoAnonFunctionType;

                      if (
                        this.state.noAnonFunctionType ||
                        !(
                          this.match(types.comma) ||
                          (this.match(types.parenR) &&
                            this.lookahead().type === types.arrow)
                        )
                      ) {
                        this.expect(types.parenR);
                        return type;
                      } else {
                        this.eat(types.comma);
                      }
                    }

                    if (type) {
                      tmp = this.flowParseFunctionTypeParams([
                        this.reinterpretTypeAsFunctionTypeParam(type),
                      ]);
                    } else {
                      tmp = this.flowParseFunctionTypeParams();
                    }

                    node.params = tmp.params;
                    node.rest = tmp.rest;
                    this.expect(types.parenR);
                    this.expect(types.arrow);
                    node.returnType = this.flowParseType();
                    node.typeParameters = null;
                    return this.finishNode(node, "FunctionTypeAnnotation");

                  case types.string:
                    return this.parseLiteral(
                      this.state.value,
                      "StringLiteralTypeAnnotation"
                    );

                  case types._true:
                  case types._false:
                    node.value = this.match(types._true);
                    this.next();
                    return this.finishNode(
                      node,
                      "BooleanLiteralTypeAnnotation"
                    );

                  case types.plusMin:
                    if (this.state.value === "-") {
                      this.next();

                      if (!this.match(types.num)) {
                        this.unexpected(
                          null,
                          'Unexpected token, expected "number"'
                        );
                      }

                      return this.parseLiteral(
                        -this.state.value,
                        "NumberLiteralTypeAnnotation",
                        node.start,
                        node.loc.start
                      );
                    }

                    this.unexpected();

                  case types.num:
                    return this.parseLiteral(
                      this.state.value,
                      "NumberLiteralTypeAnnotation"
                    );

                  case types._null:
                    this.next();
                    return this.finishNode(node, "NullLiteralTypeAnnotation");

                  case types._this:
                    this.next();
                    return this.finishNode(node, "ThisTypeAnnotation");

                  case types.star:
                    this.next();
                    return this.finishNode(node, "ExistsTypeAnnotation");

                  default:
                    if (this.state.type.keyword === "typeof") {
                      return this.flowParseTypeofType();
                    }
                }

                throw this.unexpected();
              };

              _proto.flowParsePostfixType = function flowParsePostfixType() {
                var startPos = this.state.start,
                  startLoc = this.state.startLoc;
                var type = this.flowParsePrimaryType();

                while (
                  !this.canInsertSemicolon() &&
                  this.match(types.bracketL)
                ) {
                  var node = this.startNodeAt(startPos, startLoc);
                  node.elementType = type;
                  this.expect(types.bracketL);
                  this.expect(types.bracketR);
                  type = this.finishNode(node, "ArrayTypeAnnotation");
                }

                return type;
              };

              _proto.flowParsePrefixType = function flowParsePrefixType() {
                var node = this.startNode();

                if (this.eat(types.question)) {
                  node.typeAnnotation = this.flowParsePrefixType();
                  return this.finishNode(node, "NullableTypeAnnotation");
                } else {
                  return this.flowParsePostfixType();
                }
              };

              _proto.flowParseAnonFunctionWithoutParens = function flowParseAnonFunctionWithoutParens() {
                var param = this.flowParsePrefixType();

                if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
                  var node = this.startNodeAt(param.start, param.loc.start);
                  node.params = [
                    this.reinterpretTypeAsFunctionTypeParam(param),
                  ];
                  node.rest = null;
                  node.returnType = this.flowParseType();
                  node.typeParameters = null;
                  return this.finishNode(node, "FunctionTypeAnnotation");
                }

                return param;
              };

              _proto.flowParseIntersectionType = function flowParseIntersectionType() {
                var node = this.startNode();
                this.eat(types.bitwiseAND);
                var type = this.flowParseAnonFunctionWithoutParens();
                node.types = [type];

                while (this.eat(types.bitwiseAND)) {
                  node.types.push(this.flowParseAnonFunctionWithoutParens());
                }

                return node.types.length === 1
                  ? type
                  : this.finishNode(node, "IntersectionTypeAnnotation");
              };

              _proto.flowParseUnionType = function flowParseUnionType() {
                var node = this.startNode();
                this.eat(types.bitwiseOR);
                var type = this.flowParseIntersectionType();
                node.types = [type];

                while (this.eat(types.bitwiseOR)) {
                  node.types.push(this.flowParseIntersectionType());
                }

                return node.types.length === 1
                  ? type
                  : this.finishNode(node, "UnionTypeAnnotation");
              };

              _proto.flowParseType = function flowParseType() {
                var oldInType = this.state.inType;
                this.state.inType = true;
                var type = this.flowParseUnionType();
                this.state.inType = oldInType;
                this.state.exprAllowed =
                  this.state.exprAllowed || this.state.noAnonFunctionType;
                return type;
              };

              _proto.flowParseTypeAnnotation = function flowParseTypeAnnotation() {
                var node = this.startNode();
                node.typeAnnotation = this.flowParseTypeInitialiser();
                return this.finishNode(node, "TypeAnnotation");
              };

              _proto.flowParseTypeAnnotatableIdentifier = function flowParseTypeAnnotatableIdentifier(
                allowPrimitiveOverride
              ) {
                var ident = allowPrimitiveOverride
                  ? this.parseIdentifier()
                  : this.flowParseRestrictedIdentifier();

                if (this.match(types.colon)) {
                  ident.typeAnnotation = this.flowParseTypeAnnotation();
                  this.finishNode(ident, ident.type);
                }

                return ident;
              };

              _proto.typeCastToParameter = function typeCastToParameter(node) {
                node.expression.typeAnnotation = node.typeAnnotation;
                return this.finishNodeAt(
                  node.expression,
                  node.expression.type,
                  node.typeAnnotation.end,
                  node.typeAnnotation.loc.end
                );
              };

              _proto.flowParseVariance = function flowParseVariance() {
                var variance = null;

                if (this.match(types.plusMin)) {
                  variance = this.startNode();

                  if (this.state.value === "+") {
                    variance.kind = "plus";
                  } else {
                    variance.kind = "minus";
                  }

                  this.next();
                  this.finishNode(variance, "Variance");
                }

                return variance;
              };

              _proto.parseFunctionBody = function parseFunctionBody(
                node,
                allowExpressionBody
              ) {
                var _this3 = this;

                if (allowExpressionBody) {
                  return this.forwardNoArrowParamsConversionAt(
                    node,
                    function() {
                      return _superClass.prototype.parseFunctionBody.call(
                        _this3,
                        node,
                        true
                      );
                    }
                  );
                }

                return _superClass.prototype.parseFunctionBody.call(
                  this,
                  node,
                  false
                );
              };

              _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(
                node,
                type,
                allowExpressionBody
              ) {
                if (!allowExpressionBody && this.match(types.colon)) {
                  var typeNode = this.startNode();

                  var _this$flowParseTypeAn2 = this.flowParseTypeAndPredicateInitialiser();

                  typeNode.typeAnnotation = _this$flowParseTypeAn2[0];
                  node.predicate = _this$flowParseTypeAn2[1];
                  node.returnType = typeNode.typeAnnotation
                    ? this.finishNode(typeNode, "TypeAnnotation")
                    : null;
                }

                _superClass.prototype.parseFunctionBodyAndFinish.call(
                  this,
                  node,
                  type,
                  allowExpressionBody
                );
              };

              _proto.parseStatement = function parseStatement(
                declaration,
                topLevel
              ) {
                if (
                  this.state.strict &&
                  this.match(types.name) &&
                  this.state.value === "interface"
                ) {
                  var node = this.startNode();
                  this.next();
                  return this.flowParseInterface(node);
                } else {
                  var stmt = _superClass.prototype.parseStatement.call(
                    this,
                    declaration,
                    topLevel
                  );

                  if (
                    this.flowPragma === undefined &&
                    !this.isValidDirective(stmt)
                  ) {
                    this.flowPragma = null;
                  }

                  return stmt;
                }
              };

              _proto.parseExpressionStatement = function parseExpressionStatement(
                node,
                expr
              ) {
                if (expr.type === "Identifier") {
                  if (expr.name === "declare") {
                    if (
                      this.match(types._class) ||
                      this.match(types.name) ||
                      this.match(types._function) ||
                      this.match(types._var) ||
                      this.match(types._export)
                    ) {
                      return this.flowParseDeclare(node);
                    }
                  } else if (this.match(types.name)) {
                    if (expr.name === "interface") {
                      return this.flowParseInterface(node);
                    } else if (expr.name === "type") {
                      return this.flowParseTypeAlias(node);
                    } else if (expr.name === "opaque") {
                      return this.flowParseOpaqueType(node, false);
                    }
                  }
                }

                return _superClass.prototype.parseExpressionStatement.call(
                  this,
                  node,
                  expr
                );
              };

              _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
                return (
                  this.isContextual("type") ||
                  this.isContextual("interface") ||
                  this.isContextual("opaque") ||
                  _superClass.prototype.shouldParseExportDeclaration.call(this)
                );
              };

              _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
                if (
                  this.match(types.name) &&
                  (this.state.value === "type" ||
                    this.state.value === "interface" ||
                    this.state.value == "opaque")
                ) {
                  return false;
                }

                return _superClass.prototype.isExportDefaultSpecifier.call(
                  this
                );
              };

              _proto.parseConditional = function parseConditional(
                expr,
                noIn,
                startPos,
                startLoc,
                refNeedsArrowPos
              ) {
                var _this4 = this;

                if (!this.match(types.question)) return expr;

                if (refNeedsArrowPos) {
                  var _state = this.state.clone();

                  try {
                    return _superClass.prototype.parseConditional.call(
                      this,
                      expr,
                      noIn,
                      startPos,
                      startLoc
                    );
                  } catch (err) {
                    if (err instanceof SyntaxError) {
                      this.state = _state;
                      refNeedsArrowPos.start = err.pos || this.state.start;
                      return expr;
                    } else {
                      throw err;
                    }
                  }
                }

                this.expect(types.question);
                var state = this.state.clone();
                var originalNoArrowAt = this.state.noArrowAt;
                var node = this.startNodeAt(startPos, startLoc);

                var _this$tryParseConditi = this.tryParseConditionalConsequent(),
                  consequent = _this$tryParseConditi.consequent,
                  failed = _this$tryParseConditi.failed;

                var _this$getArrowLikeExp = this.getArrowLikeExpressions(
                    consequent
                  ),
                  valid = _this$getArrowLikeExp[0],
                  invalid = _this$getArrowLikeExp[1];

                if (failed || invalid.length > 0) {
                  var noArrowAt = originalNoArrowAt.concat();

                  if (invalid.length > 0) {
                    this.state = state;
                    this.state.noArrowAt = noArrowAt;

                    for (var i = 0; i < invalid.length; i++) {
                      noArrowAt.push(invalid[i].start);
                    }

                    var _this$tryParseConditi2 = this.tryParseConditionalConsequent();

                    consequent = _this$tryParseConditi2.consequent;
                    failed = _this$tryParseConditi2.failed;

                    var _this$getArrowLikeExp2 = this.getArrowLikeExpressions(
                      consequent
                    );

                    valid = _this$getArrowLikeExp2[0];
                    invalid = _this$getArrowLikeExp2[1];
                  }

                  if (failed && valid.length > 1) {
                    this.raise(
                      state.start,
                      "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate."
                    );
                  }

                  if (failed && valid.length === 1) {
                    this.state = state;
                    this.state.noArrowAt = noArrowAt.concat(valid[0].start);

                    var _this$tryParseConditi3 = this.tryParseConditionalConsequent();

                    consequent = _this$tryParseConditi3.consequent;
                    failed = _this$tryParseConditi3.failed;
                  }

                  this.getArrowLikeExpressions(consequent, true);
                }

                this.state.noArrowAt = originalNoArrowAt;
                this.expect(types.colon);
                node.test = expr;
                node.consequent = consequent;
                node.alternate = this.forwardNoArrowParamsConversionAt(
                  node,
                  function() {
                    return _this4.parseMaybeAssign(
                      noIn,
                      undefined,
                      undefined,
                      undefined
                    );
                  }
                );
                return this.finishNode(node, "ConditionalExpression");
              };

              _proto.tryParseConditionalConsequent = function tryParseConditionalConsequent() {
                this.state.noArrowParamsConversionAt.push(this.state.start);
                var consequent = this.parseMaybeAssign();
                var failed = !this.match(types.colon);
                this.state.noArrowParamsConversionAt.pop();
                return {
                  consequent: consequent,
                  failed: failed,
                };
              };

              _proto.getArrowLikeExpressions = function getArrowLikeExpressions(
                node,
                disallowInvalid
              ) {
                var _this5 = this;

                var stack = [node];
                var arrows = [];

                while (stack.length !== 0) {
                  var _node = stack.pop();

                  if (_node.type === "ArrowFunctionExpression") {
                    if (_node.typeParameters || !_node.returnType) {
                      this.toAssignableList(
                        _node.params,
                        true,
                        "arrow function parameters"
                      );

                      _superClass.prototype.checkFunctionNameAndParams.call(
                        this,
                        _node,
                        true
                      );
                    } else {
                      arrows.push(_node);
                    }

                    stack.push(_node.body);
                  } else if (_node.type === "ConditionalExpression") {
                    stack.push(_node.consequent);
                    stack.push(_node.alternate);
                  }
                }

                if (disallowInvalid) {
                  for (var i = 0; i < arrows.length; i++) {
                    this.toAssignableList(
                      node.params,
                      true,
                      "arrow function parameters"
                    );
                  }

                  return [arrows, []];
                }

                return partition(arrows, function(node) {
                  try {
                    _this5.toAssignableList(
                      node.params,
                      true,
                      "arrow function parameters"
                    );

                    return true;
                  } catch (err) {
                    return false;
                  }
                });
              };

              _proto.forwardNoArrowParamsConversionAt = function forwardNoArrowParamsConversionAt(
                node,
                parse
              ) {
                var result;

                if (
                  this.state.noArrowParamsConversionAt.indexOf(node.start) !==
                  -1
                ) {
                  this.state.noArrowParamsConversionAt.push(this.state.start);
                  result = parse();
                  this.state.noArrowParamsConversionAt.pop();
                } else {
                  result = parse();
                }

                return result;
              };

              _proto.parseParenItem = function parseParenItem(
                node,
                startPos,
                startLoc
              ) {
                node = _superClass.prototype.parseParenItem.call(
                  this,
                  node,
                  startPos,
                  startLoc
                );

                if (this.eat(types.question)) {
                  node.optional = true;
                }

                if (this.match(types.colon)) {
                  var typeCastNode = this.startNodeAt(startPos, startLoc);
                  typeCastNode.expression = node;
                  typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
                  return this.finishNode(typeCastNode, "TypeCastExpression");
                }

                return node;
              };

              _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(
                node
              ) {
                if (
                  (node.type === "ImportDeclaration" &&
                    (node.importKind === "type" ||
                      node.importKind === "typeof")) ||
                  (node.type === "ExportNamedDeclaration" &&
                    node.exportKind === "type") ||
                  (node.type === "ExportAllDeclaration" &&
                    node.exportKind === "type")
                ) {
                  return;
                }

                _superClass.prototype.assertModuleNodeAllowed.call(this, node);
              };

              _proto.parseExport = function parseExport(node) {
                node = _superClass.prototype.parseExport.call(this, node);

                if (
                  node.type === "ExportNamedDeclaration" ||
                  node.type === "ExportAllDeclaration"
                ) {
                  node.exportKind = node.exportKind || "value";
                }

                return node;
              };

              _proto.parseExportDeclaration = function parseExportDeclaration(
                node
              ) {
                if (this.isContextual("type")) {
                  node.exportKind = "type";
                  var declarationNode = this.startNode();
                  this.next();

                  if (this.match(types.braceL)) {
                    node.specifiers = this.parseExportSpecifiers();
                    this.parseExportFrom(node);
                    return null;
                  } else {
                    return this.flowParseTypeAlias(declarationNode);
                  }
                } else if (this.isContextual("opaque")) {
                  node.exportKind = "type";

                  var _declarationNode = this.startNode();

                  this.next();
                  return this.flowParseOpaqueType(_declarationNode, false);
                } else if (this.isContextual("interface")) {
                  node.exportKind = "type";

                  var _declarationNode2 = this.startNode();

                  this.next();
                  return this.flowParseInterface(_declarationNode2);
                } else {
                  return _superClass.prototype.parseExportDeclaration.call(
                    this,
                    node
                  );
                }
              };

              _proto.shouldParseExportStar = function shouldParseExportStar() {
                return (
                  _superClass.prototype.shouldParseExportStar.call(this) ||
                  (this.isContextual("type") &&
                    this.lookahead().type === types.star)
                );
              };

              _proto.parseExportStar = function parseExportStar(node) {
                if (this.eatContextual("type")) {
                  node.exportKind = "type";
                }

                return _superClass.prototype.parseExportStar.call(this, node);
              };

              _proto.parseExportNamespace = function parseExportNamespace(
                node
              ) {
                if (node.exportKind === "type") {
                  this.unexpected();
                }

                return _superClass.prototype.parseExportNamespace.call(
                  this,
                  node
                );
              };

              _proto.parseClassId = function parseClassId(
                node,
                isStatement,
                optionalId
              ) {
                _superClass.prototype.parseClassId.call(
                  this,
                  node,
                  isStatement,
                  optionalId
                );

                if (this.isRelational("<")) {
                  node.typeParameters = this.flowParseTypeParameterDeclaration();
                }
              };

              _proto.isKeyword = function isKeyword$$1(name) {
                if (this.state.inType && name === "void") {
                  return false;
                } else {
                  return _superClass.prototype.isKeyword.call(this, name);
                }
              };

              _proto.readToken = function readToken(code) {
                var next = this.input.charCodeAt(this.state.pos + 1);

                if (this.state.inType && (code === 62 || code === 60)) {
                  return this.finishOp(types.relational, 1);
                } else if (
                  !this.options.jisonVariables &&
                  isIteratorStart(code, next)
                ) {
                  this.state.isIterator = true;
                  return _superClass.prototype.readWord.call(this);
                } else {
                  return _superClass.prototype.readToken.call(this, code);
                }
              };

              _proto.toAssignable = function toAssignable(
                node,
                isBinding,
                contextDescription
              ) {
                if (node.type === "TypeCastExpression") {
                  return _superClass.prototype.toAssignable.call(
                    this,
                    this.typeCastToParameter(node),
                    isBinding,
                    contextDescription
                  );
                } else {
                  return _superClass.prototype.toAssignable.call(
                    this,
                    node,
                    isBinding,
                    contextDescription
                  );
                }
              };

              _proto.toAssignableList = function toAssignableList(
                exprList,
                isBinding,
                contextDescription
              ) {
                for (var i = 0; i < exprList.length; i++) {
                  var expr = exprList[i];

                  if (expr && expr.type === "TypeCastExpression") {
                    exprList[i] = this.typeCastToParameter(expr);
                  }
                }

                return _superClass.prototype.toAssignableList.call(
                  this,
                  exprList,
                  isBinding,
                  contextDescription
                );
              };

              _proto.toReferencedList = function toReferencedList(exprList) {
                for (var i = 0; i < exprList.length; i++) {
                  var expr = exprList[i];

                  if (
                    expr &&
                    expr._exprListItem &&
                    expr.type === "TypeCastExpression"
                  ) {
                    this.raise(expr.start, "Unexpected type cast");
                  }
                }

                return exprList;
              };

              _proto.parseExprListItem = function parseExprListItem(
                allowEmpty,
                refShorthandDefaultPos,
                refNeedsArrowPos
              ) {
                var container = this.startNode();

                var node = _superClass.prototype.parseExprListItem.call(
                  this,
                  allowEmpty,
                  refShorthandDefaultPos,
                  refNeedsArrowPos
                );

                if (this.match(types.colon)) {
                  container._exprListItem = true;
                  container.expression = node;
                  container.typeAnnotation = this.flowParseTypeAnnotation();
                  return this.finishNode(container, "TypeCastExpression");
                } else {
                  return node;
                }
              };

              _proto.checkLVal = function checkLVal(
                expr,
                isBinding,
                checkClashes,
                contextDescription
              ) {
                if (expr.type !== "TypeCastExpression") {
                  return _superClass.prototype.checkLVal.call(
                    this,
                    expr,
                    isBinding,
                    checkClashes,
                    contextDescription
                  );
                }
              };

              _proto.parseClassProperty = function parseClassProperty(node) {
                if (this.match(types.colon)) {
                  node.typeAnnotation = this.flowParseTypeAnnotation();
                }

                return _superClass.prototype.parseClassProperty.call(
                  this,
                  node
                );
              };

              _proto.parseClassPrivateProperty = function parseClassPrivateProperty(
                node
              ) {
                if (this.match(types.colon)) {
                  node.typeAnnotation = this.flowParseTypeAnnotation();
                }

                return _superClass.prototype.parseClassPrivateProperty.call(
                  this,
                  node
                );
              };

              _proto.isClassMethod = function isClassMethod() {
                return (
                  this.isRelational("<") ||
                  _superClass.prototype.isClassMethod.call(this)
                );
              };

              _proto.isClassProperty = function isClassProperty() {
                return (
                  this.match(types.colon) ||
                  _superClass.prototype.isClassProperty.call(this)
                );
              };

              _proto.isNonstaticConstructor = function isNonstaticConstructor(
                method
              ) {
                return (
                  !this.match(types.colon) &&
                  _superClass.prototype.isNonstaticConstructor.call(
                    this,
                    method
                  )
                );
              };

              _proto.pushClassMethod = function pushClassMethod(
                classBody,
                method,
                isGenerator,
                isAsync,
                isConstructor
              ) {
                if (method.variance) {
                  this.unexpected(method.variance.start);
                }

                delete method.variance;

                if (this.isRelational("<")) {
                  method.typeParameters = this.flowParseTypeParameterDeclaration(
                    false
                  );
                }

                _superClass.prototype.pushClassMethod.call(
                  this,
                  classBody,
                  method,
                  isGenerator,
                  isAsync,
                  isConstructor
                );
              };

              _proto.pushClassPrivateMethod = function pushClassPrivateMethod(
                classBody,
                method,
                isGenerator,
                isAsync
              ) {
                if (method.variance) {
                  this.unexpected(method.variance.start);
                }

                delete method.variance;

                if (this.isRelational("<")) {
                  method.typeParameters = this.flowParseTypeParameterDeclaration();
                }

                _superClass.prototype.pushClassPrivateMethod.call(
                  this,
                  classBody,
                  method,
                  isGenerator,
                  isAsync
                );
              };

              _proto.parseClassSuper = function parseClassSuper(node) {
                _superClass.prototype.parseClassSuper.call(this, node);

                if (node.superClass && this.isRelational("<")) {
                  node.superTypeParameters = this.flowParseTypeParameterInstantiation();
                }

                if (this.isContextual("implements")) {
                  this.next();
                  var implemented = (node.implements = []);

                  do {
                    var _node2 = this.startNode();

                    _node2.id = this.flowParseRestrictedIdentifier(true);

                    if (this.isRelational("<")) {
                      _node2.typeParameters = this.flowParseTypeParameterInstantiation();
                    } else {
                      _node2.typeParameters = null;
                    }

                    implemented.push(
                      this.finishNode(_node2, "ClassImplements")
                    );
                  } while (this.eat(types.comma));
                }
              };

              _proto.parsePropertyName = function parsePropertyName(node) {
                var variance = this.flowParseVariance();

                var key = _superClass.prototype.parsePropertyName.call(
                  this,
                  node
                );

                node.variance = variance;
                return key;
              };

              _proto.parseObjPropValue = function parseObjPropValue(
                prop,
                startPos,
                startLoc,
                isGenerator,
                isAsync,
                isPattern,
                refShorthandDefaultPos,
                containsEsc
              ) {
                if (prop.variance) {
                  this.unexpected(prop.variance.start);
                }

                delete prop.variance;
                var typeParameters;

                if (this.isRelational("<")) {
                  typeParameters = this.flowParseTypeParameterDeclaration(
                    false
                  );
                  if (!this.match(types.parenL)) this.unexpected();
                }

                _superClass.prototype.parseObjPropValue.call(
                  this,
                  prop,
                  startPos,
                  startLoc,
                  isGenerator,
                  isAsync,
                  isPattern,
                  refShorthandDefaultPos,
                  containsEsc
                );

                if (typeParameters) {
                  (prop.value || prop).typeParameters = typeParameters;
                }
              };

              _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(
                param
              ) {
                if (this.eat(types.question)) {
                  if (param.type !== "Identifier") {
                    throw this.raise(
                      param.start,
                      "A binding pattern parameter cannot be optional in an implementation signature."
                    );
                  }

                  param.optional = true;
                }

                if (this.match(types.colon)) {
                  param.typeAnnotation = this.flowParseTypeAnnotation();
                }

                this.finishNode(param, param.type);
                return param;
              };

              _proto.parseMaybeDefault = function parseMaybeDefault(
                startPos,
                startLoc,
                left
              ) {
                var node = _superClass.prototype.parseMaybeDefault.call(
                  this,
                  startPos,
                  startLoc,
                  left
                );

                if (
                  node.type === "AssignmentPattern" &&
                  node.typeAnnotation &&
                  node.right.start < node.typeAnnotation.start
                ) {
                  this.raise(
                    node.typeAnnotation.start,
                    "Type annotations must come before default assignments, " +
                      "e.g. instead of `age = 25: number` use `age: number = 25`"
                  );
                }

                return node;
              };

              _proto.shouldParseDefaultImport = function shouldParseDefaultImport(
                node
              ) {
                if (!hasTypeImportKind(node)) {
                  return _superClass.prototype.shouldParseDefaultImport.call(
                    this,
                    node
                  );
                }

                return isMaybeDefaultImport(this.state);
              };

              _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(
                node,
                specifier,
                type,
                contextDescription
              ) {
                specifier.local = hasTypeImportKind(node)
                  ? this.flowParseRestrictedIdentifier(true)
                  : this.parseIdentifier();
                this.checkLVal(
                  specifier.local,
                  true,
                  undefined,
                  contextDescription
                );
                node.specifiers.push(this.finishNode(specifier, type));
              };

              _proto.parseImportSpecifiers = function parseImportSpecifiers(
                node
              ) {
                node.importKind = "value";
                var kind = null;

                if (this.match(types._typeof)) {
                  kind = "typeof";
                } else if (this.isContextual("type")) {
                  kind = "type";
                }

                if (kind) {
                  var lh = this.lookahead();

                  if (kind === "type" && lh.type === types.star) {
                    this.unexpected(lh.start);
                  }

                  if (
                    isMaybeDefaultImport(lh) ||
                    lh.type === types.braceL ||
                    lh.type === types.star
                  ) {
                    this.next();
                    node.importKind = kind;
                  }
                }

                _superClass.prototype.parseImportSpecifiers.call(this, node);
              };

              _proto.parseImportSpecifier = function parseImportSpecifier(
                node
              ) {
                var specifier = this.startNode();
                var firstIdentLoc = this.state.start;
                var firstIdent = this.parseIdentifier(true);
                var specifierTypeKind = null;

                if (firstIdent.name === "type") {
                  specifierTypeKind = "type";
                } else if (firstIdent.name === "typeof") {
                  specifierTypeKind = "typeof";
                }

                var isBinding = false;

                if (
                  this.isContextual("as") &&
                  !this.isLookaheadContextual("as")
                ) {
                  var as_ident = this.parseIdentifier(true);

                  if (
                    specifierTypeKind !== null &&
                    !this.match(types.name) &&
                    !this.state.type.keyword
                  ) {
                    specifier.imported = as_ident;
                    specifier.importKind = specifierTypeKind;
                    specifier.local = as_ident.__clone();
                  } else {
                    specifier.imported = firstIdent;
                    specifier.importKind = null;
                    specifier.local = this.parseIdentifier();
                  }
                } else if (
                  specifierTypeKind !== null &&
                  (this.match(types.name) || this.state.type.keyword)
                ) {
                  specifier.imported = this.parseIdentifier(true);
                  specifier.importKind = specifierTypeKind;

                  if (this.eatContextual("as")) {
                    specifier.local = this.parseIdentifier();
                  } else {
                    isBinding = true;
                    specifier.local = specifier.imported.__clone();
                  }
                } else {
                  isBinding = true;
                  specifier.imported = firstIdent;
                  specifier.importKind = null;
                  specifier.local = specifier.imported.__clone();
                }

                var nodeIsTypeImport = hasTypeImportKind(node);
                var specifierIsTypeImport = hasTypeImportKind(specifier);

                if (nodeIsTypeImport && specifierIsTypeImport) {
                  this.raise(
                    firstIdentLoc,
                    "The `type` and `typeof` keywords on named imports can only be used on regular " +
                      "`import` statements. It cannot be used with `import type` or `import typeof` statements"
                  );
                }

                if (nodeIsTypeImport || specifierIsTypeImport) {
                  this.checkReservedType(
                    specifier.local.name,
                    specifier.local.start
                  );
                }

                if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
                  this.checkReservedWord(
                    specifier.local.name,
                    specifier.start,
                    true,
                    true
                  );
                }

                this.checkLVal(
                  specifier.local,
                  true,
                  undefined,
                  "import specifier"
                );
                node.specifiers.push(
                  this.finishNode(specifier, "ImportSpecifier")
                );
              };

              _proto.parseFunctionParams = function parseFunctionParams(node) {
                var kind = node.kind;

                if (
                  kind !== "get" &&
                  kind !== "set" &&
                  this.isRelational("<")
                ) {
                  node.typeParameters = this.flowParseTypeParameterDeclaration(
                    false
                  );
                }

                _superClass.prototype.parseFunctionParams.call(this, node);
              };

              _proto.parseVarHead = function parseVarHead(decl) {
                _superClass.prototype.parseVarHead.call(this, decl);

                if (this.match(types.colon)) {
                  decl.id.typeAnnotation = this.flowParseTypeAnnotation();
                  this.finishNode(decl.id, decl.id.type);
                }
              };

              _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(
                node,
                call
              ) {
                if (this.match(types.colon)) {
                  var oldNoAnonFunctionType = this.state.noAnonFunctionType;
                  this.state.noAnonFunctionType = true;
                  node.returnType = this.flowParseTypeAnnotation();
                  this.state.noAnonFunctionType = oldNoAnonFunctionType;
                }

                return _superClass.prototype.parseAsyncArrowFromCallExpression.call(
                  this,
                  node,
                  call
                );
              };

              _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
                return (
                  this.match(types.colon) ||
                  _superClass.prototype.shouldParseAsyncArrow.call(this)
                );
              };

              _proto.parseMaybeAssign = function parseMaybeAssign(
                noIn,
                refShorthandDefaultPos,
                afterLeftParse,
                refNeedsArrowPos
              ) {
                var _this6 = this;

                var jsxError = null;

                if (types.jsxTagStart && this.match(types.jsxTagStart)) {
                  var state = this.state.clone();

                  try {
                    return _superClass.prototype.parseMaybeAssign.call(
                      this,
                      noIn,
                      refShorthandDefaultPos,
                      afterLeftParse,
                      refNeedsArrowPos
                    );
                  } catch (err) {
                    if (err instanceof SyntaxError) {
                      this.state = state;
                      this.state.context.length -= 2;
                      jsxError = err;
                    } else {
                      throw err;
                    }
                  }
                }

                if (jsxError != null || this.isRelational("<")) {
                  var arrowExpression;
                  var typeParameters;

                  try {
                    typeParameters = this.flowParseTypeParameterDeclaration();
                    arrowExpression = this.forwardNoArrowParamsConversionAt(
                      typeParameters,
                      function() {
                        return _superClass.prototype.parseMaybeAssign.call(
                          _this6,
                          noIn,
                          refShorthandDefaultPos,
                          afterLeftParse,
                          refNeedsArrowPos
                        );
                      }
                    );
                    arrowExpression.typeParameters = typeParameters;
                    this.resetStartLocationFromNode(
                      arrowExpression,
                      typeParameters
                    );
                  } catch (err) {
                    throw jsxError || err;
                  }

                  if (arrowExpression.type === "ArrowFunctionExpression") {
                    return arrowExpression;
                  } else if (jsxError != null) {
                    throw jsxError;
                  } else {
                    this.raise(
                      typeParameters.start,
                      "Expected an arrow function after this type parameter declaration"
                    );
                  }
                }

                return _superClass.prototype.parseMaybeAssign.call(
                  this,
                  noIn,
                  refShorthandDefaultPos,
                  afterLeftParse,
                  refNeedsArrowPos
                );
              };

              _proto.parseArrow = function parseArrow(node) {
                if (this.match(types.colon)) {
                  var state = this.state.clone();

                  try {
                    var oldNoAnonFunctionType = this.state.noAnonFunctionType;
                    this.state.noAnonFunctionType = true;
                    var typeNode = this.startNode();

                    var _this$flowParseTypeAn3 = this.flowParseTypeAndPredicateInitialiser();

                    typeNode.typeAnnotation = _this$flowParseTypeAn3[0];
                    node.predicate = _this$flowParseTypeAn3[1];
                    this.state.noAnonFunctionType = oldNoAnonFunctionType;
                    if (this.canInsertSemicolon()) this.unexpected();
                    if (!this.match(types.arrow)) this.unexpected();
                    node.returnType = typeNode.typeAnnotation
                      ? this.finishNode(typeNode, "TypeAnnotation")
                      : null;
                  } catch (err) {
                    if (err instanceof SyntaxError) {
                      this.state = state;
                    } else {
                      throw err;
                    }
                  }
                }

                return _superClass.prototype.parseArrow.call(this, node);
              };

              _proto.shouldParseArrow = function shouldParseArrow() {
                return (
                  this.match(types.colon) ||
                  _superClass.prototype.shouldParseArrow.call(this)
                );
              };

              _proto.setArrowFunctionParameters = function setArrowFunctionParameters(
                node,
                params
              ) {
                if (
                  this.state.noArrowParamsConversionAt.indexOf(node.start) !==
                  -1
                ) {
                  node.params = params;
                } else {
                  _superClass.prototype.setArrowFunctionParameters.call(
                    this,
                    node,
                    params
                  );
                }
              };

              _proto.checkFunctionNameAndParams = function checkFunctionNameAndParams(
                node,
                isArrowFunction
              ) {
                if (
                  isArrowFunction &&
                  this.state.noArrowParamsConversionAt.indexOf(node.start) !==
                    -1
                ) {
                  return;
                }

                return _superClass.prototype.checkFunctionNameAndParams.call(
                  this,
                  node,
                  isArrowFunction
                );
              };

              _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(
                canBeArrow
              ) {
                return _superClass.prototype.parseParenAndDistinguishExpression.call(
                  this,
                  canBeArrow &&
                    this.state.noArrowAt.indexOf(this.state.start) === -1
                );
              };

              _proto.parseSubscripts = function parseSubscripts(
                base,
                startPos,
                startLoc,
                noCalls
              ) {
                if (
                  base.type === "Identifier" &&
                  base.name === "async" &&
                  this.state.noArrowAt.indexOf(startPos) !== -1
                ) {
                  this.next();
                  var node = this.startNodeAt(startPos, startLoc);
                  node.callee = base;
                  node.arguments = this.parseCallExpressionArguments(
                    types.parenR,
                    false
                  );
                  base = this.finishNode(node, "CallExpression");
                } else if (
                  base.type === "Identifier" &&
                  base.name === "async" &&
                  this.isRelational("<")
                ) {
                  var state = this.state.clone();
                  var error;

                  try {
                    var _node3 = this.parseAsyncArrowWithTypeParameters(
                      startPos,
                      startLoc
                    );

                    if (_node3) return _node3;
                  } catch (e) {
                    error = e;
                  }

                  this.state = state;

                  try {
                    return _superClass.prototype.parseSubscripts.call(
                      this,
                      base,
                      startPos,
                      startLoc,
                      noCalls
                    );
                  } catch (e) {
                    throw error || e;
                  }
                }

                return _superClass.prototype.parseSubscripts.call(
                  this,
                  base,
                  startPos,
                  startLoc,
                  noCalls
                );
              };

              _proto.parseSubscript = function parseSubscript(
                base,
                startPos,
                startLoc,
                noCalls,
                subscriptState
              ) {
                if (
                  this.match(types.questionDot) &&
                  this.isLookaheadRelational("<")
                ) {
                  this.expectPlugin("optionalChaining");
                  subscriptState.optionalChainMember = true;

                  if (noCalls) {
                    subscriptState.stop = true;
                    return base;
                  }

                  this.next();
                  var node = this.startNodeAt(startPos, startLoc);
                  node.callee = base;
                  node.typeArguments = this.flowParseTypeParameterInstantiation();
                  this.expect(types.parenL);
                  node.arguments = this.parseCallExpressionArguments(
                    types.parenR,
                    false
                  );
                  node.optional = true;
                  return this.finishNode(node, "OptionalCallExpression");
                } else if (
                  !noCalls &&
                  this.shouldParseTypes() &&
                  this.isRelational("<")
                ) {
                  var _node4 = this.startNodeAt(startPos, startLoc);

                  _node4.callee = base;
                  var state = this.state.clone();

                  try {
                    _node4.typeArguments = this.flowParseTypeParameterInstantiation();
                    this.expect(types.parenL);
                    _node4.arguments = this.parseCallExpressionArguments(
                      types.parenR,
                      false
                    );

                    if (subscriptState.optionalChainMember) {
                      _node4.optional = false;
                      return this.finishNode(_node4, "OptionalCallExpression");
                    }

                    return this.finishNode(_node4, "CallExpression");
                  } catch (e) {
                    if (e instanceof SyntaxError) {
                      this.state = state;
                    } else {
                      throw e;
                    }
                  }
                }

                return _superClass.prototype.parseSubscript.call(
                  this,
                  base,
                  startPos,
                  startLoc,
                  noCalls,
                  subscriptState
                );
              };

              _proto.parseNewArguments = function parseNewArguments(node) {
                var targs = null;

                if (this.shouldParseTypes() && this.isRelational("<")) {
                  var state = this.state.clone();

                  try {
                    targs = this.flowParseTypeParameterInstantiation();
                  } catch (e) {
                    if (e instanceof SyntaxError) {
                      this.state = state;
                    } else {
                      throw e;
                    }
                  }
                }

                node.typeArguments = targs;

                _superClass.prototype.parseNewArguments.call(this, node);
              };

              _proto.parseAsyncArrowWithTypeParameters = function parseAsyncArrowWithTypeParameters(
                startPos,
                startLoc
              ) {
                var node = this.startNodeAt(startPos, startLoc);
                this.parseFunctionParams(node);
                if (!this.parseArrow(node)) return;
                return this.parseArrowExpression(node, undefined, true);
              };

              _proto.readToken_mult_modulo = function readToken_mult_modulo(
                code
              ) {
                var next = this.input.charCodeAt(this.state.pos + 1);

                if (code === 42 && next === 47 && this.state.hasFlowComment) {
                  this.state.hasFlowComment = false;
                  this.state.pos += 2;
                  this.nextToken();
                  return;
                }

                _superClass.prototype.readToken_mult_modulo.call(this, code);
              };

              _proto.skipBlockComment = function skipBlockComment() {
                if (
                  this.hasPlugin("flow") &&
                  this.hasPlugin("flowComments") &&
                  this.skipFlowComment()
                ) {
                  this.hasFlowCommentCompletion();
                  this.state.pos += this.skipFlowComment();
                  this.state.hasFlowComment = true;
                  return;
                }

                var end;

                if (this.hasPlugin("flow") && this.state.hasFlowComment) {
                  end = this.input.indexOf("*-/", (this.state.pos += 2));
                  if (end === -1)
                    this.raise(this.state.pos - 2, "Unterminated comment");
                  this.state.pos = end + 3;
                  return;
                }

                _superClass.prototype.skipBlockComment.call(this);
              };

              _proto.skipFlowComment = function skipFlowComment() {
                var ch2 = this.input.charCodeAt(this.state.pos + 2);
                var ch3 = this.input.charCodeAt(this.state.pos + 3);

                if (ch2 === 58 && ch3 === 58) {
                  return 4;
                }

                if (
                  this.input.slice(this.state.pos + 2, 14) === "flow-include"
                ) {
                  return 14;
                }

                if (ch2 === 58 && ch3 !== 58) {
                  return 2;
                }

                return false;
              };

              _proto.hasFlowCommentCompletion = function hasFlowCommentCompletion() {
                var end = this.input.indexOf("*/", this.state.pos);

                if (end === -1) {
                  this.raise(this.state.pos, "Unterminated comment");
                }
              };

              return _class;
            })(superClass);
          };

          var entities = {
            quot: '"',
            amp: "&",
            apos: "'",
            lt: "<",
            gt: ">",
            nbsp: "\xA0",
            iexcl: "\xA1",
            cent: "\xA2",
            pound: "\xA3",
            curren: "\xA4",
            yen: "\xA5",
            brvbar: "\xA6",
            sect: "\xA7",
            uml: "\xA8",
            copy: "\xA9",
            ordf: "\xAA",
            laquo: "\xAB",
            not: "\xAC",
            shy: "\xAD",
            reg: "\xAE",
            macr: "\xAF",
            deg: "\xB0",
            plusmn: "\xB1",
            sup2: "\xB2",
            sup3: "\xB3",
            acute: "\xB4",
            micro: "\xB5",
            para: "\xB6",
            middot: "\xB7",
            cedil: "\xB8",
            sup1: "\xB9",
            ordm: "\xBA",
            raquo: "\xBB",
            frac14: "\xBC",
            frac12: "\xBD",
            frac34: "\xBE",
            iquest: "\xBF",
            Agrave: "\xC0",
            Aacute: "\xC1",
            Acirc: "\xC2",
            Atilde: "\xC3",
            Auml: "\xC4",
            Aring: "\xC5",
            AElig: "\xC6",
            Ccedil: "\xC7",
            Egrave: "\xC8",
            Eacute: "\xC9",
            Ecirc: "\xCA",
            Euml: "\xCB",
            Igrave: "\xCC",
            Iacute: "\xCD",
            Icirc: "\xCE",
            Iuml: "\xCF",
            ETH: "\xD0",
            Ntilde: "\xD1",
            Ograve: "\xD2",
            Oacute: "\xD3",
            Ocirc: "\xD4",
            Otilde: "\xD5",
            Ouml: "\xD6",
            times: "\xD7",
            Oslash: "\xD8",
            Ugrave: "\xD9",
            Uacute: "\xDA",
            Ucirc: "\xDB",
            Uuml: "\xDC",
            Yacute: "\xDD",
            THORN: "\xDE",
            szlig: "\xDF",
            agrave: "\xE0",
            aacute: "\xE1",
            acirc: "\xE2",
            atilde: "\xE3",
            auml: "\xE4",
            aring: "\xE5",
            aelig: "\xE6",
            ccedil: "\xE7",
            egrave: "\xE8",
            eacute: "\xE9",
            ecirc: "\xEA",
            euml: "\xEB",
            igrave: "\xEC",
            iacute: "\xED",
            icirc: "\xEE",
            iuml: "\xEF",
            eth: "\xF0",
            ntilde: "\xF1",
            ograve: "\xF2",
            oacute: "\xF3",
            ocirc: "\xF4",
            otilde: "\xF5",
            ouml: "\xF6",
            divide: "\xF7",
            oslash: "\xF8",
            ugrave: "\xF9",
            uacute: "\xFA",
            ucirc: "\xFB",
            uuml: "\xFC",
            yacute: "\xFD",
            thorn: "\xFE",
            yuml: "\xFF",
            OElig: "\u0152",
            oelig: "\u0153",
            Scaron: "\u0160",
            scaron: "\u0161",
            Yuml: "\u0178",
            fnof: "\u0192",
            circ: "\u02C6",
            tilde: "\u02DC",
            Alpha: "\u0391",
            Beta: "\u0392",
            Gamma: "\u0393",
            Delta: "\u0394",
            Epsilon: "\u0395",
            Zeta: "\u0396",
            Eta: "\u0397",
            Theta: "\u0398",
            Iota: "\u0399",
            Kappa: "\u039A",
            Lambda: "\u039B",
            Mu: "\u039C",
            Nu: "\u039D",
            Xi: "\u039E",
            Omicron: "\u039F",
            Pi: "\u03A0",
            Rho: "\u03A1",
            Sigma: "\u03A3",
            Tau: "\u03A4",
            Upsilon: "\u03A5",
            Phi: "\u03A6",
            Chi: "\u03A7",
            Psi: "\u03A8",
            Omega: "\u03A9",
            alpha: "\u03B1",
            beta: "\u03B2",
            gamma: "\u03B3",
            delta: "\u03B4",
            epsilon: "\u03B5",
            zeta: "\u03B6",
            eta: "\u03B7",
            theta: "\u03B8",
            iota: "\u03B9",
            kappa: "\u03BA",
            lambda: "\u03BB",
            mu: "\u03BC",
            nu: "\u03BD",
            xi: "\u03BE",
            omicron: "\u03BF",
            pi: "\u03C0",
            rho: "\u03C1",
            sigmaf: "\u03C2",
            sigma: "\u03C3",
            tau: "\u03C4",
            upsilon: "\u03C5",
            phi: "\u03C6",
            chi: "\u03C7",
            psi: "\u03C8",
            omega: "\u03C9",
            thetasym: "\u03D1",
            upsih: "\u03D2",
            piv: "\u03D6",
            ensp: "\u2002",
            emsp: "\u2003",
            thinsp: "\u2009",
            zwnj: "\u200C",
            zwj: "\u200D",
            lrm: "\u200E",
            rlm: "\u200F",
            ndash: "\u2013",
            mdash: "\u2014",
            lsquo: "\u2018",
            rsquo: "\u2019",
            sbquo: "\u201A",
            ldquo: "\u201C",
            rdquo: "\u201D",
            bdquo: "\u201E",
            dagger: "\u2020",
            Dagger: "\u2021",
            bull: "\u2022",
            hellip: "\u2026",
            permil: "\u2030",
            prime: "\u2032",
            Prime: "\u2033",
            lsaquo: "\u2039",
            rsaquo: "\u203A",
            oline: "\u203E",
            frasl: "\u2044",
            euro: "\u20AC",
            image: "\u2111",
            weierp: "\u2118",
            real: "\u211C",
            trade: "\u2122",
            alefsym: "\u2135",
            larr: "\u2190",
            uarr: "\u2191",
            rarr: "\u2192",
            darr: "\u2193",
            harr: "\u2194",
            crarr: "\u21B5",
            lArr: "\u21D0",
            uArr: "\u21D1",
            rArr: "\u21D2",
            dArr: "\u21D3",
            hArr: "\u21D4",
            forall: "\u2200",
            part: "\u2202",
            exist: "\u2203",
            empty: "\u2205",
            nabla: "\u2207",
            isin: "\u2208",
            notin: "\u2209",
            ni: "\u220B",
            prod: "\u220F",
            sum: "\u2211",
            minus: "\u2212",
            lowast: "\u2217",
            radic: "\u221A",
            prop: "\u221D",
            infin: "\u221E",
            ang: "\u2220",
            and: "\u2227",
            or: "\u2228",
            cap: "\u2229",
            cup: "\u222A",
            int: "\u222B",
            there4: "\u2234",
            sim: "\u223C",
            cong: "\u2245",
            asymp: "\u2248",
            ne: "\u2260",
            equiv: "\u2261",
            le: "\u2264",
            ge: "\u2265",
            sub: "\u2282",
            sup: "\u2283",
            nsub: "\u2284",
            sube: "\u2286",
            supe: "\u2287",
            oplus: "\u2295",
            otimes: "\u2297",
            perp: "\u22A5",
            sdot: "\u22C5",
            lceil: "\u2308",
            rceil: "\u2309",
            lfloor: "\u230A",
            rfloor: "\u230B",
            lang: "\u2329",
            rang: "\u232A",
            loz: "\u25CA",
            spades: "\u2660",
            clubs: "\u2663",
            hearts: "\u2665",
            diams: "\u2666",
          };
          var lineBreak = /\r\n?|\n|\u2028|\u2029/;
          var lineBreakG = new RegExp(lineBreak.source, "g");

          function isNewLine(code) {
            switch (code) {
              case 10:
              case 13:
              case 8232:
              case 8233:
                return true;

              default:
                return false;
            }
          }

          function isWhitespace(code) {
            switch (code) {
              case 0x0009:
              case 0x000b:
              case 0x000c:
              case 32:
              case 160:
              case 5760:
              case 0x2000:
              case 0x2001:
              case 0x2002:
              case 0x2003:
              case 0x2004:
              case 0x2005:
              case 0x2006:
              case 0x2007:
              case 0x2008:
              case 0x2009:
              case 0x200a:
              case 0x202f:
              case 0x205f:
              case 0x3000:
              case 0xfeff:
                return true;

              default:
                return false;
            }
          }

          var TokContext = function TokContext(
            token,
            isExpr,
            preserveSpace,
            override
          ) {
            this.token = token;
            this.isExpr = !!isExpr;
            this.preserveSpace = !!preserveSpace;
            this.override = override;
          };

          var types$1 = {
            braceStatement: new TokContext("{", false),
            braceExpression: new TokContext("{", true),
            templateQuasi: new TokContext("${", true),
            parenStatement: new TokContext("(", false),
            parenExpression: new TokContext("(", true),
            template: new TokContext("`", true, true, function(p) {
              return p.readTmplToken();
            }),
            functionExpression: new TokContext("function", true),
          };

          types.parenR.updateContext = types.braceR.updateContext = function() {
            if (this.state.context.length === 1) {
              this.state.exprAllowed = true;
              return;
            }

            var out = this.state.context.pop();

            if (
              out === types$1.braceStatement &&
              this.curContext() === types$1.functionExpression
            ) {
              this.state.context.pop();
              this.state.exprAllowed = false;
            } else if (out === types$1.templateQuasi) {
              this.state.exprAllowed = true;
            } else {
              this.state.exprAllowed = !out.isExpr;
            }
          };

          types.name.updateContext = function(prevType) {
            if (
              this.state.value === "of" &&
              this.curContext() === types$1.parenStatement
            ) {
              this.state.exprAllowed = !prevType.beforeExpr;
              return;
            }

            this.state.exprAllowed = false;

            if (
              prevType === types._let ||
              prevType === types._const ||
              prevType === types._var
            ) {
              if (lineBreak.test(this.input.slice(this.state.end))) {
                this.state.exprAllowed = true;
              }
            }

            if (this.state.isIterator) {
              this.state.isIterator = false;
            }
          };

          types.braceL.updateContext = function(prevType) {
            this.state.context.push(
              this.braceIsBlock(prevType)
                ? types$1.braceStatement
                : types$1.braceExpression
            );
            this.state.exprAllowed = true;
          };

          types.dollarBraceL.updateContext = function() {
            this.state.context.push(types$1.templateQuasi);
            this.state.exprAllowed = true;
          };

          types.parenL.updateContext = function(prevType) {
            var statementParens =
              prevType === types._if ||
              prevType === types._for ||
              prevType === types._with ||
              prevType === types._while;
            this.state.context.push(
              statementParens ? types$1.parenStatement : types$1.parenExpression
            );
            this.state.exprAllowed = true;
          };

          types.incDec.updateContext = function() {};

          types._function.updateContext = function(prevType) {
            if (this.state.exprAllowed && !this.braceIsBlock(prevType)) {
              this.state.context.push(types$1.functionExpression);
            }

            this.state.exprAllowed = false;
          };

          types.backQuote.updateContext = function() {
            if (this.curContext() === types$1.template) {
              this.state.context.pop();
            } else {
              this.state.context.push(types$1.template);
            }

            this.state.exprAllowed = false;
          };

          var HEX_NUMBER = /^[\da-fA-F]+$/;
          var DECIMAL_NUMBER = /^\d+$/;
          types$1.j_oTag = new TokContext("<tag", false);
          types$1.j_cTag = new TokContext("</tag", false);
          types$1.j_expr = new TokContext("<tag>...</tag>", true, true);
          types.jsxName = new TokenType("jsxName");
          types.jsxText = new TokenType("jsxText", {
            beforeExpr: true,
          });
          types.jsxTagStart = new TokenType("jsxTagStart", {
            startsExpr: true,
          });
          types.jsxTagEnd = new TokenType("jsxTagEnd");

          types.jsxTagStart.updateContext = function() {
            this.state.context.push(types$1.j_expr);
            this.state.context.push(types$1.j_oTag);
            this.state.exprAllowed = false;
          };

          types.jsxTagEnd.updateContext = function(prevType) {
            var out = this.state.context.pop();

            if (
              (out === types$1.j_oTag && prevType === types.slash) ||
              out === types$1.j_cTag
            ) {
              this.state.context.pop();
              this.state.exprAllowed = this.curContext() === types$1.j_expr;
            } else {
              this.state.exprAllowed = true;
            }
          };

          function isFragment(object) {
            return object
              ? object.type === "JSXOpeningFragment" ||
                  object.type === "JSXClosingFragment"
              : false;
          }

          function getQualifiedJSXName(object) {
            if (object.type === "JSXIdentifier") {
              return object.name;
            }

            if (object.type === "JSXNamespacedName") {
              return object.namespace.name + ":" + object.name.name;
            }

            if (object.type === "JSXMemberExpression") {
              return (
                getQualifiedJSXName(object.object) +
                "." +
                getQualifiedJSXName(object.property)
              );
            }

            throw new Error("Node had unexpected type: " + object.type);
          }

          var jsx = function jsx(superClass) {
            return (function(_superClass) {
              _inheritsLoose(_class, _superClass);

              function _class() {
                return _superClass.apply(this, arguments) || this;
              }

              var _proto = _class.prototype;

              _proto.jsxReadToken = function jsxReadToken() {
                var out = "";
                var chunkStart = this.state.pos;

                for (;;) {
                  if (this.state.pos >= this.input.length) {
                    this.raise(this.state.start, "Unterminated JSX contents");
                  }

                  var ch = this.input.charCodeAt(this.state.pos);

                  switch (ch) {
                    case 60:
                    case 123:
                      if (this.state.pos === this.state.start) {
                        if (ch === 60 && this.state.exprAllowed) {
                          ++this.state.pos;
                          return this.finishToken(types.jsxTagStart);
                        }

                        return this.getTokenFromCode(ch);
                      }

                      out += this.input.slice(chunkStart, this.state.pos);
                      return this.finishToken(types.jsxText, out);

                    case 38:
                      out += this.input.slice(chunkStart, this.state.pos);
                      out += this.jsxReadEntity();
                      chunkStart = this.state.pos;
                      break;

                    default:
                      if (isNewLine(ch)) {
                        out += this.input.slice(chunkStart, this.state.pos);
                        out += this.jsxReadNewLine(true);
                        chunkStart = this.state.pos;
                      } else {
                        ++this.state.pos;
                      }
                  }
                }
              };

              _proto.jsxReadNewLine = function jsxReadNewLine(normalizeCRLF) {
                var ch = this.input.charCodeAt(this.state.pos);
                var out;
                ++this.state.pos;

                if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
                  ++this.state.pos;
                  out = normalizeCRLF ? "\n" : "\r\n";
                } else {
                  out = String.fromCharCode(ch);
                }

                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                return out;
              };

              _proto.jsxReadString = function jsxReadString(quote) {
                var out = "";
                var chunkStart = ++this.state.pos;

                for (;;) {
                  if (this.state.pos >= this.input.length) {
                    this.raise(
                      this.state.start,
                      "Unterminated string constant"
                    );
                  }

                  var ch = this.input.charCodeAt(this.state.pos);
                  if (ch === quote) break;

                  if (ch === 38) {
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadEntity();
                    chunkStart = this.state.pos;
                  } else if (isNewLine(ch)) {
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadNewLine(false);
                    chunkStart = this.state.pos;
                  } else {
                    ++this.state.pos;
                  }
                }

                out += this.input.slice(chunkStart, this.state.pos++);
                return this.finishToken(types.string, out);
              };

              _proto.jsxReadEntity = function jsxReadEntity() {
                var str = "";
                var count = 0;
                var entity;
                var ch = this.input[this.state.pos];
                var startPos = ++this.state.pos;

                while (this.state.pos < this.input.length && count++ < 10) {
                  ch = this.input[this.state.pos++];

                  if (ch === ";") {
                    if (str[0] === "#") {
                      if (str[1] === "x") {
                        str = str.substr(2);

                        if (HEX_NUMBER.test(str)) {
                          entity = String.fromCodePoint(parseInt(str, 16));
                        }
                      } else {
                        str = str.substr(1);

                        if (DECIMAL_NUMBER.test(str)) {
                          entity = String.fromCodePoint(parseInt(str, 10));
                        }
                      }
                    } else {
                      entity = entities[str];
                    }

                    break;
                  }

                  str += ch;
                }

                if (!entity) {
                  this.state.pos = startPos;
                  return "&";
                }

                return entity;
              };

              _proto.jsxReadWord = function jsxReadWord() {
                var ch;
                var start = this.state.pos;

                do {
                  ch = this.input.charCodeAt(++this.state.pos);
                } while (isIdentifierChar(ch) || ch === 45);

                return this.finishToken(
                  types.jsxName,
                  this.input.slice(start, this.state.pos)
                );
              };

              _proto.jsxParseIdentifier = function jsxParseIdentifier() {
                var node = this.startNode();

                if (this.match(types.jsxName)) {
                  node.name = this.state.value;
                } else if (this.state.type.keyword) {
                  node.name = this.state.type.keyword;
                } else {
                  this.unexpected();
                }

                this.next();
                return this.finishNode(node, "JSXIdentifier");
              };

              _proto.jsxParseNamespacedName = function jsxParseNamespacedName() {
                var startPos = this.state.start;
                var startLoc = this.state.startLoc;
                var name = this.jsxParseIdentifier();
                if (!this.eat(types.colon)) return name;
                var node = this.startNodeAt(startPos, startLoc);
                node.namespace = name;
                node.name = this.jsxParseIdentifier();
                return this.finishNode(node, "JSXNamespacedName");
              };

              _proto.jsxParseElementName = function jsxParseElementName() {
                var startPos = this.state.start;
                var startLoc = this.state.startLoc;
                var node = this.jsxParseNamespacedName();

                while (this.eat(types.dot)) {
                  var newNode = this.startNodeAt(startPos, startLoc);
                  newNode.object = node;
                  newNode.property = this.jsxParseIdentifier();
                  node = this.finishNode(newNode, "JSXMemberExpression");
                }

                return node;
              };

              _proto.jsxParseAttributeValue = function jsxParseAttributeValue() {
                var node;

                switch (this.state.type) {
                  case types.braceL:
                    node = this.jsxParseExpressionContainer();

                    if (node.expression.type === "JSXEmptyExpression") {
                      throw this.raise(
                        node.start,
                        "JSX attributes must only be assigned a non-empty expression"
                      );
                    } else {
                      return node;
                    }

                  case types.jsxTagStart:
                  case types.string:
                    return this.parseExprAtom();

                  default:
                    throw this.raise(
                      this.state.start,
                      "JSX value should be either an expression or a quoted JSX text"
                    );
                }
              };

              _proto.jsxParseEmptyExpression = function jsxParseEmptyExpression() {
                var node = this.startNodeAt(
                  this.state.lastTokEnd,
                  this.state.lastTokEndLoc
                );
                return this.finishNodeAt(
                  node,
                  "JSXEmptyExpression",
                  this.state.start,
                  this.state.startLoc
                );
              };

              _proto.jsxParseSpreadChild = function jsxParseSpreadChild() {
                var node = this.startNode();
                this.expect(types.braceL);
                this.expect(types.ellipsis);
                node.expression = this.parseExpression();
                this.expect(types.braceR);
                return this.finishNode(node, "JSXSpreadChild");
              };

              _proto.jsxParseExpressionContainer = function jsxParseExpressionContainer() {
                var node = this.startNode();
                this.next();

                if (this.match(types.braceR)) {
                  node.expression = this.jsxParseEmptyExpression();
                } else {
                  node.expression = this.parseExpression();
                }

                this.expect(types.braceR);
                return this.finishNode(node, "JSXExpressionContainer");
              };

              _proto.jsxParseAttribute = function jsxParseAttribute() {
                var node = this.startNode();

                if (this.eat(types.braceL)) {
                  this.expect(types.ellipsis);
                  node.argument = this.parseMaybeAssign();
                  this.expect(types.braceR);
                  return this.finishNode(node, "JSXSpreadAttribute");
                }

                node.name = this.jsxParseNamespacedName();
                node.value = this.eat(types.eq)
                  ? this.jsxParseAttributeValue()
                  : null;
                return this.finishNode(node, "JSXAttribute");
              };

              _proto.jsxParseOpeningElementAt = function jsxParseOpeningElementAt(
                startPos,
                startLoc
              ) {
                var node = this.startNodeAt(startPos, startLoc);

                if (this.match(types.jsxTagEnd)) {
                  this.expect(types.jsxTagEnd);
                  return this.finishNode(node, "JSXOpeningFragment");
                }

                node.name = this.jsxParseElementName();
                return this.jsxParseOpeningElementAfterName(node);
              };

              _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(
                node
              ) {
                var attributes = [];

                while (
                  !this.match(types.slash) &&
                  !this.match(types.jsxTagEnd)
                ) {
                  attributes.push(this.jsxParseAttribute());
                }

                node.attributes = attributes;
                node.selfClosing = this.eat(types.slash);
                this.expect(types.jsxTagEnd);
                return this.finishNode(node, "JSXOpeningElement");
              };

              _proto.jsxParseClosingElementAt = function jsxParseClosingElementAt(
                startPos,
                startLoc
              ) {
                var node = this.startNodeAt(startPos, startLoc);

                if (this.match(types.jsxTagEnd)) {
                  this.expect(types.jsxTagEnd);
                  return this.finishNode(node, "JSXClosingFragment");
                }

                node.name = this.jsxParseElementName();
                this.expect(types.jsxTagEnd);
                return this.finishNode(node, "JSXClosingElement");
              };

              _proto.jsxParseElementAt = function jsxParseElementAt(
                startPos,
                startLoc
              ) {
                var node = this.startNodeAt(startPos, startLoc);
                var children = [];
                var openingElement = this.jsxParseOpeningElementAt(
                  startPos,
                  startLoc
                );
                var closingElement = null;

                if (!openingElement.selfClosing) {
                  contents: for (;;) {
                    switch (this.state.type) {
                      case types.jsxTagStart:
                        startPos = this.state.start;
                        startLoc = this.state.startLoc;
                        this.next();

                        if (this.eat(types.slash)) {
                          closingElement = this.jsxParseClosingElementAt(
                            startPos,
                            startLoc
                          );
                          break contents;
                        }

                        children.push(
                          this.jsxParseElementAt(startPos, startLoc)
                        );
                        break;

                      case types.jsxText:
                        children.push(this.parseExprAtom());
                        break;

                      case types.braceL:
                        if (this.lookahead().type === types.ellipsis) {
                          children.push(this.jsxParseSpreadChild());
                        } else {
                          children.push(this.jsxParseExpressionContainer());
                        }

                        break;

                      default:
                        throw this.unexpected();
                    }
                  }

                  if (
                    isFragment(openingElement) &&
                    !isFragment(closingElement)
                  ) {
                    this.raise(
                      closingElement.start,
                      "Expected corresponding JSX closing tag for <>"
                    );
                  } else if (
                    !isFragment(openingElement) &&
                    isFragment(closingElement)
                  ) {
                    this.raise(
                      closingElement.start,
                      "Expected corresponding JSX closing tag for <" +
                        getQualifiedJSXName(openingElement.name) +
                        ">"
                    );
                  } else if (
                    !isFragment(openingElement) &&
                    !isFragment(closingElement)
                  ) {
                    if (
                      getQualifiedJSXName(closingElement.name) !==
                      getQualifiedJSXName(openingElement.name)
                    ) {
                      this.raise(
                        closingElement.start,
                        "Expected corresponding JSX closing tag for <" +
                          getQualifiedJSXName(openingElement.name) +
                          ">"
                      );
                    }
                  }
                }

                if (isFragment(openingElement)) {
                  node.openingFragment = openingElement;
                  node.closingFragment = closingElement;
                } else {
                  node.openingElement = openingElement;
                  node.closingElement = closingElement;
                }

                node.children = children;

                if (this.match(types.relational) && this.state.value === "<") {
                  this.raise(
                    this.state.start,
                    "Adjacent JSX elements must be wrapped in an enclosing tag. " +
                      "Did you want a JSX fragment <>...</>?"
                  );
                }

                return isFragment(openingElement)
                  ? this.finishNode(node, "JSXFragment")
                  : this.finishNode(node, "JSXElement");
              };

              _proto.jsxParseElement = function jsxParseElement() {
                var startPos = this.state.start;
                var startLoc = this.state.startLoc;
                this.next();
                return this.jsxParseElementAt(startPos, startLoc);
              };

              _proto.parseExprAtom = function parseExprAtom(
                refShortHandDefaultPos
              ) {
                if (this.match(types.jsxText)) {
                  return this.parseLiteral(this.state.value, "JSXText");
                } else if (this.match(types.jsxTagStart)) {
                  return this.jsxParseElement();
                } else {
                  return _superClass.prototype.parseExprAtom.call(
                    this,
                    refShortHandDefaultPos
                  );
                }
              };

              _proto.readToken = function readToken(code) {
                if (this.state.inPropertyName)
                  return _superClass.prototype.readToken.call(this, code);
                var context = this.curContext();

                if (context === types$1.j_expr) {
                  return this.jsxReadToken();
                }

                if (context === types$1.j_oTag || context === types$1.j_cTag) {
                  if (isIdentifierStart(code)) {
                    return this.jsxReadWord();
                  }

                  if (code === 62) {
                    ++this.state.pos;
                    return this.finishToken(types.jsxTagEnd);
                  }

                  if (
                    (code === 34 || code === 39) &&
                    context === types$1.j_oTag
                  ) {
                    return this.jsxReadString(code);
                  }
                }

                if (code === 60 && this.state.exprAllowed) {
                  ++this.state.pos;
                  return this.finishToken(types.jsxTagStart);
                }

                return _superClass.prototype.readToken.call(this, code);
              };

              _proto.updateContext = function updateContext(prevType) {
                if (this.match(types.braceL)) {
                  var curContext = this.curContext();

                  if (curContext === types$1.j_oTag) {
                    this.state.context.push(types$1.braceExpression);
                  } else if (curContext === types$1.j_expr) {
                    this.state.context.push(types$1.templateQuasi);
                  } else {
                    _superClass.prototype.updateContext.call(this, prevType);
                  }

                  this.state.exprAllowed = true;
                } else if (
                  this.match(types.slash) &&
                  prevType === types.jsxTagStart
                ) {
                  this.state.context.length -= 2;
                  this.state.context.push(types$1.j_cTag);
                  this.state.exprAllowed = false;
                } else {
                  return _superClass.prototype.updateContext.call(
                    this,
                    prevType
                  );
                }
              };

              return _class;
            })(superClass);
          };

          var defaultOptions = {
            sourceType: "script",
            sourceFilename: undefined,
            startLine: 1,
            allowAwaitOutsideFunction: false,
            allowReturnOutsideFunction: false,
            allowImportExportEverywhere: false,
            allowSuperOutsideMethod: false,
            plugins: [],
            strictMode: null,
            ranges: false,
            tokens: false,
            jisonVariables: false,
          };

          function getOptions(opts) {
            var options = {};

            for (var key in defaultOptions) {
              options[key] =
                opts && opts[key] != null ? opts[key] : defaultOptions[key];
            }

            return options;
          }

          var Position = function Position(line, col) {
            this.line = line;
            this.column = col;
          };

          var SourceLocation = function SourceLocation(start, end) {
            this.start = start;
            this.end = end;
          };

          function getLineInfo(input, offset) {
            var line = 1;
            var lineStart = 0;
            var match;
            lineBreakG.lastIndex = 0;

            while ((match = lineBreakG.exec(input)) && match.index < offset) {
              line++;
              lineStart = lineBreakG.lastIndex;
            }

            return new Position(line, offset - lineStart);
          }

          var BaseParser = (function() {
            function BaseParser() {
              this.sawUnambiguousESM = false;
            }

            var _proto = BaseParser.prototype;

            _proto.isReservedWord = function isReservedWord(word) {
              if (word === "await") {
                return this.inModule;
              } else {
                return reservedWords[6](word);
              }
            };

            _proto.hasPlugin = function hasPlugin(name) {
              return Object.hasOwnProperty.call(this.plugins, name);
            };

            _proto.getPluginOption = function getPluginOption(plugin, name) {
              if (this.hasPlugin(plugin)) return this.plugins[plugin][name];
            };

            return BaseParser;
          })();

          function last(stack) {
            return stack[stack.length - 1];
          }

          var CommentsParser = (function(_BaseParser) {
            _inheritsLoose(CommentsParser, _BaseParser);

            function CommentsParser() {
              return _BaseParser.apply(this, arguments) || this;
            }

            var _proto = CommentsParser.prototype;

            _proto.addComment = function addComment(comment) {
              if (this.filename) comment.loc.filename = this.filename;
              this.state.trailingComments.push(comment);
              this.state.leadingComments.push(comment);
            };

            _proto.processComment = function processComment(node) {
              if (node.type === "Program" && node.body.length > 0) return;
              var stack = this.state.commentStack;
              var firstChild, lastChild, trailingComments, i, j;

              if (this.state.trailingComments.length > 0) {
                if (this.state.trailingComments[0].start >= node.end) {
                  trailingComments = this.state.trailingComments;
                  this.state.trailingComments = [];
                } else {
                  this.state.trailingComments.length = 0;
                }
              } else if (stack.length > 0) {
                var lastInStack = last(stack);

                if (
                  lastInStack.trailingComments &&
                  lastInStack.trailingComments[0].start >= node.end
                ) {
                  trailingComments = lastInStack.trailingComments;
                  delete lastInStack.trailingComments;
                }
              }

              if (stack.length > 0 && last(stack).start >= node.start) {
                firstChild = stack.pop();
              }

              while (stack.length > 0 && last(stack).start >= node.start) {
                lastChild = stack.pop();
              }

              if (!lastChild && firstChild) lastChild = firstChild;

              if (firstChild && this.state.leadingComments.length > 0) {
                var lastComment = last(this.state.leadingComments);

                if (firstChild.type === "ObjectProperty") {
                  if (lastComment.start >= node.start) {
                    if (this.state.commentPreviousNode) {
                      for (j = 0; j < this.state.leadingComments.length; j++) {
                        if (
                          this.state.leadingComments[j].end <
                          this.state.commentPreviousNode.end
                        ) {
                          this.state.leadingComments.splice(j, 1);
                          j--;
                        }
                      }

                      if (this.state.leadingComments.length > 0) {
                        firstChild.trailingComments = this.state.leadingComments;
                        this.state.leadingComments = [];
                      }
                    }
                  }
                } else if (
                  node.type === "CallExpression" &&
                  node.arguments &&
                  node.arguments.length
                ) {
                  var lastArg = last(node.arguments);

                  if (
                    lastArg &&
                    lastComment.start >= lastArg.start &&
                    lastComment.end <= node.end
                  ) {
                    if (this.state.commentPreviousNode) {
                      for (j = 0; j < this.state.leadingComments.length; j++) {
                        if (
                          this.state.leadingComments[j].end <
                          this.state.commentPreviousNode.end
                        ) {
                          this.state.leadingComments.splice(j, 1);
                          j--;
                        }
                      }

                      if (this.state.leadingComments.length > 0) {
                        lastArg.trailingComments = this.state.leadingComments;
                        this.state.leadingComments = [];
                      }
                    }
                  }
                }
              }

              if (lastChild) {
                if (lastChild.leadingComments) {
                  if (
                    lastChild !== node &&
                    lastChild.leadingComments.length > 0 &&
                    last(lastChild.leadingComments).end <= node.start
                  ) {
                    node.leadingComments = lastChild.leadingComments;
                    delete lastChild.leadingComments;
                  } else {
                    for (
                      i = lastChild.leadingComments.length - 2;
                      i >= 0;
                      --i
                    ) {
                      if (lastChild.leadingComments[i].end <= node.start) {
                        node.leadingComments = lastChild.leadingComments.splice(
                          0,
                          i + 1
                        );
                        break;
                      }
                    }
                  }
                }
              } else if (this.state.leadingComments.length > 0) {
                if (last(this.state.leadingComments).end <= node.start) {
                  if (this.state.commentPreviousNode) {
                    for (j = 0; j < this.state.leadingComments.length; j++) {
                      if (
                        this.state.leadingComments[j].end <
                        this.state.commentPreviousNode.end
                      ) {
                        this.state.leadingComments.splice(j, 1);
                        j--;
                      }
                    }
                  }

                  if (this.state.leadingComments.length > 0) {
                    node.leadingComments = this.state.leadingComments;
                    this.state.leadingComments = [];
                  }
                } else {
                  for (i = 0; i < this.state.leadingComments.length; i++) {
                    if (this.state.leadingComments[i].end > node.start) {
                      break;
                    }
                  }

                  var leadingComments = this.state.leadingComments.slice(0, i);

                  if (leadingComments.length) {
                    node.leadingComments = leadingComments;
                  }

                  trailingComments = this.state.leadingComments.slice(i);

                  if (trailingComments.length === 0) {
                    trailingComments = null;
                  }
                }
              }

              this.state.commentPreviousNode = node;

              if (trailingComments) {
                if (
                  trailingComments.length &&
                  trailingComments[0].start >= node.start &&
                  last(trailingComments).end <= node.end
                ) {
                  node.innerComments = trailingComments;
                } else {
                  node.trailingComments = trailingComments;
                }
              }

              stack.push(node);
            };

            return CommentsParser;
          })(BaseParser);

          var LocationParser = (function(_CommentsParser) {
            _inheritsLoose(LocationParser, _CommentsParser);

            function LocationParser() {
              return _CommentsParser.apply(this, arguments) || this;
            }

            var _proto = LocationParser.prototype;

            _proto.raise = function raise(pos, message, _temp) {
              var _ref = _temp === void 0 ? {} : _temp,
                missingPluginNames = _ref.missingPluginNames,
                code = _ref.code;

              var loc = getLineInfo(this.input, pos);
              message += " (" + loc.line + ":" + loc.column + ")";
              var err = new SyntaxError(message);
              err.pos = pos;
              err.loc = loc;

              if (missingPluginNames) {
                err.missingPlugin = missingPluginNames;
              }

              if (code !== undefined) {
                err.code = code;
              }

              throw err;
            };

            return LocationParser;
          })(CommentsParser);

          var State = (function() {
            function State() {}

            var _proto = State.prototype;

            _proto.init = function init(options, input) {
              this.strict =
                options.strictMode === false
                  ? false
                  : options.sourceType === "module";
              this.input = input;
              this.potentialArrowAt = -1;
              this.noArrowAt = [];
              this.noArrowParamsConversionAt = [];
              this.inMethod = false;
              this.inFunction = false;
              this.inParameters = false;
              this.maybeInArrowParameters = false;
              this.inGenerator = false;
              this.inAsync = false;
              this.inPropertyName = false;
              this.inType = false;
              this.inClassProperty = false;
              this.noAnonFunctionType = false;
              this.hasFlowComment = false;
              this.isIterator = false;
              this.classLevel = 0;
              this.labels = [];
              this.decoratorStack = [[]];
              this.yieldInPossibleArrowParameters = null;
              this.tokens = [];
              this.comments = [];
              this.trailingComments = [];
              this.leadingComments = [];
              this.commentStack = [];
              this.commentPreviousNode = null;
              this.pos = this.lineStart = 0;
              this.curLine = options.startLine;
              this.type = types.eof;
              this.value = null;
              this.start = this.end = this.pos;
              this.startLoc = this.endLoc = this.curPosition();
              this.lastTokEndLoc = this.lastTokStartLoc = null;
              this.lastTokStart = this.lastTokEnd = this.pos;
              this.context = [types$1.braceStatement];
              this.exprAllowed = true;
              this.containsEsc = this.containsOctal = false;
              this.octalPosition = null;
              this.invalidTemplateEscapePosition = null;
              this.exportedIdentifiers = [];
            };

            _proto.curPosition = function curPosition() {
              return new Position(this.curLine, this.pos - this.lineStart);
            };

            _proto.clone = function clone(skipArrays) {
              var _this = this;

              var state = new State();
              Object.keys(this).forEach(function(key) {
                var val = _this[key];

                if ((!skipArrays || key === "context") && Array.isArray(val)) {
                  val = val.slice();
                }

                state[key] = val;
              });
              return state;
            };

            return State;
          })();

          var _isDigit = function isDigit(code) {
            return code >= 48 && code <= 57;
          };

          var VALID_REGEX_FLAGS = "gmsiyu";
          var forbiddenNumericSeparatorSiblings = {
            decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
            hex: [46, 88, 95, 120],
          };
          var allowedNumericSeparatorSiblings = {};
          allowedNumericSeparatorSiblings.bin = [48, 49];
          allowedNumericSeparatorSiblings.oct = allowedNumericSeparatorSiblings.bin.concat(
            [50, 51, 52, 53, 54, 55]
          );
          allowedNumericSeparatorSiblings.dec = allowedNumericSeparatorSiblings.oct.concat(
            [56, 57]
          );
          allowedNumericSeparatorSiblings.hex = allowedNumericSeparatorSiblings.dec.concat(
            [65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]
          );

          var Token = function Token(state) {
            this.type = state.type;
            this.value = state.value;
            this.start = state.start;
            this.end = state.end;
            this.loc = new SourceLocation(state.startLoc, state.endLoc);
          };

          var Tokenizer = (function(_LocationParser) {
            _inheritsLoose(Tokenizer, _LocationParser);

            function Tokenizer(options, input) {
              var _this;

              _this = _LocationParser.call(this) || this;
              _this.state = new State();

              _this.state.init(options, input);

              _this.isLookahead = false;
              return _this;
            }

            var _proto = Tokenizer.prototype;

            _proto.next = function next() {
              if (this.options.tokens && !this.isLookahead) {
                this.state.tokens.push(new Token(this.state));
              }

              this.state.lastTokEnd = this.state.end;
              this.state.lastTokStart = this.state.start;
              this.state.lastTokEndLoc = this.state.endLoc;
              this.state.lastTokStartLoc = this.state.startLoc;
              this.nextToken();
            };

            _proto.eat = function eat(type) {
              if (this.match(type)) {
                this.next();
                return true;
              } else {
                return false;
              }
            };

            _proto.match = function match(type) {
              return this.state.type === type;
            };

            _proto.isKeyword = function isKeyword$$1(word) {
              return isKeyword(word);
            };

            _proto.lookahead = function lookahead() {
              var old = this.state;
              this.state = old.clone(true);
              this.isLookahead = true;
              this.next();
              this.isLookahead = false;
              var curr = this.state;
              this.state = old;
              return curr;
            };

            _proto.setStrict = function setStrict(strict) {
              this.state.strict = strict;
              if (!this.match(types.num) && !this.match(types.string)) return;
              this.state.pos = this.state.start;

              while (this.state.pos < this.state.lineStart) {
                this.state.lineStart =
                  this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
                --this.state.curLine;
              }

              this.nextToken();
            };

            _proto.curContext = function curContext() {
              return this.state.context[this.state.context.length - 1];
            };

            _proto.nextToken = function nextToken() {
              var curContext = this.curContext();
              if (!curContext || !curContext.preserveSpace) this.skipSpace();
              this.state.containsOctal = false;
              this.state.octalPosition = null;
              this.state.start = this.state.pos;
              this.state.startLoc = this.state.curPosition();

              if (this.state.pos >= this.input.length) {
                this.finishToken(types.eof);
                return;
              }

              if (curContext.override) {
                curContext.override(this);
              } else {
                this.readToken(this.input.codePointAt(this.state.pos));
              }
            };

            _proto.readToken = function readToken(code) {
              if (
                this.options.jisonVariables &&
                !this.state.isIterator &&
                !this.state.inType &&
                (code === 35 || code === 64 || code === 36)
              ) {
                var type = types.name;
                var chunkStart = this.state.pos;

                for (;;) {
                  var ch = this.input.charCodeAt(this.state.pos);

                  if (ch === code) {
                    this.state.pos++;
                  } else {
                    break;
                  }
                }

                var code1 = this.input.charCodeAt(this.state.pos);

                if (code1 === 45) {
                  var code2 = this.input.charCodeAt(this.state.pos + 1);

                  if (code2 >= 0x30 && code2 <= 0x39) {
                    this.state.pos++;
                  }
                }

                var identifierStart = this.state.pos;
                this.readWord1();

                if (this.state.pos === identifierStart && code !== 36) {
                  this.raise(
                    chunkStart,
                    "Invalid JISON identifier " +
                      this.input.slice(chunkStart, this.state.pos)
                  );
                }

                for (;;) {
                  var _ch = this.input.charCodeAt(this.state.pos);

                  if (_ch === code) {
                    this.state.pos++;
                  } else {
                    break;
                  }
                }

                var word = this.input.slice(chunkStart, this.state.pos);
                this.finishToken(type, word);
              } else if (isIdentifierStart(code) || code === 92) {
                this.readWord();
              } else {
                this.getTokenFromCode(code);
              }
            };

            _proto.pushComment = function pushComment(
              block,
              text,
              start,
              end,
              startLoc,
              endLoc
            ) {
              var comment = {
                type: block ? "CommentBlock" : "CommentLine",
                value: text,
                start: start,
                end: end,
                loc: new SourceLocation(startLoc, endLoc),
              };

              if (!this.isLookahead) {
                if (this.options.tokens) this.state.tokens.push(comment);
                this.state.comments.push(comment);
                this.addComment(comment);
              }
            };

            _proto.skipBlockComment = function skipBlockComment() {
              var startLoc = this.state.curPosition();
              var start = this.state.pos;
              var end = this.input.indexOf("*/", (this.state.pos += 2));
              if (end === -1)
                this.raise(this.state.pos - 2, "Unterminated comment");
              this.state.pos = end + 2;
              lineBreakG.lastIndex = start;
              var match;

              while (
                (match = lineBreakG.exec(this.input)) &&
                match.index < this.state.pos
              ) {
                ++this.state.curLine;
                this.state.lineStart = match.index + match[0].length;
              }

              this.pushComment(
                true,
                this.input.slice(start + 2, end),
                start,
                this.state.pos,
                startLoc,
                this.state.curPosition()
              );
            };

            _proto.skipLineComment = function skipLineComment(startSkip) {
              var start = this.state.pos;
              var startLoc = this.state.curPosition();
              var ch = this.input.charCodeAt((this.state.pos += startSkip));

              if (this.state.pos < this.input.length) {
                while (
                  ch !== 10 &&
                  ch !== 13 &&
                  ch !== 8232 &&
                  ch !== 8233 &&
                  ++this.state.pos < this.input.length
                ) {
                  ch = this.input.charCodeAt(this.state.pos);
                }
              }

              this.pushComment(
                false,
                this.input.slice(start + startSkip, this.state.pos),
                start,
                this.state.pos,
                startLoc,
                this.state.curPosition()
              );
            };

            _proto.skipSpace = function skipSpace() {
              loop: while (this.state.pos < this.input.length) {
                var ch = this.input.charCodeAt(this.state.pos);

                switch (ch) {
                  case 13:
                    if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                      ++this.state.pos;
                    }

                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos;
                    ++this.state.curLine;
                    this.state.lineStart = this.state.pos;
                    break;

                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42:
                        this.skipBlockComment();
                        break;

                      case 47:
                        this.skipLineComment(2);
                        break;

                      default:
                        break loop;
                    }

                    break;

                  default:
                    if (isWhitespace(ch)) {
                      ++this.state.pos;
                    } else {
                      break loop;
                    }
                }
              }
            };

            _proto.finishToken = function finishToken(type, val) {
              this.state.end = this.state.pos;
              this.state.endLoc = this.state.curPosition();
              var prevType = this.state.type;
              this.state.type = type;
              this.state.value = val;
              this.updateContext(prevType);
            };

            _proto.readToken_dot = function readToken_dot() {
              var next = this.input.charCodeAt(this.state.pos + 1);

              if (next >= 48 && next <= 57) {
                this.readNumber(true);
                return;
              }

              var next2 = this.input.charCodeAt(this.state.pos + 2);

              if (next === 46 && next2 === 46) {
                this.state.pos += 3;
                this.finishToken(types.ellipsis);
              } else {
                ++this.state.pos;
                this.finishToken(types.dot);
              }
            };

            _proto.readToken_slash = function readToken_slash() {
              if (this.state.exprAllowed && !this.state.inType) {
                ++this.state.pos;
                this.readRegexp();
                return;
              }

              var next = this.input.charCodeAt(this.state.pos + 1);

              if (next === 61) {
                this.finishOp(types.assign, 2);
              } else {
                this.finishOp(types.slash, 1);
              }
            };

            _proto.readToken_interpreter = function readToken_interpreter() {
              if (this.state.pos !== 0 || this.state.input.length < 2)
                return false;
              var start = this.state.pos;
              this.state.pos += 1;
              var ch = this.input.charCodeAt(this.state.pos);
              if (ch !== 33) return false;

              while (
                ch !== 10 &&
                ch !== 13 &&
                ch !== 8232 &&
                ch !== 8233 &&
                ++this.state.pos < this.input.length
              ) {
                ch = this.input.charCodeAt(this.state.pos);
              }

              var value = this.input.slice(start + 2, this.state.pos);
              this.finishToken(types.interpreterDirective, value);
              return true;
            };

            _proto.readToken_mult_modulo = function readToken_mult_modulo(
              code
            ) {
              var type = code === 42 ? types.star : types.modulo;
              var width = 1;
              var next = this.input.charCodeAt(this.state.pos + 1);
              var exprAllowed = this.state.exprAllowed;

              if (code === 42 && next === 42) {
                width++;
                next = this.input.charCodeAt(this.state.pos + 2);
                type = types.exponent;
              }

              if (next === 61 && !exprAllowed) {
                width++;
                type = types.assign;
              }

              this.finishOp(type, width);
            };

            _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
              var next = this.input.charCodeAt(this.state.pos + 1);

              if (next === code) {
                if (this.input.charCodeAt(this.state.pos + 2) === 61) {
                  this.finishOp(types.assign, 3);
                } else {
                  this.finishOp(
                    code === 124 ? types.logicalOR : types.logicalAND,
                    2
                  );
                }

                return;
              }

              if (code === 124) {
                if (next === 62) {
                  this.finishOp(types.pipeline, 2);
                  return;
                } else if (next === 125 && this.hasPlugin("flow")) {
                  this.finishOp(types.braceBarR, 2);
                  return;
                }
              }

              if (next === 61) {
                this.finishOp(types.assign, 2);
                return;
              }

              this.finishOp(
                code === 124 ? types.bitwiseOR : types.bitwiseAND,
                1
              );
            };

            _proto.readToken_caret = function readToken_caret() {
              var next = this.input.charCodeAt(this.state.pos + 1);

              if (next === 61) {
                this.finishOp(types.assign, 2);
              } else {
                this.finishOp(types.bitwiseXOR, 1);
              }
            };

            _proto.readToken_plus_min = function readToken_plus_min(code) {
              var next = this.input.charCodeAt(this.state.pos + 1);

              if (next === code) {
                if (
                  next === 45 &&
                  !this.inModule &&
                  this.input.charCodeAt(this.state.pos + 2) === 62 &&
                  lineBreak.test(
                    this.input.slice(this.state.lastTokEnd, this.state.pos)
                  )
                ) {
                  this.skipLineComment(3);
                  this.skipSpace();
                  this.nextToken();
                  return;
                }

                this.finishOp(types.incDec, 2);
                return;
              }

              if (next === 61) {
                this.finishOp(types.assign, 2);
              } else {
                this.finishOp(types.plusMin, 1);
              }
            };

            _proto.readToken_lt_gt = function readToken_lt_gt(code) {
              var next = this.input.charCodeAt(this.state.pos + 1);
              var size = 1;

              if (next === code) {
                size =
                  code === 62 &&
                  this.input.charCodeAt(this.state.pos + 2) === 62
                    ? 3
                    : 2;

                if (this.input.charCodeAt(this.state.pos + size) === 61) {
                  this.finishOp(types.assign, size + 1);
                  return;
                }

                this.finishOp(types.bitShift, size);
                return;
              }

              if (
                next === 33 &&
                code === 60 &&
                !this.inModule &&
                this.input.charCodeAt(this.state.pos + 2) === 45 &&
                this.input.charCodeAt(this.state.pos + 3) === 45
              ) {
                this.skipLineComment(4);
                this.skipSpace();
                this.nextToken();
                return;
              }

              if (next === 61) {
                size = 2;
              }

              this.finishOp(types.relational, size);
            };

            _proto.readToken_eq_excl = function readToken_eq_excl(code) {
              var next = this.input.charCodeAt(this.state.pos + 1);

              if (next === 61) {
                this.finishOp(
                  types.equality,
                  this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2
                );
                return;
              }

              if (code === 61 && next === 62) {
                this.state.pos += 2;
                this.finishToken(types.arrow);
                return;
              }

              this.finishOp(code === 61 ? types.eq : types.bang, 1);
            };

            _proto.readToken_question = function readToken_question() {
              var next = this.input.charCodeAt(this.state.pos + 1);
              var next2 = this.input.charCodeAt(this.state.pos + 2);

              if (next === 63 && !this.state.inType) {
                if (next2 === 61) {
                  this.finishOp(types.assign, 3);
                } else {
                  this.finishOp(types.nullishCoalescing, 2);
                }
              } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
                this.state.pos += 2;
                this.finishToken(types.questionDot);
              } else {
                ++this.state.pos;
                this.finishToken(types.question);
              }
            };

            _proto.getTokenFromCode = function getTokenFromCode(code) {
              switch (code) {
                case 35:
                  if (this.state.pos === 0 && this.readToken_interpreter()) {
                    return;
                  }

                  if (
                    (this.hasPlugin("classPrivateProperties") ||
                      this.hasPlugin("classPrivateMethods")) &&
                    this.state.classLevel > 0
                  ) {
                    ++this.state.pos;
                    this.finishToken(types.hash);
                    return;
                  } else {
                    this.raise(
                      this.state.pos,
                      "Unexpected character '" +
                        String.fromCodePoint(code) +
                        "'"
                    );
                  }

                case 46:
                  this.readToken_dot();
                  return;

                case 40:
                  ++this.state.pos;
                  this.finishToken(types.parenL);
                  return;

                case 41:
                  ++this.state.pos;
                  this.finishToken(types.parenR);
                  return;

                case 59:
                  ++this.state.pos;
                  this.finishToken(types.semi);
                  return;

                case 44:
                  ++this.state.pos;
                  this.finishToken(types.comma);
                  return;

                case 91:
                  ++this.state.pos;
                  this.finishToken(types.bracketL);
                  return;

                case 93:
                  ++this.state.pos;
                  this.finishToken(types.bracketR);
                  return;

                case 123:
                  if (
                    this.hasPlugin("flow") &&
                    this.input.charCodeAt(this.state.pos + 1) === 124
                  ) {
                    this.finishOp(types.braceBarL, 2);
                  } else {
                    ++this.state.pos;
                    this.finishToken(types.braceL);
                  }

                  return;

                case 125:
                  ++this.state.pos;
                  this.finishToken(types.braceR);
                  return;

                case 58:
                  if (
                    this.hasPlugin("functionBind") &&
                    this.input.charCodeAt(this.state.pos + 1) === 58
                  ) {
                    this.finishOp(types.doubleColon, 2);
                  } else {
                    ++this.state.pos;
                    this.finishToken(types.colon);
                  }

                  return;

                case 63:
                  this.readToken_question();
                  return;

                case 64:
                  ++this.state.pos;
                  this.finishToken(types.at);
                  return;

                case 96:
                  ++this.state.pos;
                  this.finishToken(types.backQuote);
                  return;

                case 48: {
                  var next = this.input.charCodeAt(this.state.pos + 1);

                  if (next === 120 || next === 88) {
                    this.readRadixNumber(16);
                    return;
                  }

                  if (next === 111 || next === 79) {
                    this.readRadixNumber(8);
                    return;
                  }

                  if (next === 98 || next === 66) {
                    this.readRadixNumber(2);
                    return;
                  }
                }

                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  this.readNumber(false);
                  return;

                case 34:
                case 39:
                  this.readString(code);
                  return;

                case 47:
                  this.readToken_slash();
                  return;

                case 37:
                case 42:
                  this.readToken_mult_modulo(code);
                  return;

                case 124:
                case 38:
                  this.readToken_pipe_amp(code);
                  return;

                case 94:
                  this.readToken_caret();
                  return;

                case 43:
                case 45:
                  this.readToken_plus_min(code);
                  return;

                case 60:
                case 62:
                  this.readToken_lt_gt(code);
                  return;

                case 61:
                case 33:
                  this.readToken_eq_excl(code);
                  return;

                case 126:
                  this.finishOp(types.tilde, 1);
                  return;
              }

              this.raise(
                this.state.pos,
                "Unexpected character '" + String.fromCodePoint(code) + "'"
              );
            };

            _proto.finishOp = function finishOp(type, size) {
              var str = this.input.slice(this.state.pos, this.state.pos + size);
              this.state.pos += size;
              this.finishToken(type, str);
            };

            _proto.readRegexp = function readRegexp() {
              var start = this.state.pos;
              var escaped, inClass;

              for (;;) {
                if (this.state.pos >= this.input.length) {
                  this.raise(start, "Unterminated regular expression");
                }

                var ch = this.input.charAt(this.state.pos);

                if (lineBreak.test(ch)) {
                  this.raise(start, "Unterminated regular expression");
                }

                if (escaped) {
                  escaped = false;
                } else {
                  if (ch === "[") {
                    inClass = true;
                  } else if (ch === "]" && inClass) {
                    inClass = false;
                  } else if (ch === "/" && !inClass) {
                    break;
                  }

                  escaped = ch === "\\";
                }

                ++this.state.pos;
              }

              var content = this.input.slice(start, this.state.pos);
              ++this.state.pos;
              var mods = "";

              while (this.state.pos < this.input.length) {
                var char = this.input[this.state.pos];
                var charCode = this.input.codePointAt(this.state.pos);

                if (VALID_REGEX_FLAGS.indexOf(char) > -1) {
                  if (mods.indexOf(char) > -1) {
                    this.raise(
                      this.state.pos + 1,
                      "Duplicate regular expression flag"
                    );
                  }

                  ++this.state.pos;
                  mods += char;
                } else if (isIdentifierChar(charCode) || charCode === 92) {
                  this.raise(
                    this.state.pos + 1,
                    "Invalid regular expression flag"
                  );
                } else {
                  break;
                }
              }

              this.finishToken(types.regexp, {
                pattern: content,
                flags: mods,
              });
            };

            _proto.readInt = function readInt(radix, len) {
              var start = this.state.pos;
              var forbiddenSiblings =
                radix === 16
                  ? forbiddenNumericSeparatorSiblings.hex
                  : forbiddenNumericSeparatorSiblings.decBinOct;
              var allowedSiblings =
                radix === 16
                  ? allowedNumericSeparatorSiblings.hex
                  : radix === 10
                    ? allowedNumericSeparatorSiblings.dec
                    : radix === 8
                      ? allowedNumericSeparatorSiblings.oct
                      : allowedNumericSeparatorSiblings.bin;
              var total = 0;

              for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
                var code = this.input.charCodeAt(this.state.pos);
                var val = void 0;

                if (this.hasPlugin("numericSeparator")) {
                  var prev = this.input.charCodeAt(this.state.pos - 1);
                  var next = this.input.charCodeAt(this.state.pos + 1);

                  if (code === 95) {
                    if (allowedSiblings.indexOf(next) === -1) {
                      this.raise(this.state.pos, "Invalid or unexpected token");
                    }

                    if (
                      forbiddenSiblings.indexOf(prev) > -1 ||
                      forbiddenSiblings.indexOf(next) > -1 ||
                      Number.isNaN(next)
                    ) {
                      this.raise(this.state.pos, "Invalid or unexpected token");
                    }

                    ++this.state.pos;
                    continue;
                  }
                }

                if (code >= 97) {
                  val = code - 97 + 10;
                } else if (code >= 65) {
                  val = code - 65 + 10;
                } else if (_isDigit(code)) {
                  val = code - 48;
                } else {
                  val = Infinity;
                }

                if (val >= radix) break;
                ++this.state.pos;
                total = total * radix + val;
              }

              if (
                this.state.pos === start ||
                (len != null && this.state.pos - start !== len)
              ) {
                return null;
              }

              return total;
            };

            _proto.readRadixNumber = function readRadixNumber(radix) {
              var start = this.state.pos;
              var isBigInt = false;
              this.state.pos += 2;
              var val = this.readInt(radix);

              if (val == null) {
                this.raise(
                  this.state.start + 2,
                  "Expected number in radix " + radix
                );
              }

              if (this.hasPlugin("bigInt")) {
                if (this.input.charCodeAt(this.state.pos) === 110) {
                  ++this.state.pos;
                  isBigInt = true;
                }
              }

              if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
                this.raise(this.state.pos, "Identifier directly after number");
              }

              if (isBigInt) {
                var str = this.input
                  .slice(start, this.state.pos)
                  .replace(/[_n]/g, "");
                this.finishToken(types.bigint, str);
                return;
              }

              this.finishToken(types.num, val);
            };

            _proto.readNumber = function readNumber(startsWithDot) {
              var start = this.state.pos;
              var octal = this.input.charCodeAt(start) === 48;
              var isFloat = false;
              var isBigInt = false;

              if (!startsWithDot && this.readInt(10) === null) {
                this.raise(start, "Invalid number");
              }

              if (octal && this.state.pos == start + 1) octal = false;
              var next = this.input.charCodeAt(this.state.pos);

              if (next === 46 && !octal) {
                ++this.state.pos;
                this.readInt(10);
                isFloat = true;
                next = this.input.charCodeAt(this.state.pos);
              }

              if ((next === 69 || next === 101) && !octal) {
                next = this.input.charCodeAt(++this.state.pos);

                if (next === 43 || next === 45) {
                  ++this.state.pos;
                }

                if (this.readInt(10) === null)
                  this.raise(start, "Invalid number");
                isFloat = true;
                next = this.input.charCodeAt(this.state.pos);
              }

              if (this.hasPlugin("bigInt")) {
                if (next === 110) {
                  if (isFloat || octal)
                    this.raise(start, "Invalid BigIntLiteral");
                  ++this.state.pos;
                  isBigInt = true;
                }
              }

              if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
                this.raise(this.state.pos, "Identifier directly after number");
              }

              var str = this.input
                .slice(start, this.state.pos)
                .replace(/[_n]/g, "");

              if (isBigInt) {
                this.finishToken(types.bigint, str);
                return;
              }

              var val;

              if (isFloat) {
                val = parseFloat(str);
              } else if (!octal || str.length === 1) {
                val = parseInt(str, 10);
              } else if (this.state.strict) {
                this.raise(start, "Invalid number");
              } else if (/[89]/.test(str)) {
                val = parseInt(str, 10);
              } else {
                val = parseInt(str, 8);
              }

              this.finishToken(types.num, val);
            };

            _proto.readCodePoint = function readCodePoint(throwOnInvalid) {
              var ch = this.input.charCodeAt(this.state.pos);
              var code;

              if (ch === 123) {
                var codePos = ++this.state.pos;
                code = this.readHexChar(
                  this.input.indexOf("}", this.state.pos) - this.state.pos,
                  throwOnInvalid
                );
                ++this.state.pos;

                if (code === null) {
                  --this.state.invalidTemplateEscapePosition;
                } else if (code > 0x10ffff) {
                  if (throwOnInvalid) {
                    this.raise(codePos, "Code point out of bounds");
                  } else {
                    this.state.invalidTemplateEscapePosition = codePos - 2;
                    return null;
                  }
                }
              } else {
                code = this.readHexChar(4, throwOnInvalid);
              }

              return code;
            };

            _proto.readString = function readString(quote) {
              var out = "",
                chunkStart = ++this.state.pos;
              var hasJsonStrings = this.hasPlugin("jsonStrings");

              for (;;) {
                if (this.state.pos >= this.input.length) {
                  this.raise(this.state.start, "Unterminated string constant");
                }

                var ch = this.input.charCodeAt(this.state.pos);
                if (ch === quote) break;

                if (ch === 92) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.readEscapedChar(false);
                  chunkStart = this.state.pos;
                } else if (hasJsonStrings && (ch === 8232 || ch === 8233)) {
                  ++this.state.pos;
                } else if (isNewLine(ch)) {
                  this.raise(this.state.start, "Unterminated string constant");
                } else {
                  ++this.state.pos;
                }
              }

              out += this.input.slice(chunkStart, this.state.pos++);
              this.finishToken(types.string, out);
            };

            _proto.readTmplToken = function readTmplToken() {
              var out = "",
                chunkStart = this.state.pos,
                containsInvalid = false;

              for (;;) {
                if (this.state.pos >= this.input.length) {
                  this.raise(this.state.start, "Unterminated template");
                }

                var ch = this.input.charCodeAt(this.state.pos);

                if (
                  ch === 96 ||
                  (ch === 36 &&
                    this.input.charCodeAt(this.state.pos + 1) === 123)
                ) {
                  if (
                    this.state.pos === this.state.start &&
                    this.match(types.template)
                  ) {
                    if (ch === 36) {
                      this.state.pos += 2;
                      this.finishToken(types.dollarBraceL);
                      return;
                    } else {
                      ++this.state.pos;
                      this.finishToken(types.backQuote);
                      return;
                    }
                  }

                  out += this.input.slice(chunkStart, this.state.pos);
                  this.finishToken(
                    types.template,
                    containsInvalid ? null : out
                  );
                  return;
                }

                if (ch === 92) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  var escaped = this.readEscapedChar(true);

                  if (escaped === null) {
                    containsInvalid = true;
                  } else {
                    out += escaped;
                  }

                  chunkStart = this.state.pos;
                } else if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  ++this.state.pos;

                  switch (ch) {
                    case 13:
                      if (this.input.charCodeAt(this.state.pos) === 10) {
                        ++this.state.pos;
                      }

                    case 10:
                      out += "\n";
                      break;

                    default:
                      out += String.fromCharCode(ch);
                      break;
                  }

                  ++this.state.curLine;
                  this.state.lineStart = this.state.pos;
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }
              }
            };

            _proto.readEscapedChar = function readEscapedChar(inTemplate) {
              var throwOnInvalid = !inTemplate;
              var ch = this.input.charCodeAt(++this.state.pos);
              ++this.state.pos;

              switch (ch) {
                case 110:
                  return "\n";

                case 114:
                  return "\r";

                case 120: {
                  var code = this.readHexChar(2, throwOnInvalid);
                  return code === null ? null : String.fromCharCode(code);
                }

                case 117: {
                  var _code = this.readCodePoint(throwOnInvalid);

                  return _code === null ? null : String.fromCodePoint(_code);
                }

                case 116:
                  return "\t";

                case 98:
                  return "\b";

                case 118:
                  return "\x0B";

                case 102:
                  return "\f";

                case 13:
                  if (this.input.charCodeAt(this.state.pos) === 10) {
                    ++this.state.pos;
                  }

                case 10:
                  this.state.lineStart = this.state.pos;
                  ++this.state.curLine;
                  return "";

                default:
                  if (ch >= 48 && ch <= 55) {
                    var codePos = this.state.pos - 1;
                    var octalStr = this.input
                      .substr(this.state.pos - 1, 3)
                      .match(/^[0-7]+/)[0];
                    var octal = parseInt(octalStr, 8);

                    if (octal > 255) {
                      octalStr = octalStr.slice(0, -1);
                      octal = parseInt(octalStr, 8);
                    }

                    if (octal > 0) {
                      if (inTemplate) {
                        this.state.invalidTemplateEscapePosition = codePos;
                        return null;
                      } else if (this.state.strict) {
                        this.raise(codePos, "Octal literal in strict mode");
                      } else if (!this.state.containsOctal) {
                        this.state.containsOctal = true;
                        this.state.octalPosition = codePos;
                      }
                    }

                    this.state.pos += octalStr.length - 1;
                    return String.fromCharCode(octal);
                  }

                  return String.fromCharCode(ch);
              }
            };

            _proto.readHexChar = function readHexChar(len, throwOnInvalid) {
              var codePos = this.state.pos;
              var n = this.readInt(16, len);

              if (n === null) {
                if (throwOnInvalid) {
                  this.raise(codePos, "Bad character escape sequence");
                } else {
                  this.state.pos = codePos - 1;
                  this.state.invalidTemplateEscapePosition = codePos - 1;
                }
              }

              return n;
            };

            _proto.readWord1 = function readWord1() {
              this.state.containsEsc = false;
              var word = "",
                first = true,
                chunkStart = this.state.pos;

              while (this.state.pos < this.input.length) {
                var ch = this.input.codePointAt(this.state.pos);

                if (isIdentifierChar(ch)) {
                  this.state.pos += ch <= 0xffff ? 1 : 2;
                } else if (this.state.isIterator && ch === 64) {
                  this.state.pos += 1;
                } else if (ch === 92) {
                  this.state.containsEsc = true;
                  word += this.input.slice(chunkStart, this.state.pos);
                  var escStart = this.state.pos;

                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(
                      this.state.pos,
                      "Expecting Unicode escape sequence \\uXXXX"
                    );
                  }

                  ++this.state.pos;
                  var esc = this.readCodePoint(true);

                  if (
                    !(first ? isIdentifierStart : isIdentifierChar)(esc, true)
                  ) {
                    this.raise(escStart, "Invalid Unicode escape");
                  }

                  word += String.fromCodePoint(esc);
                  chunkStart = this.state.pos;
                } else {
                  break;
                }

                first = false;
              }

              return word + this.input.slice(chunkStart, this.state.pos);
            };

            _proto.isIterator = function isIterator(word) {
              return word === "@@iterator" || word === "@@asyncIterator";
            };

            _proto.readWord = function readWord() {
              var word = this.readWord1();
              var type = types.name;

              if (this.isKeyword(word)) {
                if (this.state.containsEsc) {
                  this.raise(
                    this.state.pos,
                    "Escape sequence in keyword " + word
                  );
                }

                type = keywords[word];
              }

              if (
                this.state.isIterator &&
                (!this.isIterator(word) || !this.state.inType)
              ) {
                this.raise(this.state.pos, "Invalid identifier " + word);
              }

              this.finishToken(type, word);
            };

            _proto.braceIsBlock = function braceIsBlock(prevType) {
              if (prevType === types.colon) {
                var parent = this.curContext();

                if (
                  parent === types$1.braceStatement ||
                  parent === types$1.braceExpression
                ) {
                  return !parent.isExpr;
                }
              }

              if (prevType === types._return) {
                return lineBreak.test(
                  this.input.slice(this.state.lastTokEnd, this.state.start)
                );
              }

              if (
                prevType === types._else ||
                prevType === types.semi ||
                prevType === types.eof ||
                prevType === types.parenR
              ) {
                return true;
              }

              if (prevType === types.braceL) {
                return this.curContext() === types$1.braceStatement;
              }

              if (prevType === types.relational) {
                return true;
              }

              return !this.state.exprAllowed;
            };

            _proto.updateContext = function updateContext(prevType) {
              var type = this.state.type;
              var update;

              if (
                type.keyword &&
                (prevType === types.dot || prevType === types.questionDot)
              ) {
                this.state.exprAllowed = false;
              } else if ((update = type.updateContext)) {
                update.call(this, prevType);
              } else {
                this.state.exprAllowed = type.beforeExpr;
              }
            };

            return Tokenizer;
          })(LocationParser);

          var UtilParser = (function(_Tokenizer) {
            _inheritsLoose(UtilParser, _Tokenizer);

            function UtilParser() {
              return _Tokenizer.apply(this, arguments) || this;
            }

            var _proto = UtilParser.prototype;

            _proto.addExtra = function addExtra(node, key, val) {
              if (!node) return;
              var extra = (node.extra = node.extra || {});
              extra[key] = val;
            };

            _proto.isRelational = function isRelational(op) {
              return this.match(types.relational) && this.state.value === op;
            };

            _proto.isLookaheadRelational = function isLookaheadRelational(op) {
              var l = this.lookahead();
              return l.type == types.relational && l.value == op;
            };

            _proto.expectRelational = function expectRelational(op) {
              if (this.isRelational(op)) {
                this.next();
              } else {
                this.unexpected(null, types.relational);
              }
            };

            _proto.eatRelational = function eatRelational(op) {
              if (this.isRelational(op)) {
                this.next();
                return true;
              }

              return false;
            };

            _proto.isContextual = function isContextual(name) {
              return (
                this.match(types.name) &&
                this.state.value === name &&
                !this.state.containsEsc
              );
            };

            _proto.isLookaheadContextual = function isLookaheadContextual(
              name
            ) {
              var l = this.lookahead();
              return l.type === types.name && l.value === name;
            };

            _proto.eatContextual = function eatContextual(name) {
              return this.isContextual(name) && this.eat(types.name);
            };

            _proto.expectContextual = function expectContextual(name, message) {
              if (!this.eatContextual(name)) this.unexpected(null, message);
            };

            _proto.canInsertSemicolon = function canInsertSemicolon() {
              return (
                this.match(types.eof) ||
                this.match(types.braceR) ||
                this.hasPrecedingLineBreak()
              );
            };

            _proto.hasPrecedingLineBreak = function hasPrecedingLineBreak() {
              return lineBreak.test(
                this.input.slice(this.state.lastTokEnd, this.state.start)
              );
            };

            _proto.isLineTerminator = function isLineTerminator() {
              return this.eat(types.semi) || this.canInsertSemicolon();
            };

            _proto.semicolon = function semicolon() {
              if (!this.isLineTerminator()) this.unexpected(null, types.semi);
            };

            _proto.expect = function expect(type, pos) {
              this.eat(type) || this.unexpected(pos, type);
            };

            _proto.unexpected = function unexpected(pos, messageOrType) {
              if (messageOrType === void 0) {
                messageOrType = "Unexpected token";
              }

              if (typeof messageOrType !== "string") {
                messageOrType =
                  'Unexpected token, expected "' + messageOrType.label + '"';
              }

              throw this.raise(
                pos != null ? pos : this.state.start,
                messageOrType
              );
            };

            _proto.expectPlugin = function expectPlugin(name, pos) {
              if (!this.hasPlugin(name)) {
                throw this.raise(
                  pos != null ? pos : this.state.start,
                  "This experimental syntax requires enabling the parser plugin: '" +
                    name +
                    "'",
                  {
                    missingPluginNames: [name],
                  }
                );
              }

              return true;
            };

            _proto.expectOnePlugin = function expectOnePlugin(names, pos) {
              var _this = this;

              if (
                !names.some(function(n) {
                  return _this.hasPlugin(n);
                })
              ) {
                throw this.raise(
                  pos != null ? pos : this.state.start,
                  "This experimental syntax requires enabling one of the following parser plugin(s): '" +
                    names.join(", ") +
                    "'",
                  {
                    missingPluginNames: names,
                  }
                );
              }
            };

            return UtilParser;
          })(Tokenizer);

          var commentKeys = [
            "leadingComments",
            "trailingComments",
            "innerComments",
          ];

          var Node = (function() {
            function Node(parser, pos, loc) {
              this.type = "";
              this.start = pos;
              this.end = 0;
              this.loc = new SourceLocation(loc);
              if (parser && parser.options.ranges) this.range = [pos, 0];
              if (parser && parser.filename)
                this.loc.filename = parser.filename;
            }

            var _proto = Node.prototype;

            _proto.__clone = function __clone() {
              var _this = this;

              var node2 = new Node();
              Object.keys(this).forEach(function(key) {
                if (commentKeys.indexOf(key) < 0) {
                  node2[key] = _this[key];
                }
              });
              return node2;
            };

            return Node;
          })();

          var NodeUtils = (function(_UtilParser) {
            _inheritsLoose(NodeUtils, _UtilParser);

            function NodeUtils() {
              return _UtilParser.apply(this, arguments) || this;
            }

            var _proto2 = NodeUtils.prototype;

            _proto2.startNode = function startNode() {
              return new Node(this, this.state.start, this.state.startLoc);
            };

            _proto2.startNodeAt = function startNodeAt(pos, loc) {
              return new Node(this, pos, loc);
            };

            _proto2.startNodeAtNode = function startNodeAtNode(type) {
              return this.startNodeAt(type.start, type.loc.start);
            };

            _proto2.finishNode = function finishNode(node, type) {
              return this.finishNodeAt(
                node,
                type,
                this.state.lastTokEnd,
                this.state.lastTokEndLoc
              );
            };

            _proto2.finishNodeAt = function finishNodeAt(node, type, pos, loc) {
              node.type = type;
              node.end = pos;
              node.loc.end = loc;
              if (this.options.ranges) node.range[1] = pos;
              this.processComment(node);
              return node;
            };

            _proto2.resetStartLocationFromNode = function resetStartLocationFromNode(
              node,
              locationNode
            ) {
              node.start = locationNode.start;
              node.loc.start = locationNode.loc.start;
              if (this.options.ranges) node.range[0] = locationNode.range[0];
            };

            return NodeUtils;
          })(UtilParser);

          var LValParser = (function(_NodeUtils) {
            _inheritsLoose(LValParser, _NodeUtils);

            function LValParser() {
              return _NodeUtils.apply(this, arguments) || this;
            }

            var _proto = LValParser.prototype;

            _proto.toAssignable = function toAssignable(
              node,
              isBinding,
              contextDescription
            ) {
              if (node) {
                switch (node.type) {
                  case "Identifier":
                  case "ObjectPattern":
                  case "ArrayPattern":
                  case "AssignmentPattern":
                    break;

                  case "ObjectExpression":
                    node.type = "ObjectPattern";

                    for (
                      var index = 0;
                      index < node.properties.length;
                      index++
                    ) {
                      var prop = node.properties[index];
                      var isLast = index === node.properties.length - 1;
                      this.toAssignableObjectExpressionProp(
                        prop,
                        isBinding,
                        isLast
                      );
                    }

                    break;

                  case "ObjectProperty":
                    this.toAssignable(
                      node.value,
                      isBinding,
                      contextDescription
                    );
                    break;

                  case "SpreadElement": {
                    this.checkToRestConversion(node);
                    node.type = "RestElement";
                    var arg = node.argument;
                    this.toAssignable(arg, isBinding, contextDescription);
                    break;
                  }

                  case "ArrayExpression":
                    node.type = "ArrayPattern";
                    this.toAssignableList(
                      node.elements,
                      isBinding,
                      contextDescription
                    );
                    break;

                  case "AssignmentExpression":
                    if (node.operator === "=") {
                      node.type = "AssignmentPattern";
                      delete node.operator;
                    } else {
                      this.raise(
                        node.left.end,
                        "Only '=' operator can be used for specifying default value."
                      );
                    }

                    break;

                  case "MemberExpression":
                    if (!isBinding) break;

                  default: {
                    var message =
                      "Invalid left-hand side" +
                      (contextDescription
                        ? " in " + contextDescription
                        : "expression");
                    this.raise(node.start, message);
                  }
                }
              }

              return node;
            };

            _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(
              prop,
              isBinding,
              isLast
            ) {
              if (prop.type === "ObjectMethod") {
                var error =
                  prop.kind === "get" || prop.kind === "set"
                    ? "Object pattern can't contain getter or setter"
                    : "Object pattern can't contain methods";
                this.raise(prop.key.start, error);
              } else if (prop.type === "SpreadElement" && !isLast) {
                this.raise(
                  prop.start,
                  "The rest element has to be the last element when destructuring"
                );
              } else {
                this.toAssignable(
                  prop,
                  isBinding,
                  "object destructuring pattern"
                );
              }
            };

            _proto.toAssignableList = function toAssignableList(
              exprList,
              isBinding,
              contextDescription
            ) {
              var end = exprList.length;

              if (end) {
                var last = exprList[end - 1];

                if (last && last.type === "RestElement") {
                  --end;
                } else if (last && last.type === "SpreadElement") {
                  last.type = "RestElement";
                  var arg = last.argument;
                  this.toAssignable(arg, isBinding, contextDescription);

                  if (
                    [
                      "Identifier",
                      "MemberExpression",
                      "ArrayPattern",
                      "ObjectPattern",
                    ].indexOf(arg.type) === -1
                  ) {
                    this.unexpected(arg.start);
                  }

                  --end;
                }
              }

              for (var i = 0; i < end; i++) {
                var elt = exprList[i];

                if (elt && elt.type === "SpreadElement") {
                  this.raise(
                    elt.start,
                    "The rest element has to be the last element when destructuring"
                  );
                }

                if (elt) this.toAssignable(elt, isBinding, contextDescription);
              }

              return exprList;
            };

            _proto.toReferencedList = function toReferencedList(exprList) {
              return exprList;
            };

            _proto.parseSpread = function parseSpread(
              refShorthandDefaultPos,
              refNeedsArrowPos
            ) {
              var node = this.startNode();
              this.next();
              node.argument = this.parseMaybeAssign(
                false,
                refShorthandDefaultPos,
                undefined,
                refNeedsArrowPos
              );
              return this.finishNode(node, "SpreadElement");
            };

            _proto.parseRest = function parseRest() {
              var node = this.startNode();
              this.next();
              node.argument = this.parseBindingAtom();
              return this.finishNode(node, "RestElement");
            };

            _proto.shouldAllowYieldIdentifier = function shouldAllowYieldIdentifier() {
              return (
                this.match(types._yield) &&
                !this.state.strict &&
                !this.state.inGenerator
              );
            };

            _proto.parseBindingIdentifier = function parseBindingIdentifier() {
              return this.parseIdentifier(this.shouldAllowYieldIdentifier());
            };

            _proto.parseBindingAtom = function parseBindingAtom() {
              switch (this.state.type) {
                case types._yield:
                case types.name:
                  return this.parseBindingIdentifier();

                case types.bracketL: {
                  var node = this.startNode();
                  this.next();
                  node.elements = this.parseBindingList(types.bracketR, true);
                  return this.finishNode(node, "ArrayPattern");
                }

                case types.braceL:
                  return this.parseObj(true);

                default:
                  throw this.unexpected();
              }
            };

            _proto.parseBindingList = function parseBindingList(
              close,
              allowEmpty,
              allowModifiers
            ) {
              var elts = [];
              var first = true;

              while (!this.eat(close)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types.comma);
                }

                if (allowEmpty && this.match(types.comma)) {
                  elts.push(null);
                } else if (this.eat(close)) {
                  break;
                } else if (this.match(types.ellipsis)) {
                  elts.push(
                    this.parseAssignableListItemTypes(this.parseRest())
                  );
                  this.expect(close);
                  break;
                } else {
                  var decorators = [];

                  if (this.match(types.at) && this.hasPlugin("decorators")) {
                    this.raise(
                      this.state.start,
                      "Stage 2 decorators cannot be used to decorate parameters"
                    );
                  }

                  while (this.match(types.at)) {
                    decorators.push(this.parseDecorator());
                  }

                  elts.push(
                    this.parseAssignableListItem(allowModifiers, decorators)
                  );
                }
              }

              return elts;
            };

            _proto.parseAssignableListItem = function parseAssignableListItem(
              allowModifiers,
              decorators
            ) {
              var left = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(left);
              var elt = this.parseMaybeDefault(
                left.start,
                left.loc.start,
                left
              );

              if (decorators.length) {
                left.decorators = decorators;
              }

              return elt;
            };

            _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(
              param
            ) {
              return param;
            };

            _proto.parseMaybeDefault = function parseMaybeDefault(
              startPos,
              startLoc,
              left
            ) {
              startLoc = startLoc || this.state.startLoc;
              startPos = startPos || this.state.start;
              left = left || this.parseBindingAtom();
              if (!this.eat(types.eq)) return left;
              var node = this.startNodeAt(startPos, startLoc);
              node.left = left;
              node.right = this.parseMaybeAssign();
              return this.finishNode(node, "AssignmentPattern");
            };

            _proto.checkLVal = function checkLVal(
              expr,
              isBinding,
              checkClashes,
              contextDescription
            ) {
              switch (expr.type) {
                case "Identifier":
                  this.checkReservedWord(expr.name, expr.start, false, true);

                  if (checkClashes) {
                    var _key = "_" + expr.name;

                    if (checkClashes[_key]) {
                      this.raise(
                        expr.start,
                        "Argument name clash in strict mode"
                      );
                    } else {
                      checkClashes[_key] = true;
                    }
                  }

                  break;

                case "MemberExpression":
                  if (isBinding)
                    this.raise(expr.start, "Binding member expression");
                  break;

                case "ObjectPattern":
                  for (
                    var _i2 = 0, _expr$properties2 = expr.properties;
                    _i2 < _expr$properties2.length;
                    _i2++
                  ) {
                    var prop = _expr$properties2[_i2];
                    if (prop.type === "ObjectProperty") prop = prop.value;
                    this.checkLVal(
                      prop,
                      isBinding,
                      checkClashes,
                      "object destructuring pattern"
                    );
                  }

                  break;

                case "ArrayPattern":
                  for (
                    var _i4 = 0, _expr$elements2 = expr.elements;
                    _i4 < _expr$elements2.length;
                    _i4++
                  ) {
                    var elem = _expr$elements2[_i4];

                    if (elem) {
                      this.checkLVal(
                        elem,
                        isBinding,
                        checkClashes,
                        "array destructuring pattern"
                      );
                    }
                  }

                  break;

                case "AssignmentPattern":
                  this.checkLVal(
                    expr.left,
                    isBinding,
                    checkClashes,
                    "assignment pattern"
                  );
                  break;

                case "RestElement":
                  this.checkLVal(
                    expr.argument,
                    isBinding,
                    checkClashes,
                    "rest element"
                  );
                  break;

                default: {
                  var message =
                    (isBinding ? "Binding invalid" : "Invalid") +
                    " left-hand side" +
                    (contextDescription
                      ? " in " + contextDescription
                      : "expression");
                  this.raise(expr.start, message);
                }
              }
            };

            _proto.checkToRestConversion = function checkToRestConversion(
              node
            ) {
              var validArgumentTypes = ["Identifier", "MemberExpression"];

              if (validArgumentTypes.indexOf(node.argument.type) !== -1) {
                return;
              }

              this.raise(
                node.argument.start,
                "Invalid rest operator's argument"
              );
            };

            return LValParser;
          })(NodeUtils);

          var ExpressionParser = (function(_LValParser) {
            _inheritsLoose(ExpressionParser, _LValParser);

            function ExpressionParser() {
              return _LValParser.apply(this, arguments) || this;
            }

            var _proto = ExpressionParser.prototype;

            _proto.checkPropClash = function checkPropClash(prop, propHash) {
              if (prop.computed || prop.kind) return;
              var key = prop.key;
              var name =
                key.type === "Identifier" ? key.name : String(key.value);

              if (name === "__proto__") {
                if (propHash.proto) {
                  this.raise(key.start, "Redefinition of __proto__ property");
                }

                propHash.proto = true;
              }
            };

            _proto.getExpression = function getExpression() {
              this.nextToken();
              var expr = this.parseExpression();

              if (!this.match(types.eof)) {
                this.unexpected();
              }

              expr.comments = this.state.comments;
              return expr;
            };

            _proto.parseExpression = function parseExpression(
              noIn,
              refShorthandDefaultPos
            ) {
              var startPos = this.state.start;
              var startLoc = this.state.startLoc;
              var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);

              if (this.match(types.comma)) {
                var _node = this.startNodeAt(startPos, startLoc);

                _node.expressions = [expr];

                while (this.eat(types.comma)) {
                  _node.expressions.push(
                    this.parseMaybeAssign(noIn, refShorthandDefaultPos)
                  );
                }

                this.toReferencedList(_node.expressions);
                return this.finishNode(_node, "SequenceExpression");
              }

              return expr;
            };

            _proto.parseMaybeAssign = function parseMaybeAssign(
              noIn,
              refShorthandDefaultPos,
              afterLeftParse,
              refNeedsArrowPos
            ) {
              var startPos = this.state.start;
              var startLoc = this.state.startLoc;

              if (this.match(types._yield) && this.state.inGenerator) {
                var _left = this.parseYield();

                if (afterLeftParse) {
                  _left = afterLeftParse.call(this, _left, startPos, startLoc);
                }

                return _left;
              }

              var failOnShorthandAssign;

              if (refShorthandDefaultPos) {
                failOnShorthandAssign = false;
              } else {
                refShorthandDefaultPos = {
                  start: 0,
                };
                failOnShorthandAssign = true;
              }

              if (
                this.match(types.parenL) ||
                this.match(types.name) ||
                this.match(types._yield)
              ) {
                this.state.potentialArrowAt = this.state.start;
              }

              var left = this.parseMaybeConditional(
                noIn,
                refShorthandDefaultPos,
                refNeedsArrowPos
              );

              if (afterLeftParse) {
                left = afterLeftParse.call(this, left, startPos, startLoc);
              }

              if (this.state.type.isAssign) {
                var _node2 = this.startNodeAt(startPos, startLoc);

                var operator = this.state.value;
                _node2.operator = operator;

                if (operator === "??=") {
                  this.expectPlugin("nullishCoalescingOperator");
                  this.expectPlugin("logicalAssignment");
                }

                if (operator === "||=" || operator === "&&=") {
                  this.expectPlugin("logicalAssignment");
                }

                _node2.left = this.match(types.eq)
                  ? this.toAssignable(left, undefined, "assignment expression")
                  : left;
                refShorthandDefaultPos.start = 0;
                this.checkLVal(
                  left,
                  undefined,
                  undefined,
                  "assignment expression"
                );

                if (left.extra && left.extra.parenthesized) {
                  var errorMsg;

                  if (left.type === "ObjectPattern") {
                    errorMsg = "`({a}) = 0` use `({a} = 0)`";
                  } else if (left.type === "ArrayPattern") {
                    errorMsg = "`([a]) = 0` use `([a] = 0)`";
                  }

                  if (errorMsg) {
                    this.raise(
                      left.start,
                      "You're trying to assign to a parenthesized expression, eg. instead of " +
                        errorMsg
                    );
                  }
                }

                this.next();
                _node2.right = this.parseMaybeAssign(noIn);
                return this.finishNode(_node2, "AssignmentExpression");
              } else if (
                failOnShorthandAssign &&
                refShorthandDefaultPos.start
              ) {
                this.unexpected(refShorthandDefaultPos.start);
              }

              return left;
            };

            _proto.parseMaybeConditional = function parseMaybeConditional(
              noIn,
              refShorthandDefaultPos,
              refNeedsArrowPos
            ) {
              var startPos = this.state.start;
              var startLoc = this.state.startLoc;
              var potentialArrowAt = this.state.potentialArrowAt;
              var expr = this.parseExprOps(noIn, refShorthandDefaultPos);

              if (
                expr.type === "ArrowFunctionExpression" &&
                expr.start === potentialArrowAt
              ) {
                return expr;
              }

              if (refShorthandDefaultPos && refShorthandDefaultPos.start)
                return expr;
              return this.parseConditional(
                expr,
                noIn,
                startPos,
                startLoc,
                refNeedsArrowPos
              );
            };

            _proto.parseConditional = function parseConditional(
              expr,
              noIn,
              startPos,
              startLoc,
              refNeedsArrowPos
            ) {
              if (this.eat(types.question)) {
                var _node3 = this.startNodeAt(startPos, startLoc);

                _node3.test = expr;
                _node3.consequent = this.parseMaybeAssign();
                this.expect(types.colon);
                _node3.alternate = this.parseMaybeAssign(noIn);
                return this.finishNode(_node3, "ConditionalExpression");
              }

              return expr;
            };

            _proto.parseExprOps = function parseExprOps(
              noIn,
              refShorthandDefaultPos
            ) {
              var startPos = this.state.start;
              var startLoc = this.state.startLoc;
              var potentialArrowAt = this.state.potentialArrowAt;
              var expr = this.parseMaybeUnary(refShorthandDefaultPos);

              if (
                expr.type === "ArrowFunctionExpression" &&
                expr.start === potentialArrowAt
              ) {
                return expr;
              }

              if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
                return expr;
              }

              return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
            };

            _proto.parseExprOp = function parseExprOp(
              left,
              leftStartPos,
              leftStartLoc,
              minPrec,
              noIn
            ) {
              var prec = this.state.type.binop;

              if (prec != null && (!noIn || !this.match(types._in))) {
                if (prec > minPrec) {
                  var _node4 = this.startNodeAt(leftStartPos, leftStartLoc);

                  var operator = this.state.value;
                  _node4.left = left;
                  _node4.operator = operator;

                  if (
                    operator === "**" &&
                    left.type === "UnaryExpression" &&
                    !(left.extra && left.extra.parenthesized)
                  ) {
                    this.raise(
                      left.argument.start,
                      "Illegal expression. Wrap left hand side or entire exponentiation in parentheses."
                    );
                  }

                  var op = this.state.type;

                  if (op === types.nullishCoalescing) {
                    this.expectPlugin("nullishCoalescingOperator");
                  } else if (op === types.pipeline) {
                    this.expectPlugin("pipelineOperator");
                  }

                  this.next();
                  var startPos = this.state.start;
                  var startLoc = this.state.startLoc;

                  if (op === types.pipeline) {
                    if (
                      this.match(types.name) &&
                      this.state.value === "await" &&
                      this.state.inAsync
                    ) {
                      throw this.raise(
                        this.state.start,
                        'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal'
                      );
                    }
                  }

                  _node4.right = this.parseExprOp(
                    this.parseMaybeUnary(),
                    startPos,
                    startLoc,
                    op.rightAssociative ? prec - 1 : prec,
                    noIn
                  );
                  this.finishNode(
                    _node4,
                    op === types.logicalOR ||
                    op === types.logicalAND ||
                    op === types.nullishCoalescing
                      ? "LogicalExpression"
                      : "BinaryExpression"
                  );
                  return this.parseExprOp(
                    _node4,
                    leftStartPos,
                    leftStartLoc,
                    minPrec,
                    noIn
                  );
                }
              }

              return left;
            };

            _proto.parseMaybeUnary = function parseMaybeUnary(
              refShorthandDefaultPos
            ) {
              if (this.state.type.prefix) {
                var _node5 = this.startNode();

                var update = this.match(types.incDec);
                _node5.operator = this.state.value;
                _node5.prefix = true;

                if (_node5.operator === "throw") {
                  this.expectPlugin("throwExpressions");
                }

                this.next();
                _node5.argument = this.parseMaybeUnary();

                if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
                  this.unexpected(refShorthandDefaultPos.start);
                }

                if (update) {
                  this.checkLVal(
                    _node5.argument,
                    undefined,
                    undefined,
                    "prefix operation"
                  );
                } else if (this.state.strict && _node5.operator === "delete") {
                  var arg = _node5.argument;

                  if (arg.type === "Identifier") {
                    this.raise(
                      _node5.start,
                      "Deleting local variable in strict mode"
                    );
                  } else if (
                    arg.type === "MemberExpression" &&
                    arg.property.type === "PrivateName"
                  ) {
                    this.raise(
                      _node5.start,
                      "Deleting a private field is not allowed"
                    );
                  }
                }

                return this.finishNode(
                  _node5,
                  update ? "UpdateExpression" : "UnaryExpression"
                );
              }

              var startPos = this.state.start;
              var startLoc = this.state.startLoc;
              var expr = this.parseExprSubscripts(refShorthandDefaultPos);
              if (refShorthandDefaultPos && refShorthandDefaultPos.start)
                return expr;

              while (this.state.type.postfix && !this.canInsertSemicolon()) {
                var _node6 = this.startNodeAt(startPos, startLoc);

                _node6.operator = this.state.value;
                _node6.prefix = false;
                _node6.argument = expr;
                this.checkLVal(expr, undefined, undefined, "postfix operation");
                this.next();
                expr = this.finishNode(_node6, "UpdateExpression");
              }

              return expr;
            };

            _proto.parseExprSubscripts = function parseExprSubscripts(
              refShorthandDefaultPos
            ) {
              var startPos = this.state.start;
              var startLoc = this.state.startLoc;
              var potentialArrowAt = this.state.potentialArrowAt;
              var expr = this.parseExprAtom(refShorthandDefaultPos);

              if (
                expr.type === "ArrowFunctionExpression" &&
                expr.start === potentialArrowAt
              ) {
                return expr;
              }

              if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
                return expr;
              }

              return this.parseSubscripts(expr, startPos, startLoc);
            };

            _proto.parseSubscripts = function parseSubscripts(
              base,
              startPos,
              startLoc,
              noCalls
            ) {
              var state = {
                optionalChainMember: false,
                stop: false,
              };

              do {
                base = this.parseSubscript(
                  base,
                  startPos,
                  startLoc,
                  noCalls,
                  state
                );
              } while (!state.stop);

              return base;
            };

            _proto.parseSubscript = function parseSubscript(
              base,
              startPos,
              startLoc,
              noCalls,
              state
            ) {
              if (!noCalls && this.eat(types.doubleColon)) {
                var _node7 = this.startNodeAt(startPos, startLoc);

                _node7.object = base;
                _node7.callee = this.parseNoCallExpr();
                state.stop = true;
                return this.parseSubscripts(
                  this.finishNode(_node7, "BindExpression"),
                  startPos,
                  startLoc,
                  noCalls
                );
              } else if (this.match(types.questionDot)) {
                this.expectPlugin("optionalChaining");
                state.optionalChainMember = true;

                if (noCalls && this.lookahead().type == types.parenL) {
                  state.stop = true;
                  return base;
                }

                this.next();

                var _node8 = this.startNodeAt(startPos, startLoc);

                if (this.eat(types.bracketL)) {
                  _node8.object = base;
                  _node8.property = this.parseExpression();
                  _node8.computed = true;
                  _node8.optional = true;
                  this.expect(types.bracketR);
                  return this.finishNode(_node8, "OptionalMemberExpression");
                } else if (this.eat(types.parenL)) {
                  var possibleAsync = this.atPossibleAsync(base);
                  _node8.callee = base;
                  _node8.arguments = this.parseCallExpressionArguments(
                    types.parenR,
                    possibleAsync
                  );
                  _node8.optional = true;
                  return this.finishNode(_node8, "OptionalCallExpression");
                } else {
                  _node8.object = base;
                  _node8.property = this.parseIdentifier(true);
                  _node8.computed = false;
                  _node8.optional = true;
                  return this.finishNode(_node8, "OptionalMemberExpression");
                }
              } else if (this.eat(types.dot)) {
                var _node9 = this.startNodeAt(startPos, startLoc);

                _node9.object = base;
                _node9.property = this.parseMaybePrivateName();
                _node9.computed = false;

                if (state.optionalChainMember) {
                  _node9.optional = false;
                  return this.finishNode(_node9, "OptionalMemberExpression");
                }

                return this.finishNode(_node9, "MemberExpression");
              } else if (this.eat(types.bracketL)) {
                var _node10 = this.startNodeAt(startPos, startLoc);

                _node10.object = base;
                _node10.property = this.parseExpression();
                _node10.computed = true;
                this.expect(types.bracketR);

                if (state.optionalChainMember) {
                  _node10.optional = false;
                  return this.finishNode(_node10, "OptionalMemberExpression");
                }

                return this.finishNode(_node10, "MemberExpression");
              } else if (!noCalls && this.match(types.parenL)) {
                var _possibleAsync = this.atPossibleAsync(base);

                this.next();

                var _node11 = this.startNodeAt(startPos, startLoc);

                _node11.callee = base;
                var refTrailingCommaPos = {
                  start: -1,
                };
                _node11.arguments = this.parseCallExpressionArguments(
                  types.parenR,
                  _possibleAsync,
                  refTrailingCommaPos
                );

                if (!state.optionalChainMember) {
                  this.finishCallExpression(_node11);
                } else {
                  this.finishOptionalCallExpression(_node11);
                }

                if (_possibleAsync && this.shouldParseAsyncArrow()) {
                  state.stop = true;

                  if (refTrailingCommaPos.start > -1) {
                    this.raise(
                      refTrailingCommaPos.start,
                      "A trailing comma is not permitted after the rest element"
                    );
                  }

                  return this.parseAsyncArrowFromCallExpression(
                    this.startNodeAt(startPos, startLoc),
                    _node11
                  );
                } else {
                  this.toReferencedList(_node11.arguments);
                }

                return _node11;
              } else if (this.match(types.backQuote)) {
                return this.parseTaggedTemplateExpression(
                  startPos,
                  startLoc,
                  base,
                  state
                );
              } else {
                state.stop = true;
                return base;
              }
            };

            _proto.parseTaggedTemplateExpression = function parseTaggedTemplateExpression(
              startPos,
              startLoc,
              base,
              state,
              typeArguments
            ) {
              var node = this.startNodeAt(startPos, startLoc);
              node.tag = base;
              node.quasi = this.parseTemplate(true);
              if (typeArguments) node.typeParameters = typeArguments;

              if (state.optionalChainMember) {
                this.raise(
                  startPos,
                  "Tagged Template Literals are not allowed in optionalChain"
                );
              }

              return this.finishNode(node, "TaggedTemplateExpression");
            };

            _proto.atPossibleAsync = function atPossibleAsync(base) {
              return (
                !this.state.containsEsc &&
                this.state.potentialArrowAt === base.start &&
                base.type === "Identifier" &&
                base.name === "async" &&
                !this.canInsertSemicolon()
              );
            };

            _proto.finishCallExpression = function finishCallExpression(node) {
              if (node.callee.type === "Import") {
                if (node.arguments.length !== 1) {
                  this.raise(
                    node.start,
                    "import() requires exactly one argument"
                  );
                }

                var importArg = node.arguments[0];

                if (importArg && importArg.type === "SpreadElement") {
                  this.raise(importArg.start, "... is not allowed in import()");
                }
              }

              return this.finishNode(node, "CallExpression");
            };

            _proto.finishOptionalCallExpression = function finishOptionalCallExpression(
              node
            ) {
              if (node.callee.type === "Import") {
                if (node.arguments.length !== 1) {
                  this.raise(
                    node.start,
                    "import() requires exactly one argument"
                  );
                }

                var importArg = node.arguments[0];

                if (importArg && importArg.type === "SpreadElement") {
                  this.raise(importArg.start, "... is not allowed in import()");
                }
              }

              return this.finishNode(node, "OptionalCallExpression");
            };

            _proto.parseCallExpressionArguments = function parseCallExpressionArguments(
              close,
              possibleAsyncArrow,
              refTrailingCommaPos
            ) {
              var elts = [];
              var innerParenStart;
              var first = true;

              while (!this.eat(close)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types.comma);
                  if (this.eat(close)) break;
                }

                if (this.match(types.parenL) && !innerParenStart) {
                  innerParenStart = this.state.start;
                }

                elts.push(
                  this.parseExprListItem(
                    false,
                    possibleAsyncArrow
                      ? {
                          start: 0,
                        }
                      : undefined,
                    possibleAsyncArrow
                      ? {
                          start: 0,
                        }
                      : undefined,
                    possibleAsyncArrow ? refTrailingCommaPos : undefined
                  )
                );
              }

              if (
                possibleAsyncArrow &&
                innerParenStart &&
                this.shouldParseAsyncArrow()
              ) {
                this.unexpected();
              }

              return elts;
            };

            _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
              return this.match(types.arrow);
            };

            _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(
              node,
              call
            ) {
              var oldYield = this.state.yieldInPossibleArrowParameters;
              this.state.yieldInPossibleArrowParameters = null;
              this.expect(types.arrow);
              this.parseArrowExpression(node, call.arguments, true);
              this.state.yieldInPossibleArrowParameters = oldYield;
              return node;
            };

            _proto.parseNoCallExpr = function parseNoCallExpr() {
              var startPos = this.state.start;
              var startLoc = this.state.startLoc;
              return this.parseSubscripts(
                this.parseExprAtom(),
                startPos,
                startLoc,
                true
              );
            };

            _proto.parseExprAtom = function parseExprAtom(
              refShorthandDefaultPos
            ) {
              var canBeArrow = this.state.potentialArrowAt === this.state.start;
              var node;

              switch (this.state.type) {
                case types._super:
                  if (
                    !this.state.inMethod &&
                    !this.state.inClassProperty &&
                    !this.options.allowSuperOutsideMethod
                  ) {
                    this.raise(
                      this.state.start,
                      "super is only allowed in object methods and classes"
                    );
                  }

                  node = this.startNode();
                  this.next();

                  if (
                    !this.match(types.parenL) &&
                    !this.match(types.bracketL) &&
                    !this.match(types.dot)
                  ) {
                    this.unexpected();
                  }

                  if (
                    this.match(types.parenL) &&
                    this.state.inMethod !== "constructor" &&
                    !this.options.allowSuperOutsideMethod
                  ) {
                    this.raise(
                      node.start,
                      "super() is only valid inside a class constructor. " +
                        "Make sure the method name is spelled exactly as 'constructor'."
                    );
                  }

                  return this.finishNode(node, "Super");

                case types._import:
                  if (this.lookahead().type === types.dot) {
                    return this.parseImportMetaProperty();
                  }

                  this.expectPlugin("dynamicImport");
                  node = this.startNode();
                  this.next();

                  if (!this.match(types.parenL)) {
                    this.unexpected(null, types.parenL);
                  }

                  return this.finishNode(node, "Import");

                case types._this:
                  node = this.startNode();
                  this.next();
                  return this.finishNode(node, "ThisExpression");

                case types._yield:
                  if (this.state.inGenerator) this.unexpected();

                case types.name: {
                  node = this.startNode();
                  var allowAwait =
                    this.state.value === "await" &&
                    (this.state.inAsync ||
                      (!this.state.inFunction &&
                        this.options.allowAwaitOutsideFunction));
                  var containsEsc = this.state.containsEsc;
                  var allowYield = this.shouldAllowYieldIdentifier();
                  var id = this.parseIdentifier(allowAwait || allowYield);

                  if (id.name === "await") {
                    if (
                      this.state.inAsync ||
                      this.inModule ||
                      (!this.state.inFunction &&
                        this.options.allowAwaitOutsideFunction)
                    ) {
                      return this.parseAwait(node);
                    }
                  } else if (
                    !containsEsc &&
                    id.name === "async" &&
                    this.match(types._function) &&
                    !this.canInsertSemicolon()
                  ) {
                    this.next();
                    return this.parseFunction(node, false, false, true);
                  } else if (
                    canBeArrow &&
                    id.name === "async" &&
                    this.match(types.name)
                  ) {
                    var oldYield = this.state.yieldInPossibleArrowParameters;
                    this.state.yieldInPossibleArrowParameters = null;
                    var params = [this.parseIdentifier()];
                    this.expect(types.arrow);
                    this.parseArrowExpression(node, params, true);
                    this.state.yieldInPossibleArrowParameters = oldYield;
                    return node;
                  }

                  if (
                    canBeArrow &&
                    !this.canInsertSemicolon() &&
                    this.eat(types.arrow)
                  ) {
                    var _oldYield = this.state.yieldInPossibleArrowParameters;
                    this.state.yieldInPossibleArrowParameters = null;
                    this.parseArrowExpression(node, [id]);
                    this.state.yieldInPossibleArrowParameters = _oldYield;
                    return node;
                  }

                  return id;
                }

                case types._do: {
                  this.expectPlugin("doExpressions");

                  var _node12 = this.startNode();

                  this.next();
                  var oldInFunction = this.state.inFunction;
                  var oldLabels = this.state.labels;
                  this.state.labels = [];
                  this.state.inFunction = false;
                  _node12.body = this.parseBlock(false);
                  this.state.inFunction = oldInFunction;
                  this.state.labels = oldLabels;
                  return this.finishNode(_node12, "DoExpression");
                }

                case types.regexp: {
                  var value = this.state.value;
                  node = this.parseLiteral(value.value, "RegExpLiteral");
                  node.pattern = value.pattern;
                  node.flags = value.flags;
                  return node;
                }

                case types.num:
                  return this.parseLiteral(this.state.value, "NumericLiteral");

                case types.bigint:
                  return this.parseLiteral(this.state.value, "BigIntLiteral");

                case types.string:
                  return this.parseLiteral(this.state.value, "StringLiteral");

                case types._null:
                  node = this.startNode();
                  this.next();
                  return this.finishNode(node, "NullLiteral");

                case types._true:
                case types._false:
                  return this.parseBooleanLiteral();

                case types.parenL:
                  return this.parseParenAndDistinguishExpression(canBeArrow);

                case types.bracketL:
                  node = this.startNode();
                  this.next();
                  node.elements = this.parseExprList(
                    types.bracketR,
                    true,
                    refShorthandDefaultPos
                  );
                  this.toReferencedList(node.elements);
                  return this.finishNode(node, "ArrayExpression");

                case types.braceL:
                  return this.parseObj(false, refShorthandDefaultPos);

                case types._function:
                  return this.parseFunctionExpression();

                case types.at:
                  this.parseDecorators();

                case types._class:
                  node = this.startNode();
                  this.takeDecorators(node);
                  return this.parseClass(node, false);

                case types._new:
                  return this.parseNew();

                case types.backQuote:
                  return this.parseTemplate(false);

                case types.doubleColon: {
                  node = this.startNode();
                  this.next();
                  node.object = null;
                  var callee = (node.callee = this.parseNoCallExpr());

                  if (callee.type === "MemberExpression") {
                    return this.finishNode(node, "BindExpression");
                  } else {
                    throw this.raise(
                      callee.start,
                      "Binding should be performed on object property."
                    );
                  }
                }

                default:
                  throw this.unexpected();
              }
            };

            _proto.parseBooleanLiteral = function parseBooleanLiteral() {
              var node = this.startNode();
              node.value = this.match(types._true);
              this.next();
              return this.finishNode(node, "BooleanLiteral");
            };

            _proto.parseMaybePrivateName = function parseMaybePrivateName() {
              var isPrivate = this.match(types.hash);

              if (isPrivate) {
                this.expectOnePlugin([
                  "classPrivateProperties",
                  "classPrivateMethods",
                ]);

                var _node13 = this.startNode();

                this.next();
                _node13.id = this.parseIdentifier(true);
                return this.finishNode(_node13, "PrivateName");
              } else {
                return this.parseIdentifier(true);
              }
            };

            _proto.parseFunctionExpression = function parseFunctionExpression() {
              var node = this.startNode();
              var meta = this.parseIdentifier(true);

              if (this.state.inGenerator && this.eat(types.dot)) {
                return this.parseMetaProperty(node, meta, "sent");
              }

              return this.parseFunction(node, false);
            };

            _proto.parseMetaProperty = function parseMetaProperty(
              node,
              meta,
              propertyName
            ) {
              node.meta = meta;

              if (meta.name === "function" && propertyName === "sent") {
                if (this.isContextual(propertyName)) {
                  this.expectPlugin("functionSent");
                } else if (!this.hasPlugin("functionSent")) {
                  this.unexpected();
                }
              }

              var containsEsc = this.state.containsEsc;
              node.property = this.parseIdentifier(true);

              if (node.property.name !== propertyName || containsEsc) {
                this.raise(
                  node.property.start,
                  "The only valid meta property for " +
                    meta.name +
                    " is " +
                    meta.name +
                    "." +
                    propertyName
                );
              }

              return this.finishNode(node, "MetaProperty");
            };

            _proto.parseImportMetaProperty = function parseImportMetaProperty() {
              var node = this.startNode();
              var id = this.parseIdentifier(true);
              this.expect(types.dot);

              if (id.name === "import") {
                if (this.isContextual("meta")) {
                  this.expectPlugin("importMeta");
                } else if (!this.hasPlugin("importMeta")) {
                  this.raise(
                    id.start,
                    "Dynamic imports require a parameter: import('a.js')"
                  );
                }
              }

              if (!this.inModule) {
                this.raise(
                  id.start,
                  "import.meta may appear only with 'sourceType: \"module\"'",
                  {
                    code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED",
                  }
                );
              }

              this.sawUnambiguousESM = true;
              return this.parseMetaProperty(node, id, "meta");
            };

            _proto.parseLiteral = function parseLiteral(
              value,
              type,
              startPos,
              startLoc
            ) {
              startPos = startPos || this.state.start;
              startLoc = startLoc || this.state.startLoc;
              var node = this.startNodeAt(startPos, startLoc);
              this.addExtra(node, "rawValue", value);
              this.addExtra(
                node,
                "raw",
                this.input.slice(startPos, this.state.end)
              );
              node.value = value;
              this.next();
              return this.finishNode(node, type);
            };

            _proto.parseParenExpression = function parseParenExpression() {
              this.expect(types.parenL);
              var val = this.parseExpression();
              this.expect(types.parenR);
              return val;
            };

            _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(
              canBeArrow
            ) {
              var startPos = this.state.start;
              var startLoc = this.state.startLoc;
              var val;
              this.expect(types.parenL);
              var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
              var oldYield = this.state.yieldInPossibleArrowParameters;
              this.state.maybeInArrowParameters = true;
              this.state.yieldInPossibleArrowParameters = null;
              var innerStartPos = this.state.start;
              var innerStartLoc = this.state.startLoc;
              var exprList = [];
              var refShorthandDefaultPos = {
                start: 0,
              };
              var refNeedsArrowPos = {
                start: 0,
              };
              var first = true;
              var spreadStart;
              var optionalCommaStart;

              while (!this.match(types.parenR)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types.comma, refNeedsArrowPos.start || null);

                  if (this.match(types.parenR)) {
                    optionalCommaStart = this.state.start;
                    break;
                  }
                }

                if (this.match(types.ellipsis)) {
                  var spreadNodeStartPos = this.state.start;
                  var spreadNodeStartLoc = this.state.startLoc;
                  spreadStart = this.state.start;
                  exprList.push(
                    this.parseParenItem(
                      this.parseRest(),
                      spreadNodeStartPos,
                      spreadNodeStartLoc
                    )
                  );

                  if (
                    this.match(types.comma) &&
                    this.lookahead().type === types.parenR
                  ) {
                    this.raise(
                      this.state.start,
                      "A trailing comma is not permitted after the rest element"
                    );
                  }

                  break;
                } else {
                  exprList.push(
                    this.parseMaybeAssign(
                      false,
                      refShorthandDefaultPos,
                      this.parseParenItem,
                      refNeedsArrowPos
                    )
                  );
                }
              }

              var innerEndPos = this.state.start;
              var innerEndLoc = this.state.startLoc;
              this.expect(types.parenR);
              this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
              var arrowNode = this.startNodeAt(startPos, startLoc);

              if (
                canBeArrow &&
                this.shouldParseArrow() &&
                (arrowNode = this.parseArrow(arrowNode))
              ) {
                for (var _i2 = 0; _i2 < exprList.length; _i2++) {
                  var param = exprList[_i2];

                  if (param.extra && param.extra.parenthesized) {
                    this.unexpected(param.extra.parenStart);
                  }
                }

                this.parseArrowExpression(arrowNode, exprList);
                this.state.yieldInPossibleArrowParameters = oldYield;
                return arrowNode;
              }

              this.state.yieldInPossibleArrowParameters = oldYield;

              if (!exprList.length) {
                this.unexpected(this.state.lastTokStart);
              }

              if (optionalCommaStart) this.unexpected(optionalCommaStart);
              if (spreadStart) this.unexpected(spreadStart);

              if (refShorthandDefaultPos.start) {
                this.unexpected(refShorthandDefaultPos.start);
              }

              if (refNeedsArrowPos.start)
                this.unexpected(refNeedsArrowPos.start);

              if (exprList.length > 1) {
                val = this.startNodeAt(innerStartPos, innerStartLoc);
                val.expressions = exprList;
                this.toReferencedList(val.expressions);
                this.finishNodeAt(
                  val,
                  "SequenceExpression",
                  innerEndPos,
                  innerEndLoc
                );
              } else {
                val = exprList[0];
              }

              this.addExtra(val, "parenthesized", true);
              this.addExtra(val, "parenStart", startPos);
              return val;
            };

            _proto.shouldParseArrow = function shouldParseArrow() {
              return !this.canInsertSemicolon();
            };

            _proto.parseArrow = function parseArrow(node) {
              if (this.eat(types.arrow)) {
                return node;
              }
            };

            _proto.parseParenItem = function parseParenItem(
              node,
              startPos,
              startLoc
            ) {
              return node;
            };

            _proto.parseNew = function parseNew() {
              var node = this.startNode();
              var meta = this.parseIdentifier(true);

              if (this.eat(types.dot)) {
                var metaProp = this.parseMetaProperty(node, meta, "target");

                if (!this.state.inFunction && !this.state.inClassProperty) {
                  var error = "new.target can only be used in functions";

                  if (this.hasPlugin("classProperties")) {
                    error += " or class properties";
                  }

                  this.raise(metaProp.start, error);
                }

                return metaProp;
              }

              node.callee = this.parseNoCallExpr();

              if (
                node.callee.type === "OptionalMemberExpression" ||
                node.callee.type === "OptionalCallExpression"
              ) {
                this.raise(
                  this.state.lastTokEnd,
                  "constructors in/after an Optional Chain are not allowed"
                );
              }

              if (this.eat(types.questionDot)) {
                this.raise(
                  this.state.start,
                  "constructors in/after an Optional Chain are not allowed"
                );
              }

              this.parseNewArguments(node);
              return this.finishNode(node, "NewExpression");
            };

            _proto.parseNewArguments = function parseNewArguments(node) {
              if (this.eat(types.parenL)) {
                var args = this.parseExprList(types.parenR);
                this.toReferencedList(args);
                node.arguments = args;
              } else {
                node.arguments = [];
              }
            };

            _proto.parseTemplateElement = function parseTemplateElement(
              isTagged
            ) {
              var elem = this.startNode();

              if (this.state.value === null) {
                if (!isTagged) {
                  this.raise(
                    this.state.invalidTemplateEscapePosition || 0,
                    "Invalid escape sequence in template"
                  );
                } else {
                  this.state.invalidTemplateEscapePosition = null;
                }
              }

              elem.value = {
                raw: this.input
                  .slice(this.state.start, this.state.end)
                  .replace(/\r\n?/g, "\n"),
                cooked: this.state.value,
              };
              this.next();
              elem.tail = this.match(types.backQuote);
              return this.finishNode(elem, "TemplateElement");
            };

            _proto.parseTemplate = function parseTemplate(isTagged) {
              var node = this.startNode();
              this.next();
              node.expressions = [];
              var curElt = this.parseTemplateElement(isTagged);
              node.quasis = [curElt];

              while (!curElt.tail) {
                this.expect(types.dollarBraceL);
                node.expressions.push(this.parseExpression());
                this.expect(types.braceR);
                node.quasis.push(
                  (curElt = this.parseTemplateElement(isTagged))
                );
              }

              this.next();
              return this.finishNode(node, "TemplateLiteral");
            };

            _proto.parseObj = function parseObj(
              isPattern,
              refShorthandDefaultPos
            ) {
              var decorators = [];
              var propHash = Object.create(null);
              var first = true;
              var node = this.startNode();
              node.properties = [];
              this.next();
              var firstRestLocation = null;

              while (!this.eat(types.braceR)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types.comma);
                  if (this.eat(types.braceR)) break;
                }

                if (this.match(types.at)) {
                  if (this.hasPlugin("decorators")) {
                    this.raise(
                      this.state.start,
                      "Stage 2 decorators disallow object literal property decorators"
                    );
                  } else {
                    while (this.match(types.at)) {
                      decorators.push(this.parseDecorator());
                    }
                  }
                }

                var prop = this.startNode(),
                  isGenerator = false,
                  _isAsync = false,
                  startPos = void 0,
                  startLoc = void 0;

                if (decorators.length) {
                  prop.decorators = decorators;
                  decorators = [];
                }

                if (this.match(types.ellipsis)) {
                  this.expectPlugin("objectRestSpread");
                  prop = this.parseSpread(
                    isPattern
                      ? {
                          start: 0,
                        }
                      : undefined
                  );

                  if (isPattern) {
                    this.toAssignable(prop, true, "object pattern");
                  }

                  node.properties.push(prop);

                  if (isPattern) {
                    var position = this.state.start;

                    if (firstRestLocation !== null) {
                      this.unexpected(
                        firstRestLocation,
                        "Cannot have multiple rest elements when destructuring"
                      );
                    } else if (this.eat(types.braceR)) {
                      break;
                    } else if (
                      this.match(types.comma) &&
                      this.lookahead().type === types.braceR
                    ) {
                      this.unexpected(
                        position,
                        "A trailing comma is not permitted after the rest element"
                      );
                    } else {
                      firstRestLocation = position;
                      continue;
                    }
                  } else {
                    continue;
                  }
                }

                prop.method = false;

                if (isPattern || refShorthandDefaultPos) {
                  startPos = this.state.start;
                  startLoc = this.state.startLoc;
                }

                if (!isPattern) {
                  isGenerator = this.eat(types.star);
                }

                var containsEsc = this.state.containsEsc;

                if (!isPattern && this.isContextual("async")) {
                  if (isGenerator) this.unexpected();
                  var asyncId = this.parseIdentifier();

                  if (
                    this.match(types.colon) ||
                    this.match(types.parenL) ||
                    this.match(types.braceR) ||
                    this.match(types.eq) ||
                    this.match(types.comma)
                  ) {
                    prop.key = asyncId;
                    prop.computed = false;
                  } else {
                    _isAsync = true;

                    if (this.match(types.star)) {
                      this.expectPlugin("asyncGenerators");
                      this.next();
                      isGenerator = true;
                    }

                    this.parsePropertyName(prop);
                  }
                } else {
                  this.parsePropertyName(prop);
                }

                this.parseObjPropValue(
                  prop,
                  startPos,
                  startLoc,
                  isGenerator,
                  _isAsync,
                  isPattern,
                  refShorthandDefaultPos,
                  containsEsc
                );
                this.checkPropClash(prop, propHash);

                if (prop.shorthand) {
                  this.addExtra(prop, "shorthand", true);
                }

                node.properties.push(prop);
              }

              if (firstRestLocation !== null) {
                this.unexpected(
                  firstRestLocation,
                  "The rest element has to be the last element when destructuring"
                );
              }

              if (decorators.length) {
                this.raise(
                  this.state.start,
                  "You have trailing decorators with no property"
                );
              }

              return this.finishNode(
                node,
                isPattern ? "ObjectPattern" : "ObjectExpression"
              );
            };

            _proto.isGetterOrSetterMethod = function isGetterOrSetterMethod(
              prop,
              isPattern
            ) {
              return (
                !isPattern &&
                !prop.computed &&
                prop.key.type === "Identifier" &&
                (prop.key.name === "get" || prop.key.name === "set") &&
                (this.match(types.string) ||
                  this.match(types.num) ||
                  this.match(types.bracketL) ||
                  this.match(types.name) ||
                  !!this.state.type.keyword)
              );
            };

            _proto.checkGetterSetterParams = function checkGetterSetterParams(
              method
            ) {
              var paramCount = method.kind === "get" ? 0 : 1;
              var start = method.start;

              if (method.params.length !== paramCount) {
                if (method.kind === "get") {
                  this.raise(
                    start,
                    "getter must not have any formal parameters"
                  );
                } else {
                  this.raise(
                    start,
                    "setter must have exactly one formal parameter"
                  );
                }
              }

              if (
                method.kind === "set" &&
                method.params[0].type === "RestElement"
              ) {
                this.raise(
                  start,
                  "setter function argument must not be a rest parameter"
                );
              }
            };

            _proto.parseObjectMethod = function parseObjectMethod(
              prop,
              isGenerator,
              isAsync,
              isPattern,
              containsEsc
            ) {
              if (isAsync || isGenerator || this.match(types.parenL)) {
                if (isPattern) this.unexpected();
                prop.kind = "method";
                prop.method = true;
                return this.parseMethod(
                  prop,
                  isGenerator,
                  isAsync,
                  false,
                  "ObjectMethod"
                );
              }

              if (
                !containsEsc &&
                this.isGetterOrSetterMethod(prop, isPattern)
              ) {
                if (isGenerator || isAsync) this.unexpected();
                prop.kind = prop.key.name;
                this.parsePropertyName(prop);
                this.parseMethod(prop, false, false, false, "ObjectMethod");
                this.checkGetterSetterParams(prop);
                return prop;
              }
            };

            _proto.parseObjectProperty = function parseObjectProperty(
              prop,
              startPos,
              startLoc,
              isPattern,
              refShorthandDefaultPos
            ) {
              prop.shorthand = false;

              if (this.eat(types.colon)) {
                prop.value = isPattern
                  ? this.parseMaybeDefault(
                      this.state.start,
                      this.state.startLoc
                    )
                  : this.parseMaybeAssign(false, refShorthandDefaultPos);
                return this.finishNode(prop, "ObjectProperty");
              }

              if (!prop.computed && prop.key.type === "Identifier") {
                this.checkReservedWord(
                  prop.key.name,
                  prop.key.start,
                  true,
                  true
                );

                if (isPattern) {
                  prop.value = this.parseMaybeDefault(
                    startPos,
                    startLoc,
                    prop.key.__clone()
                  );
                } else if (this.match(types.eq) && refShorthandDefaultPos) {
                  if (!refShorthandDefaultPos.start) {
                    refShorthandDefaultPos.start = this.state.start;
                  }

                  prop.value = this.parseMaybeDefault(
                    startPos,
                    startLoc,
                    prop.key.__clone()
                  );
                } else {
                  prop.value = prop.key.__clone();
                }

                prop.shorthand = true;
                return this.finishNode(prop, "ObjectProperty");
              }
            };

            _proto.parseObjPropValue = function parseObjPropValue(
              prop,
              startPos,
              startLoc,
              isGenerator,
              isAsync,
              isPattern,
              refShorthandDefaultPos,
              containsEsc
            ) {
              var node =
                this.parseObjectMethod(
                  prop,
                  isGenerator,
                  isAsync,
                  isPattern,
                  containsEsc
                ) ||
                this.parseObjectProperty(
                  prop,
                  startPos,
                  startLoc,
                  isPattern,
                  refShorthandDefaultPos
                );
              if (!node) this.unexpected();
              return node;
            };

            _proto.parsePropertyName = function parsePropertyName(prop) {
              if (this.eat(types.bracketL)) {
                prop.computed = true;
                prop.key = this.parseMaybeAssign();
                this.expect(types.bracketR);
              } else {
                var oldInPropertyName = this.state.inPropertyName;
                this.state.inPropertyName = true;
                prop.key =
                  this.match(types.num) || this.match(types.string)
                    ? this.parseExprAtom()
                    : this.parseMaybePrivateName();

                if (prop.key.type !== "PrivateName") {
                  prop.computed = false;
                }

                this.state.inPropertyName = oldInPropertyName;
              }

              return prop.key;
            };

            _proto.initFunction = function initFunction(node, isAsync) {
              node.id = null;
              node.generator = false;
              node.async = !!isAsync;
            };

            _proto.parseMethod = function parseMethod(
              node,
              isGenerator,
              isAsync,
              isConstructor,
              type
            ) {
              var oldInFunc = this.state.inFunction;
              var oldInMethod = this.state.inMethod;
              var oldInGenerator = this.state.inGenerator;
              this.state.inFunction = true;
              this.state.inMethod = node.kind || true;
              this.state.inGenerator = isGenerator;
              this.initFunction(node, isAsync);
              node.generator = !!isGenerator;
              var allowModifiers = isConstructor;
              this.parseFunctionParams(node, allowModifiers);
              this.parseFunctionBodyAndFinish(node, type);
              this.state.inFunction = oldInFunc;
              this.state.inMethod = oldInMethod;
              this.state.inGenerator = oldInGenerator;
              return node;
            };

            _proto.parseArrowExpression = function parseArrowExpression(
              node,
              params,
              isAsync
            ) {
              if (this.state.yieldInPossibleArrowParameters) {
                this.raise(
                  this.state.yieldInPossibleArrowParameters.start,
                  "yield is not allowed in the parameters of an arrow function" +
                    " inside a generator"
                );
              }

              var oldInFunc = this.state.inFunction;
              this.state.inFunction = true;
              this.initFunction(node, isAsync);
              if (params) this.setArrowFunctionParameters(node, params);
              var oldInGenerator = this.state.inGenerator;
              var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
              this.state.inGenerator = false;
              this.state.maybeInArrowParameters = false;
              this.parseFunctionBody(node, true);
              this.state.inGenerator = oldInGenerator;
              this.state.inFunction = oldInFunc;
              this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
              return this.finishNode(node, "ArrowFunctionExpression");
            };

            _proto.setArrowFunctionParameters = function setArrowFunctionParameters(
              node,
              params
            ) {
              node.params = this.toAssignableList(
                params,
                true,
                "arrow function parameters"
              );
            };

            _proto.isStrictBody = function isStrictBody(node) {
              var isBlockStatement = node.body.type === "BlockStatement";

              if (isBlockStatement && node.body.directives.length) {
                for (
                  var _i4 = 0, _node$body$directives2 = node.body.directives;
                  _i4 < _node$body$directives2.length;
                  _i4++
                ) {
                  var directive = _node$body$directives2[_i4];

                  if (directive.value.value === "use strict") {
                    return true;
                  }
                }
              }

              return false;
            };

            _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(
              node,
              type,
              allowExpressionBody
            ) {
              this.parseFunctionBody(node, allowExpressionBody);
              this.finishNode(node, type);
            };

            _proto.parseFunctionBody = function parseFunctionBody(
              node,
              allowExpression
            ) {
              var isExpression = allowExpression && !this.match(types.braceL);
              var oldInParameters = this.state.inParameters;
              var oldInAsync = this.state.inAsync;
              this.state.inParameters = false;
              this.state.inAsync = node.async;

              if (isExpression) {
                node.body = this.parseMaybeAssign();
              } else {
                var oldInGen = this.state.inGenerator;
                var oldInFunc = this.state.inFunction;
                var oldLabels = this.state.labels;
                this.state.inGenerator = node.generator;
                this.state.inFunction = true;
                this.state.labels = [];
                node.body = this.parseBlock(true);
                this.state.inFunction = oldInFunc;
                this.state.inGenerator = oldInGen;
                this.state.labels = oldLabels;
              }

              this.state.inAsync = oldInAsync;
              this.checkFunctionNameAndParams(node, allowExpression);
              this.state.inParameters = oldInParameters;
            };

            _proto.checkFunctionNameAndParams = function checkFunctionNameAndParams(
              node,
              isArrowFunction
            ) {
              var isStrict = this.isStrictBody(node);
              var checkLVal = this.state.strict || isStrict || isArrowFunction;
              var oldStrict = this.state.strict;
              if (isStrict) this.state.strict = isStrict;

              if (checkLVal) {
                var nameHash = Object.create(null);

                if (node.id) {
                  this.checkLVal(node.id, true, undefined, "function name");
                }

                for (
                  var _i6 = 0, _node$params2 = node.params;
                  _i6 < _node$params2.length;
                  _i6++
                ) {
                  var param = _node$params2[_i6];

                  if (isStrict && param.type !== "Identifier") {
                    this.raise(
                      param.start,
                      "Non-simple parameter in strict mode"
                    );
                  }

                  this.checkLVal(
                    param,
                    true,
                    nameHash,
                    "function parameter list"
                  );
                }
              }

              this.state.strict = oldStrict;
            };

            _proto.parseExprList = function parseExprList(
              close,
              allowEmpty,
              refShorthandDefaultPos
            ) {
              var elts = [];
              var first = true;

              while (!this.eat(close)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types.comma);
                  if (this.eat(close)) break;
                }

                elts.push(
                  this.parseExprListItem(allowEmpty, refShorthandDefaultPos)
                );
              }

              return elts;
            };

            _proto.parseExprListItem = function parseExprListItem(
              allowEmpty,
              refShorthandDefaultPos,
              refNeedsArrowPos,
              refTrailingCommaPos
            ) {
              var elt;

              if (allowEmpty && this.match(types.comma)) {
                elt = null;
              } else if (this.match(types.ellipsis)) {
                var spreadNodeStartPos = this.state.start;
                var spreadNodeStartLoc = this.state.startLoc;
                elt = this.parseParenItem(
                  this.parseSpread(refShorthandDefaultPos, refNeedsArrowPos),
                  spreadNodeStartPos,
                  spreadNodeStartLoc
                );

                if (refTrailingCommaPos && this.match(types.comma)) {
                  refTrailingCommaPos.start = this.state.start;
                }
              } else {
                elt = this.parseMaybeAssign(
                  false,
                  refShorthandDefaultPos,
                  this.parseParenItem,
                  refNeedsArrowPos
                );
              }

              return elt;
            };

            _proto.parseIdentifier = function parseIdentifier(liberal) {
              var node = this.startNode();
              var name = this.parseIdentifierName(node.start, liberal);
              node.name = name;
              node.loc.identifierName = name;
              return this.finishNode(node, "Identifier");
            };

            _proto.parseIdentifierName = function parseIdentifierName(
              pos,
              liberal
            ) {
              if (!liberal) {
                this.checkReservedWord(
                  this.state.value,
                  this.state.start,
                  !!this.state.type.keyword,
                  false
                );
              }

              var name;

              if (this.match(types.name)) {
                name = this.state.value;
              } else if (this.state.type.keyword) {
                name = this.state.type.keyword;
              } else {
                throw this.unexpected();
              }

              if (!liberal && name === "await" && this.state.inAsync) {
                this.raise(
                  pos,
                  "invalid use of await inside of an async function"
                );
              }

              this.next();
              return name;
            };

            _proto.checkReservedWord = function checkReservedWord(
              word,
              startLoc,
              checkKeywords,
              isBinding
            ) {
              if (
                this.state.strict &&
                (reservedWords.strict(word) ||
                  (isBinding && reservedWords.strictBind(word)))
              ) {
                this.raise(
                  startLoc,
                  word + " is a reserved word in strict mode"
                );
              }

              if (this.state.inGenerator && word === "yield") {
                this.raise(
                  startLoc,
                  "yield is a reserved word inside generator functions"
                );
              }

              if (this.state.inClassProperty && word === "arguments") {
                this.raise(
                  startLoc,
                  "'arguments' is not allowed in class field initializer"
                );
              }

              if (
                this.isReservedWord(word) ||
                (checkKeywords && this.isKeyword(word))
              ) {
                this.raise(startLoc, word + " is a reserved word");
              }
            };

            _proto.parseAwait = function parseAwait(node) {
              if (
                !this.state.inAsync &&
                (this.state.inFunction ||
                  !this.options.allowAwaitOutsideFunction)
              ) {
                this.unexpected();
              }

              if (this.match(types.star)) {
                this.raise(
                  node.start,
                  "await* has been removed from the async functions proposal. Use Promise.all() instead."
                );
              }

              node.argument = this.parseMaybeUnary();
              return this.finishNode(node, "AwaitExpression");
            };

            _proto.parseYield = function parseYield() {
              var node = this.startNode();

              if (this.state.inParameters) {
                this.raise(
                  node.start,
                  "yield is not allowed in generator parameters"
                );
              }

              if (
                this.state.maybeInArrowParameters &&
                !this.state.yieldInPossibleArrowParameters
              ) {
                this.state.yieldInPossibleArrowParameters = node;
              }

              this.next();

              if (
                this.match(types.semi) ||
                this.canInsertSemicolon() ||
                (!this.match(types.star) && !this.state.type.startsExpr)
              ) {
                node.delegate = false;
                node.argument = null;
              } else {
                node.delegate = this.eat(types.star);
                node.argument = this.parseMaybeAssign();
              }

              return this.finishNode(node, "YieldExpression");
            };

            return ExpressionParser;
          })(LValParser);

          var empty = [];
          var loopLabel = {
            kind: "loop",
          };
          var switchLabel = {
            kind: "switch",
          };

          var StatementParser = (function(_ExpressionParser) {
            _inheritsLoose(StatementParser, _ExpressionParser);

            function StatementParser() {
              return _ExpressionParser.apply(this, arguments) || this;
            }

            var _proto = StatementParser.prototype;

            _proto.parseTopLevel = function parseTopLevel(file, program) {
              program.sourceType = this.options.sourceType;
              program.interpreter = this.parseInterpreterDirective();
              this.parseBlockBody(program, true, true, types.eof);
              file.program = this.finishNode(program, "Program");
              file.comments = this.state.comments;
              if (this.options.tokens) file.tokens = this.state.tokens;
              return this.finishNode(file, "File");
            };

            _proto.stmtToDirective = function stmtToDirective(stmt) {
              var expr = stmt.expression;
              var directiveLiteral = this.startNodeAt(
                expr.start,
                expr.loc.start
              );
              var directive = this.startNodeAt(stmt.start, stmt.loc.start);
              var raw = this.input.slice(expr.start, expr.end);
              var val = (directiveLiteral.value = raw.slice(1, -1));
              this.addExtra(directiveLiteral, "raw", raw);
              this.addExtra(directiveLiteral, "rawValue", val);
              directive.value = this.finishNodeAt(
                directiveLiteral,
                "DirectiveLiteral",
                expr.end,
                expr.loc.end
              );
              return this.finishNodeAt(
                directive,
                "Directive",
                stmt.end,
                stmt.loc.end
              );
            };

            _proto.parseInterpreterDirective = function parseInterpreterDirective() {
              if (!this.match(types.interpreterDirective)) {
                return null;
              }

              var node = this.startNode();
              node.value = this.state.value;
              this.next();
              return this.finishNode(node, "InterpreterDirective");
            };

            _proto.parseStatement = function parseStatement(
              declaration,
              topLevel
            ) {
              if (this.match(types.at)) {
                this.parseDecorators(true);
              }

              return this.parseStatementContent(declaration, topLevel);
            };

            _proto.parseStatementContent = function parseStatementContent(
              declaration,
              topLevel
            ) {
              var starttype = this.state.type;
              var node = this.startNode();

              switch (starttype) {
                case types._break:
                case types._continue:
                  return this.parseBreakContinueStatement(
                    node,
                    starttype.keyword
                  );

                case types._debugger:
                  return this.parseDebuggerStatement(node);

                case types._do:
                  return this.parseDoStatement(node);

                case types._for:
                  return this.parseForStatement(node);

                case types._function:
                  if (this.lookahead().type === types.dot) break;
                  if (!declaration) this.unexpected();
                  return this.parseFunctionStatement(node);

                case types._class:
                  if (!declaration) this.unexpected();
                  return this.parseClass(node, true);

                case types._if:
                  return this.parseIfStatement(node);

                case types._return:
                  return this.parseReturnStatement(node);

                case types._switch:
                  return this.parseSwitchStatement(node);

                case types._throw:
                  return this.parseThrowStatement(node);

                case types._try:
                  return this.parseTryStatement(node);

                case types._let:
                case types._const:
                  if (!declaration) this.unexpected();

                case types._var:
                  return this.parseVarStatement(node, starttype);

                case types._while:
                  return this.parseWhileStatement(node);

                case types._with:
                  return this.parseWithStatement(node);

                case types.braceL:
                  return this.parseBlock();

                case types.semi:
                  return this.parseEmptyStatement(node);

                case types._export:
                case types._import: {
                  var nextToken = this.lookahead();

                  if (
                    nextToken.type === types.parenL ||
                    nextToken.type === types.dot
                  ) {
                    break;
                  }

                  if (!this.options.allowImportExportEverywhere && !topLevel) {
                    this.raise(
                      this.state.start,
                      "'import' and 'export' may only appear at the top level"
                    );
                  }

                  this.next();
                  var result;

                  if (starttype == types._import) {
                    result = this.parseImport(node);

                    if (
                      result.type === "ImportDeclaration" &&
                      (!result.importKind || result.importKind === "value")
                    ) {
                      this.sawUnambiguousESM = true;
                    }
                  } else {
                    result = this.parseExport(node);

                    if (
                      (result.type === "ExportNamedDeclaration" &&
                        (!result.exportKind ||
                          result.exportKind === "value")) ||
                      (result.type === "ExportAllDeclaration" &&
                        (!result.exportKind ||
                          result.exportKind === "value")) ||
                      result.type === "ExportDefaultDeclaration"
                    ) {
                      this.sawUnambiguousESM = true;
                    }
                  }

                  this.assertModuleNodeAllowed(node);
                  return result;
                }

                case types.name:
                  if (this.isContextual("async")) {
                    var state = this.state.clone();
                    this.next();

                    if (
                      this.match(types._function) &&
                      !this.canInsertSemicolon()
                    ) {
                      this.expect(types._function);
                      return this.parseFunction(node, true, false, true);
                    } else {
                      this.state = state;
                    }
                  }
              }

              var maybeName = this.state.value;
              var expr = this.parseExpression();

              if (
                starttype === types.name &&
                expr.type === "Identifier" &&
                this.eat(types.colon)
              ) {
                return this.parseLabeledStatement(node, maybeName, expr);
              } else {
                return this.parseExpressionStatement(node, expr);
              }
            };

            _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(
              node
            ) {
              if (!this.options.allowImportExportEverywhere && !this.inModule) {
                this.raise(
                  node.start,
                  "'import' and 'export' may appear only with 'sourceType: \"module\"'",
                  {
                    code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED",
                  }
                );
              }
            };

            _proto.takeDecorators = function takeDecorators(node) {
              var decorators = this.state.decoratorStack[
                this.state.decoratorStack.length - 1
              ];

              if (decorators.length) {
                node.decorators = decorators;
                this.resetStartLocationFromNode(node, decorators[0]);
                this.state.decoratorStack[
                  this.state.decoratorStack.length - 1
                ] = [];
              }
            };

            _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
              return this.match(types._class);
            };

            _proto.parseDecorators = function parseDecorators(allowExport) {
              var currentContextDecorators = this.state.decoratorStack[
                this.state.decoratorStack.length - 1
              ];

              while (this.match(types.at)) {
                var decorator = this.parseDecorator();
                currentContextDecorators.push(decorator);
              }

              if (this.match(types._export)) {
                if (!allowExport) {
                  this.unexpected();
                }

                if (
                  this.hasPlugin("decorators") &&
                  !this.getPluginOption("decorators", "decoratorsBeforeExport")
                ) {
                  this.raise(
                    this.state.start,
                    "Using the export keyword between a decorator and a class is not allowed. " +
                      "Please use `export @dec class` instead."
                  );
                }
              } else if (!this.canHaveLeadingDecorator()) {
                this.raise(
                  this.state.start,
                  "Leading decorators must be attached to a class declaration"
                );
              }
            };

            _proto.parseDecorator = function parseDecorator() {
              this.expectOnePlugin(["decorators-legacy", "decorators"]);
              var node = this.startNode();
              this.next();

              if (this.hasPlugin("decorators")) {
                this.state.decoratorStack.push([]);
                var startPos = this.state.start;
                var startLoc = this.state.startLoc;
                var expr;

                if (this.eat(types.parenL)) {
                  expr = this.parseExpression();
                  this.expect(types.parenR);
                } else {
                  expr = this.parseIdentifier(false);

                  while (this.eat(types.dot)) {
                    var _node = this.startNodeAt(startPos, startLoc);

                    _node.object = expr;
                    _node.property = this.parseIdentifier(true);
                    _node.computed = false;
                    expr = this.finishNode(_node, "MemberExpression");
                  }
                }

                if (this.eat(types.parenL)) {
                  var _node2 = this.startNodeAt(startPos, startLoc);

                  _node2.callee = expr;
                  _node2.arguments = this.parseCallExpressionArguments(
                    types.parenR,
                    false
                  );
                  this.toReferencedList(_node2.arguments);
                  expr = this.finishNode(_node2, "CallExpression");
                }

                node.expression = expr;
                this.state.decoratorStack.pop();
              } else {
                node.expression = this.parseMaybeAssign();
              }

              return this.finishNode(node, "Decorator");
            };

            _proto.parseBreakContinueStatement = function parseBreakContinueStatement(
              node,
              keyword
            ) {
              var isBreak = keyword === "break";
              this.next();

              if (this.isLineTerminator()) {
                node.label = null;
              } else if (!this.match(types.name)) {
                this.unexpected();
              } else {
                node.label = this.parseIdentifier();
                this.semicolon();
              }

              var i;

              for (i = 0; i < this.state.labels.length; ++i) {
                var lab = this.state.labels[i];

                if (node.label == null || lab.name === node.label.name) {
                  if (lab.kind != null && (isBreak || lab.kind === "loop"))
                    break;
                  if (node.label && isBreak) break;
                }
              }

              if (i === this.state.labels.length) {
                this.raise(node.start, "Unsyntactic " + keyword);
              }

              return this.finishNode(
                node,
                isBreak ? "BreakStatement" : "ContinueStatement"
              );
            };

            _proto.parseDebuggerStatement = function parseDebuggerStatement(
              node
            ) {
              this.next();
              this.semicolon();
              return this.finishNode(node, "DebuggerStatement");
            };

            _proto.parseDoStatement = function parseDoStatement(node) {
              this.next();
              this.state.labels.push(loopLabel);
              node.body = this.parseStatement(false);
              this.state.labels.pop();
              this.expect(types._while);
              node.test = this.parseParenExpression();
              this.eat(types.semi);
              return this.finishNode(node, "DoWhileStatement");
            };

            _proto.parseForStatement = function parseForStatement(node) {
              this.next();
              this.state.labels.push(loopLabel);
              var forAwait = false;

              if (this.state.inAsync && this.isContextual("await")) {
                this.expectPlugin("asyncGenerators");
                forAwait = true;
                this.next();
              }

              this.expect(types.parenL);

              if (this.match(types.semi)) {
                if (forAwait) {
                  this.unexpected();
                }

                return this.parseFor(node, null);
              }

              if (
                this.match(types._var) ||
                this.match(types._let) ||
                this.match(types._const)
              ) {
                var _init = this.startNode();

                var varKind = this.state.type;
                this.next();
                this.parseVar(_init, true, varKind);
                this.finishNode(_init, "VariableDeclaration");

                if (this.match(types._in) || this.isContextual("of")) {
                  if (_init.declarations.length === 1) {
                    var declaration = _init.declarations[0];
                    var isForInInitializer =
                      varKind === types._var &&
                      declaration.init &&
                      declaration.id.type != "ObjectPattern" &&
                      declaration.id.type != "ArrayPattern" &&
                      !this.isContextual("of");

                    if (this.state.strict && isForInInitializer) {
                      this.raise(
                        this.state.start,
                        "for-in initializer in strict mode"
                      );
                    } else if (isForInInitializer || !declaration.init) {
                      return this.parseForIn(node, _init, forAwait);
                    }
                  }
                }

                if (forAwait) {
                  this.unexpected();
                }

                return this.parseFor(node, _init);
              }

              var refShorthandDefaultPos = {
                start: 0,
              };
              var init = this.parseExpression(true, refShorthandDefaultPos);

              if (this.match(types._in) || this.isContextual("of")) {
                var description = this.isContextual("of")
                  ? "for-of statement"
                  : "for-in statement";
                this.toAssignable(init, undefined, description);
                this.checkLVal(init, undefined, undefined, description);
                return this.parseForIn(node, init, forAwait);
              } else if (refShorthandDefaultPos.start) {
                this.unexpected(refShorthandDefaultPos.start);
              }

              if (forAwait) {
                this.unexpected();
              }

              return this.parseFor(node, init);
            };

            _proto.parseFunctionStatement = function parseFunctionStatement(
              node
            ) {
              this.next();
              return this.parseFunction(node, true);
            };

            _proto.parseIfStatement = function parseIfStatement(node) {
              this.next();
              node.test = this.parseParenExpression();
              node.consequent = this.parseStatement(false);
              node.alternate = this.eat(types._else)
                ? this.parseStatement(false)
                : null;
              return this.finishNode(node, "IfStatement");
            };

            _proto.parseReturnStatement = function parseReturnStatement(node) {
              if (
                !this.state.inFunction &&
                !this.options.allowReturnOutsideFunction
              ) {
                this.raise(this.state.start, "'return' outside of function");
              }

              this.next();

              if (this.isLineTerminator()) {
                node.argument = null;
              } else {
                node.argument = this.parseExpression();
                this.semicolon();
              }

              return this.finishNode(node, "ReturnStatement");
            };

            _proto.parseSwitchStatement = function parseSwitchStatement(node) {
              this.next();
              node.discriminant = this.parseParenExpression();
              var cases = (node.cases = []);
              this.expect(types.braceL);
              this.state.labels.push(switchLabel);
              var cur;

              for (var sawDefault; !this.match(types.braceR); ) {
                if (this.match(types._case) || this.match(types._default)) {
                  var isCase = this.match(types._case);
                  if (cur) this.finishNode(cur, "SwitchCase");
                  cases.push((cur = this.startNode()));
                  cur.consequent = [];
                  this.next();

                  if (isCase) {
                    cur.test = this.parseExpression();
                  } else {
                    if (sawDefault) {
                      this.raise(
                        this.state.lastTokStart,
                        "Multiple default clauses"
                      );
                    }

                    sawDefault = true;
                    cur.test = null;
                  }

                  this.expect(types.colon);
                } else {
                  if (cur) {
                    cur.consequent.push(this.parseStatement(true));
                  } else {
                    this.unexpected();
                  }
                }
              }

              if (cur) this.finishNode(cur, "SwitchCase");
              this.next();
              this.state.labels.pop();
              return this.finishNode(node, "SwitchStatement");
            };

            _proto.parseThrowStatement = function parseThrowStatement(node) {
              this.next();

              if (
                lineBreak.test(
                  this.input.slice(this.state.lastTokEnd, this.state.start)
                )
              ) {
                this.raise(
                  this.state.lastTokEnd,
                  "Illegal newline after throw"
                );
              }

              node.argument = this.parseExpression();
              this.semicolon();
              return this.finishNode(node, "ThrowStatement");
            };

            _proto.parseTryStatement = function parseTryStatement(node) {
              this.next();
              node.block = this.parseBlock();
              node.handler = null;

              if (this.match(types._catch)) {
                var clause = this.startNode();
                this.next();

                if (this.match(types.parenL)) {
                  this.expect(types.parenL);
                  clause.param = this.parseBindingAtom();
                  var clashes = Object.create(null);
                  this.checkLVal(clause.param, true, clashes, "catch clause");
                  this.expect(types.parenR);
                } else {
                  this.expectPlugin("optionalCatchBinding");
                  clause.param = null;
                }

                clause.body = this.parseBlock();
                node.handler = this.finishNode(clause, "CatchClause");
              }

              node.guardedHandlers = empty;
              node.finalizer = this.eat(types._finally)
                ? this.parseBlock()
                : null;

              if (!node.handler && !node.finalizer) {
                this.raise(node.start, "Missing catch or finally clause");
              }

              return this.finishNode(node, "TryStatement");
            };

            _proto.parseVarStatement = function parseVarStatement(node, kind) {
              this.next();
              this.parseVar(node, false, kind);
              this.semicolon();
              return this.finishNode(node, "VariableDeclaration");
            };

            _proto.parseWhileStatement = function parseWhileStatement(node) {
              this.next();
              node.test = this.parseParenExpression();
              this.state.labels.push(loopLabel);
              node.body = this.parseStatement(false);
              this.state.labels.pop();
              return this.finishNode(node, "WhileStatement");
            };

            _proto.parseWithStatement = function parseWithStatement(node) {
              if (this.state.strict) {
                this.raise(this.state.start, "'with' in strict mode");
              }

              this.next();
              node.object = this.parseParenExpression();
              node.body = this.parseStatement(false);
              return this.finishNode(node, "WithStatement");
            };

            _proto.parseEmptyStatement = function parseEmptyStatement(node) {
              this.next();
              return this.finishNode(node, "EmptyStatement");
            };

            _proto.parseLabeledStatement = function parseLabeledStatement(
              node,
              maybeName,
              expr
            ) {
              for (
                var _i2 = 0, _this$state$labels2 = this.state.labels;
                _i2 < _this$state$labels2.length;
                _i2++
              ) {
                var label = _this$state$labels2[_i2];

                if (label.name === maybeName) {
                  this.raise(
                    expr.start,
                    "Label '" + maybeName + "' is already declared"
                  );
                }
              }

              var kind = this.state.type.isLoop
                ? "loop"
                : this.match(types._switch)
                  ? "switch"
                  : null;

              for (var i = this.state.labels.length - 1; i >= 0; i--) {
                var _label = this.state.labels[i];

                if (_label.statementStart === node.start) {
                  _label.statementStart = this.state.start;
                  _label.kind = kind;
                } else {
                  break;
                }
              }

              this.state.labels.push({
                name: maybeName,
                kind: kind,
                statementStart: this.state.start,
              });
              node.body = this.parseStatement(true);

              if (
                node.body.type == "ClassDeclaration" ||
                (node.body.type == "VariableDeclaration" &&
                  node.body.kind !== "var") ||
                (node.body.type == "FunctionDeclaration" &&
                  (this.state.strict || node.body.generator || node.body.async))
              ) {
                this.raise(node.body.start, "Invalid labeled declaration");
              }

              this.state.labels.pop();
              node.label = expr;
              return this.finishNode(node, "LabeledStatement");
            };

            _proto.parseExpressionStatement = function parseExpressionStatement(
              node,
              expr
            ) {
              node.expression = expr;
              this.semicolon();
              return this.finishNode(node, "ExpressionStatement");
            };

            _proto.parseBlock = function parseBlock(allowDirectives) {
              var node = this.startNode();
              this.expect(types.braceL);
              this.parseBlockBody(node, allowDirectives, false, types.braceR);
              return this.finishNode(node, "BlockStatement");
            };

            _proto.isValidDirective = function isValidDirective(stmt) {
              return (
                stmt.type === "ExpressionStatement" &&
                stmt.expression.type === "StringLiteral" &&
                !stmt.expression.extra.parenthesized
              );
            };

            _proto.parseBlockBody = function parseBlockBody(
              node,
              allowDirectives,
              topLevel,
              end
            ) {
              var body = (node.body = []);
              var directives = (node.directives = []);
              this.parseBlockOrModuleBlockBody(
                body,
                allowDirectives ? directives : undefined,
                topLevel,
                end
              );
            };

            _proto.parseBlockOrModuleBlockBody = function parseBlockOrModuleBlockBody(
              body,
              directives,
              topLevel,
              end
            ) {
              var parsedNonDirective = false;
              var oldStrict;
              var octalPosition;

              while (!this.eat(end)) {
                if (
                  !parsedNonDirective &&
                  this.state.containsOctal &&
                  !octalPosition
                ) {
                  octalPosition = this.state.octalPosition;
                }

                var stmt = this.parseStatement(true, topLevel);

                if (
                  directives &&
                  !parsedNonDirective &&
                  this.isValidDirective(stmt)
                ) {
                  var directive = this.stmtToDirective(stmt);
                  directives.push(directive);

                  if (
                    oldStrict === undefined &&
                    directive.value.value === "use strict"
                  ) {
                    oldStrict = this.state.strict;
                    this.setStrict(true);

                    if (octalPosition) {
                      this.raise(octalPosition, "Octal literal in strict mode");
                    }
                  }

                  continue;
                }

                parsedNonDirective = true;
                body.push(stmt);
              }

              if (oldStrict === false) {
                this.setStrict(false);
              }
            };

            _proto.parseFor = function parseFor(node, init) {
              node.init = init;
              this.expect(types.semi);
              node.test = this.match(types.semi)
                ? null
                : this.parseExpression();
              this.expect(types.semi);
              node.update = this.match(types.parenR)
                ? null
                : this.parseExpression();
              this.expect(types.parenR);
              node.body = this.parseStatement(false);
              this.state.labels.pop();
              return this.finishNode(node, "ForStatement");
            };

            _proto.parseForIn = function parseForIn(node, init, forAwait) {
              var type = this.match(types._in)
                ? "ForInStatement"
                : "ForOfStatement";

              if (forAwait) {
                this.eatContextual("of");
              } else {
                this.next();
              }

              if (type === "ForOfStatement") {
                node.await = !!forAwait;
              }

              node.left = init;
              node.right = this.parseExpression();
              this.expect(types.parenR);
              node.body = this.parseStatement(false);
              this.state.labels.pop();
              return this.finishNode(node, type);
            };

            _proto.parseVar = function parseVar(node, isFor, kind) {
              var declarations = (node.declarations = []);
              node.kind = kind.keyword;

              for (;;) {
                var decl = this.startNode();
                this.parseVarHead(decl);

                if (this.eat(types.eq)) {
                  decl.init = this.parseMaybeAssign(isFor);
                } else {
                  if (
                    kind === types._const &&
                    !(this.match(types._in) || this.isContextual("of"))
                  ) {
                    if (!this.hasPlugin("typescript")) {
                      this.unexpected();
                    }
                  } else if (
                    decl.id.type !== "Identifier" &&
                    !(
                      isFor &&
                      (this.match(types._in) || this.isContextual("of"))
                    )
                  ) {
                    this.raise(
                      this.state.lastTokEnd,
                      "Complex binding patterns require an initialization value"
                    );
                  }

                  decl.init = null;
                }

                declarations.push(this.finishNode(decl, "VariableDeclarator"));
                if (!this.eat(types.comma)) break;
              }

              return node;
            };

            _proto.parseVarHead = function parseVarHead(decl) {
              decl.id = this.parseBindingAtom();
              this.checkLVal(decl.id, true, undefined, "variable declaration");
            };

            _proto.parseFunction = function parseFunction(
              node,
              isStatement,
              allowExpressionBody,
              isAsync,
              optionalId
            ) {
              var oldInFunc = this.state.inFunction;
              var oldInMethod = this.state.inMethod;
              var oldInGenerator = this.state.inGenerator;
              var oldInClassProperty = this.state.inClassProperty;
              this.state.inFunction = true;
              this.state.inMethod = false;
              this.state.inClassProperty = false;
              this.initFunction(node, isAsync);

              if (this.match(types.star)) {
                if (node.async) {
                  this.expectPlugin("asyncGenerators");
                }

                node.generator = true;
                this.next();
              }

              if (
                isStatement &&
                !optionalId &&
                !this.match(types.name) &&
                !this.match(types._yield)
              ) {
                this.unexpected();
              }

              if (!isStatement) this.state.inGenerator = node.generator;

              if (this.match(types.name) || this.match(types._yield)) {
                node.id = this.parseBindingIdentifier();
              }

              if (isStatement) this.state.inGenerator = node.generator;
              this.parseFunctionParams(node);
              this.parseFunctionBodyAndFinish(
                node,
                isStatement ? "FunctionDeclaration" : "FunctionExpression",
                allowExpressionBody
              );
              this.state.inFunction = oldInFunc;
              this.state.inMethod = oldInMethod;
              this.state.inGenerator = oldInGenerator;
              this.state.inClassProperty = oldInClassProperty;
              return node;
            };

            _proto.parseFunctionParams = function parseFunctionParams(
              node,
              allowModifiers
            ) {
              var oldInParameters = this.state.inParameters;
              this.state.inParameters = true;
              this.expect(types.parenL);
              node.params = this.parseBindingList(
                types.parenR,
                false,
                allowModifiers
              );
              this.state.inParameters = oldInParameters;
            };

            _proto.parseClass = function parseClass(
              node,
              isStatement,
              optionalId
            ) {
              this.next();
              this.takeDecorators(node);
              this.parseClassId(node, isStatement, optionalId);
              this.parseClassSuper(node);
              this.parseClassBody(node);
              return this.finishNode(
                node,
                isStatement ? "ClassDeclaration" : "ClassExpression"
              );
            };

            _proto.isClassProperty = function isClassProperty() {
              return (
                this.match(types.eq) ||
                this.match(types.semi) ||
                this.match(types.braceR)
              );
            };

            _proto.isClassMethod = function isClassMethod() {
              return this.match(types.parenL);
            };

            _proto.isNonstaticConstructor = function isNonstaticConstructor(
              method
            ) {
              return (
                !method.computed &&
                !method.static &&
                (method.key.name === "constructor" ||
                  method.key.value === "constructor")
              );
            };

            _proto.parseClassBody = function parseClassBody(node) {
              var oldStrict = this.state.strict;
              this.state.strict = true;
              this.state.classLevel++;
              var state = {
                hadConstructor: false,
              };
              var decorators = [];
              var classBody = this.startNode();
              classBody.body = [];
              this.expect(types.braceL);

              while (!this.eat(types.braceR)) {
                if (this.eat(types.semi)) {
                  if (decorators.length > 0) {
                    this.raise(
                      this.state.lastTokEnd,
                      "Decorators must not be followed by a semicolon"
                    );
                  }

                  continue;
                }

                if (this.match(types.at)) {
                  decorators.push(this.parseDecorator());
                  continue;
                }

                var member = this.startNode();

                if (decorators.length) {
                  member.decorators = decorators;
                  this.resetStartLocationFromNode(member, decorators[0]);
                  decorators = [];
                }

                this.parseClassMember(classBody, member, state);

                if (
                  member.kind === "constructor" &&
                  member.decorators &&
                  member.decorators.length > 0
                ) {
                  this.raise(
                    member.start,
                    "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"
                  );
                }
              }

              if (decorators.length) {
                this.raise(
                  this.state.start,
                  "You have trailing decorators with no method"
                );
              }

              node.body = this.finishNode(classBody, "ClassBody");
              this.state.classLevel--;
              this.state.strict = oldStrict;
            };

            _proto.parseClassMember = function parseClassMember(
              classBody,
              member,
              state
            ) {
              var isStatic = false;
              var containsEsc = this.state.containsEsc;

              if (this.match(types.name) && this.state.value === "static") {
                var key = this.parseIdentifier(true);

                if (this.isClassMethod()) {
                  var method = member;
                  method.kind = "method";
                  method.computed = false;
                  method.key = key;
                  method.static = false;
                  this.pushClassMethod(classBody, method, false, false, false);
                  return;
                } else if (this.isClassProperty()) {
                  var prop = member;
                  prop.computed = false;
                  prop.key = key;
                  prop.static = false;
                  classBody.body.push(this.parseClassProperty(prop));
                  return;
                } else if (containsEsc) {
                  throw this.unexpected();
                }

                isStatic = true;
              }

              this.parseClassMemberWithIsStatic(
                classBody,
                member,
                state,
                isStatic
              );
            };

            _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(
              classBody,
              member,
              state,
              isStatic
            ) {
              var publicMethod = member;
              var privateMethod = member;
              var publicProp = member;
              var privateProp = member;
              var method = publicMethod;
              var publicMember = publicMethod;
              member.static = isStatic;

              if (this.eat(types.star)) {
                method.kind = "method";
                this.parseClassPropertyName(method);

                if (method.key.type === "PrivateName") {
                  this.pushClassPrivateMethod(
                    classBody,
                    privateMethod,
                    true,
                    false
                  );
                  return;
                }

                if (this.isNonstaticConstructor(publicMethod)) {
                  this.raise(
                    publicMethod.key.start,
                    "Constructor can't be a generator"
                  );
                }

                this.pushClassMethod(
                  classBody,
                  publicMethod,
                  true,
                  false,
                  false
                );
                return;
              }

              var key = this.parseClassPropertyName(member);
              var isPrivate = key.type === "PrivateName";
              var isSimple = key.type === "Identifier";
              this.parsePostMemberNameModifiers(publicMember);

              if (this.isClassMethod()) {
                method.kind = "method";

                if (isPrivate) {
                  this.pushClassPrivateMethod(
                    classBody,
                    privateMethod,
                    false,
                    false
                  );
                  return;
                }

                var isConstructor = this.isNonstaticConstructor(publicMethod);

                if (isConstructor) {
                  publicMethod.kind = "constructor";

                  if (publicMethod.decorators) {
                    this.raise(
                      publicMethod.start,
                      "You can't attach decorators to a class constructor"
                    );
                  }

                  if (state.hadConstructor && !this.hasPlugin("typescript")) {
                    this.raise(
                      key.start,
                      "Duplicate constructor in the same class"
                    );
                  }

                  state.hadConstructor = true;
                }

                this.pushClassMethod(
                  classBody,
                  publicMethod,
                  false,
                  false,
                  isConstructor
                );
              } else if (this.isClassProperty()) {
                if (isPrivate) {
                  this.pushClassPrivateProperty(classBody, privateProp);
                } else {
                  this.pushClassProperty(classBody, publicProp);
                }
              } else if (
                isSimple &&
                key.name === "async" &&
                !this.isLineTerminator()
              ) {
                var isGenerator = this.match(types.star);

                if (isGenerator) {
                  this.expectPlugin("asyncGenerators");
                  this.next();
                }

                method.kind = "method";
                this.parseClassPropertyName(method);

                if (method.key.type === "PrivateName") {
                  this.pushClassPrivateMethod(
                    classBody,
                    privateMethod,
                    isGenerator,
                    true
                  );
                } else {
                  if (this.isNonstaticConstructor(publicMethod)) {
                    this.raise(
                      publicMethod.key.start,
                      "Constructor can't be an async function"
                    );
                  }

                  this.pushClassMethod(
                    classBody,
                    publicMethod,
                    isGenerator,
                    true,
                    false
                  );
                }
              } else if (
                isSimple &&
                (key.name === "get" || key.name === "set") &&
                !(this.isLineTerminator() && this.match(types.star))
              ) {
                method.kind = key.name;
                this.parseClassPropertyName(publicMethod);

                if (method.key.type === "PrivateName") {
                  this.pushClassPrivateMethod(
                    classBody,
                    privateMethod,
                    false,
                    false
                  );
                } else {
                  if (this.isNonstaticConstructor(publicMethod)) {
                    this.raise(
                      publicMethod.key.start,
                      "Constructor can't have get/set modifier"
                    );
                  }

                  this.pushClassMethod(
                    classBody,
                    publicMethod,
                    false,
                    false,
                    false
                  );
                }

                this.checkGetterSetterParams(publicMethod);
              } else if (this.isLineTerminator()) {
                if (isPrivate) {
                  this.pushClassPrivateProperty(classBody, privateProp);
                } else {
                  this.pushClassProperty(classBody, publicProp);
                }
              } else {
                this.unexpected();
              }
            };

            _proto.parseClassPropertyName = function parseClassPropertyName(
              member
            ) {
              var key = this.parsePropertyName(member);

              if (
                !member.computed &&
                member.static &&
                (key.name === "prototype" || key.value === "prototype")
              ) {
                this.raise(
                  key.start,
                  "Classes may not have static property named prototype"
                );
              }

              if (key.type === "PrivateName" && key.id.name === "constructor") {
                this.raise(
                  key.start,
                  "Classes may not have a private field named '#constructor'"
                );
              }

              return key;
            };

            _proto.pushClassProperty = function pushClassProperty(
              classBody,
              prop
            ) {
              if (this.isNonstaticConstructor(prop)) {
                this.raise(
                  prop.key.start,
                  "Classes may not have a non-static field named 'constructor'"
                );
              }

              classBody.body.push(this.parseClassProperty(prop));
            };

            _proto.pushClassPrivateProperty = function pushClassPrivateProperty(
              classBody,
              prop
            ) {
              this.expectPlugin("classPrivateProperties", prop.key.start);
              classBody.body.push(this.parseClassPrivateProperty(prop));
            };

            _proto.pushClassMethod = function pushClassMethod(
              classBody,
              method,
              isGenerator,
              isAsync,
              isConstructor
            ) {
              classBody.body.push(
                this.parseMethod(
                  method,
                  isGenerator,
                  isAsync,
                  isConstructor,
                  "ClassMethod"
                )
              );
            };

            _proto.pushClassPrivateMethod = function pushClassPrivateMethod(
              classBody,
              method,
              isGenerator,
              isAsync
            ) {
              this.expectPlugin("classPrivateMethods", method.key.start);
              classBody.body.push(
                this.parseMethod(
                  method,
                  isGenerator,
                  isAsync,
                  false,
                  "ClassPrivateMethod"
                )
              );
            };

            _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(
              methodOrProp
            ) {};

            _proto.parseAccessModifier = function parseAccessModifier() {
              return undefined;
            };

            _proto.parseClassPrivateProperty = function parseClassPrivateProperty(
              node
            ) {
              var oldInMethod = this.state.inMethod;
              this.state.inMethod = false;
              this.state.inClassProperty = true;
              node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;
              this.semicolon();
              this.state.inClassProperty = false;
              this.state.inMethod = oldInMethod;
              return this.finishNode(node, "ClassPrivateProperty");
            };

            _proto.parseClassProperty = function parseClassProperty(node) {
              if (!node.typeAnnotation) {
                this.expectPlugin("classProperties");
              }

              var oldInMethod = this.state.inMethod;
              this.state.inMethod = false;
              this.state.inClassProperty = true;

              if (this.match(types.eq)) {
                this.expectPlugin("classProperties");
                this.next();
                node.value = this.parseMaybeAssign();
              } else {
                node.value = null;
              }

              this.semicolon();
              this.state.inClassProperty = false;
              this.state.inMethod = oldInMethod;
              return this.finishNode(node, "ClassProperty");
            };

            _proto.parseClassId = function parseClassId(
              node,
              isStatement,
              optionalId
            ) {
              if (this.match(types.name)) {
                node.id = this.parseIdentifier();
              } else {
                if (optionalId || !isStatement) {
                  node.id = null;
                } else {
                  this.unexpected(null, "A class name is required");
                }
              }
            };

            _proto.parseClassSuper = function parseClassSuper(node) {
              node.superClass = this.eat(types._extends)
                ? this.parseExprSubscripts()
                : null;
            };

            _proto.parseExport = function parseExport(node) {
              if (this.shouldParseExportStar()) {
                this.parseExportStar(node);
                if (node.type === "ExportAllDeclaration") return node;
              } else if (this.isExportDefaultSpecifier()) {
                this.expectPlugin("exportDefaultFrom");
                var specifier = this.startNode();
                specifier.exported = this.parseIdentifier(true);
                var specifiers = [
                  this.finishNode(specifier, "ExportDefaultSpecifier"),
                ];
                node.specifiers = specifiers;

                if (
                  this.match(types.comma) &&
                  this.lookahead().type === types.star
                ) {
                  this.expect(types.comma);

                  var _specifier = this.startNode();

                  this.expect(types.star);
                  this.expectContextual("as");
                  _specifier.exported = this.parseIdentifier();
                  specifiers.push(
                    this.finishNode(_specifier, "ExportNamespaceSpecifier")
                  );
                } else {
                  this.parseExportSpecifiersMaybe(node);
                }

                this.parseExportFrom(node, true);
              } else if (this.eat(types._default)) {
                node.declaration = this.parseExportDefaultExpression();
                this.checkExport(node, true, true);
                return this.finishNode(node, "ExportDefaultDeclaration");
              } else if (this.shouldParseExportDeclaration()) {
                if (this.isContextual("async")) {
                  var next = this.lookahead();

                  if (next.type !== types._function) {
                    this.unexpected(
                      next.start,
                      'Unexpected token, expected "function"'
                    );
                  }
                }

                node.specifiers = [];
                node.source = null;
                node.declaration = this.parseExportDeclaration(node);
              } else {
                node.declaration = null;
                node.specifiers = this.parseExportSpecifiers();
                this.parseExportFrom(node);
              }

              this.checkExport(node, true);
              return this.finishNode(node, "ExportNamedDeclaration");
            };

            _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
              var expr = this.startNode();

              if (this.eat(types._function)) {
                return this.parseFunction(expr, true, false, false, true);
              } else if (
                this.isContextual("async") &&
                this.lookahead().type === types._function
              ) {
                this.eatContextual("async");
                this.eat(types._function);
                return this.parseFunction(expr, true, false, true, true);
              } else if (this.match(types._class)) {
                return this.parseClass(expr, true, true);
              } else if (this.match(types.at)) {
                if (
                  this.hasPlugin("decorators") &&
                  this.getPluginOption("decorators", "decoratorsBeforeExport")
                ) {
                  this.unexpected(
                    this.state.start,
                    "Decorators must be placed *before* the 'export' keyword." +
                      " You can set the 'decoratorsBeforeExport' option to false to use" +
                      " the 'export @decorator class {}' syntax"
                  );
                }

                this.parseDecorators(false);
                return this.parseClass(expr, true, true);
              } else if (
                this.match(types._let) ||
                this.match(types._const) ||
                this.match(types._var)
              ) {
                return this.raise(
                  this.state.start,
                  "Only expressions, functions or classes are allowed as the `default` export."
                );
              } else {
                var res = this.parseMaybeAssign();
                this.semicolon();
                return res;
              }
            };

            _proto.parseExportDeclaration = function parseExportDeclaration(
              node
            ) {
              return this.parseStatement(true);
            };

            _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
              if (this.match(types.name)) {
                return this.state.value !== "async";
              }

              if (!this.match(types._default)) {
                return false;
              }

              var lookahead = this.lookahead();
              return (
                lookahead.type === types.comma ||
                (lookahead.type === types.name && lookahead.value === "from")
              );
            };

            _proto.parseExportSpecifiersMaybe = function parseExportSpecifiersMaybe(
              node
            ) {
              if (this.eat(types.comma)) {
                node.specifiers = node.specifiers.concat(
                  this.parseExportSpecifiers()
                );
              }
            };

            _proto.parseExportFrom = function parseExportFrom(node, expect) {
              if (this.eatContextual("from")) {
                node.source = this.match(types.string)
                  ? this.parseExprAtom()
                  : this.unexpected();
                this.checkExport(node);
              } else {
                if (expect) {
                  this.unexpected();
                } else {
                  node.source = null;
                }
              }

              this.semicolon();
            };

            _proto.shouldParseExportStar = function shouldParseExportStar() {
              return this.match(types.star);
            };

            _proto.parseExportStar = function parseExportStar(node) {
              this.expect(types.star);

              if (this.isContextual("as")) {
                this.parseExportNamespace(node);
              } else {
                this.parseExportFrom(node, true);
                this.finishNode(node, "ExportAllDeclaration");
              }
            };

            _proto.parseExportNamespace = function parseExportNamespace(node) {
              this.expectPlugin("exportNamespaceFrom");
              var specifier = this.startNodeAt(
                this.state.lastTokStart,
                this.state.lastTokStartLoc
              );
              this.next();
              specifier.exported = this.parseIdentifier(true);
              node.specifiers = [
                this.finishNode(specifier, "ExportNamespaceSpecifier"),
              ];
              this.parseExportSpecifiersMaybe(node);
              this.parseExportFrom(node, true);
            };

            _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
              if (this.match(types.at)) {
                this.expectOnePlugin(["decorators", "decorators-legacy"]);

                if (this.hasPlugin("decorators")) {
                  if (
                    this.getPluginOption("decorators", "decoratorsBeforeExport")
                  ) {
                    this.unexpected(
                      this.state.start,
                      "Decorators must be placed *before* the 'export' keyword." +
                        " You can set the 'decoratorsBeforeExport' option to false to use" +
                        " the 'export @decorator class {}' syntax"
                    );
                  } else {
                    return true;
                  }
                }
              }

              return (
                this.state.type.keyword === "var" ||
                this.state.type.keyword === "const" ||
                this.state.type.keyword === "let" ||
                this.state.type.keyword === "function" ||
                this.state.type.keyword === "class" ||
                this.isContextual("async")
              );
            };

            _proto.checkExport = function checkExport(
              node,
              checkNames,
              isDefault
            ) {
              if (checkNames) {
                if (isDefault) {
                  this.checkDuplicateExports(node, "default");
                } else if (node.specifiers && node.specifiers.length) {
                  for (
                    var _i4 = 0, _node$specifiers2 = node.specifiers;
                    _i4 < _node$specifiers2.length;
                    _i4++
                  ) {
                    var specifier = _node$specifiers2[_i4];
                    this.checkDuplicateExports(
                      specifier,
                      specifier.exported.name
                    );
                  }
                } else if (node.declaration) {
                  if (
                    node.declaration.type === "FunctionDeclaration" ||
                    node.declaration.type === "ClassDeclaration"
                  ) {
                    var id = node.declaration.id;
                    if (!id) throw new Error("Assertion failure");
                    this.checkDuplicateExports(node, id.name);
                  } else if (node.declaration.type === "VariableDeclaration") {
                    for (
                      var _i6 = 0,
                        _node$declaration$dec2 = node.declaration.declarations;
                      _i6 < _node$declaration$dec2.length;
                      _i6++
                    ) {
                      var declaration = _node$declaration$dec2[_i6];
                      this.checkDeclaration(declaration.id);
                    }
                  }
                }
              }

              var currentContextDecorators = this.state.decoratorStack[
                this.state.decoratorStack.length - 1
              ];

              if (currentContextDecorators.length) {
                var isClass =
                  node.declaration &&
                  (node.declaration.type === "ClassDeclaration" ||
                    node.declaration.type === "ClassExpression");

                if (!node.declaration || !isClass) {
                  throw this.raise(
                    node.start,
                    "You can only use decorators on an export when exporting a class"
                  );
                }

                this.takeDecorators(node.declaration);
              }
            };

            _proto.checkDeclaration = function checkDeclaration(node) {
              if (node.type === "ObjectPattern") {
                for (
                  var _i8 = 0, _node$properties2 = node.properties;
                  _i8 < _node$properties2.length;
                  _i8++
                ) {
                  var prop = _node$properties2[_i8];
                  this.checkDeclaration(prop);
                }
              } else if (node.type === "ArrayPattern") {
                for (
                  var _i10 = 0, _node$elements2 = node.elements;
                  _i10 < _node$elements2.length;
                  _i10++
                ) {
                  var elem = _node$elements2[_i10];

                  if (elem) {
                    this.checkDeclaration(elem);
                  }
                }
              } else if (node.type === "ObjectProperty") {
                this.checkDeclaration(node.value);
              } else if (node.type === "RestElement") {
                this.checkDeclaration(node.argument);
              } else if (node.type === "Identifier") {
                this.checkDuplicateExports(node, node.name);
              }
            };

            _proto.checkDuplicateExports = function checkDuplicateExports(
              node,
              name
            ) {
              if (this.state.exportedIdentifiers.indexOf(name) > -1) {
                this.raiseDuplicateExportError(node, name);
              }

              this.state.exportedIdentifiers.push(name);
            };

            _proto.raiseDuplicateExportError = function raiseDuplicateExportError(
              node,
              name
            ) {
              throw this.raise(
                node.start,
                name === "default"
                  ? "Only one default export allowed per module."
                  : "`" +
                    name +
                    "` has already been exported. Exported identifiers must be unique."
              );
            };

            _proto.parseExportSpecifiers = function parseExportSpecifiers() {
              var nodes = [];
              var first = true;
              var needsFrom;
              this.expect(types.braceL);

              while (!this.eat(types.braceR)) {
                if (first) {
                  first = false;
                } else {
                  this.expect(types.comma);
                  if (this.eat(types.braceR)) break;
                }

                var isDefault = this.match(types._default);
                if (isDefault && !needsFrom) needsFrom = true;
                var node = this.startNode();
                node.local = this.parseIdentifier(isDefault);
                node.exported = this.eatContextual("as")
                  ? this.parseIdentifier(true)
                  : node.local.__clone();
                nodes.push(this.finishNode(node, "ExportSpecifier"));
              }

              if (needsFrom && !this.isContextual("from")) {
                this.unexpected();
              }

              return nodes;
            };

            _proto.parseImport = function parseImport(node) {
              if (this.match(types.string)) {
                node.specifiers = [];
                node.source = this.parseExprAtom();
              } else {
                node.specifiers = [];
                this.parseImportSpecifiers(node);
                this.expectContextual("from");
                node.source = this.match(types.string)
                  ? this.parseExprAtom()
                  : this.unexpected();
              }

              this.semicolon();
              return this.finishNode(node, "ImportDeclaration");
            };

            _proto.shouldParseDefaultImport = function shouldParseDefaultImport(
              node
            ) {
              return this.match(types.name);
            };

            _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(
              node,
              specifier,
              type,
              contextDescription
            ) {
              specifier.local = this.parseIdentifier();
              this.checkLVal(
                specifier.local,
                true,
                undefined,
                contextDescription
              );
              node.specifiers.push(this.finishNode(specifier, type));
            };

            _proto.parseImportSpecifiers = function parseImportSpecifiers(
              node
            ) {
              var first = true;

              if (this.shouldParseDefaultImport(node)) {
                this.parseImportSpecifierLocal(
                  node,
                  this.startNode(),
                  "ImportDefaultSpecifier",
                  "default import specifier"
                );
                if (!this.eat(types.comma)) return;
              }

              if (this.match(types.star)) {
                var specifier = this.startNode();
                this.next();
                this.expectContextual("as");
                this.parseImportSpecifierLocal(
                  node,
                  specifier,
                  "ImportNamespaceSpecifier",
                  "import namespace specifier"
                );
                return;
              }

              this.expect(types.braceL);

              while (!this.eat(types.braceR)) {
                if (first) {
                  first = false;
                } else {
                  if (this.eat(types.colon)) {
                    this.unexpected(
                      null,
                      "ES2015 named imports do not destructure. " +
                        "Use another statement for destructuring after the import."
                    );
                  }

                  this.expect(types.comma);
                  if (this.eat(types.braceR)) break;
                }

                this.parseImportSpecifier(node);
              }
            };

            _proto.parseImportSpecifier = function parseImportSpecifier(node) {
              var specifier = this.startNode();
              specifier.imported = this.parseIdentifier(true);

              if (this.eatContextual("as")) {
                specifier.local = this.parseIdentifier();
              } else {
                this.checkReservedWord(
                  specifier.imported.name,
                  specifier.start,
                  true,
                  true
                );
                specifier.local = specifier.imported.__clone();
              }

              this.checkLVal(
                specifier.local,
                true,
                undefined,
                "import specifier"
              );
              node.specifiers.push(
                this.finishNode(specifier, "ImportSpecifier")
              );
            };

            return StatementParser;
          })(ExpressionParser);

          var Parser = (function(_StatementParser) {
            _inheritsLoose(Parser, _StatementParser);

            function Parser(options, input) {
              var _this;

              options = getOptions(options);
              _this = _StatementParser.call(this, options, input) || this;
              _this.options = options;
              _this.inModule = _this.options.sourceType === "module";
              _this.input = input;
              _this.plugins = pluginsMap(_this.options.plugins);
              _this.filename = options.sourceFilename;
              return _this;
            }

            var _proto = Parser.prototype;

            _proto.parse = function parse() {
              var file = this.startNode();
              var program = this.startNode();
              this.nextToken();
              return this.parseTopLevel(file, program);
            };

            return Parser;
          })(StatementParser);

          function pluginsMap(plugins) {
            var pluginMap = Object.create(null);

            for (var _i2 = 0; _i2 < plugins.length; _i2++) {
              var plugin = plugins[_i2];

              var _ref = Array.isArray(plugin) ? plugin : [plugin, {}],
                name = _ref[0],
                _ref$ = _ref[1],
                options = _ref$ === void 0 ? {} : _ref$;

              if (!pluginMap[name]) pluginMap[name] = options || {};
            }

            return pluginMap;
          }

          function nonNull(x) {
            if (x == null) {
              throw new Error("Unexpected " + x + " value.");
            }

            return x;
          }

          function assert(x) {
            if (!x) {
              throw new Error("Assert fail");
            }
          }

          function keywordTypeFromName(value) {
            switch (value) {
              case "any":
                return "TSAnyKeyword";

              case "boolean":
                return "TSBooleanKeyword";

              case "never":
                return "TSNeverKeyword";

              case "number":
                return "TSNumberKeyword";

              case "object":
                return "TSObjectKeyword";

              case "string":
                return "TSStringKeyword";

              case "symbol":
                return "TSSymbolKeyword";

              case "undefined":
                return "TSUndefinedKeyword";

              default:
                return undefined;
            }
          }

          var typescript = function typescript(superClass) {
            return (function(_superClass) {
              _inheritsLoose(_class, _superClass);

              function _class() {
                return _superClass.apply(this, arguments) || this;
              }

              var _proto = _class.prototype;

              _proto.tsIsIdentifier = function tsIsIdentifier() {
                return this.match(types.name);
              };

              _proto.tsNextTokenCanFollowModifier = function tsNextTokenCanFollowModifier() {
                this.next();
                return (
                  !this.hasPrecedingLineBreak() &&
                  !this.match(types.parenL) &&
                  !this.match(types.parenR) &&
                  !this.match(types.colon) &&
                  !this.match(types.eq) &&
                  !this.match(types.question)
                );
              };

              _proto.tsParseModifier = function tsParseModifier(
                allowedModifiers
              ) {
                if (!this.match(types.name)) {
                  return undefined;
                }

                var modifier = this.state.value;

                if (
                  allowedModifiers.indexOf(modifier) !== -1 &&
                  this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))
                ) {
                  return modifier;
                }

                return undefined;
              };

              _proto.tsIsListTerminator = function tsIsListTerminator(kind) {
                switch (kind) {
                  case "EnumMembers":
                  case "TypeMembers":
                    return this.match(types.braceR);

                  case "HeritageClauseElement":
                    return this.match(types.braceL);

                  case "TupleElementTypes":
                    return this.match(types.bracketR);

                  case "TypeParametersOrArguments":
                    return this.isRelational(">");
                }

                throw new Error("Unreachable");
              };

              _proto.tsParseList = function tsParseList(kind, parseElement) {
                var result = [];

                while (!this.tsIsListTerminator(kind)) {
                  result.push(parseElement());
                }

                return result;
              };

              _proto.tsParseDelimitedList = function tsParseDelimitedList(
                kind,
                parseElement
              ) {
                return nonNull(
                  this.tsParseDelimitedListWorker(kind, parseElement, true)
                );
              };

              _proto.tsTryParseDelimitedList = function tsTryParseDelimitedList(
                kind,
                parseElement
              ) {
                return this.tsParseDelimitedListWorker(
                  kind,
                  parseElement,
                  false
                );
              };

              _proto.tsParseDelimitedListWorker = function tsParseDelimitedListWorker(
                kind,
                parseElement,
                expectSuccess
              ) {
                var result = [];

                while (true) {
                  if (this.tsIsListTerminator(kind)) {
                    break;
                  }

                  var element = parseElement();

                  if (element == null) {
                    return undefined;
                  }

                  result.push(element);

                  if (this.eat(types.comma)) {
                    continue;
                  }

                  if (this.tsIsListTerminator(kind)) {
                    break;
                  }

                  if (expectSuccess) {
                    this.expect(types.comma);
                  }

                  return undefined;
                }

                return result;
              };

              _proto.tsParseBracketedList = function tsParseBracketedList(
                kind,
                parseElement,
                bracket,
                skipFirstToken
              ) {
                if (!skipFirstToken) {
                  if (bracket) {
                    this.expect(types.bracketL);
                  } else {
                    this.expectRelational("<");
                  }
                }

                var result = this.tsParseDelimitedList(kind, parseElement);

                if (bracket) {
                  this.expect(types.bracketR);
                } else {
                  this.expectRelational(">");
                }

                return result;
              };

              _proto.tsParseEntityName = function tsParseEntityName(
                allowReservedWords
              ) {
                var entity = this.parseIdentifier();

                while (this.eat(types.dot)) {
                  var node = this.startNodeAtNode(entity);
                  node.left = entity;
                  node.right = this.parseIdentifier(allowReservedWords);
                  entity = this.finishNode(node, "TSQualifiedName");
                }

                return entity;
              };

              _proto.tsParseTypeReference = function tsParseTypeReference() {
                var node = this.startNode();
                node.typeName = this.tsParseEntityName(false);

                if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
                  node.typeParameters = this.tsParseTypeArguments();
                }

                return this.finishNode(node, "TSTypeReference");
              };

              _proto.tsParseThisTypePredicate = function tsParseThisTypePredicate(
                lhs
              ) {
                this.next();
                var node = this.startNode();
                node.parameterName = lhs;
                node.typeAnnotation = this.tsParseTypeAnnotation(false);
                return this.finishNode(node, "TSTypePredicate");
              };

              _proto.tsParseThisTypeNode = function tsParseThisTypeNode() {
                var node = this.startNode();
                this.next();
                return this.finishNode(node, "TSThisType");
              };

              _proto.tsParseTypeQuery = function tsParseTypeQuery() {
                var node = this.startNode();
                this.expect(types._typeof);
                node.exprName = this.tsParseEntityName(true);
                return this.finishNode(node, "TSTypeQuery");
              };

              _proto.tsParseTypeParameter = function tsParseTypeParameter() {
                var node = this.startNode();
                node.name = this.parseIdentifierName(node.start);
                node.constraint = this.tsEatThenParseType(types._extends);
                node.default = this.tsEatThenParseType(types.eq);
                return this.finishNode(node, "TSTypeParameter");
              };

              _proto.tsTryParseTypeParameters = function tsTryParseTypeParameters() {
                if (this.isRelational("<")) {
                  return this.tsParseTypeParameters();
                }
              };

              _proto.tsParseTypeParameters = function tsParseTypeParameters() {
                var node = this.startNode();

                if (this.isRelational("<") || this.match(types.jsxTagStart)) {
                  this.next();
                } else {
                  this.unexpected();
                }

                node.params = this.tsParseBracketedList(
                  "TypeParametersOrArguments",
                  this.tsParseTypeParameter.bind(this),
                  false,
                  true
                );
                return this.finishNode(node, "TSTypeParameterDeclaration");
              };

              _proto.tsFillSignature = function tsFillSignature(
                returnToken,
                signature
              ) {
                var returnTokenRequired = returnToken === types.arrow;
                signature.typeParameters = this.tsTryParseTypeParameters();
                this.expect(types.parenL);
                signature.parameters = this.tsParseBindingListForSignature();

                if (returnTokenRequired) {
                  signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(
                    returnToken
                  );
                } else if (this.match(returnToken)) {
                  signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(
                    returnToken
                  );
                }
              };

              _proto.tsParseBindingListForSignature = function tsParseBindingListForSignature() {
                var _this = this;

                return this.parseBindingList(types.parenR).map(function(
                  pattern
                ) {
                  if (
                    pattern.type !== "Identifier" &&
                    pattern.type !== "RestElement"
                  ) {
                    throw _this.unexpected(
                      pattern.start,
                      "Name in a signature must be an Identifier."
                    );
                  }

                  return pattern;
                });
              };

              _proto.tsParseTypeMemberSemicolon = function tsParseTypeMemberSemicolon() {
                if (!this.eat(types.comma)) {
                  this.semicolon();
                }
              };

              _proto.tsParseSignatureMember = function tsParseSignatureMember(
                kind
              ) {
                var node = this.startNode();

                if (kind === "TSConstructSignatureDeclaration") {
                  this.expect(types._new);
                }

                this.tsFillSignature(types.colon, node);
                this.tsParseTypeMemberSemicolon();
                return this.finishNode(node, kind);
              };

              _proto.tsIsUnambiguouslyIndexSignature = function tsIsUnambiguouslyIndexSignature() {
                this.next();
                return this.eat(types.name) && this.match(types.colon);
              };

              _proto.tsTryParseIndexSignature = function tsTryParseIndexSignature(
                node
              ) {
                if (
                  !(
                    this.match(types.bracketL) &&
                    this.tsLookAhead(
                      this.tsIsUnambiguouslyIndexSignature.bind(this)
                    )
                  )
                ) {
                  return undefined;
                }

                this.expect(types.bracketL);
                var id = this.parseIdentifier();
                this.expect(types.colon);
                id.typeAnnotation = this.tsParseTypeAnnotation(false);
                this.expect(types.bracketR);
                node.parameters = [id];
                var type = this.tsTryParseTypeAnnotation();
                if (type) node.typeAnnotation = type;
                this.tsParseTypeMemberSemicolon();
                return this.finishNode(node, "TSIndexSignature");
              };

              _proto.tsParsePropertyOrMethodSignature = function tsParsePropertyOrMethodSignature(
                node,
                readonly
              ) {
                this.parsePropertyName(node);
                if (this.eat(types.question)) node.optional = true;
                var nodeAny = node;

                if (
                  !readonly &&
                  (this.match(types.parenL) || this.isRelational("<"))
                ) {
                  var method = nodeAny;
                  this.tsFillSignature(types.colon, method);
                  this.tsParseTypeMemberSemicolon();
                  return this.finishNode(method, "TSMethodSignature");
                } else {
                  var property = nodeAny;
                  if (readonly) property.readonly = true;
                  var type = this.tsTryParseTypeAnnotation();
                  if (type) property.typeAnnotation = type;
                  this.tsParseTypeMemberSemicolon();
                  return this.finishNode(property, "TSPropertySignature");
                }
              };

              _proto.tsParseTypeMember = function tsParseTypeMember() {
                if (this.match(types.parenL) || this.isRelational("<")) {
                  return this.tsParseSignatureMember(
                    "TSCallSignatureDeclaration"
                  );
                }

                if (
                  this.match(types._new) &&
                  this.tsLookAhead(
                    this.tsIsStartOfConstructSignature.bind(this)
                  )
                ) {
                  return this.tsParseSignatureMember(
                    "TSConstructSignatureDeclaration"
                  );
                }

                var node = this.startNode();
                var readonly = !!this.tsParseModifier(["readonly"]);
                var idx = this.tsTryParseIndexSignature(node);

                if (idx) {
                  if (readonly) node.readonly = true;
                  return idx;
                }

                return this.tsParsePropertyOrMethodSignature(node, readonly);
              };

              _proto.tsIsStartOfConstructSignature = function tsIsStartOfConstructSignature() {
                this.next();
                return this.match(types.parenL) || this.isRelational("<");
              };

              _proto.tsParseTypeLiteral = function tsParseTypeLiteral() {
                var node = this.startNode();
                node.members = this.tsParseObjectTypeMembers();
                return this.finishNode(node, "TSTypeLiteral");
              };

              _proto.tsParseObjectTypeMembers = function tsParseObjectTypeMembers() {
                this.expect(types.braceL);
                var members = this.tsParseList(
                  "TypeMembers",
                  this.tsParseTypeMember.bind(this)
                );
                this.expect(types.braceR);
                return members;
              };

              _proto.tsIsStartOfMappedType = function tsIsStartOfMappedType() {
                this.next();

                if (this.eat(types.plusMin)) {
                  return this.isContextual("readonly");
                }

                if (this.isContextual("readonly")) {
                  this.next();
                }

                if (!this.match(types.bracketL)) {
                  return false;
                }

                this.next();

                if (!this.tsIsIdentifier()) {
                  return false;
                }

                this.next();
                return this.match(types._in);
              };

              _proto.tsParseMappedTypeParameter = function tsParseMappedTypeParameter() {
                var node = this.startNode();
                node.name = this.parseIdentifierName(node.start);
                node.constraint = this.tsExpectThenParseType(types._in);
                return this.finishNode(node, "TSTypeParameter");
              };

              _proto.tsParseMappedType = function tsParseMappedType() {
                var node = this.startNode();
                this.expect(types.braceL);

                if (this.match(types.plusMin)) {
                  node.readonly = this.state.value;
                  this.next();
                  this.expectContextual("readonly");
                } else if (this.eatContextual("readonly")) {
                  node.readonly = true;
                }

                this.expect(types.bracketL);
                node.typeParameter = this.tsParseMappedTypeParameter();
                this.expect(types.bracketR);

                if (this.match(types.plusMin)) {
                  node.optional = this.state.value;
                  this.next();
                  this.expect(types.question);
                } else if (this.eat(types.question)) {
                  node.optional = true;
                }

                node.typeAnnotation = this.tsTryParseType();
                this.semicolon();
                this.expect(types.braceR);
                return this.finishNode(node, "TSMappedType");
              };

              _proto.tsParseTupleType = function tsParseTupleType() {
                var node = this.startNode();
                node.elementTypes = this.tsParseBracketedList(
                  "TupleElementTypes",
                  this.tsParseType.bind(this),
                  true,
                  false
                );
                return this.finishNode(node, "TSTupleType");
              };

              _proto.tsParseParenthesizedType = function tsParseParenthesizedType() {
                var node = this.startNode();
                this.expect(types.parenL);
                node.typeAnnotation = this.tsParseType();
                this.expect(types.parenR);
                return this.finishNode(node, "TSParenthesizedType");
              };

              _proto.tsParseFunctionOrConstructorType = function tsParseFunctionOrConstructorType(
                type
              ) {
                var node = this.startNode();

                if (type === "TSConstructorType") {
                  this.expect(types._new);
                }

                this.tsFillSignature(types.arrow, node);
                return this.finishNode(node, type);
              };

              _proto.tsParseLiteralTypeNode = function tsParseLiteralTypeNode() {
                var _this2 = this;

                var node = this.startNode();

                node.literal = (function() {
                  switch (_this2.state.type) {
                    case types.num:
                      return _this2.parseLiteral(
                        _this2.state.value,
                        "NumericLiteral"
                      );

                    case types.string:
                      return _this2.parseLiteral(
                        _this2.state.value,
                        "StringLiteral"
                      );

                    case types._true:
                    case types._false:
                      return _this2.parseBooleanLiteral();

                    default:
                      throw _this2.unexpected();
                  }
                })();

                return this.finishNode(node, "TSLiteralType");
              };

              _proto.tsParseNonArrayType = function tsParseNonArrayType() {
                switch (this.state.type) {
                  case types.name:
                  case types._void:
                  case types._null: {
                    var type = this.match(types._void)
                      ? "TSVoidKeyword"
                      : this.match(types._null)
                        ? "TSNullKeyword"
                        : keywordTypeFromName(this.state.value);

                    if (
                      type !== undefined &&
                      this.lookahead().type !== types.dot
                    ) {
                      var node = this.startNode();
                      this.next();
                      return this.finishNode(node, type);
                    }

                    return this.tsParseTypeReference();
                  }

                  case types.string:
                  case types.num:
                  case types._true:
                  case types._false:
                    return this.tsParseLiteralTypeNode();

                  case types.plusMin:
                    if (this.state.value === "-") {
                      var _node = this.startNode();

                      this.next();

                      if (!this.match(types.num)) {
                        throw this.unexpected();
                      }

                      _node.literal = this.parseLiteral(
                        -this.state.value,
                        "NumericLiteral",
                        _node.start,
                        _node.loc.start
                      );
                      return this.finishNode(_node, "TSLiteralType");
                    }

                    break;

                  case types._this: {
                    var thisKeyword = this.tsParseThisTypeNode();

                    if (
                      this.isContextual("is") &&
                      !this.hasPrecedingLineBreak()
                    ) {
                      return this.tsParseThisTypePredicate(thisKeyword);
                    } else {
                      return thisKeyword;
                    }
                  }

                  case types._typeof:
                    return this.tsParseTypeQuery();

                  case types.braceL:
                    return this.tsLookAhead(
                      this.tsIsStartOfMappedType.bind(this)
                    )
                      ? this.tsParseMappedType()
                      : this.tsParseTypeLiteral();

                  case types.bracketL:
                    return this.tsParseTupleType();

                  case types.parenL:
                    return this.tsParseParenthesizedType();
                }

                throw this.unexpected();
              };

              _proto.tsParseArrayTypeOrHigher = function tsParseArrayTypeOrHigher() {
                var type = this.tsParseNonArrayType();

                while (
                  !this.hasPrecedingLineBreak() &&
                  this.eat(types.bracketL)
                ) {
                  if (this.match(types.bracketR)) {
                    var node = this.startNodeAtNode(type);
                    node.elementType = type;
                    this.expect(types.bracketR);
                    type = this.finishNode(node, "TSArrayType");
                  } else {
                    var _node2 = this.startNodeAtNode(type);

                    _node2.objectType = type;
                    _node2.indexType = this.tsParseType();
                    this.expect(types.bracketR);
                    type = this.finishNode(_node2, "TSIndexedAccessType");
                  }
                }

                return type;
              };

              _proto.tsParseTypeOperator = function tsParseTypeOperator(
                operator
              ) {
                var node = this.startNode();
                this.expectContextual(operator);
                node.operator = operator;
                node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
                return this.finishNode(node, "TSTypeOperator");
              };

              _proto.tsParseInferType = function tsParseInferType() {
                var node = this.startNode();
                this.expectContextual("infer");
                var typeParameter = this.startNode();
                typeParameter.name = this.parseIdentifierName(
                  typeParameter.start
                );
                node.typeParameter = this.finishNode(
                  typeParameter,
                  "TSTypeParameter"
                );
                return this.finishNode(node, "TSInferType");
              };

              _proto.tsParseTypeOperatorOrHigher = function tsParseTypeOperatorOrHigher() {
                var _this3 = this;

                var operator = ["keyof", "unique"].find(function(kw) {
                  return _this3.isContextual(kw);
                });
                return operator
                  ? this.tsParseTypeOperator(operator)
                  : this.isContextual("infer")
                    ? this.tsParseInferType()
                    : this.tsParseArrayTypeOrHigher();
              };

              _proto.tsParseUnionOrIntersectionType = function tsParseUnionOrIntersectionType(
                kind,
                parseConstituentType,
                operator
              ) {
                this.eat(operator);
                var type = parseConstituentType();

                if (this.match(operator)) {
                  var types$$1 = [type];

                  while (this.eat(operator)) {
                    types$$1.push(parseConstituentType());
                  }

                  var node = this.startNodeAtNode(type);
                  node.types = types$$1;
                  type = this.finishNode(node, kind);
                }

                return type;
              };

              _proto.tsParseIntersectionTypeOrHigher = function tsParseIntersectionTypeOrHigher() {
                return this.tsParseUnionOrIntersectionType(
                  "TSIntersectionType",
                  this.tsParseTypeOperatorOrHigher.bind(this),
                  types.bitwiseAND
                );
              };

              _proto.tsParseUnionTypeOrHigher = function tsParseUnionTypeOrHigher() {
                return this.tsParseUnionOrIntersectionType(
                  "TSUnionType",
                  this.tsParseIntersectionTypeOrHigher.bind(this),
                  types.bitwiseOR
                );
              };

              _proto.tsIsStartOfFunctionType = function tsIsStartOfFunctionType() {
                if (this.isRelational("<")) {
                  return true;
                }

                return (
                  this.match(types.parenL) &&
                  this.tsLookAhead(
                    this.tsIsUnambiguouslyStartOfFunctionType.bind(this)
                  )
                );
              };

              _proto.tsSkipParameterStart = function tsSkipParameterStart() {
                if (this.match(types.name) || this.match(types._this)) {
                  this.next();
                  return true;
                }

                return false;
              };

              _proto.tsIsUnambiguouslyStartOfFunctionType = function tsIsUnambiguouslyStartOfFunctionType() {
                this.next();

                if (this.match(types.parenR) || this.match(types.ellipsis)) {
                  return true;
                }

                if (this.tsSkipParameterStart()) {
                  if (
                    this.match(types.colon) ||
                    this.match(types.comma) ||
                    this.match(types.question) ||
                    this.match(types.eq)
                  ) {
                    return true;
                  }

                  if (this.match(types.parenR)) {
                    this.next();

                    if (this.match(types.arrow)) {
                      return true;
                    }
                  }
                }

                return false;
              };

              _proto.tsParseTypeOrTypePredicateAnnotation = function tsParseTypeOrTypePredicateAnnotation(
                returnToken
              ) {
                var _this4 = this;

                return this.tsInType(function() {
                  var t = _this4.startNode();

                  _this4.expect(returnToken);

                  var typePredicateVariable =
                    _this4.tsIsIdentifier() &&
                    _this4.tsTryParse(
                      _this4.tsParseTypePredicatePrefix.bind(_this4)
                    );

                  if (!typePredicateVariable) {
                    return _this4.tsParseTypeAnnotation(false, t);
                  }

                  var type = _this4.tsParseTypeAnnotation(false);

                  var node = _this4.startNodeAtNode(typePredicateVariable);

                  node.parameterName = typePredicateVariable;
                  node.typeAnnotation = type;
                  t.typeAnnotation = _this4.finishNode(node, "TSTypePredicate");
                  return _this4.finishNode(t, "TSTypeAnnotation");
                });
              };

              _proto.tsTryParseTypeOrTypePredicateAnnotation = function tsTryParseTypeOrTypePredicateAnnotation() {
                return this.match(types.colon)
                  ? this.tsParseTypeOrTypePredicateAnnotation(types.colon)
                  : undefined;
              };

              _proto.tsTryParseTypeAnnotation = function tsTryParseTypeAnnotation() {
                return this.match(types.colon)
                  ? this.tsParseTypeAnnotation()
                  : undefined;
              };

              _proto.tsTryParseType = function tsTryParseType() {
                return this.tsEatThenParseType(types.colon);
              };

              _proto.tsParseTypePredicatePrefix = function tsParseTypePredicatePrefix() {
                var id = this.parseIdentifier();

                if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
                  this.next();
                  return id;
                }
              };

              _proto.tsParseTypeAnnotation = function tsParseTypeAnnotation(
                eatColon,
                t
              ) {
                var _this5 = this;

                if (eatColon === void 0) {
                  eatColon = true;
                }

                if (t === void 0) {
                  t = this.startNode();
                }

                this.tsInType(function() {
                  if (eatColon) _this5.expect(types.colon);
                  t.typeAnnotation = _this5.tsParseType();
                });
                return this.finishNode(t, "TSTypeAnnotation");
              };

              _proto.tsParseType = function tsParseType() {
                assert(this.state.inType);
                var type = this.tsParseNonConditionalType();

                if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {
                  return type;
                }

                var node = this.startNodeAtNode(type);
                node.checkType = type;
                node.extendsType = this.tsParseNonConditionalType();
                this.expect(types.question);
                node.trueType = this.tsParseType();
                this.expect(types.colon);
                node.falseType = this.tsParseType();
                return this.finishNode(node, "TSConditionalType");
              };

              _proto.tsParseNonConditionalType = function tsParseNonConditionalType() {
                if (this.tsIsStartOfFunctionType()) {
                  return this.tsParseFunctionOrConstructorType(
                    "TSFunctionType"
                  );
                }

                if (this.match(types._new)) {
                  return this.tsParseFunctionOrConstructorType(
                    "TSConstructorType"
                  );
                }

                return this.tsParseUnionTypeOrHigher();
              };

              _proto.tsParseTypeAssertion = function tsParseTypeAssertion() {
                var _this6 = this;

                var node = this.startNode();
                node.typeAnnotation = this.tsInType(function() {
                  return _this6.tsParseType();
                });
                this.expectRelational(">");
                node.expression = this.parseMaybeUnary();
                return this.finishNode(node, "TSTypeAssertion");
              };

              _proto.tsParseHeritageClause = function tsParseHeritageClause() {
                return this.tsParseDelimitedList(
                  "HeritageClauseElement",
                  this.tsParseExpressionWithTypeArguments.bind(this)
                );
              };

              _proto.tsParseExpressionWithTypeArguments = function tsParseExpressionWithTypeArguments() {
                var node = this.startNode();
                node.expression = this.tsParseEntityName(false);

                if (this.isRelational("<")) {
                  node.typeParameters = this.tsParseTypeArguments();
                }

                return this.finishNode(node, "TSExpressionWithTypeArguments");
              };

              _proto.tsParseInterfaceDeclaration = function tsParseInterfaceDeclaration(
                node
              ) {
                node.id = this.parseIdentifier();
                node.typeParameters = this.tsTryParseTypeParameters();

                if (this.eat(types._extends)) {
                  node.extends = this.tsParseHeritageClause();
                }

                var body = this.startNode();
                body.body = this.tsParseObjectTypeMembers();
                node.body = this.finishNode(body, "TSInterfaceBody");
                return this.finishNode(node, "TSInterfaceDeclaration");
              };

              _proto.tsParseTypeAliasDeclaration = function tsParseTypeAliasDeclaration(
                node
              ) {
                node.id = this.parseIdentifier();
                node.typeParameters = this.tsTryParseTypeParameters();
                node.typeAnnotation = this.tsExpectThenParseType(types.eq);
                this.semicolon();
                return this.finishNode(node, "TSTypeAliasDeclaration");
              };

              _proto.tsInNoContext = function tsInNoContext(cb) {
                var oldContext = this.state.context;
                this.state.context = [oldContext[0]];

                try {
                  return cb();
                } finally {
                  this.state.context = oldContext;
                }
              };

              _proto.tsInType = function tsInType(cb) {
                var oldInType = this.state.inType;
                this.state.inType = true;

                try {
                  return cb();
                } finally {
                  this.state.inType = oldInType;
                }
              };

              _proto.tsEatThenParseType = function tsEatThenParseType(token) {
                return !this.match(token)
                  ? undefined
                  : this.tsNextThenParseType();
              };

              _proto.tsExpectThenParseType = function tsExpectThenParseType(
                token
              ) {
                var _this7 = this;

                return this.tsDoThenParseType(function() {
                  return _this7.expect(token);
                });
              };

              _proto.tsNextThenParseType = function tsNextThenParseType() {
                var _this8 = this;

                return this.tsDoThenParseType(function() {
                  return _this8.next();
                });
              };

              _proto.tsDoThenParseType = function tsDoThenParseType(cb) {
                var _this9 = this;

                return this.tsInType(function() {
                  cb();
                  return _this9.tsParseType();
                });
              };

              _proto.tsParseEnumMember = function tsParseEnumMember() {
                var node = this.startNode();
                node.id = this.match(types.string)
                  ? this.parseLiteral(this.state.value, "StringLiteral")
                  : this.parseIdentifier(true);

                if (this.eat(types.eq)) {
                  node.initializer = this.parseMaybeAssign();
                }

                return this.finishNode(node, "TSEnumMember");
              };

              _proto.tsParseEnumDeclaration = function tsParseEnumDeclaration(
                node,
                isConst
              ) {
                if (isConst) node.const = true;
                node.id = this.parseIdentifier();
                this.expect(types.braceL);
                node.members = this.tsParseDelimitedList(
                  "EnumMembers",
                  this.tsParseEnumMember.bind(this)
                );
                this.expect(types.braceR);
                return this.finishNode(node, "TSEnumDeclaration");
              };

              _proto.tsParseModuleBlock = function tsParseModuleBlock() {
                var node = this.startNode();
                this.expect(types.braceL);
                this.parseBlockOrModuleBlockBody(
                  (node.body = []),
                  undefined,
                  true,
                  types.braceR
                );
                return this.finishNode(node, "TSModuleBlock");
              };

              _proto.tsParseModuleOrNamespaceDeclaration = function tsParseModuleOrNamespaceDeclaration(
                node
              ) {
                node.id = this.parseIdentifier();

                if (this.eat(types.dot)) {
                  var inner = this.startNode();
                  this.tsParseModuleOrNamespaceDeclaration(inner);
                  node.body = inner;
                } else {
                  node.body = this.tsParseModuleBlock();
                }

                return this.finishNode(node, "TSModuleDeclaration");
              };

              _proto.tsParseAmbientExternalModuleDeclaration = function tsParseAmbientExternalModuleDeclaration(
                node
              ) {
                if (this.isContextual("global")) {
                  node.global = true;
                  node.id = this.parseIdentifier();
                } else if (this.match(types.string)) {
                  node.id = this.parseExprAtom();
                } else {
                  this.unexpected();
                }

                if (this.match(types.braceL)) {
                  node.body = this.tsParseModuleBlock();
                } else {
                  this.semicolon();
                }

                return this.finishNode(node, "TSModuleDeclaration");
              };

              _proto.tsParseImportEqualsDeclaration = function tsParseImportEqualsDeclaration(
                node,
                isExport
              ) {
                node.isExport = isExport || false;
                node.id = this.parseIdentifier();
                this.expect(types.eq);
                node.moduleReference = this.tsParseModuleReference();
                this.semicolon();
                return this.finishNode(node, "TSImportEqualsDeclaration");
              };

              _proto.tsIsExternalModuleReference = function tsIsExternalModuleReference() {
                return (
                  this.isContextual("require") &&
                  this.lookahead().type === types.parenL
                );
              };

              _proto.tsParseModuleReference = function tsParseModuleReference() {
                return this.tsIsExternalModuleReference()
                  ? this.tsParseExternalModuleReference()
                  : this.tsParseEntityName(false);
              };

              _proto.tsParseExternalModuleReference = function tsParseExternalModuleReference() {
                var node = this.startNode();
                this.expectContextual("require");
                this.expect(types.parenL);

                if (!this.match(types.string)) {
                  throw this.unexpected();
                }

                node.expression = this.parseLiteral(
                  this.state.value,
                  "StringLiteral"
                );
                this.expect(types.parenR);
                return this.finishNode(node, "TSExternalModuleReference");
              };

              _proto.tsLookAhead = function tsLookAhead(f) {
                var state = this.state.clone();
                var res = f();
                this.state = state;
                return res;
              };

              _proto.tsTryParseAndCatch = function tsTryParseAndCatch(f) {
                var state = this.state.clone();

                try {
                  return f();
                } catch (e) {
                  if (e instanceof SyntaxError) {
                    this.state = state;
                    return undefined;
                  }

                  throw e;
                }
              };

              _proto.tsTryParse = function tsTryParse(f) {
                var state = this.state.clone();
                var result = f();

                if (result !== undefined && result !== false) {
                  return result;
                } else {
                  this.state = state;
                  return undefined;
                }
              };

              _proto.nodeWithSamePosition = function nodeWithSamePosition(
                original,
                type
              ) {
                var node = this.startNodeAtNode(original);
                node.type = type;
                node.end = original.end;
                node.loc.end = original.loc.end;

                if (original.leadingComments) {
                  node.leadingComments = original.leadingComments;
                }

                if (original.trailingComments) {
                  node.trailingComments = original.trailingComments;
                }

                if (original.innerComments)
                  node.innerComments = original.innerComments;
                return node;
              };

              _proto.tsTryParseDeclare = function tsTryParseDeclare(nany) {
                switch (this.state.type) {
                  case types._function:
                    this.next();
                    return this.parseFunction(nany, true);

                  case types._class:
                    return this.parseClass(nany, true, false);

                  case types._const:
                    if (
                      this.match(types._const) &&
                      this.isLookaheadContextual("enum")
                    ) {
                      this.expect(types._const);
                      this.expectContextual("enum");
                      return this.tsParseEnumDeclaration(nany, true);
                    }

                  case types._var:
                  case types._let:
                    return this.parseVarStatement(nany, this.state.type);

                  case types.name: {
                    var value = this.state.value;

                    if (value === "global") {
                      return this.tsParseAmbientExternalModuleDeclaration(nany);
                    } else {
                      return this.tsParseDeclaration(nany, value, true);
                    }
                  }
                }
              };

              _proto.tsTryParseExportDeclaration = function tsTryParseExportDeclaration() {
                return this.tsParseDeclaration(
                  this.startNode(),
                  this.state.value,
                  true
                );
              };

              _proto.tsParseExpressionStatement = function tsParseExpressionStatement(
                node,
                expr
              ) {
                switch (expr.name) {
                  case "declare": {
                    var declaration = this.tsTryParseDeclare(node);

                    if (declaration) {
                      declaration.declare = true;
                      return declaration;
                    }

                    break;
                  }

                  case "global":
                    if (this.match(types.braceL)) {
                      var mod = node;
                      mod.global = true;
                      mod.id = expr;
                      mod.body = this.tsParseModuleBlock();
                      return this.finishNode(mod, "TSModuleDeclaration");
                    }

                    break;

                  default:
                    return this.tsParseDeclaration(node, expr.name, false);
                }
              };

              _proto.tsParseDeclaration = function tsParseDeclaration(
                node,
                value,
                next
              ) {
                switch (value) {
                  case "abstract":
                    if (next || this.match(types._class)) {
                      var cls = node;
                      cls.abstract = true;
                      if (next) this.next();
                      return this.parseClass(cls, true, false);
                    }

                    break;

                  case "enum":
                    if (next || this.match(types.name)) {
                      if (next) this.next();
                      return this.tsParseEnumDeclaration(node, false);
                    }

                    break;

                  case "interface":
                    if (next || this.match(types.name)) {
                      if (next) this.next();
                      return this.tsParseInterfaceDeclaration(node);
                    }

                    break;

                  case "module":
                    if (next) this.next();

                    if (this.match(types.string)) {
                      return this.tsParseAmbientExternalModuleDeclaration(node);
                    } else if (next || this.match(types.name)) {
                      return this.tsParseModuleOrNamespaceDeclaration(node);
                    }

                    break;

                  case "namespace":
                    if (next || this.match(types.name)) {
                      if (next) this.next();
                      return this.tsParseModuleOrNamespaceDeclaration(node);
                    }

                    break;

                  case "type":
                    if (next || this.match(types.name)) {
                      if (next) this.next();
                      return this.tsParseTypeAliasDeclaration(node);
                    }

                    break;
                }
              };

              _proto.tsTryParseGenericAsyncArrowFunction = function tsTryParseGenericAsyncArrowFunction(
                startPos,
                startLoc
              ) {
                var _this10 = this;

                var res = this.tsTryParseAndCatch(function() {
                  var node = _this10.startNodeAt(startPos, startLoc);

                  node.typeParameters = _this10.tsParseTypeParameters();

                  _superClass.prototype.parseFunctionParams.call(_this10, node);

                  node.returnType = _this10.tsTryParseTypeOrTypePredicateAnnotation();

                  _this10.expect(types.arrow);

                  return node;
                });

                if (!res) {
                  return undefined;
                }

                res.id = null;
                res.generator = false;
                res.expression = true;
                res.async = true;
                this.parseFunctionBody(res, true);
                return this.finishNode(res, "ArrowFunctionExpression");
              };

              _proto.tsParseTypeArguments = function tsParseTypeArguments() {
                var _this11 = this;

                var node = this.startNode();
                node.params = this.tsInType(function() {
                  return _this11.tsInNoContext(function() {
                    _this11.expectRelational("<");

                    return _this11.tsParseDelimitedList(
                      "TypeParametersOrArguments",
                      _this11.tsParseType.bind(_this11)
                    );
                  });
                });
                this.state.exprAllowed = false;
                this.expectRelational(">");
                return this.finishNode(node, "TSTypeParameterInstantiation");
              };

              _proto.tsIsDeclarationStart = function tsIsDeclarationStart() {
                if (this.match(types.name)) {
                  switch (this.state.value) {
                    case "abstract":
                    case "declare":
                    case "enum":
                    case "interface":
                    case "module":
                    case "namespace":
                    case "type":
                      return true;
                  }
                }

                return false;
              };

              _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
                if (this.tsIsDeclarationStart()) return false;
                return _superClass.prototype.isExportDefaultSpecifier.call(
                  this
                );
              };

              _proto.parseAssignableListItem = function parseAssignableListItem(
                allowModifiers,
                decorators
              ) {
                var accessibility;
                var readonly = false;

                if (allowModifiers) {
                  accessibility = this.parseAccessModifier();
                  readonly = !!this.tsParseModifier(["readonly"]);
                }

                var left = this.parseMaybeDefault();
                this.parseAssignableListItemTypes(left);
                var elt = this.parseMaybeDefault(
                  left.start,
                  left.loc.start,
                  left
                );

                if (accessibility || readonly) {
                  var pp = this.startNodeAtNode(elt);

                  if (decorators.length) {
                    pp.decorators = decorators;
                  }

                  if (accessibility) pp.accessibility = accessibility;
                  if (readonly) pp.readonly = readonly;

                  if (
                    elt.type !== "Identifier" &&
                    elt.type !== "AssignmentPattern"
                  ) {
                    throw this.raise(
                      pp.start,
                      "A parameter property may not be declared using a binding pattern."
                    );
                  }

                  pp.parameter = elt;
                  return this.finishNode(pp, "TSParameterProperty");
                } else {
                  if (decorators.length) {
                    left.decorators = decorators;
                  }

                  return elt;
                }
              };

              _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(
                node,
                type,
                allowExpressionBody
              ) {
                if (!allowExpressionBody && this.match(types.colon)) {
                  node.returnType = this.tsParseTypeOrTypePredicateAnnotation(
                    types.colon
                  );
                }

                var bodilessType =
                  type === "FunctionDeclaration"
                    ? "TSDeclareFunction"
                    : type === "ClassMethod"
                      ? "TSDeclareMethod"
                      : undefined;

                if (
                  bodilessType &&
                  !this.match(types.braceL) &&
                  this.isLineTerminator()
                ) {
                  this.finishNode(node, bodilessType);
                  return;
                }

                _superClass.prototype.parseFunctionBodyAndFinish.call(
                  this,
                  node,
                  type,
                  allowExpressionBody
                );
              };

              _proto.parseSubscript = function parseSubscript(
                base,
                startPos,
                startLoc,
                noCalls,
                state
              ) {
                var _this12 = this;

                if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
                  this.state.exprAllowed = false;
                  this.next();
                  var nonNullExpression = this.startNodeAt(startPos, startLoc);
                  nonNullExpression.expression = base;
                  return this.finishNode(
                    nonNullExpression,
                    "TSNonNullExpression"
                  );
                }

                var result = this.tsTryParseAndCatch(function() {
                  if (_this12.isRelational("<")) {
                    if (!noCalls && _this12.atPossibleAsync(base)) {
                      var asyncArrowFn = _this12.tsTryParseGenericAsyncArrowFunction(
                        startPos,
                        startLoc
                      );

                      if (asyncArrowFn) {
                        return asyncArrowFn;
                      }
                    }

                    var node = _this12.startNodeAt(startPos, startLoc);

                    node.callee = base;

                    var typeArguments = _this12.tsParseTypeArguments();

                    if (typeArguments) {
                      if (!noCalls && _this12.eat(types.parenL)) {
                        node.arguments = _this12.parseCallExpressionArguments(
                          types.parenR,
                          false
                        );
                        node.typeParameters = typeArguments;
                        return _this12.finishCallExpression(node);
                      } else if (_this12.match(types.backQuote)) {
                        return _this12.parseTaggedTemplateExpression(
                          startPos,
                          startLoc,
                          base,
                          state,
                          typeArguments
                        );
                      }
                    }
                  }

                  _this12.unexpected();
                });
                if (result) return result;
                return _superClass.prototype.parseSubscript.call(
                  this,
                  base,
                  startPos,
                  startLoc,
                  noCalls,
                  state
                );
              };

              _proto.parseNewArguments = function parseNewArguments(node) {
                var _this13 = this;

                if (this.isRelational("<")) {
                  var typeParameters = this.tsTryParseAndCatch(function() {
                    var args = _this13.tsParseTypeArguments();

                    if (!_this13.match(types.parenL)) _this13.unexpected();
                    return args;
                  });

                  if (typeParameters) {
                    node.typeParameters = typeParameters;
                  }
                }

                _superClass.prototype.parseNewArguments.call(this, node);
              };

              _proto.parseExprOp = function parseExprOp(
                left,
                leftStartPos,
                leftStartLoc,
                minPrec,
                noIn
              ) {
                if (
                  nonNull(types._in.binop) > minPrec &&
                  !this.hasPrecedingLineBreak() &&
                  this.isContextual("as")
                ) {
                  var node = this.startNodeAt(leftStartPos, leftStartLoc);
                  node.expression = left;
                  node.typeAnnotation = this.tsNextThenParseType();
                  this.finishNode(node, "TSAsExpression");
                  return this.parseExprOp(
                    node,
                    leftStartPos,
                    leftStartLoc,
                    minPrec,
                    noIn
                  );
                }

                return _superClass.prototype.parseExprOp.call(
                  this,
                  left,
                  leftStartPos,
                  leftStartLoc,
                  minPrec,
                  noIn
                );
              };

              _proto.checkReservedWord = function checkReservedWord(
                word,
                startLoc,
                checkKeywords,
                isBinding
              ) {};

              _proto.checkDuplicateExports = function checkDuplicateExports() {};

              _proto.parseImport = function parseImport(node) {
                if (
                  this.match(types.name) &&
                  this.lookahead().type === types.eq
                ) {
                  return this.tsParseImportEqualsDeclaration(node);
                }

                return _superClass.prototype.parseImport.call(this, node);
              };

              _proto.parseExport = function parseExport(node) {
                if (this.match(types._import)) {
                  this.expect(types._import);
                  return this.tsParseImportEqualsDeclaration(node, true);
                } else if (this.eat(types.eq)) {
                  var assign = node;
                  assign.expression = this.parseExpression();
                  this.semicolon();
                  return this.finishNode(assign, "TSExportAssignment");
                } else if (this.eatContextual("as")) {
                  var decl = node;
                  this.expectContextual("namespace");
                  decl.id = this.parseIdentifier();
                  this.semicolon();
                  return this.finishNode(decl, "TSNamespaceExportDeclaration");
                } else {
                  return _superClass.prototype.parseExport.call(this, node);
                }
              };

              _proto.isAbstractClass = function isAbstractClass() {
                return (
                  this.isContextual("abstract") &&
                  this.lookahead().type === types._class
                );
              };

              _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
                if (this.isAbstractClass()) {
                  var cls = this.startNode();
                  this.next();
                  this.parseClass(cls, true, true);
                  cls.abstract = true;
                  return cls;
                }

                if (this.state.value === "interface") {
                  var result = this.tsParseDeclaration(
                    this.startNode(),
                    this.state.value,
                    true
                  );
                  if (result) return result;
                }

                return _superClass.prototype.parseExportDefaultExpression.call(
                  this
                );
              };

              _proto.parseStatementContent = function parseStatementContent(
                declaration,
                topLevel
              ) {
                if (this.state.type === types._const) {
                  var ahead = this.lookahead();

                  if (ahead.type === types.name && ahead.value === "enum") {
                    var node = this.startNode();
                    this.expect(types._const);
                    this.expectContextual("enum");
                    return this.tsParseEnumDeclaration(node, true);
                  }
                }

                return _superClass.prototype.parseStatementContent.call(
                  this,
                  declaration,
                  topLevel
                );
              };

              _proto.parseAccessModifier = function parseAccessModifier() {
                return this.tsParseModifier(["public", "protected", "private"]);
              };

              _proto.parseClassMember = function parseClassMember(
                classBody,
                member,
                state
              ) {
                var accessibility = this.parseAccessModifier();
                if (accessibility) member.accessibility = accessibility;

                _superClass.prototype.parseClassMember.call(
                  this,
                  classBody,
                  member,
                  state
                );
              };

              _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(
                classBody,
                member,
                state,
                isStatic
              ) {
                var methodOrProp = member;
                var prop = member;
                var propOrIdx = member;
                var abstract = false,
                  readonly = false;
                var mod = this.tsParseModifier(["abstract", "readonly"]);

                switch (mod) {
                  case "readonly":
                    readonly = true;
                    abstract = !!this.tsParseModifier(["abstract"]);
                    break;

                  case "abstract":
                    abstract = true;
                    readonly = !!this.tsParseModifier(["readonly"]);
                    break;
                }

                if (abstract) methodOrProp.abstract = true;
                if (readonly) propOrIdx.readonly = true;

                if (!abstract && !isStatic && !methodOrProp.accessibility) {
                  var idx = this.tsTryParseIndexSignature(member);

                  if (idx) {
                    classBody.body.push(idx);
                    return;
                  }
                }

                if (readonly) {
                  methodOrProp.static = isStatic;
                  this.parseClassPropertyName(prop);
                  this.parsePostMemberNameModifiers(methodOrProp);
                  this.pushClassProperty(classBody, prop);
                  return;
                }

                _superClass.prototype.parseClassMemberWithIsStatic.call(
                  this,
                  classBody,
                  member,
                  state,
                  isStatic
                );
              };

              _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(
                methodOrProp
              ) {
                var optional = this.eat(types.question);
                if (optional) methodOrProp.optional = true;
              };

              _proto.parseExpressionStatement = function parseExpressionStatement(
                node,
                expr
              ) {
                var decl =
                  expr.type === "Identifier"
                    ? this.tsParseExpressionStatement(node, expr)
                    : undefined;
                return (
                  decl ||
                  _superClass.prototype.parseExpressionStatement.call(
                    this,
                    node,
                    expr
                  )
                );
              };

              _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
                if (this.tsIsDeclarationStart()) return true;
                return _superClass.prototype.shouldParseExportDeclaration.call(
                  this
                );
              };

              _proto.parseConditional = function parseConditional(
                expr,
                noIn,
                startPos,
                startLoc,
                refNeedsArrowPos
              ) {
                if (!refNeedsArrowPos || !this.match(types.question)) {
                  return _superClass.prototype.parseConditional.call(
                    this,
                    expr,
                    noIn,
                    startPos,
                    startLoc,
                    refNeedsArrowPos
                  );
                }

                var state = this.state.clone();

                try {
                  return _superClass.prototype.parseConditional.call(
                    this,
                    expr,
                    noIn,
                    startPos,
                    startLoc
                  );
                } catch (err) {
                  if (!(err instanceof SyntaxError)) {
                    throw err;
                  }

                  this.state = state;
                  refNeedsArrowPos.start = err.pos || this.state.start;
                  return expr;
                }
              };

              _proto.parseParenItem = function parseParenItem(
                node,
                startPos,
                startLoc
              ) {
                node = _superClass.prototype.parseParenItem.call(
                  this,
                  node,
                  startPos,
                  startLoc
                );

                if (this.eat(types.question)) {
                  node.optional = true;
                }

                if (this.match(types.colon)) {
                  var typeCastNode = this.startNodeAt(startPos, startLoc);
                  typeCastNode.expression = node;
                  typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
                  return this.finishNode(typeCastNode, "TSTypeCastExpression");
                }

                return node;
              };

              _proto.parseExportDeclaration = function parseExportDeclaration(
                node
              ) {
                var isDeclare = this.eatContextual("declare");
                var declaration;

                if (this.match(types.name)) {
                  declaration = this.tsTryParseExportDeclaration();
                }

                if (!declaration) {
                  declaration = _superClass.prototype.parseExportDeclaration.call(
                    this,
                    node
                  );
                }

                if (declaration && isDeclare) {
                  declaration.declare = true;
                }

                return declaration;
              };

              _proto.parseClassId = function parseClassId(
                node,
                isStatement,
                optionalId
              ) {
                if (
                  (!isStatement || optionalId) &&
                  this.isContextual("implements")
                ) {
                  return;
                }

                _superClass.prototype.parseClassId.apply(this, arguments);

                var typeParameters = this.tsTryParseTypeParameters();
                if (typeParameters) node.typeParameters = typeParameters;
              };

              _proto.parseClassProperty = function parseClassProperty(node) {
                if (!node.optional && this.eat(types.bang)) {
                  node.definite = true;
                }

                var type = this.tsTryParseTypeAnnotation();
                if (type) node.typeAnnotation = type;
                return _superClass.prototype.parseClassProperty.call(
                  this,
                  node
                );
              };

              _proto.pushClassMethod = function pushClassMethod(
                classBody,
                method,
                isGenerator,
                isAsync,
                isConstructor
              ) {
                var typeParameters = this.tsTryParseTypeParameters();
                if (typeParameters) method.typeParameters = typeParameters;

                _superClass.prototype.pushClassMethod.call(
                  this,
                  classBody,
                  method,
                  isGenerator,
                  isAsync,
                  isConstructor
                );
              };

              _proto.pushClassPrivateMethod = function pushClassPrivateMethod(
                classBody,
                method,
                isGenerator,
                isAsync
              ) {
                var typeParameters = this.tsTryParseTypeParameters();
                if (typeParameters) method.typeParameters = typeParameters;

                _superClass.prototype.pushClassPrivateMethod.call(
                  this,
                  classBody,
                  method,
                  isGenerator,
                  isAsync
                );
              };

              _proto.parseClassSuper = function parseClassSuper(node) {
                _superClass.prototype.parseClassSuper.call(this, node);

                if (node.superClass && this.isRelational("<")) {
                  node.superTypeParameters = this.tsParseTypeArguments();
                }

                if (this.eatContextual("implements")) {
                  node.implements = this.tsParseHeritageClause();
                }
              };

              _proto.parseObjPropValue = function parseObjPropValue(prop) {
                var _superClass$prototype;

                if (this.isRelational("<")) {
                  throw new Error("TODO");
                }

                for (
                  var _len = arguments.length,
                    args = new Array(_len > 1 ? _len - 1 : 0),
                    _key = 1;
                  _key < _len;
                  _key++
                ) {
                  args[_key - 1] = arguments[_key];
                }

                (_superClass$prototype =
                  _superClass.prototype.parseObjPropValue).call.apply(
                  _superClass$prototype,
                  [this, prop].concat(args)
                );
              };

              _proto.parseFunctionParams = function parseFunctionParams(
                node,
                allowModifiers
              ) {
                var typeParameters = this.tsTryParseTypeParameters();
                if (typeParameters) node.typeParameters = typeParameters;

                _superClass.prototype.parseFunctionParams.call(
                  this,
                  node,
                  allowModifiers
                );
              };

              _proto.parseVarHead = function parseVarHead(decl) {
                _superClass.prototype.parseVarHead.call(this, decl);

                if (decl.id.type === "Identifier" && this.eat(types.bang)) {
                  decl.definite = true;
                }

                var type = this.tsTryParseTypeAnnotation();

                if (type) {
                  decl.id.typeAnnotation = type;
                  this.finishNode(decl.id, decl.id.type);
                }
              };

              _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(
                node,
                call
              ) {
                if (this.match(types.colon)) {
                  node.returnType = this.tsParseTypeAnnotation();
                }

                return _superClass.prototype.parseAsyncArrowFromCallExpression.call(
                  this,
                  node,
                  call
                );
              };

              _proto.parseMaybeAssign = function parseMaybeAssign() {
                var jsxError;

                for (
                  var _len2 = arguments.length,
                    args = new Array(_len2),
                    _key2 = 0;
                  _key2 < _len2;
                  _key2++
                ) {
                  args[_key2] = arguments[_key2];
                }

                if (this.match(types.jsxTagStart)) {
                  var context = this.curContext();
                  assert(context === types$1.j_oTag);
                  assert(
                    this.state.context[this.state.context.length - 2] ===
                      types$1.j_expr
                  );

                  var _state = this.state.clone();

                  try {
                    var _superClass$prototype2;

                    return (_superClass$prototype2 =
                      _superClass.prototype.parseMaybeAssign).call.apply(
                      _superClass$prototype2,
                      [this].concat(args)
                    );
                  } catch (err) {
                    if (!(err instanceof SyntaxError)) {
                      throw err;
                    }

                    this.state = _state;
                    assert(this.curContext() === types$1.j_oTag);
                    this.state.context.pop();
                    assert(this.curContext() === types$1.j_expr);
                    this.state.context.pop();
                    jsxError = err;
                  }
                }

                if (jsxError === undefined && !this.isRelational("<")) {
                  var _superClass$prototype3;

                  return (_superClass$prototype3 =
                    _superClass.prototype.parseMaybeAssign).call.apply(
                    _superClass$prototype3,
                    [this].concat(args)
                  );
                }

                var arrowExpression;
                var typeParameters;
                var state = this.state.clone();

                try {
                  var _superClass$prototype4;

                  typeParameters = this.tsParseTypeParameters();
                  arrowExpression = (_superClass$prototype4 =
                    _superClass.prototype.parseMaybeAssign).call.apply(
                    _superClass$prototype4,
                    [this].concat(args)
                  );

                  if (arrowExpression.type !== "ArrowFunctionExpression") {
                    this.unexpected();
                  }
                } catch (err) {
                  var _superClass$prototype5;

                  if (!(err instanceof SyntaxError)) {
                    throw err;
                  }

                  if (jsxError) {
                    throw jsxError;
                  }

                  assert(!this.hasPlugin("jsx"));
                  this.state = state;
                  return (_superClass$prototype5 =
                    _superClass.prototype.parseMaybeAssign).call.apply(
                    _superClass$prototype5,
                    [this].concat(args)
                  );
                }

                if (typeParameters && typeParameters.params.length !== 0) {
                  this.resetStartLocationFromNode(
                    arrowExpression,
                    typeParameters.params[0]
                  );
                }

                arrowExpression.typeParameters = typeParameters;
                return arrowExpression;
              };

              _proto.parseMaybeUnary = function parseMaybeUnary(
                refShorthandDefaultPos
              ) {
                if (!this.hasPlugin("jsx") && this.eatRelational("<")) {
                  return this.tsParseTypeAssertion();
                } else {
                  return _superClass.prototype.parseMaybeUnary.call(
                    this,
                    refShorthandDefaultPos
                  );
                }
              };

              _proto.parseArrow = function parseArrow(node) {
                if (this.match(types.colon)) {
                  var state = this.state.clone();

                  try {
                    var returnType = this.tsParseTypeOrTypePredicateAnnotation(
                      types.colon
                    );
                    if (this.canInsertSemicolon()) this.unexpected();
                    if (!this.match(types.arrow)) this.unexpected();
                    node.returnType = returnType;
                  } catch (err) {
                    if (err instanceof SyntaxError) {
                      this.state = state;
                    } else {
                      throw err;
                    }
                  }
                }

                return _superClass.prototype.parseArrow.call(this, node);
              };

              _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(
                param
              ) {
                if (this.eat(types.question)) {
                  if (param.type !== "Identifier") {
                    throw this.raise(
                      param.start,
                      "A binding pattern parameter cannot be optional in an implementation signature."
                    );
                  }

                  param.optional = true;
                }

                var type = this.tsTryParseTypeAnnotation();
                if (type) param.typeAnnotation = type;
                return this.finishNode(param, param.type);
              };

              _proto.toAssignable = function toAssignable(
                node,
                isBinding,
                contextDescription
              ) {
                switch (node.type) {
                  case "TSTypeCastExpression":
                    return _superClass.prototype.toAssignable.call(
                      this,
                      this.typeCastToParameter(node),
                      isBinding,
                      contextDescription
                    );

                  case "TSParameterProperty":
                    return _superClass.prototype.toAssignable.call(
                      this,
                      node,
                      isBinding,
                      contextDescription
                    );

                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "TSTypeAssertion":
                    node.expression = this.toAssignable(
                      node.expression,
                      isBinding,
                      contextDescription
                    );
                    return node;

                  default:
                    return _superClass.prototype.toAssignable.call(
                      this,
                      node,
                      isBinding,
                      contextDescription
                    );
                }
              };

              _proto.checkLVal = function checkLVal(
                expr,
                isBinding,
                checkClashes,
                contextDescription
              ) {
                switch (expr.type) {
                  case "TSTypeCastExpression":
                    return;

                  case "TSParameterProperty":
                    this.checkLVal(
                      expr.parameter,
                      isBinding,
                      checkClashes,
                      "parameter property"
                    );
                    return;

                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "TSTypeAssertion":
                    this.checkLVal(
                      expr.expression,
                      isBinding,
                      checkClashes,
                      contextDescription
                    );
                    return;

                  default:
                    _superClass.prototype.checkLVal.call(
                      this,
                      expr,
                      isBinding,
                      checkClashes,
                      contextDescription
                    );

                    return;
                }
              };

              _proto.parseBindingAtom = function parseBindingAtom() {
                switch (this.state.type) {
                  case types._this:
                    return this.parseIdentifier(true);

                  default:
                    return _superClass.prototype.parseBindingAtom.call(this);
                }
              };

              _proto.isClassMethod = function isClassMethod() {
                return (
                  this.isRelational("<") ||
                  _superClass.prototype.isClassMethod.call(this)
                );
              };

              _proto.isClassProperty = function isClassProperty() {
                return (
                  this.match(types.bang) ||
                  this.match(types.colon) ||
                  _superClass.prototype.isClassProperty.call(this)
                );
              };

              _proto.parseMaybeDefault = function parseMaybeDefault() {
                var _superClass$prototype6;

                for (
                  var _len3 = arguments.length,
                    args = new Array(_len3),
                    _key3 = 0;
                  _key3 < _len3;
                  _key3++
                ) {
                  args[_key3] = arguments[_key3];
                }

                var node = (_superClass$prototype6 =
                  _superClass.prototype.parseMaybeDefault).call.apply(
                  _superClass$prototype6,
                  [this].concat(args)
                );

                if (
                  node.type === "AssignmentPattern" &&
                  node.typeAnnotation &&
                  node.right.start < node.typeAnnotation.start
                ) {
                  this.raise(
                    node.typeAnnotation.start,
                    "Type annotations must come before default assignments, " +
                      "e.g. instead of `age = 25: number` use `age: number = 25`"
                  );
                }

                return node;
              };

              _proto.readToken = function readToken(code) {
                if (this.state.inType && (code === 62 || code === 60)) {
                  return this.finishOp(types.relational, 1);
                } else {
                  return _superClass.prototype.readToken.call(this, code);
                }
              };

              _proto.toAssignableList = function toAssignableList(
                exprList,
                isBinding,
                contextDescription
              ) {
                for (var i = 0; i < exprList.length; i++) {
                  var expr = exprList[i];

                  if (expr && expr.type === "TSTypeCastExpression") {
                    exprList[i] = this.typeCastToParameter(expr);
                  }
                }

                return _superClass.prototype.toAssignableList.call(
                  this,
                  exprList,
                  isBinding,
                  contextDescription
                );
              };

              _proto.typeCastToParameter = function typeCastToParameter(node) {
                node.expression.typeAnnotation = node.typeAnnotation;
                return this.finishNodeAt(
                  node.expression,
                  node.expression.type,
                  node.typeAnnotation.end,
                  node.typeAnnotation.loc.end
                );
              };

              _proto.toReferencedList = function toReferencedList(exprList) {
                for (var i = 0; i < exprList.length; i++) {
                  var expr = exprList[i];

                  if (
                    expr &&
                    expr._exprListItem &&
                    expr.type === "TsTypeCastExpression"
                  ) {
                    this.raise(
                      expr.start,
                      "Did not expect a type annotation here."
                    );
                  }
                }

                return exprList;
              };

              _proto.shouldParseArrow = function shouldParseArrow() {
                return (
                  this.match(types.colon) ||
                  _superClass.prototype.shouldParseArrow.call(this)
                );
              };

              _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
                return (
                  this.match(types.colon) ||
                  _superClass.prototype.shouldParseAsyncArrow.call(this)
                );
              };

              _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
                return (
                  _superClass.prototype.canHaveLeadingDecorator.call(this) ||
                  this.isAbstractClass()
                );
              };

              _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(
                node
              ) {
                var _this14 = this;

                var typeArguments = this.tsTryParseAndCatch(function() {
                  return _this14.tsParseTypeArguments();
                });
                if (typeArguments) node.typeParameters = typeArguments;
                return _superClass.prototype.jsxParseOpeningElementAfterName.call(
                  this,
                  node
                );
              };

              return _class;
            })(superClass);
          };

          function hasPlugin(plugins, name) {
            return plugins.some(function(plugin) {
              if (Array.isArray(plugin)) {
                return plugin[0] === name;
              } else {
                return plugin === name;
              }
            });
          }

          function getPluginOption(plugins, name, option) {
            var plugin = plugins.find(function(plugin) {
              if (Array.isArray(plugin)) {
                return plugin[0] === name;
              } else {
                return plugin === name;
              }
            });

            if (plugin && Array.isArray(plugin)) {
              return plugin[1][option];
            }

            return null;
          }

          var PIPELINE_PROPOSALS = ["minimal"];

          function validatePlugins(plugins) {
            if (hasPlugin(plugins, "decorators")) {
              if (hasPlugin(plugins, "decorators-legacy")) {
                throw new Error(
                  "Cannot use the decorators and decorators-legacy plugin together"
                );
              }

              var decoratorsBeforeExport = getPluginOption(
                plugins,
                "decorators",
                "decoratorsBeforeExport"
              );

              if (decoratorsBeforeExport == null) {
                throw new Error(
                  "The 'decorators' plugin requires a 'decoratorsBeforeExport' option," +
                    " whose value must be a boolean. If you are migrating from" +
                    " Babylon/Babel 6 or want to use the old decorators proposal, you" +
                    " should use the 'decorators-legacy' plugin instead of 'decorators'."
                );
              } else if (typeof decoratorsBeforeExport !== "boolean") {
                throw new Error("'decoratorsBeforeExport' must be a boolean.");
              }
            }

            if (
              hasPlugin(plugins, "flow") &&
              hasPlugin(plugins, "typescript")
            ) {
              throw new Error("Cannot combine flow and typescript plugins.");
            }

            if (
              hasPlugin(plugins, "pipelineOperator") &&
              !PIPELINE_PROPOSALS.includes(
                getPluginOption(plugins, "pipelineOperator", "proposal")
              )
            ) {
              throw new Error(
                "'pipelineOperator' requires 'proposal' option whose value should be one of: " +
                  PIPELINE_PROPOSALS.join(", ")
              );
            }
          }

          var mixinPluginNames = ["estree", "jsx", "flow", "typescript"];
          var mixinPlugins = {
            estree: estree,
            jsx: jsx,
            flow: flow,
            typescript: typescript,
          };

          function parse(input, options) {
            if (options && options.sourceType === "unambiguous") {
              options = Object.assign({}, options);

              try {
                options.sourceType = "module";
                var parser = getParser(options, input);
                var ast = parser.parse();
                if (!parser.sawUnambiguousESM)
                  ast.program.sourceType = "script";
                return ast;
              } catch (moduleError) {
                try {
                  options.sourceType = "script";
                  return getParser(options, input).parse();
                } catch (scriptError) {}

                throw moduleError;
              }
            } else {
              return getParser(options, input).parse();
            }
          }

          function parseExpression(input, options) {
            var parser = getParser(options, input);

            if (parser.options.strictMode) {
              parser.state.strict = true;
            }

            return parser.getExpression();
          }

          function getParser(options, input) {
            var cls = Parser;

            if (options && options.plugins) {
              validatePlugins(options.plugins);
              cls = getParserClass(options.plugins);
            }

            return new cls(options, input);
          }

          var parserClassCache = {};

          function getParserClass(pluginsFromOptions) {
            var pluginList = mixinPluginNames.filter(function(name) {
              return hasPlugin(pluginsFromOptions, name);
            });
            var key = pluginList.join("/");
            var cls = parserClassCache[key];

            if (!cls) {
              cls = Parser;

              for (var _i2 = 0; _i2 < pluginList.length; _i2++) {
                var plugin = pluginList[_i2];
                cls = mixinPlugins[plugin](cls);
              }

              parserClassCache[key] = cls;
            }

            return cls;
          }

          exports.parse = parse;
          exports.parseExpression = parseExpression;
          exports.tokTypes = types;
        },
        /* 81 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.merge = merge;
          exports.validate = validate;
          exports.normalizeReplacements = normalizeReplacements;

          function _objectWithoutPropertiesLoose(source, excluded) {
            if (source == null) return {};
            var target = {};
            var sourceKeys = Object.keys(source);
            var key, i;

            for (i = 0; i < sourceKeys.length; i++) {
              key = sourceKeys[i];
              if (excluded.indexOf(key) >= 0) continue;
              target[key] = source[key];
            }

            return target;
          }

          function merge(a, b) {
            var _b$placeholderWhiteli = b.placeholderWhitelist,
              placeholderWhitelist =
                _b$placeholderWhiteli === void 0
                  ? a.placeholderWhitelist
                  : _b$placeholderWhiteli,
              _b$placeholderPattern = b.placeholderPattern,
              placeholderPattern =
                _b$placeholderPattern === void 0
                  ? a.placeholderPattern
                  : _b$placeholderPattern,
              _b$preserveComments = b.preserveComments,
              preserveComments =
                _b$preserveComments === void 0
                  ? a.preserveComments
                  : _b$preserveComments;
            return {
              parser: Object.assign({}, a.parser, b.parser),
              placeholderWhitelist: placeholderWhitelist,
              placeholderPattern: placeholderPattern,
              preserveComments: preserveComments,
            };
          }

          function validate(opts) {
            if (opts != null && typeof opts !== "object") {
              throw new Error("Unknown template options.");
            }

            var _ref = opts || {},
              placeholderWhitelist = _ref.placeholderWhitelist,
              placeholderPattern = _ref.placeholderPattern,
              preserveComments = _ref.preserveComments,
              parser = _objectWithoutPropertiesLoose(_ref, [
                "placeholderWhitelist",
                "placeholderPattern",
                "preserveComments",
              ]);

            if (
              placeholderWhitelist != null &&
              !(placeholderWhitelist instanceof Set)
            ) {
              throw new Error(
                "'.placeholderWhitelist' must be a Set, null, or undefined"
              );
            }

            if (
              placeholderPattern != null &&
              !(placeholderPattern instanceof RegExp) &&
              placeholderPattern !== false
            ) {
              throw new Error(
                "'.placeholderPattern' must be a RegExp, false, null, or undefined"
              );
            }

            if (
              preserveComments != null &&
              typeof preserveComments !== "boolean"
            ) {
              throw new Error(
                "'.preserveComments' must be a boolean, null, or undefined"
              );
            }

            return {
              parser: parser,
              placeholderWhitelist: placeholderWhitelist || undefined,
              placeholderPattern:
                placeholderPattern == null ? undefined : placeholderPattern,
              preserveComments:
                preserveComments == null ? false : preserveComments,
            };
          }

          function normalizeReplacements(replacements) {
            if (Array.isArray(replacements)) {
              return replacements.reduce(function(acc, replacement, i) {
                acc["$" + i] = replacement;
                return acc;
              }, {});
            } else if (
              typeof replacements === "object" ||
              replacements == null
            ) {
              return replacements || undefined;
            }

            throw new Error(
              "Template replacements must be an array, object, null, or undefined"
            );
          }
        },
        /* 82 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.findPackageData = findPackageData;
          exports.findRelativeConfig = findRelativeConfig;
          exports.findRootConfig = findRootConfig;
          exports.loadConfig = loadConfig;
          exports.resolvePlugin = resolvePlugin;
          exports.resolvePreset = resolvePreset;
          exports.loadPlugin = loadPlugin;
          exports.loadPreset = loadPreset;

          function findPackageData(filepath) {
            return {
              filepath: filepath,
              directories: [],
              pkg: null,
              isPackage: false,
            };
          }

          function findRelativeConfig(pkgData, envName, caller) {
            return {
              pkg: null,
              config: null,
              ignore: null,
            };
          }

          function findRootConfig(dirname, envName, caller) {
            return null;
          }

          function loadConfig(name, dirname, envName, caller) {
            throw new Error(
              "Cannot load " +
                name +
                " relative to " +
                dirname +
                " in a browser"
            );
          }

          function resolvePlugin(name, dirname) {
            return null;
          }

          function resolvePreset(name, dirname) {
            return null;
          }

          function loadPlugin(name, dirname) {
            throw new Error(
              "Cannot load plugin " +
                name +
                " relative to " +
                dirname +
                " in a browser"
            );
          }

          function loadPreset(name, dirname) {
            throw new Error(
              "Cannot load preset " +
                name +
                " relative to " +
                dirname +
                " in a browser"
            );
          }
        },
        /* 83 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          var Plugin = function Plugin(plugin, options, key) {
            this.key = plugin.name || key;
            this.manipulateOptions = plugin.manipulateOptions;
            this.post = plugin.post;
            this.pre = plugin.pre;
            this.visitor = plugin.visitor || {};
            this.parserOverride = plugin.parserOverride;
            this.generatorOverride = plugin.generatorOverride;
            this.options = options;
          };

          exports.default = Plugin;
        },
        /* 84 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.validate = validate;

          var _plugin = _interopRequireDefault(__webpack_require__(83));

          var _removed = _interopRequireDefault(__webpack_require__(404));

          var _optionAssertions = __webpack_require__(156);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var ROOT_VALIDATORS = {
            cwd: _optionAssertions.assertString,
            root: _optionAssertions.assertString,
            configFile: _optionAssertions.assertConfigFileSearch,
            caller: _optionAssertions.assertCallerMetadata,
            filename: _optionAssertions.assertString,
            filenameRelative: _optionAssertions.assertString,
            code: _optionAssertions.assertBoolean,
            ast: _optionAssertions.assertBoolean,
            envName: _optionAssertions.assertString,
          };
          var BABELRC_VALIDATORS = {
            babelrc: _optionAssertions.assertBoolean,
            babelrcRoots: _optionAssertions.assertBabelrcSearch,
          };
          var NONPRESET_VALIDATORS = {
            extends: _optionAssertions.assertString,
            ignore: _optionAssertions.assertIgnoreList,
            only: _optionAssertions.assertIgnoreList,
          };
          var COMMON_VALIDATORS = {
            inputSourceMap: _optionAssertions.assertInputSourceMap,
            presets: _optionAssertions.assertPluginList,
            plugins: _optionAssertions.assertPluginList,
            passPerPreset: _optionAssertions.assertBoolean,
            env: assertEnvSet,
            overrides: assertOverridesList,
            test: _optionAssertions.assertConfigApplicableTest,
            include: _optionAssertions.assertConfigApplicableTest,
            exclude: _optionAssertions.assertConfigApplicableTest,
            retainLines: _optionAssertions.assertBoolean,
            comments: _optionAssertions.assertBoolean,
            shouldPrintComment: _optionAssertions.assertFunction,
            compact: _optionAssertions.assertCompact,
            minified: _optionAssertions.assertBoolean,
            auxiliaryCommentBefore: _optionAssertions.assertString,
            auxiliaryCommentAfter: _optionAssertions.assertString,
            sourceType: _optionAssertions.assertSourceType,
            wrapPluginVisitorMethod: _optionAssertions.assertFunction,
            highlightCode: _optionAssertions.assertBoolean,
            sourceMaps: _optionAssertions.assertSourceMaps,
            sourceMap: _optionAssertions.assertSourceMaps,
            sourceFileName: _optionAssertions.assertString,
            sourceRoot: _optionAssertions.assertString,
            getModuleId: _optionAssertions.assertFunction,
            moduleRoot: _optionAssertions.assertString,
            moduleIds: _optionAssertions.assertBoolean,
            moduleId: _optionAssertions.assertString,
            parserOpts: _optionAssertions.assertObject,
            generatorOpts: _optionAssertions.assertObject,
          };

          function getSource(loc) {
            return loc.type === "root" ? loc.source : getSource(loc.parent);
          }

          function validate(type, opts) {
            return validateNested(
              {
                type: "root",
                source: type,
              },
              opts
            );
          }

          function validateNested(loc, opts) {
            var type = getSource(loc);
            assertNoDuplicateSourcemap(opts);
            Object.keys(opts).forEach(function(key) {
              var optLoc = {
                type: "option",
                name: key,
                parent: loc,
              };

              if (type === "preset" && NONPRESET_VALIDATORS[key]) {
                throw new Error(
                  (0, _optionAssertions.msg)(optLoc) +
                    " is not allowed in preset options"
                );
              }

              if (type !== "arguments" && ROOT_VALIDATORS[key]) {
                throw new Error(
                  (0, _optionAssertions.msg)(optLoc) +
                    " is only allowed in root programmatic options"
                );
              }

              if (
                type !== "arguments" &&
                type !== "configfile" &&
                BABELRC_VALIDATORS[key]
              ) {
                if (type === "babelrcfile" || type === "extendsfile") {
                  throw new Error(
                    (0, _optionAssertions.msg)(optLoc) +
                      ' is not allowed in .babelrc or "extends"ed files, only in root programmatic options, ' +
                      "or babel.config.js/config file options"
                  );
                }

                throw new Error(
                  (0, _optionAssertions.msg)(optLoc) +
                    " is only allowed in root programmatic options, or babel.config.js/config file options"
                );
              }

              var validator =
                COMMON_VALIDATORS[key] ||
                NONPRESET_VALIDATORS[key] ||
                BABELRC_VALIDATORS[key] ||
                ROOT_VALIDATORS[key] ||
                throwUnknownError;
              validator(optLoc, opts[key]);
            });
            return opts;
          }

          function throwUnknownError(loc) {
            var key = loc.name;

            if (_removed.default[key]) {
              var _removed$default$key = _removed.default[key],
                message = _removed$default$key.message,
                _removed$default$key$ = _removed$default$key.version,
                version =
                  _removed$default$key$ === void 0 ? 5 : _removed$default$key$;
              throw new ReferenceError(
                "Using removed Babel " +
                  version +
                  " option: " +
                  (0, _optionAssertions.msg)(loc) +
                  " - " +
                  message
              );
            } else {
              var unknownOptErr =
                "Unknown option: " +
                (0, _optionAssertions.msg)(loc) +
                ". Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.";
              throw new ReferenceError(unknownOptErr);
            }
          }

          function has(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key);
          }

          function assertNoDuplicateSourcemap(opts) {
            if (has(opts, "sourceMap") && has(opts, "sourceMaps")) {
              throw new Error(
                ".sourceMap is an alias for .sourceMaps, cannot use both"
              );
            }
          }

          function assertEnvSet(loc, value) {
            if (loc.parent.type === "env") {
              throw new Error(
                (0, _optionAssertions.msg)(loc) +
                  " is not allowed inside of another .env block"
              );
            }

            var parent = loc.parent;
            var obj = (0, _optionAssertions.assertObject)(loc, value);

            if (obj) {
              var _arr = Object.keys(obj);

              for (var _i = 0; _i < _arr.length; _i++) {
                var envName = _arr[_i];
                var env = (0, _optionAssertions.assertObject)(
                  (0, _optionAssertions.access)(loc, envName),
                  obj[envName]
                );
                if (!env) continue;
                var envLoc = {
                  type: "env",
                  name: envName,
                  parent: parent,
                };
                validateNested(envLoc, env);
              }
            }

            return obj;
          }

          function assertOverridesList(loc, value) {
            if (loc.parent.type === "env") {
              throw new Error(
                (0, _optionAssertions.msg)(loc) +
                  " is not allowed inside an .env block"
              );
            }

            if (loc.parent.type === "overrides") {
              throw new Error(
                (0, _optionAssertions.msg)(loc) +
                  " is not allowed inside an .overrides block"
              );
            }

            var parent = loc.parent;
            var arr = (0, _optionAssertions.assertArray)(loc, value);

            if (arr) {
              for (
                var _iterator = arr.entries(),
                  _isArray = Array.isArray(_iterator),
                  _i2 = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i2 >= _iterator.length) break;
                  _ref = _iterator[_i2++];
                } else {
                  _i2 = _iterator.next();
                  if (_i2.done) break;
                  _ref = _i2.value;
                }

                var _ref2 = _ref,
                  index = _ref2[0],
                  item = _ref2[1];
                var objLoc = (0, _optionAssertions.access)(loc, index);
                var env = (0, _optionAssertions.assertObject)(objLoc, item);
                if (!env)
                  throw new Error(
                    (0, _optionAssertions.msg)(objLoc) + " must be an object"
                  );
                var overridesLoc = {
                  type: "overrides",
                  index: index,
                  parent: parent,
                };
                validateNested(overridesLoc, env);
              }
            }

            return arr;
          }
        },
        /* 85 */
        function(module, exports, __webpack_require__) {
          var isArray = __webpack_require__(5),
            isSymbol = __webpack_require__(29);

          var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            reIsPlainProp = /^\w*$/;

          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }

            var type = typeof value;

            if (
              type == "number" ||
              type == "symbol" ||
              type == "boolean" ||
              value == null ||
              isSymbol(value)
            ) {
              return true;
            }

            return (
              reIsPlainProp.test(value) ||
              !reIsDeepProp.test(value) ||
              (object != null && value in Object(object))
            );
          }

          module.exports = isKey;
        },
        /* 86 */
        function(module) {
          module.exports = {
            "es6.array.copy-within": {
              chrome: "45",
              edge: "12",
              firefox: "32",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "32",
              electron: "0.35",
            },
            "es6.array.every": {
              chrome: "5",
              opera: "10.10",
              edge: "12",
              firefox: "2",
              safari: "3.1",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.array.fill": {
              chrome: "45",
              edge: "12",
              firefox: "31",
              safari: "7.1",
              node: "4",
              ios: "8",
              opera: "32",
              electron: "0.35",
            },
            "es6.array.filter": {
              chrome: "5",
              opera: "10.10",
              edge: "12",
              firefox: "2",
              safari: "3.1",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.array.find": {
              chrome: "45",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "4",
              ios: "8",
              opera: "32",
              electron: "0.35",
            },
            "es6.array.find-index": {
              chrome: "45",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "4",
              ios: "8",
              opera: "32",
              electron: "0.35",
            },
            "es6.array.for-each": {
              chrome: "5",
              opera: "10.10",
              edge: "12",
              firefox: "2",
              safari: "3.1",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.array.from": {
              chrome: "51",
              edge: "15",
              firefox: "36",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es7.array.includes": {
              chrome: "47",
              edge: "14",
              firefox: "43",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "34",
              electron: "0.36",
            },
            "es6.array.index-of": {
              chrome: "5",
              opera: "10.10",
              edge: "12",
              firefox: "2",
              safari: "3.1",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.array.is-array": {
              chrome: "5",
              opera: "10.50",
              edge: "12",
              firefox: "4",
              safari: "4",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.array.iterator": {
              chrome: "38",
              edge: "12",
              firefox: "28",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.array.last-index-of": {
              chrome: "5",
              opera: "10.10",
              edge: "12",
              firefox: "2",
              safari: "3.1",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.array.map": {
              chrome: "5",
              opera: "10.10",
              edge: "12",
              firefox: "2",
              safari: "3.1",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.array.of": {
              chrome: "45",
              edge: "12",
              firefox: "25",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "32",
              electron: "0.35",
            },
            "es6.array.reduce": {
              chrome: "5",
              opera: "10.50",
              edge: "12",
              firefox: "3",
              safari: "4",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.array.reduce-right": {
              chrome: "5",
              opera: "10.50",
              edge: "12",
              firefox: "3",
              safari: "4",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.array.some": {
              chrome: "5",
              opera: "10.10",
              edge: "12",
              firefox: "2",
              safari: "3.1",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.array.sort": {
              chrome: "63",
              opera: "50",
              edge: "12",
              firefox: "5",
              safari: "10.1",
              ie: "9",
              ios: "10.3",
              electron: "3",
            },
            "es6.array.species": {
              chrome: "51",
              edge: "13",
              firefox: "48",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.date.now": {
              chrome: "5",
              opera: "10.50",
              edge: "12",
              firefox: "2",
              safari: "4",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.date.to-iso-string": {
              chrome: "5",
              opera: "10.50",
              edge: "12",
              firefox: "3.5",
              safari: "4",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.date.to-json": {
              chrome: "5",
              opera: "12.10",
              edge: "12",
              firefox: "4",
              safari: "10",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "10",
              electron: "1.1",
            },
            "es6.date.to-primitive": {
              chrome: "47",
              edge: "15",
              firefox: "44",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "34",
              electron: "0.36",
            },
            "es6.date.to-string": {
              chrome: "5",
              opera: "10.50",
              edge: "12",
              firefox: "2",
              safari: "3.1",
              node: "0.12",
              ie: "10",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.function.bind": {
              chrome: "7",
              opera: "12",
              edge: "12",
              firefox: "4",
              safari: "5.1",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "7",
            },
            "es6.function.has-instance": {
              chrome: "51",
              edge: "15",
              firefox: "50",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.function.name": {
              chrome: "5",
              opera: "10.50",
              edge: "12",
              firefox: "2",
              safari: "4",
              node: "0.12",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.map": {
              chrome: "51",
              edge: "15",
              firefox: "53",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.math.acosh": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.asinh": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.atanh": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.cbrt": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.clz32": {
              chrome: "38",
              edge: "12",
              firefox: "31",
              safari: "9",
              node: "0.12",
              ios: "9",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.cosh": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.expm1": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.fround": {
              chrome: "38",
              edge: "12",
              firefox: "26",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.hypot": {
              chrome: "38",
              edge: "12",
              firefox: "27",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.imul": {
              chrome: "30",
              edge: "12",
              firefox: "23",
              safari: "7",
              node: "0.12",
              android: "4.4",
              ios: "7",
              opera: "17",
              electron: "0.2",
            },
            "es6.math.log1p": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.log10": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.log2": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.sign": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "9",
              node: "0.12",
              ios: "9",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.sinh": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.tanh": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.math.trunc": {
              chrome: "38",
              edge: "12",
              firefox: "25",
              safari: "7.1",
              node: "0.12",
              ios: "8",
              opera: "25",
              electron: "0.2",
            },
            "es6.number.constructor": {
              chrome: "41",
              edge: "12",
              firefox: "36",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "28",
              electron: "0.24",
            },
            "es6.number.epsilon": {
              chrome: "34",
              edge: "12",
              firefox: "25",
              safari: "9",
              node: "0.12",
              ios: "9",
              opera: "21",
              electron: "0.2",
            },
            "es6.number.is-finite": {
              chrome: "19",
              edge: "12",
              firefox: "16",
              safari: "9",
              node: "0.12",
              android: "4.1",
              ios: "9",
              electron: "0.2",
            },
            "es6.number.is-integer": {
              chrome: "34",
              edge: "12",
              firefox: "16",
              safari: "9",
              node: "0.12",
              ios: "9",
              opera: "21",
              electron: "0.2",
            },
            "es6.number.is-nan": {
              chrome: "19",
              edge: "12",
              firefox: "15",
              safari: "9",
              node: "0.12",
              android: "4.1",
              ios: "9",
              electron: "0.2",
            },
            "es6.number.is-safe-integer": {
              chrome: "34",
              edge: "12",
              firefox: "32",
              safari: "9",
              node: "0.12",
              ios: "9",
              opera: "21",
              electron: "0.2",
            },
            "es6.number.max-safe-integer": {
              chrome: "34",
              edge: "12",
              firefox: "31",
              safari: "9",
              node: "0.12",
              ios: "9",
              opera: "21",
              electron: "0.2",
            },
            "es6.number.min-safe-integer": {
              chrome: "34",
              edge: "12",
              firefox: "31",
              safari: "9",
              node: "0.12",
              ios: "9",
              opera: "21",
              electron: "0.2",
            },
            "es6.number.parse-float": {
              chrome: "34",
              edge: "12",
              firefox: "25",
              safari: "9",
              node: "0.12",
              ios: "9",
              opera: "21",
              electron: "0.2",
            },
            "es6.number.parse-int": {
              chrome: "34",
              edge: "12",
              firefox: "25",
              safari: "9",
              node: "0.12",
              ios: "9",
              opera: "21",
              electron: "0.2",
            },
            "es6.object.assign": {
              chrome: "49",
              edge: "13",
              firefox: "36",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.object.create": {
              chrome: "5",
              opera: "12",
              edge: "12",
              firefox: "4",
              safari: "4",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es7.object.define-getter": {
              chrome: "62",
              edge: "16",
              firefox: "48",
              safari: "9",
              node: "8.10",
              ios: "9",
              opera: "49",
              electron: "3",
            },
            "es7.object.define-setter": {
              chrome: "62",
              edge: "16",
              firefox: "48",
              safari: "9",
              node: "8.10",
              ios: "9",
              opera: "49",
              electron: "3",
            },
            "es6.object.define-property": {
              chrome: "5",
              opera: "12",
              edge: "12",
              firefox: "4",
              safari: "5.1",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.object.define-properties": {
              chrome: "5",
              opera: "12",
              edge: "12",
              firefox: "4",
              safari: "4",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es7.object.entries": {
              chrome: "54",
              edge: "14",
              firefox: "47",
              safari: "10.1",
              node: "7",
              ios: "10.3",
              opera: "41",
              electron: "1.5",
            },
            "es6.object.freeze": {
              chrome: "44",
              edge: "12",
              firefox: "35",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "31",
              electron: "0.31",
            },
            "es6.object.get-own-property-descriptor": {
              chrome: "44",
              edge: "12",
              firefox: "35",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "31",
              electron: "0.31",
            },
            "es7.object.get-own-property-descriptors": {
              chrome: "54",
              edge: "15",
              firefox: "50",
              safari: "10.1",
              node: "7",
              ios: "10.3",
              opera: "41",
              electron: "1.5",
            },
            "es6.object.get-own-property-names": {
              chrome: "40",
              edge: "12",
              firefox: "33",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "27",
              electron: "0.21",
            },
            "es6.object.get-prototype-of": {
              chrome: "44",
              edge: "12",
              firefox: "3.5",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "31",
              electron: "0.31",
            },
            "es7.object.lookup-getter": {
              chrome: "62",
              firefox: "36",
              safari: "9",
              node: "8.10",
              ios: "9",
              opera: "49",
              electron: "3",
            },
            "es7.object.lookup-setter": {
              chrome: "62",
              firefox: "36",
              safari: "9",
              node: "8.10",
              ios: "9",
              opera: "49",
              electron: "3",
            },
            "es6.object.prevent-extensions": {
              chrome: "44",
              edge: "12",
              firefox: "35",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "31",
              electron: "0.31",
            },
            "es6.object.is": {
              chrome: "19",
              edge: "12",
              firefox: "22",
              safari: "9",
              node: "0.12",
              android: "4.1",
              ios: "9",
              electron: "0.2",
            },
            "es6.object.is-frozen": {
              chrome: "44",
              edge: "12",
              firefox: "35",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "31",
              electron: "0.31",
            },
            "es6.object.is-sealed": {
              chrome: "44",
              edge: "12",
              firefox: "35",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "31",
              electron: "0.31",
            },
            "es6.object.is-extensible": {
              chrome: "44",
              edge: "12",
              firefox: "35",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "31",
              electron: "0.31",
            },
            "es6.object.keys": {
              chrome: "40",
              edge: "12",
              firefox: "35",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "27",
              electron: "0.21",
            },
            "es6.object.seal": {
              chrome: "44",
              edge: "12",
              firefox: "35",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "31",
              electron: "0.31",
            },
            "es6.object.set-prototype-of": {
              chrome: "34",
              edge: "12",
              firefox: "31",
              safari: "9",
              node: "0.12",
              ie: "11",
              ios: "9",
              opera: "21",
              electron: "0.2",
            },
            "es7.object.values": {
              chrome: "54",
              edge: "14",
              firefox: "47",
              safari: "10.1",
              node: "7",
              ios: "10.3",
              opera: "41",
              electron: "1.5",
            },
            "es6.promise": {
              chrome: "51",
              edge: "14",
              firefox: "45",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es7.promise.finally": {
              chrome: "63",
              firefox: "58",
              safari: "11.1",
              ios: "11.3",
              opera: "50",
              electron: "3",
            },
            "es6.reflect.apply": {
              chrome: "49",
              edge: "12",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.construct": {
              chrome: "49",
              edge: "13",
              firefox: "44",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.define-property": {
              chrome: "49",
              edge: "13",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.delete-property": {
              chrome: "49",
              edge: "12",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.get": {
              chrome: "49",
              edge: "12",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.get-own-property-descriptor": {
              chrome: "49",
              edge: "12",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.get-prototype-of": {
              chrome: "49",
              edge: "12",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.has": {
              chrome: "49",
              edge: "12",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.is-extensible": {
              chrome: "49",
              edge: "12",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.own-keys": {
              chrome: "49",
              edge: "12",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.prevent-extensions": {
              chrome: "49",
              edge: "12",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.set": {
              chrome: "49",
              edge: "12",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.reflect.set-prototype-of": {
              chrome: "49",
              edge: "12",
              firefox: "42",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "es6.regexp.constructor": {
              chrome: "50",
              firefox: "40",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "37",
              electron: "1.1",
            },
            "es6.regexp.flags": {
              chrome: "49",
              firefox: "37",
              safari: "9",
              node: "6",
              ios: "9",
              opera: "36",
              electron: "1",
            },
            "es6.regexp.match": {
              chrome: "50",
              firefox: "49",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "37",
              electron: "1.1",
            },
            "es6.regexp.replace": {
              chrome: "50",
              firefox: "49",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "37",
              electron: "1.1",
            },
            "es6.regexp.split": {
              chrome: "50",
              firefox: "49",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "37",
              electron: "1.1",
            },
            "es6.regexp.search": {
              chrome: "50",
              firefox: "49",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "37",
              electron: "1.1",
            },
            "es6.regexp.to-string": {
              chrome: "50",
              firefox: "39",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "37",
              electron: "1.1",
            },
            "es6.set": {
              chrome: "51",
              edge: "15",
              firefox: "53",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.symbol": {
              chrome: "51",
              firefox: "51",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es7.symbol.async-iterator": {
              chrome: "63",
              firefox: "57",
              safari: "12",
              opera: "50",
              electron: "3",
            },
            "es6.string.anchor": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.big": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.blink": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.bold": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.code-point-at": {
              chrome: "41",
              edge: "12",
              firefox: "29",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "28",
              electron: "0.24",
            },
            "es6.string.ends-with": {
              chrome: "41",
              edge: "12",
              firefox: "29",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "28",
              electron: "0.24",
            },
            "es6.string.fixed": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.fontcolor": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.fontsize": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.from-code-point": {
              chrome: "41",
              edge: "12",
              firefox: "29",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "28",
              electron: "0.24",
            },
            "es6.string.includes": {
              chrome: "41",
              edge: "12",
              firefox: "40",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "28",
              electron: "0.24",
            },
            "es6.string.italics": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.iterator": {
              chrome: "5",
              opera: "10.10",
              edge: "12",
              firefox: "2",
              safari: "3.1",
              node: "0.10",
              ie: "8",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.string.link": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es7.string.pad-start": {
              chrome: "57",
              edge: "15",
              firefox: "48",
              safari: "10",
              node: "8",
              ios: "10",
              opera: "44",
              electron: "1.7",
            },
            "es7.string.pad-end": {
              chrome: "57",
              edge: "15",
              firefox: "48",
              safari: "10",
              node: "8",
              ios: "10",
              opera: "44",
              electron: "1.7",
            },
            "es6.string.raw": {
              chrome: "41",
              edge: "12",
              firefox: "34",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "28",
              electron: "0.24",
            },
            "es6.string.repeat": {
              chrome: "41",
              edge: "12",
              firefox: "24",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "28",
              electron: "0.24",
            },
            "es6.string.small": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.starts-with": {
              chrome: "41",
              edge: "12",
              firefox: "29",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "28",
              electron: "0.24",
            },
            "es6.string.strike": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.sub": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.sup": {
              chrome: "5",
              edge: "12",
              firefox: "17",
              safari: "6",
              node: "0.12",
              android: "4.0",
              ios: "7",
              electron: "1.1",
            },
            "es6.string.trim": {
              chrome: "5",
              opera: "10.50",
              edge: "12",
              firefox: "3.5",
              safari: "4",
              node: "0.10",
              ie: "9",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.typed.array-buffer": {
              chrome: "51",
              edge: "13",
              firefox: "48",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.typed.data-view": {
              chrome: "5",
              opera: "12",
              edge: "12",
              firefox: "15",
              safari: "5.1",
              node: "0.12",
              ie: "10",
              android: "4.0",
              ios: "6",
              electron: "1.1",
            },
            "es6.typed.int8-array": {
              chrome: "51",
              edge: "13",
              firefox: "48",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.typed.uint8-array": {
              chrome: "51",
              edge: "13",
              firefox: "48",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.typed.uint8-clamped-array": {
              chrome: "51",
              edge: "13",
              firefox: "48",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.typed.int16-array": {
              chrome: "51",
              edge: "13",
              firefox: "48",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.typed.uint16-array": {
              chrome: "51",
              edge: "13",
              firefox: "48",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.typed.int32-array": {
              chrome: "51",
              edge: "13",
              firefox: "48",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.typed.uint32-array": {
              chrome: "51",
              edge: "13",
              firefox: "48",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.typed.float32-array": {
              chrome: "51",
              edge: "13",
              firefox: "48",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.typed.float64-array": {
              chrome: "51",
              edge: "13",
              firefox: "48",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "es6.weak-map": {
              chrome: "51",
              edge: "15",
              firefox: "53",
              safari: "9",
              node: "6.5",
              ios: "9",
              opera: "38",
              electron: "1.2",
            },
            "es6.weak-set": {
              chrome: "51",
              edge: "15",
              firefox: "53",
              safari: "9",
              node: "6.5",
              ios: "9",
              opera: "38",
              electron: "1.2",
            },
            "es7.array.flat-map": {
              chrome: "69",
              firefox: "62",
              safari: "12",
              opera: "56",
            },
          };
        },
        /* 87 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = buildMatchMemberExpression;

          var _matchesPattern = _interopRequireDefault(__webpack_require__(88));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function buildMatchMemberExpression(match, allowPartial) {
            var parts = match.split(".");
            return function(member) {
              return (0, _matchesPattern.default)(member, parts, allowPartial);
            };
          }
        },
        /* 88 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = matchesPattern;

          var _generated = __webpack_require__(2);

          function matchesPattern(member, match, allowPartial) {
            if (!(0, _generated.isMemberExpression)(member)) return false;
            var parts = Array.isArray(match) ? match : match.split(".");
            var nodes = [];
            var node;

            for (
              node = member;
              (0, _generated.isMemberExpression)(node);
              node = node.object
            ) {
              nodes.push(node.property);
            }

            nodes.push(node);
            if (nodes.length < parts.length) return false;
            if (!allowPartial && nodes.length > parts.length) return false;

            for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
              var _node = nodes[j];
              var value = void 0;

              if ((0, _generated.isIdentifier)(_node)) {
                value = _node.name;
              } else if ((0, _generated.isStringLiteral)(_node)) {
                value = _node.value;
              } else {
                return false;
              }

              if (parts[i] !== value) return false;
            }

            return true;
          }
        },
        /* 89 */
        function(module, exports, __webpack_require__) {
          var baseClone = __webpack_require__(90);

          var CLONE_SYMBOLS_FLAG = 4;

          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }

          module.exports = clone;
        },
        /* 90 */
        function(module, exports, __webpack_require__) {
          var Stack = __webpack_require__(52),
            arrayEach = __webpack_require__(210),
            assignValue = __webpack_require__(94),
            baseAssign = __webpack_require__(211),
            baseAssignIn = __webpack_require__(218),
            cloneBuffer = __webpack_require__(221),
            copyArray = __webpack_require__(222),
            copySymbols = __webpack_require__(223),
            copySymbolsIn = __webpack_require__(225),
            getAllKeys = __webpack_require__(102),
            getAllKeysIn = __webpack_require__(226),
            getTag = __webpack_require__(39),
            initCloneArray = __webpack_require__(230),
            initCloneByTag = __webpack_require__(231),
            initCloneObject = __webpack_require__(236),
            isArray = __webpack_require__(5),
            isBuffer = __webpack_require__(56),
            isMap = __webpack_require__(238),
            isObject = __webpack_require__(11),
            isSet = __webpack_require__(240),
            keys = __webpack_require__(19);

          var CLONE_DEEP_FLAG = 1,
            CLONE_FLAT_FLAG = 2,
            CLONE_SYMBOLS_FLAG = 4;
          var argsTag = "[object Arguments]",
            arrayTag = "[object Array]",
            boolTag = "[object Boolean]",
            dateTag = "[object Date]",
            errorTag = "[object Error]",
            funcTag = "[object Function]",
            genTag = "[object GeneratorFunction]",
            mapTag = "[object Map]",
            numberTag = "[object Number]",
            objectTag = "[object Object]",
            regexpTag = "[object RegExp]",
            setTag = "[object Set]",
            stringTag = "[object String]",
            symbolTag = "[object Symbol]",
            weakMapTag = "[object WeakMap]";
          var arrayBufferTag = "[object ArrayBuffer]",
            dataViewTag = "[object DataView]",
            float32Tag = "[object Float32Array]",
            float64Tag = "[object Float64Array]",
            int8Tag = "[object Int8Array]",
            int16Tag = "[object Int16Array]",
            int32Tag = "[object Int32Array]",
            uint8Tag = "[object Uint8Array]",
            uint8ClampedTag = "[object Uint8ClampedArray]",
            uint16Tag = "[object Uint16Array]",
            uint32Tag = "[object Uint32Array]";
          var cloneableTags = {};
          cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[
            arrayBufferTag
          ] = cloneableTags[dataViewTag] = cloneableTags[
            boolTag
          ] = cloneableTags[dateTag] = cloneableTags[
            float32Tag
          ] = cloneableTags[float64Tag] = cloneableTags[
            int8Tag
          ] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[
            mapTag
          ] = cloneableTags[numberTag] = cloneableTags[
            objectTag
          ] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[
            stringTag
          ] = cloneableTags[symbolTag] = cloneableTags[
            uint8Tag
          ] = cloneableTags[uint8ClampedTag] = cloneableTags[
            uint16Tag
          ] = cloneableTags[uint32Tag] = true;
          cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[
            weakMapTag
          ] = false;

          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result,
              isDeep = bitmask & CLONE_DEEP_FLAG,
              isFlat = bitmask & CLONE_FLAT_FLAG,
              isFull = bitmask & CLONE_SYMBOLS_FLAG;

            if (customizer) {
              result = object
                ? customizer(value, key, object, stack)
                : customizer(value);
            }

            if (result !== undefined) {
              return result;
            }

            if (!isObject(value)) {
              return value;
            }

            var isArr = isArray(value);

            if (isArr) {
              result = initCloneArray(value);

              if (!isDeep) {
                return copyArray(value, result);
              }
            } else {
              var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag;

              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }

              if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                result = isFlat || isFunc ? {} : initCloneObject(value);

                if (!isDeep) {
                  return isFlat
                    ? copySymbolsIn(value, baseAssignIn(result, value))
                    : copySymbols(value, baseAssign(result, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }

                result = initCloneByTag(value, tag, isDeep);
              }
            }

            stack || (stack = new Stack());
            var stacked = stack.get(value);

            if (stacked) {
              return stacked;
            }

            stack.set(value, result);

            if (isSet(value)) {
              value.forEach(function(subValue) {
                result.add(
                  baseClone(
                    subValue,
                    bitmask,
                    customizer,
                    subValue,
                    value,
                    stack
                  )
                );
              });
              return result;
            }

            if (isMap(value)) {
              value.forEach(function(subValue, key) {
                result.set(
                  key,
                  baseClone(subValue, bitmask, customizer, key, value, stack)
                );
              });
              return result;
            }

            var keysFunc = isFull
              ? isFlat
                ? getAllKeysIn
                : getAllKeys
              : isFlat
                ? keysIn
                : keys;
            var props = isArr ? undefined : keysFunc(value);
            arrayEach(props || value, function(subValue, key) {
              if (props) {
                key = subValue;
                subValue = value[key];
              }

              assignValue(
                result,
                key,
                baseClone(subValue, bitmask, customizer, key, value, stack)
              );
            });
            return result;
          }

          module.exports = baseClone;
        },
        /* 91 */
        function(module, exports, __webpack_require__) {
          var baseGetTag = __webpack_require__(10),
            isObject = __webpack_require__(11);

          var asyncTag = "[object AsyncFunction]",
            funcTag = "[object Function]",
            genTag = "[object GeneratorFunction]",
            proxyTag = "[object Proxy]";

          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }

            var tag = baseGetTag(value);
            return (
              tag == funcTag ||
              tag == genTag ||
              tag == asyncTag ||
              tag == proxyTag
            );
          }

          module.exports = isFunction;
        },
        /* 92 */
        function(module, exports, __webpack_require__) {
          /* WEBPACK VAR INJECTION */ (function(global) {
            var freeGlobal =
              typeof global == "object" &&
              global &&
              global.Object === Object &&
              global;
            module.exports = freeGlobal;
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(24)));
        },
        /* 93 */
        function(module, exports) {
          var funcProto = Function.prototype;
          var funcToString = funcProto.toString;

          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {}

              try {
                return func + "";
              } catch (e) {}
            }

            return "";
          }

          module.exports = toSource;
        },
        /* 94 */
        function(module, exports, __webpack_require__) {
          var baseAssignValue = __webpack_require__(95),
            eq = __webpack_require__(25);

          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;

          function assignValue(object, key, value) {
            var objValue = object[key];

            if (
              !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined && !(key in object))
            ) {
              baseAssignValue(object, key, value);
            }
          }

          module.exports = assignValue;
        },
        /* 95 */
        function(module, exports, __webpack_require__) {
          var defineProperty = __webpack_require__(96);

          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                configurable: true,
                enumerable: true,
                value: value,
                writable: true,
              });
            } else {
              object[key] = value;
            }
          }

          module.exports = baseAssignValue;
        },
        /* 96 */
        function(module, exports, __webpack_require__) {
          var getNative = __webpack_require__(13);

          var defineProperty = (function() {
            try {
              var func = getNative(Object, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {}
          })();

          module.exports = defineProperty;
        },
        /* 97 */
        function(module, exports, __webpack_require__) {
          var baseTimes = __webpack_require__(212),
            isArguments = __webpack_require__(55),
            isArray = __webpack_require__(5),
            isBuffer = __webpack_require__(56),
            isIndex = __webpack_require__(57),
            isTypedArray = __webpack_require__(98);

          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;

          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length;

            for (var key in value) {
              if (
                (inherited || hasOwnProperty.call(value, key)) &&
                !(
                  skipIndexes &&
                  (key == "length" ||
                    (isBuff && (key == "offset" || key == "parent")) ||
                    (isType &&
                      (key == "buffer" ||
                        key == "byteLength" ||
                        key == "byteOffset")) ||
                    isIndex(key, length))
                )
              ) {
                result.push(key);
              }
            }

            return result;
          }

          module.exports = arrayLikeKeys;
        },
        /* 98 */
        function(module, exports, __webpack_require__) {
          var baseIsTypedArray = __webpack_require__(215),
            baseUnary = __webpack_require__(26),
            nodeUtil = __webpack_require__(38);

          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
          var isTypedArray = nodeIsTypedArray
            ? baseUnary(nodeIsTypedArray)
            : baseIsTypedArray;
          module.exports = isTypedArray;
        },
        /* 99 */
        function(module, exports) {
          function overArg(func, transform) {
            return function(arg) {
              return func(transform(arg));
            };
          }

          module.exports = overArg;
        },
        /* 100 */
        function(module, exports) {
          function stubArray() {
            return [];
          }

          module.exports = stubArray;
        },
        /* 101 */
        function(module, exports, __webpack_require__) {
          var arrayPush = __webpack_require__(62),
            getPrototype = __webpack_require__(63),
            getSymbols = __webpack_require__(61),
            stubArray = __webpack_require__(100);

          var nativeGetSymbols = Object.getOwnPropertySymbols;
          var getSymbolsIn = !nativeGetSymbols
            ? stubArray
            : function(object) {
                var result = [];

                while (object) {
                  arrayPush(result, getSymbols(object));
                  object = getPrototype(object);
                }

                return result;
              };
          module.exports = getSymbolsIn;
        },
        /* 102 */
        function(module, exports, __webpack_require__) {
          var baseGetAllKeys = __webpack_require__(103),
            getSymbols = __webpack_require__(61),
            keys = __webpack_require__(19);

          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }

          module.exports = getAllKeys;
        },
        /* 103 */
        function(module, exports, __webpack_require__) {
          var arrayPush = __webpack_require__(62),
            isArray = __webpack_require__(5);

          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object)
              ? result
              : arrayPush(result, symbolsFunc(object));
          }

          module.exports = baseGetAllKeys;
        },
        /* 104 */
        function(module, exports, __webpack_require__) {
          var getNative = __webpack_require__(13),
            root = __webpack_require__(6);

          var Set = getNative(root, "Set");
          module.exports = Set;
        },
        /* 105 */
        function(module, exports, __webpack_require__) {
          var root = __webpack_require__(6);

          var Uint8Array = root.Uint8Array;
          module.exports = Uint8Array;
        },
        /* 106 */
        function(module, exports, __webpack_require__) {
          (function() {
            "use strict";

            exports.ast = __webpack_require__(243);
            exports.code = __webpack_require__(107);
            exports.keyword = __webpack_require__(244);
          })();
        },
        /* 107 */
        function(module, exports) {
          (function() {
            "use strict";

            var ES6Regex,
              ES5Regex,
              NON_ASCII_WHITESPACES,
              IDENTIFIER_START,
              IDENTIFIER_PART,
              ch;
            ES5Regex = {
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
              NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
            };
            ES6Regex = {
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
              NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
            };

            function isDecimalDigit(ch) {
              return 0x30 <= ch && ch <= 0x39;
            }

            function isHexDigit(ch) {
              return (
                (0x30 <= ch && ch <= 0x39) ||
                (0x61 <= ch && ch <= 0x66) ||
                (0x41 <= ch && ch <= 0x46)
              );
            }

            function isOctalDigit(ch) {
              return ch >= 0x30 && ch <= 0x37;
            }

            NON_ASCII_WHITESPACES = [
              0x1680,
              0x180e,
              0x2000,
              0x2001,
              0x2002,
              0x2003,
              0x2004,
              0x2005,
              0x2006,
              0x2007,
              0x2008,
              0x2009,
              0x200a,
              0x202f,
              0x205f,
              0x3000,
              0xfeff,
            ];

            function isWhiteSpace(ch) {
              return (
                ch === 0x20 ||
                ch === 0x09 ||
                ch === 0x0b ||
                ch === 0x0c ||
                ch === 0xa0 ||
                (ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0)
              );
            }

            function isLineTerminator(ch) {
              return (
                ch === 0x0a || ch === 0x0d || ch === 0x2028 || ch === 0x2029
              );
            }

            function fromCodePoint(cp) {
              if (cp <= 0xffff) {
                return String.fromCharCode(cp);
              }

              var cu1 = String.fromCharCode(
                Math.floor((cp - 0x10000) / 0x400) + 0xd800
              );
              var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xdc00);
              return cu1 + cu2;
            }

            IDENTIFIER_START = new Array(0x80);

            for (ch = 0; ch < 0x80; ++ch) {
              IDENTIFIER_START[ch] =
                (ch >= 0x61 && ch <= 0x7a) ||
                (ch >= 0x41 && ch <= 0x5a) ||
                ch === 0x24 ||
                ch === 0x5f;
            }

            IDENTIFIER_PART = new Array(0x80);

            for (ch = 0; ch < 0x80; ++ch) {
              IDENTIFIER_PART[ch] =
                (ch >= 0x61 && ch <= 0x7a) ||
                (ch >= 0x41 && ch <= 0x5a) ||
                (ch >= 0x30 && ch <= 0x39) ||
                ch === 0x24 ||
                ch === 0x5f;
            }

            function isIdentifierStartES5(ch) {
              return ch < 0x80
                ? IDENTIFIER_START[ch]
                : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
            }

            function isIdentifierPartES5(ch) {
              return ch < 0x80
                ? IDENTIFIER_PART[ch]
                : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
            }

            function isIdentifierStartES6(ch) {
              return ch < 0x80
                ? IDENTIFIER_START[ch]
                : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
            }

            function isIdentifierPartES6(ch) {
              return ch < 0x80
                ? IDENTIFIER_PART[ch]
                : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
            }

            module.exports = {
              isDecimalDigit: isDecimalDigit,
              isHexDigit: isHexDigit,
              isOctalDigit: isOctalDigit,
              isWhiteSpace: isWhiteSpace,
              isLineTerminator: isLineTerminator,
              isIdentifierStartES5: isIdentifierStartES5,
              isIdentifierPartES5: isIdentifierPartES5,
              isIdentifierStartES6: isIdentifierStartES6,
              isIdentifierPartES6: isIdentifierPartES6,
            };
          })();
        },
        /* 108 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = validate;

          var _definitions = __webpack_require__(8);

          function validate(node, key, val) {
            if (!node) return;
            var fields = _definitions.NODE_FIELDS[node.type];
            if (!fields) return;
            var field = fields[key];
            if (!field || !field.validate) return;
            if (field.optional && val == null) return;
            field.validate(node, key, val);
          }
        },
        /* 109 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isNode;

          var _definitions = __webpack_require__(8);

          function isNode(node) {
            return !!(node && _definitions.VISITOR_KEYS[node.type]);
          }
        },
        /* 110 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = removeTypeDuplicates;

          var _generated = __webpack_require__(2);

          function removeTypeDuplicates(nodes) {
            var generics = {};
            var bases = {};
            var typeGroups = [];
            var types = [];

            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              if (!node) continue;

              if (types.indexOf(node) >= 0) {
                continue;
              }

              if ((0, _generated.isAnyTypeAnnotation)(node)) {
                return [node];
              }

              if ((0, _generated.isFlowBaseAnnotation)(node)) {
                bases[node.type] = node;
                continue;
              }

              if ((0, _generated.isUnionTypeAnnotation)(node)) {
                if (typeGroups.indexOf(node.types) < 0) {
                  nodes = nodes.concat(node.types);
                  typeGroups.push(node.types);
                }

                continue;
              }

              if ((0, _generated.isGenericTypeAnnotation)(node)) {
                var name = node.id.name;

                if (generics[name]) {
                  var existing = generics[name];

                  if (existing.typeParameters) {
                    if (node.typeParameters) {
                      existing.typeParameters.params = removeTypeDuplicates(
                        existing.typeParameters.params.concat(
                          node.typeParameters.params
                        )
                      );
                    }
                  } else {
                    existing = node.typeParameters;
                  }
                } else {
                  generics[name] = node;
                }

                continue;
              }

              types.push(node);
            }

            for (var type in bases) {
              types.push(bases[type]);
            }

            for (var _name in generics) {
              types.push(generics[_name]);
            }

            return types;
          }
        },
        /* 111 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = clone;

          var _cloneNode = _interopRequireDefault(__webpack_require__(28));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function clone(node) {
            return (0, _cloneNode.default)(node, false);
          }
        },
        /* 112 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = addComments;

          function addComments(node, type, comments) {
            if (!comments || !node) return node;
            var key = type + "Comments";

            if (node[key]) {
              if (type === "leading") {
                node[key] = comments.concat(node[key]);
              } else {
                node[key] = node[key].concat(comments);
              }
            } else {
              node[key] = comments;
            }

            return node;
          }
        },
        /* 113 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = inheritInnerComments;

          var _inherit = _interopRequireDefault(__webpack_require__(69));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function inheritInnerComments(child, parent) {
            (0, _inherit.default)("innerComments", child, parent);
          }
        },
        /* 114 */
        function(module, exports, __webpack_require__) {
          var MapCache = __webpack_require__(54),
            setCacheAdd = __webpack_require__(259),
            setCacheHas = __webpack_require__(260);

          function SetCache(values) {
            var index = -1,
              length = values == null ? 0 : values.length;
            this.__data__ = new MapCache();

            while (++index < length) {
              this.add(values[index]);
            }
          }

          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          module.exports = SetCache;
        },
        /* 115 */
        function(module, exports, __webpack_require__) {
          var baseFindIndex = __webpack_require__(262),
            baseIsNaN = __webpack_require__(263),
            strictIndexOf = __webpack_require__(264);

          function baseIndexOf(array, value, fromIndex) {
            return value === value
              ? strictIndexOf(array, value, fromIndex)
              : baseFindIndex(array, baseIsNaN, fromIndex);
          }

          module.exports = baseIndexOf;
        },
        /* 116 */
        function(module, exports) {
          function cacheHas(cache, key) {
            return cache.has(key);
          }

          module.exports = cacheHas;
        },
        /* 117 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = inheritLeadingComments;

          var _inherit = _interopRequireDefault(__webpack_require__(69));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function inheritLeadingComments(child, parent) {
            (0, _inherit.default)("leadingComments", child, parent);
          }
        },
        /* 118 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = inheritsComments;

          var _inheritTrailingComments = _interopRequireDefault(
            __webpack_require__(119)
          );

          var _inheritLeadingComments = _interopRequireDefault(
            __webpack_require__(117)
          );

          var _inheritInnerComments = _interopRequireDefault(
            __webpack_require__(113)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function inheritsComments(child, parent) {
            (0, _inheritTrailingComments.default)(child, parent);
            (0, _inheritLeadingComments.default)(child, parent);
            (0, _inheritInnerComments.default)(child, parent);
            return child;
          }
        },
        /* 119 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = inheritTrailingComments;

          var _inherit = _interopRequireDefault(__webpack_require__(69));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function inheritTrailingComments(child, parent) {
            (0, _inherit.default)("trailingComments", child, parent);
          }
        },
        /* 120 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = toBlock;

          var _generated = __webpack_require__(2);

          var _generated2 = __webpack_require__(4);

          function toBlock(node, parent) {
            if ((0, _generated.isBlockStatement)(node)) {
              return node;
            }

            var blockNodes = [];

            if ((0, _generated.isEmptyStatement)(node)) {
              blockNodes = [];
            } else {
              if (!(0, _generated.isStatement)(node)) {
                if ((0, _generated.isFunction)(parent)) {
                  node = (0, _generated2.returnStatement)(node);
                } else {
                  node = (0, _generated2.expressionStatement)(node);
                }
              }

              blockNodes = [node];
            }

            return (0, _generated2.blockStatement)(blockNodes);
          }
        },
        /* 121 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = toIdentifier;

          var _isValidIdentifier = _interopRequireDefault(
            __webpack_require__(27)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function toIdentifier(name) {
            name = name + "";
            name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
            name = name.replace(/^[-0-9]+/, "");
            name = name.replace(/[-\s]+(.)?/g, function(match, c) {
              return c ? c.toUpperCase() : "";
            });

            if (!(0, _isValidIdentifier.default)(name)) {
              name = "_" + name;
            }

            return name || "_";
          }
        },
        /* 122 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = removePropertiesDeep;

          var _traverseFast = _interopRequireDefault(__webpack_require__(123));

          var _removeProperties = _interopRequireDefault(
            __webpack_require__(124)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function removePropertiesDeep(tree, opts) {
            (0, _traverseFast.default)(tree, _removeProperties.default, opts);
            return tree;
          }
        },
        /* 123 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = traverseFast;

          var _definitions = __webpack_require__(8);

          function traverseFast(node, enter, opts) {
            if (!node) return;
            var keys = _definitions.VISITOR_KEYS[node.type];
            if (!keys) return;
            opts = opts || {};
            enter(node, opts);

            for (
              var _iterator = keys,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var key = _ref;
              var subNode = node[key];

              if (Array.isArray(subNode)) {
                for (
                  var _iterator2 = subNode,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : _iterator2[Symbol.iterator]();
                  ;

                ) {
                  var _ref2;

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                  } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                  }

                  var _node = _ref2;
                  traverseFast(_node, enter, opts);
                }
              } else {
                traverseFast(subNode, enter, opts);
              }
            }
          }
        },
        /* 124 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = removeProperties;

          var _constants = __webpack_require__(14);

          var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

          var CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat([
            "comments",
          ]).concat(CLEAR_KEYS);

          function removeProperties(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            var map = opts.preserveComments
              ? CLEAR_KEYS
              : CLEAR_KEYS_PLUS_COMMENTS;

            for (
              var _iterator = map,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var _key = _ref;
              if (node[_key] != null) node[_key] = undefined;
            }

            for (var key in node) {
              if (key[0] === "_" && node[key] != null) node[key] = undefined;
            }

            var symbols = Object.getOwnPropertySymbols(node);

            for (
              var _iterator2 = symbols,
                _isArray2 = Array.isArray(_iterator2),
                _i2 = 0,
                _iterator2 = _isArray2
                  ? _iterator2
                  : _iterator2[Symbol.iterator]();
              ;

            ) {
              var _ref2;

              if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
              } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
              }

              var sym = _ref2;
              node[sym] = null;
            }
          }
        },
        /* 125 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isLet;

          var _generated = __webpack_require__(2);

          var _constants = __webpack_require__(14);

          function isLet(node) {
            return (
              (0, _generated.isVariableDeclaration)(node) &&
              (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL])
            );
          }
        },
        /* 126 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isModule;

          function isModule(path) {
            var sourceType = path.node.sourceType;

            if (sourceType !== "module" && sourceType !== "script") {
              throw path.buildCodeFrameError(
                'Unknown sourceType "' + sourceType + '", cannot transform.'
              );
            }

            return path.node.sourceType === "module";
          }
        },
        /* 127 */
        function(module, exports, __webpack_require__) {
          var jsReleases = __webpack_require__(298);

          var agents = __webpack_require__(299).agents;

          var jsEOL = __webpack_require__(305);

          var path = __webpack_require__(306);

          var e2c = __webpack_require__(307);

          var BrowserslistError = __webpack_require__(128);

          var env = __webpack_require__(308);

          var FLOAT_RANGE = /^\d+(\.\d+)?(-\d+(\.\d+)?)*$/;

          function normalize(versions) {
            return versions.filter(function(version) {
              return typeof version === "string";
            });
          }

          function nameMapper(name) {
            return function mapName(version) {
              return name + " " + version;
            };
          }

          function getMajor(version) {
            return parseInt(version.split(".")[0]);
          }

          function getMajorVersions(released, number) {
            if (released.length === 0) return [];
            var minimum =
              getMajor(released[released.length - 1]) - parseInt(number) + 1;
            var selected = [];

            for (var i = released.length - 1; i >= 0; i--) {
              if (minimum > getMajor(released[i])) break;
              selected.unshift(released[i]);
            }

            return selected;
          }

          function uniq(array) {
            var filtered = [];

            for (var i = 0; i < array.length; i++) {
              if (filtered.indexOf(array[i]) === -1) filtered.push(array[i]);
            }

            return filtered;
          }

          function fillUsage(result, name, data) {
            for (var i in data) {
              result[name + " " + i] = data[i];
            }
          }

          function generateFilter(sign, version) {
            version = parseFloat(version);

            if (sign === ">") {
              return function(v) {
                return parseFloat(v) > version;
              };
            } else if (sign === ">=") {
              return function(v) {
                return parseFloat(v) >= version;
              };
            } else if (sign === "<") {
              return function(v) {
                return parseFloat(v) < version;
              };
            } else {
              return function(v) {
                return parseFloat(v) <= version;
              };
            }
          }

          function compareStrings(a, b) {
            if (a < b) return -1;
            if (a > b) return +1;
            return 0;
          }

          function normalizeVersion(data, version) {
            if (data.versions.indexOf(version) !== -1) {
              return version;
            } else if (browserslist.versionAliases[data.name][version]) {
              return browserslist.versionAliases[data.name][version];
            } else if (data.versions.length === 1) {
              return data.versions[0];
            } else {
              return false;
            }
          }

          function filterByYear(since) {
            return Object.keys(agents).reduce(function(selected, name) {
              var data = byName(name);
              if (!data) return selected;
              var versions = Object.keys(data.releaseDate).filter(function(v) {
                return data.releaseDate[v] >= since;
              });
              return selected.concat(versions.map(nameMapper(data.name)));
            }, []);
          }

          function byName(name) {
            name = name.toLowerCase();
            name = browserslist.aliases[name] || name;
            return browserslist.data[name];
          }

          function checkName(name) {
            var data = byName(name);
            if (!data) throw new BrowserslistError("Unknown browser " + name);
            return data;
          }

          function unknownQuery(query) {
            return new BrowserslistError(
              "Unknown browser query `" + query + "`"
            );
          }

          function resolve(queries, context) {
            return queries.reduce(function(result, selection, index) {
              selection = selection.trim();
              if (selection === "") return result;
              var isExclude = selection.indexOf("not ") === 0;

              if (isExclude) {
                if (index === 0) {
                  throw new BrowserslistError(
                    "Write any browsers query (for instance, `defaults`) " +
                      "before `" +
                      selection +
                      "`"
                  );
                }

                selection = selection.slice(4);
              }

              for (var i = 0; i < QUERIES.length; i++) {
                var type = QUERIES[i];
                var match = selection.match(type.regexp);

                if (match) {
                  var args = [context].concat(match.slice(1));
                  var array = type.select.apply(browserslist, args);

                  if (isExclude) {
                    array = array.concat(
                      array.map(function(j) {
                        return j.replace(/\s\S+/, " 0");
                      })
                    );
                    return result.filter(function(j) {
                      return array.indexOf(j) === -1;
                    });
                  }

                  return result.concat(array);
                }
              }

              throw unknownQuery(selection);
            }, []);
          }

          function browserslist(queries, opts) {
            if (typeof opts === "undefined") opts = {};

            if (typeof opts.path === "undefined") {
              opts.path = path.resolve ? path.resolve(".") : ".";
            }

            if (typeof queries === "undefined" || queries === null) {
              var config = browserslist.loadConfig(opts);

              if (config) {
                queries = config;
              } else {
                queries = browserslist.defaults;
              }
            }

            if (typeof queries === "string") {
              queries = queries.split(/,\s*/);
            }

            if (!Array.isArray(queries)) {
              throw new BrowserslistError(
                "Browser queries must be an array. Got " + typeof queries + "."
              );
            }

            var context = {
              ignoreUnknownVersions: opts.ignoreUnknownVersions,
              dangerousExtend: opts.dangerousExtend,
            };
            env.oldDataWarning(browserslist.data);
            var stats = env.getStat(opts);

            if (stats) {
              context.customUsage = {};

              for (var browser in stats) {
                fillUsage(context.customUsage, browser, stats[browser]);
              }
            }

            var result = resolve(queries, context)
              .map(function(i) {
                var parts = i.split(" ");
                var name = parts[0];
                var version = parts[1];

                if (version === "0") {
                  return name + " " + byName(name).versions[0];
                } else {
                  return i;
                }
              })
              .sort(function(name1, name2) {
                name1 = name1.split(" ");
                name2 = name2.split(" ");

                if (name1[0] === name2[0]) {
                  if (
                    FLOAT_RANGE.test(name1[1]) &&
                    FLOAT_RANGE.test(name2[1])
                  ) {
                    return parseFloat(name2[1]) - parseFloat(name1[1]);
                  } else {
                    return compareStrings(name2[1], name1[1]);
                  }
                } else {
                  return compareStrings(name1[0], name2[0]);
                }
              });
            return uniq(result);
          }

          browserslist.data = {};
          browserslist.usage = {
            global: {},
            custom: null,
          };
          browserslist.defaults = [
            "> 0.5%",
            "last 2 versions",
            "Firefox ESR",
            "not dead",
          ];
          browserslist.aliases = {
            fx: "firefox",
            ff: "firefox",
            ios: "ios_saf",
            explorer: "ie",
            blackberry: "bb",
            explorermobile: "ie_mob",
            operamini: "op_mini",
            operamobile: "op_mob",
            chromeandroid: "and_chr",
            firefoxandroid: "and_ff",
            ucandroid: "and_uc",
            qqandroid: "and_qq",
          };
          browserslist.versionAliases = {};
          browserslist.clearCaches = env.clearCaches;
          browserslist.parseConfig = env.parseConfig;
          browserslist.readConfig = env.readConfig;
          browserslist.findConfig = env.findConfig;
          browserslist.loadConfig = env.loadConfig;

          browserslist.coverage = function(browsers, stats) {
            var data;

            if (typeof stats === "undefined") {
              data = browserslist.usage.global;
            } else if (stats === "my stats") {
              var opts = {};
              opts.path = path.resolve ? path.resolve(".") : ".";
              var customStats = env.getStat(opts);

              if (!customStats) {
                throw new BrowserslistError(
                  "Custom usage statistics was not provided"
                );
              }

              data = {};

              for (var browser in customStats) {
                fillUsage(data, browser, customStats[browser]);
              }
            } else if (typeof stats === "string") {
              if (stats.length > 2) {
                stats = stats.toLowerCase();
              } else {
                stats = stats.toUpperCase();
              }

              env.loadCountry(browserslist.usage, stats);
              data = browserslist.usage[stats];
            } else {
              if ("dataByBrowser" in stats) {
                stats = stats.dataByBrowser;
              }

              data = {};

              for (var name in stats) {
                for (var version in stats[name]) {
                  data[name + " " + version] = stats[name][version];
                }
              }
            }

            return browsers.reduce(function(all, i) {
              var usage = data[i];

              if (usage === undefined) {
                usage = data[i.replace(/ \S+$/, " 0")];
              }

              return all + (usage || 0);
            }, 0);
          };

          var QUERIES = [
            {
              regexp: /^last\s+(\d+)\s+major versions?$/i,
              select: function select(context, versions) {
                return Object.keys(agents).reduce(function(selected, name) {
                  var data = byName(name);
                  if (!data) return selected;
                  var array = getMajorVersions(data.released, versions);
                  array = array.map(nameMapper(data.name));
                  return selected.concat(array);
                }, []);
              },
            },
            {
              regexp: /^last\s+(\d+)\s+versions?$/i,
              select: function select(context, versions) {
                return Object.keys(agents).reduce(function(selected, name) {
                  var data = byName(name);
                  if (!data) return selected;
                  var array = data.released.slice(-versions);
                  array = array.map(nameMapper(data.name));
                  return selected.concat(array);
                }, []);
              },
            },
            {
              regexp: /^last\s+(\d+)\s+electron\s+major versions?$/i,
              select: function select(context, versions) {
                var validVersions = getMajorVersions(
                  Object.keys(e2c).reverse(),
                  versions
                );
                return validVersions.map(function(i) {
                  return "chrome " + e2c[i];
                });
              },
            },
            {
              regexp: /^last\s+(\d+)\s+(\w+)\s+major versions?$/i,
              select: function select(context, versions, name) {
                var data = checkName(name);
                var validVersions = getMajorVersions(data.released, versions);
                return validVersions.map(nameMapper(data.name));
              },
            },
            {
              regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
              select: function select(context, versions) {
                return Object.keys(e2c)
                  .reverse()
                  .slice(-versions)
                  .map(function(i) {
                    return "chrome " + e2c[i];
                  });
              },
            },
            {
              regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
              select: function select(context, versions, name) {
                var data = checkName(name);
                return data.released
                  .slice(-versions)
                  .map(nameMapper(data.name));
              },
            },
            {
              regexp: /^unreleased\s+versions$/i,
              select: function select() {
                return Object.keys(agents).reduce(function(selected, name) {
                  var data = byName(name);
                  if (!data) return selected;
                  var array = data.versions.filter(function(v) {
                    return data.released.indexOf(v) === -1;
                  });
                  array = array.map(nameMapper(data.name));
                  return selected.concat(array);
                }, []);
              },
            },
            {
              regexp: /^unreleased\s+electron\s+versions?$/i,
              select: function select() {
                return [];
              },
            },
            {
              regexp: /^unreleased\s+(\w+)\s+versions?$/i,
              select: function select(context, name) {
                var data = checkName(name);
                return data.versions
                  .filter(function(v) {
                    return data.released.indexOf(v) === -1;
                  })
                  .map(nameMapper(data.name));
              },
            },
            {
              regexp: /^last\s+(\d+)\s+years?$/i,
              select: function select(context, years) {
                var date = new Date();
                var since = date.setFullYear(date.getFullYear() - years) / 1000;
                return filterByYear(since);
              },
            },
            {
              regexp: /^since (\d+)(?:-(\d+))?(?:-(\d+))?$/i,
              select: function select(context, year, month, date) {
                year = parseInt(year);
                month = parseInt(month || "01") - 1;
                date = parseInt(date || "01");
                var since = Date.UTC(year, month, date, 0, 0, 0) / 1000;
                return filterByYear(since);
              },
            },
            {
              regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%$/,
              select: function select(context, sign, popularity) {
                popularity = parseFloat(popularity);
                var usage = browserslist.usage.global;
                return Object.keys(usage).reduce(function(result, version) {
                  if (sign === ">") {
                    if (usage[version] > popularity) {
                      result.push(version);
                    }
                  } else if (sign === "<") {
                    if (usage[version] < popularity) {
                      result.push(version);
                    }
                  } else if (sign === "<=") {
                    if (usage[version] <= popularity) {
                      result.push(version);
                    }
                  } else if (usage[version] >= popularity) {
                    result.push(version);
                  }

                  return result;
                }, []);
              },
            },
            {
              regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+my\s+stats$/,
              select: function select(context, sign, popularity) {
                popularity = parseFloat(popularity);

                if (!context.customUsage) {
                  throw new BrowserslistError(
                    "Custom usage statistics was not provided"
                  );
                }

                var usage = context.customUsage;
                return Object.keys(usage).reduce(function(result, version) {
                  if (sign === ">") {
                    if (usage[version] > popularity) {
                      result.push(version);
                    }
                  } else if (sign === "<") {
                    if (usage[version] < popularity) {
                      result.push(version);
                    }
                  } else if (sign === "<=") {
                    if (usage[version] <= popularity) {
                      result.push(version);
                    }
                  } else if (usage[version] >= popularity) {
                    result.push(version);
                  }

                  return result;
                }, []);
              },
            },
            {
              regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+((alt-)?\w\w)$/,
              select: function select(context, sign, popularity, place) {
                popularity = parseFloat(popularity);

                if (place.length === 2) {
                  place = place.toUpperCase();
                } else {
                  place = place.toLowerCase();
                }

                env.loadCountry(browserslist.usage, place);
                var usage = browserslist.usage[place];
                return Object.keys(usage).reduce(function(result, version) {
                  if (sign === ">") {
                    if (usage[version] > popularity) {
                      result.push(version);
                    }
                  } else if (sign === "<") {
                    if (usage[version] < popularity) {
                      result.push(version);
                    }
                  } else if (sign === "<=") {
                    if (usage[version] <= popularity) {
                      result.push(version);
                    }
                  } else if (usage[version] >= popularity) {
                    result.push(version);
                  }

                  return result;
                }, []);
              },
            },
            {
              regexp: /^cover\s+(\d*\.?\d+)%(\s+in\s+(my\s+stats|(alt-)?\w\w))?$/,
              select: function select(context, coverage, statMode) {
                coverage = parseFloat(coverage);
                var usage = browserslist.usage.global;

                if (statMode) {
                  if (statMode.match(/^\s+in\s+my\s+stats$/)) {
                    if (!context.customUsage) {
                      throw new BrowserslistError(
                        "Custom usage statistics was not provided"
                      );
                    }

                    usage = context.customUsage;
                  } else {
                    var match = statMode.match(/\s+in\s+((alt-)?\w\w)/);
                    var place = match[1];

                    if (place.length === 2) {
                      place = place.toUpperCase();
                    } else {
                      place = place.toLowerCase();
                    }

                    env.loadCountry(browserslist.usage, place);
                    usage = browserslist.usage[place];
                  }
                }

                var versions = Object.keys(usage).sort(function(a, b) {
                  return usage[b] - usage[a];
                });
                var coveraged = 0;
                var result = [];
                var version;

                for (var i = 0; i <= versions.length; i++) {
                  version = versions[i];
                  if (usage[version] === 0) break;
                  coveraged += usage[version];
                  result.push(version);
                  if (coveraged >= coverage) break;
                }

                return result;
              },
            },
            {
              regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
              select: function select(context, from, to) {
                if (!e2c[from]) {
                  throw new BrowserslistError(
                    "Unknown version " + from + " of electron"
                  );
                }

                if (!e2c[to]) {
                  throw new BrowserslistError(
                    "Unknown version " + to + " of electron"
                  );
                }

                from = parseFloat(from);
                to = parseFloat(to);
                return Object.keys(e2c)
                  .filter(function(i) {
                    var parsed = parseFloat(i);
                    return parsed >= from && parsed <= to;
                  })
                  .map(function(i) {
                    return "chrome " + e2c[i];
                  });
              },
            },
            {
              regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
              select: function select(context, name, from, to) {
                var data = checkName(name);
                from = parseFloat(normalizeVersion(data, from) || from);
                to = parseFloat(normalizeVersion(data, to) || to);

                function filter(v) {
                  var parsed = parseFloat(v);
                  return parsed >= from && parsed <= to;
                }

                return data.released.filter(filter).map(nameMapper(data.name));
              },
            },
            {
              regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
              select: function select(context, sign, version) {
                return Object.keys(e2c)
                  .filter(generateFilter(sign, version))
                  .map(function(i) {
                    return "chrome " + e2c[i];
                  });
              },
            },
            {
              regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
              select: function select(context, name, sign, version) {
                var data = checkName(name);
                var alias = browserslist.versionAliases[data.name][version];

                if (alias) {
                  version = alias;
                }

                return data.released
                  .filter(generateFilter(sign, version))
                  .map(function(v) {
                    return data.name + " " + v;
                  });
              },
            },
            {
              regexp: /^(firefox|ff|fx)\s+esr$/i,
              select: function select() {
                return ["firefox 52", "firefox 60"];
              },
            },
            {
              regexp: /(operamini|op_mini)\s+all/i,
              select: function select() {
                return ["op_mini all"];
              },
            },
            {
              regexp: /^electron\s+([\d.]+)$/i,
              select: function select(context, version) {
                var chrome = e2c[version];

                if (!chrome) {
                  throw new BrowserslistError(
                    "Unknown version " + version + " of electron"
                  );
                }

                return ["chrome " + chrome];
              },
            },
            {
              regexp: /^node\s+(\d+(\.\d+)?(\.\d+)?)$/i,
              select: function select(context, version) {
                var nodeReleases = jsReleases.filter(function(i) {
                  return i.name === "nodejs";
                });
                var matched = nodeReleases.filter(function(i) {
                  return (i.version + ".").indexOf(version + ".") === 0;
                });

                if (matched.length === 0) {
                  if (context.ignoreUnknownVersions) {
                    return [];
                  } else {
                    throw new BrowserslistError(
                      "Unknown version " + version + " of Node.js"
                    );
                  }
                }

                return ["node " + matched[matched.length - 1].version];
              },
            },
            {
              regexp: /^current\s+node$/i,
              select: function select(context) {
                return [env.currentNode(resolve, context)];
              },
            },
            {
              regexp: /^maintained\s+node\s+versions$/i,
              select: function select(context) {
                var now = Date.now();
                var queries = Object.keys(jsEOL)
                  .filter(function(key) {
                    return (
                      now < Date.parse(jsEOL[key].end) &&
                      now > Date.parse(jsEOL[key].start)
                    );
                  })
                  .map(function(key) {
                    return "node " + key.slice(1);
                  });
                return resolve(queries, context);
              },
            },
            {
              regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
              select: function select(context, name, version) {
                if (/^tp$/i.test(version)) version = "TP";
                var data = checkName(name);
                var alias = normalizeVersion(data, version);

                if (alias) {
                  version = alias;
                } else {
                  if (version.indexOf(".") === -1) {
                    alias = version + ".0";
                  } else {
                    alias = version.replace(/\.0$/, "");
                  }

                  alias = normalizeVersion(data, alias);

                  if (alias) {
                    version = alias;
                  } else if (context.ignoreUnknownVersions) {
                    return [];
                  } else {
                    throw new BrowserslistError(
                      "Unknown version " + version + " of " + name
                    );
                  }
                }

                return [data.name + " " + version];
              },
            },
            {
              regexp: /^extends (.+)$/i,
              select: function select(context, name) {
                return resolve(env.loadQueries(context, name), context);
              },
            },
            {
              regexp: /^defaults$/i,
              select: function select() {
                return browserslist(browserslist.defaults);
              },
            },
            {
              regexp: /^dead$/i,
              select: function select(context) {
                var dead = [
                  "ie <= 10",
                  "ie_mob <= 10",
                  "bb <= 10",
                  "op_mob <= 12.1",
                ];
                return resolve(dead, context);
              },
            },
            {
              regexp: /^(\w+)$/i,
              select: function select(context, name) {
                if (byName(name)) {
                  throw new BrowserslistError(
                    "Specify versions in Browserslist query for browser " + name
                  );
                } else {
                  throw unknownQuery(name);
                }
              },
            },
          ];

          (function() {
            for (var name in agents) {
              var browser = agents[name];
              browserslist.data[name] = {
                name: name,
                versions: normalize(agents[name].versions),
                released: normalize(agents[name].versions.slice(0, -3)),
                releaseDate: agents[name].release_date,
              };
              fillUsage(browserslist.usage.global, name, browser.usage_global);
              browserslist.versionAliases[name] = {};

              for (var i = 0; i < browser.versions.length; i++) {
                var full = browser.versions[i];
                if (!full) continue;

                if (full.indexOf("-") !== -1) {
                  var interval = full.split("-");

                  for (var j = 0; j < interval.length; j++) {
                    browserslist.versionAliases[name][interval[j]] = full;
                  }
                }
              }
            }
          })();

          module.exports = browserslist;
        },
        /* 128 */
        function(module, exports) {
          function BrowserslistError(message) {
            this.name = "BrowserslistError";
            this.message = message;
            this.browserslist = true;

            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, BrowserslistError);
            }
          }

          BrowserslistError.prototype = Error.prototype;
          module.exports = BrowserslistError;
        },
        /* 129 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(process) {
            Object.defineProperty(exports, "__esModule", {
              value: true,
            });
            exports.default = normalizeOptions;
            exports.validateUseBuiltInsOption = exports.objectToBrowserslist = exports.validateModulesOption = exports.validateIgnoreBrowserslistConfig = exports.validateBoolOption = exports.validateConfigPathOption = exports.checkDuplicateIncludeExcludes = exports.normalizePluginName = void 0;

            function _assert() {
              var data = _interopRequireDefault(__webpack_require__(23));

              _assert = function _assert() {
                return data;
              };

              return data;
            }

            function _browserslist() {
              var data = _interopRequireDefault(__webpack_require__(127));

              _browserslist = function _browserslist() {
                return data;
              };

              return data;
            }

            var _builtIns = _interopRequireDefault(__webpack_require__(86));

            var _defaultIncludes = __webpack_require__(309);

            var _moduleTransformations = _interopRequireDefault(
              __webpack_require__(130)
            );

            var _targetsParser = __webpack_require__(71);

            var _utils = __webpack_require__(17);

            var _plugins = _interopRequireDefault(__webpack_require__(131));

            var _options = __webpack_require__(132);

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule
                ? obj
                : {
                    default: obj,
                  };
            }

            var validateTopLevelOptions = function validateTopLevelOptions(
              options
            ) {
              for (var option in options) {
                if (!_options.TopLevelOptions[option]) {
                  var validOptions = (0, _utils.getValues)(
                    _options.TopLevelOptions
                  );
                  throw new Error(
                    "Invalid Option: " +
                      option +
                      " is not a valid top-level option.\n        Maybe you meant to use '" +
                      (0, _utils.findSuggestion)(validOptions, option) +
                      "'?"
                  );
                }
              }
            };

            var validIncludesAndExcludes = new Set(
              Object.keys(_plugins.default).concat(
                Object.keys(_moduleTransformations.default).map(function(m) {
                  return _moduleTransformations.default[m];
                }),
                Object.keys(_builtIns.default),
                _defaultIncludes.defaultWebIncludes
              )
            );

            var pluginToRegExp = function pluginToRegExp(plugin) {
              if (plugin instanceof RegExp) return plugin;

              try {
                return new RegExp("^" + normalizePluginName(plugin) + "$");
              } catch (e) {
                return null;
              }
            };

            var selectPlugins = function selectPlugins(regexp) {
              return Array.from(validIncludesAndExcludes).filter(function(
                item
              ) {
                return regexp instanceof RegExp && regexp.test(item);
              });
            };

            var flatten = function flatten(array) {
              var _ref;

              return (_ref = []).concat.apply(_ref, array);
            };

            var expandIncludesAndExcludes = function expandIncludesAndExcludes(
              plugins,
              type
            ) {
              if (plugins === void 0) {
                plugins = [];
              }

              if (plugins.length === 0) return [];
              var selectedPlugins = plugins.map(function(plugin) {
                return selectPlugins(pluginToRegExp(plugin));
              });
              var invalidRegExpList = plugins.filter(function(p, i) {
                return selectedPlugins[i].length === 0;
              });
              (0, _assert().default)(
                invalidRegExpList.length === 0,
                "Invalid Option: The plugins/built-ins '" +
                  invalidRegExpList.join(", ") +
                  "' passed to the '" +
                  type +
                  "' option are not\n    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env"
              );
              return flatten(selectedPlugins);
            };

            var validBrowserslistTargets = Object.keys(
              _browserslist().default.data
            ).concat(Object.keys(_browserslist().default.aliases));

            var normalizePluginName = function normalizePluginName(plugin) {
              return plugin.replace(/^babel-plugin-/, "");
            };

            exports.normalizePluginName = normalizePluginName;

            var checkDuplicateIncludeExcludes = function checkDuplicateIncludeExcludes(
              include,
              exclude
            ) {
              if (include === void 0) {
                include = [];
              }

              if (exclude === void 0) {
                exclude = [];
              }

              var duplicates = include.filter(function(opt) {
                return exclude.indexOf(opt) >= 0;
              });
              (0, _assert().default)(
                duplicates.length === 0,
                "Invalid Option: The plugins/built-ins '" +
                  duplicates.join(", ") +
                  '\' were found in both the "include" and\n    "exclude" options.'
              );
            };

            exports.checkDuplicateIncludeExcludes = checkDuplicateIncludeExcludes;

            var normalizeTargets = function normalizeTargets(targets) {
              if ((0, _targetsParser.isBrowsersQueryValid)(targets)) {
                return {
                  browsers: targets,
                };
              }

              return Object.assign({}, targets);
            };

            var validateConfigPathOption = function validateConfigPathOption(
              configPath
            ) {
              if (configPath === void 0) {
                configPath = process.cwd();
              }

              (0, _assert().default)(
                typeof configPath === "string",
                "Invalid Option: The configPath option '" +
                  configPath +
                  "' is invalid, only strings are allowed."
              );
              return configPath;
            };

            exports.validateConfigPathOption = validateConfigPathOption;

            var validateBoolOption = function validateBoolOption(
              name,
              value,
              defaultValue
            ) {
              if (typeof value === "undefined") {
                value = defaultValue;
              }

              if (typeof value !== "boolean") {
                throw new Error(
                  "Preset env: '" + name + "' option must be a boolean."
                );
              }

              return value;
            };

            exports.validateBoolOption = validateBoolOption;

            var validateIgnoreBrowserslistConfig = function validateIgnoreBrowserslistConfig(
              ignoreBrowserslistConfig
            ) {
              return validateBoolOption(
                _options.TopLevelOptions.ignoreBrowserslistConfig,
                ignoreBrowserslistConfig,
                false
              );
            };

            exports.validateIgnoreBrowserslistConfig = validateIgnoreBrowserslistConfig;

            var validateModulesOption = function validateModulesOption(
              modulesOpt
            ) {
              if (modulesOpt === void 0) {
                modulesOpt = _options.ModulesOption.auto;
              }

              (0, _assert().default)(
                _options.ModulesOption[modulesOpt] ||
                  _options.ModulesOption[modulesOpt] ===
                    _options.ModulesOption.false,
                "Invalid Option: The 'modules' option must be one of \n" +
                  " - 'false' to indicate no module processing\n" +
                  " - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs'" +
                  " - 'auto' (default) which will automatically select 'false' if the current\n" +
                  '   process is known to support ES module syntax, or "commonjs" otherwise\n'
              );
              return modulesOpt;
            };

            exports.validateModulesOption = validateModulesOption;

            var objectToBrowserslist = function objectToBrowserslist(object) {
              return Object.keys(object).reduce(function(list, targetName) {
                if (validBrowserslistTargets.indexOf(targetName) >= 0) {
                  var targetVersion = object[targetName];
                  return list.concat(targetName + " " + targetVersion);
                }

                return list;
              }, []);
            };

            exports.objectToBrowserslist = objectToBrowserslist;

            var validateUseBuiltInsOption = function validateUseBuiltInsOption(
              builtInsOpt
            ) {
              if (builtInsOpt === void 0) {
                builtInsOpt = false;
              }

              (0, _assert().default)(
                _options.UseBuiltInsOption[builtInsOpt] ||
                  _options.UseBuiltInsOption[builtInsOpt] ===
                    _options.UseBuiltInsOption.false,
                "Invalid Option: The 'useBuiltIns' option must be either\n    'false' (default) to indicate no polyfill,\n    '\"entry\"' to indicate replacing the entry polyfill, or\n    '\"usage\"' to import only used polyfills per file"
              );
              return builtInsOpt;
            };

            exports.validateUseBuiltInsOption = validateUseBuiltInsOption;

            function normalizeOptions(opts) {
              validateTopLevelOptions(opts);
              var include = expandIncludesAndExcludes(
                opts.include,
                _options.TopLevelOptions.include
              );
              var exclude = expandIncludesAndExcludes(
                opts.exclude,
                _options.TopLevelOptions.exclude
              );
              checkDuplicateIncludeExcludes(include, exclude);
              return {
                configPath: validateConfigPathOption(opts.configPath),
                debug: validateBoolOption(
                  _options.TopLevelOptions.debug,
                  opts.debug,
                  false
                ),
                include: include,
                exclude: exclude,
                forceAllTransforms: validateBoolOption(
                  _options.TopLevelOptions.forceAllTransforms,
                  opts.forceAllTransforms,
                  false
                ),
                ignoreBrowserslistConfig: validateIgnoreBrowserslistConfig(
                  opts.ignoreBrowserslistConfig
                ),
                loose: validateBoolOption(
                  _options.TopLevelOptions.loose,
                  opts.loose,
                  false
                ),
                modules: validateModulesOption(opts.modules),
                shippedProposals: validateBoolOption(
                  _options.TopLevelOptions.shippedProposals,
                  opts.shippedProposals,
                  false
                ),
                spec: validateBoolOption(
                  _options.TopLevelOptions.spec,
                  opts.spec,
                  false
                ),
                targets: normalizeTargets(opts.targets),
                useBuiltIns: validateUseBuiltInsOption(opts.useBuiltIns),
              };
            }
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(3)));
        },
        /* 130 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;
          var _default = {
            auto: "transform-modules-commonjs",
            amd: "transform-modules-amd",
            commonjs: "transform-modules-commonjs",
            cjs: "transform-modules-commonjs",
            systemjs: "transform-modules-systemjs",
            umd: "transform-modules-umd",
          };
          exports.default = _default;
        },
        /* 131 */
        function(module) {
          module.exports = {
            "transform-template-literals": {
              chrome: "41",
              edge: "13",
              firefox: "34",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "28",
              electron: "0.24",
            },
            "transform-literals": {
              chrome: "44",
              edge: "12",
              firefox: "53",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "31",
              electron: "0.31",
            },
            "transform-function-name": {
              chrome: "51",
              firefox: "53",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "transform-arrow-functions": {
              chrome: "47",
              edge: "13",
              firefox: "45",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "34",
              electron: "0.36",
            },
            "transform-block-scoped-functions": {
              chrome: "41",
              edge: "12",
              firefox: "46",
              safari: "10",
              node: "4",
              ie: "11",
              ios: "10",
              opera: "28",
              electron: "0.24",
            },
            "transform-classes": {
              chrome: "46",
              edge: "13",
              firefox: "45",
              safari: "10",
              node: "5",
              ios: "10",
              opera: "33",
              electron: "0.36",
            },
            "transform-object-super": {
              chrome: "46",
              edge: "13",
              firefox: "45",
              safari: "10",
              node: "5",
              ios: "10",
              opera: "33",
              electron: "0.36",
            },
            "transform-shorthand-properties": {
              chrome: "43",
              edge: "12",
              firefox: "33",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "30",
              electron: "0.29",
            },
            "transform-duplicate-keys": {
              chrome: "42",
              edge: "12",
              firefox: "34",
              safari: "9",
              node: "4",
              ios: "9",
              opera: "29",
              electron: "0.27",
            },
            "transform-computed-properties": {
              chrome: "44",
              edge: "12",
              firefox: "34",
              safari: "7.1",
              node: "4",
              ios: "8",
              opera: "31",
              electron: "0.31",
            },
            "transform-for-of": {
              chrome: "51",
              edge: "15",
              firefox: "53",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "transform-sticky-regex": {
              chrome: "49",
              edge: "13",
              firefox: "3",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "transform-dotall-regex": {
              chrome: "62",
              safari: "11.1",
              node: "8.10",
              ios: "11.3",
              opera: "49",
              electron: "3",
            },
            "transform-unicode-regex": {
              chrome: "50",
              edge: "13",
              firefox: "46",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "37",
              electron: "1.1",
            },
            "transform-spread": {
              chrome: "46",
              edge: "13",
              firefox: "36",
              safari: "10",
              node: "5",
              ios: "10",
              opera: "33",
              electron: "0.36",
            },
            "transform-parameters": {
              chrome: "49",
              edge: "14",
              firefox: "53",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "transform-destructuring": {
              chrome: "51",
              firefox: "53",
              safari: "10",
              node: "6.5",
              ios: "10",
              opera: "38",
              electron: "1.2",
            },
            "transform-block-scoping": {
              chrome: "49",
              edge: "14",
              firefox: "51",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "36",
              electron: "1",
            },
            "transform-typeof-symbol": {
              chrome: "38",
              edge: "12",
              firefox: "36",
              safari: "9",
              node: "0.12",
              ios: "9",
              opera: "25",
              electron: "0.2",
            },
            "transform-new-target": {
              chrome: "46",
              edge: "14",
              firefox: "41",
              safari: "10",
              node: "5",
              ios: "10",
              opera: "33",
              electron: "0.36",
            },
            "transform-regenerator": {
              chrome: "50",
              edge: "13",
              firefox: "53",
              safari: "10",
              node: "6",
              ios: "10",
              opera: "37",
              electron: "1.1",
            },
            "transform-exponentiation-operator": {
              chrome: "52",
              edge: "14",
              firefox: "52",
              safari: "10.1",
              node: "7",
              ios: "10.3",
              opera: "39",
              electron: "1.3",
            },
            "transform-async-to-generator": {
              chrome: "55",
              edge: "15",
              firefox: "52",
              safari: "10.1",
              node: "7.6",
              ios: "10.3",
              opera: "42",
              electron: "1.6",
            },
            "proposal-async-generator-functions": {
              chrome: "63",
              firefox: "57",
              safari: "12",
              opera: "50",
              electron: "3",
            },
            "proposal-object-rest-spread": {
              chrome: "60",
              firefox: "55",
              safari: "11.1",
              node: "8.3",
              ios: "11.3",
              opera: "47",
              electron: "2",
            },
            "proposal-unicode-property-regex": {
              chrome: "64",
              safari: "11.1",
              ios: "11.3",
              opera: "51",
              electron: "3",
            },
            "proposal-json-strings": {},
            "proposal-optional-catch-binding": {
              chrome: "66",
              firefox: "58",
              safari: "11.1",
              ios: "11.3",
              opera: "53",
              electron: "3",
            },
          };
        },
        /* 132 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.TargetNames = exports.UseBuiltInsOption = exports.ModulesOption = exports.TopLevelOptions = void 0;
          var TopLevelOptions = {
            configPath: "configPath",
            debug: "debug",
            exclude: "exclude",
            forceAllTransforms: "forceAllTransforms",
            ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
            include: "include",
            loose: "loose",
            modules: "modules",
            shippedProposals: "shippedProposals",
            spec: "spec",
            targets: "targets",
            useBuiltIns: "useBuiltIns",
          };
          exports.TopLevelOptions = TopLevelOptions;
          var ModulesOption = {
            false: false,
            auto: "auto",
            amd: "amd",
            commonjs: "commonjs",
            cjs: "cjs",
            systemjs: "systemjs",
            umd: "umd",
          };
          exports.ModulesOption = ModulesOption;
          var UseBuiltInsOption = {
            false: false,
            entry: "entry",
            usage: "usage",
          };
          exports.UseBuiltInsOption = UseBuiltInsOption;
          var TargetNames = {
            esmodules: "esmodules",
            node: "node",
            browsers: "browsers",
            chrome: "chrome",
            opera: "opera",
            edge: "edge",
            firefox: "firefox",
            safari: "safari",
            ie: "ie",
            ios: "ios",
            android: "android",
            electron: "electron",
          };
          exports.TargetNames = TargetNames;
        },
        /* 133 */
        function(module, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _gerhobbelt_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            49
          );
          /* harmony import */ var _gerhobbelt_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
            _gerhobbelt_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__
          );

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function helpers() {
            var data = _interopRequireWildcard(__webpack_require__(134));

            helpers = function helpers() {
              return data;
            };

            return data;
          }

          function _babelTraverse() {
            var data = _interopRequireWildcard(__webpack_require__(9));

            _babelTraverse = function _babelTraverse() {
              return data;
            };

            return data;
          }

          function _babelCodeFrame() {
            var data = __webpack_require__(44);

            _babelCodeFrame = function _babelCodeFrame() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _semver() {
            var data = _interopRequireDefault(__webpack_require__(16));

            _semver = function _semver() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          var errorVisitor = {
            enter: function enter(path, state) {
              var loc = path.node.loc;

              if (loc) {
                state.loc = loc;
                path.stop();
              }
            },
          };

          var File = (function() {
            function File(options, _ref) {
              var _this = this;

              var code = _ref.code,
                ast = _ref.ast,
                inputMap = _ref.inputMap;
              this._map = new Map();
              this.declarations = {};
              this.path = null;
              this.ast = {};
              this.metadata = {};
              this.code = "";
              this.inputMap = null;
              this.hub = {
                file: this,
                getCode: function getCode() {
                  return _this.code;
                },
                getScope: function getScope() {
                  return _this.scope;
                },
                addHelper: this.addHelper.bind(this),
                buildError: this.buildCodeFrameError.bind(this),
              };
              this.opts = options;
              this.code = code;
              this.ast = ast;
              this.inputMap = inputMap;
              this.path = _babelTraverse()
                .NodePath.get({
                  hub: this.hub,
                  parentPath: null,
                  parent: this.ast,
                  container: this.ast,
                  key: "program",
                })
                .setContext();
              this.scope = this.path.scope;
            }

            var _proto = File.prototype;

            _proto.set = function set(key, val) {
              if (key === "helpersNamespace") {
                throw new Error(
                  "Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility." +
                    "If you are using @gerhobbelt/babel-plugin-external-helpers you will need to use a newer " +
                    "version than the one you currently have installed. " +
                    "If you have your own implementation, you'll want to explore using 'helperGenerator' " +
                    "alongside 'file.availableHelper()'."
                );
              }

              this._map.set(key, val);
            };

            _proto.get = function get(key) {
              return this._map.get(key);
            };

            _proto.has = function has(key) {
              return this._map.has(key);
            };

            _proto.getModuleName = function getModuleName() {
              var _this$opts = this.opts,
                filename = _this$opts.filename,
                _this$opts$filenameRe = _this$opts.filenameRelative,
                filenameRelative =
                  _this$opts$filenameRe === void 0
                    ? filename
                    : _this$opts$filenameRe,
                moduleId = _this$opts.moduleId,
                _this$opts$moduleIds = _this$opts.moduleIds,
                moduleIds =
                  _this$opts$moduleIds === void 0
                    ? !!moduleId
                    : _this$opts$moduleIds,
                getModuleId = _this$opts.getModuleId,
                sourceRootTmp = _this$opts.sourceRoot,
                _this$opts$moduleRoot = _this$opts.moduleRoot,
                moduleRoot =
                  _this$opts$moduleRoot === void 0
                    ? sourceRootTmp
                    : _this$opts$moduleRoot,
                _this$opts$sourceRoot = _this$opts.sourceRoot,
                sourceRoot =
                  _this$opts$sourceRoot === void 0
                    ? moduleRoot
                    : _this$opts$sourceRoot;
              if (!moduleIds) return null;

              if (moduleId != null && !getModuleId) {
                return moduleId;
              }

              var moduleName = moduleRoot != null ? moduleRoot + "/" : "";

              if (filenameRelative) {
                var sourceRootReplacer =
                  sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
                moduleName += filenameRelative
                  .replace(sourceRootReplacer, "")
                  .replace(/\.(\w*?)$/, "");
              }

              moduleName = moduleName.replace(/\\\\?/g, "/");

              if (getModuleId) {
                return getModuleId(moduleName) || moduleName;
              } else {
                return moduleName;
              }
            };

            _proto.addImport = function addImport() {
              throw new Error(
                "This API has been removed. If you're looking for this " +
                  "functionality in Babel 7, you should import the " +
                  "'@gerhobbelt/babel-helper-module-imports' module and use the functions exposed " +
                  " from that module, such as 'addNamed' or 'addDefault'."
              );
            };

            _proto.availableHelper = function availableHelper(
              name,
              versionRange
            ) {
              var minVersion;

              try {
                minVersion = helpers().minVersion(name);
              } catch (err) {
                if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
                return false;
              }

              return (
                typeof versionRange !== "string" ||
                (!_semver().default.intersects(
                  "<" + minVersion,
                  versionRange
                ) &&
                  !_semver().default.intersects(">=8.0.0", versionRange))
              );
            };

            _proto.addHelper = function addHelper(name) {
              var _this2 = this;

              var declar = this.declarations[name];
              if (declar) return t().cloneNode(declar);
              var generator = this.get("helperGenerator");

              if (generator) {
                var res = generator(name);
                if (res) return res;
              }

              var uid = (this.declarations[
                name
              ] = this.scope.generateUidIdentifier(name));
              var dependencies = {};

              for (
                var _iterator = helpers().getDependencies(name),
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref2;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref2 = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref2 = _i.value;
                }

                var dep = _ref2;
                dependencies[dep] = this.addHelper(dep);
              }

              var _helpers$get = helpers().get(
                  name,
                  function(dep) {
                    return dependencies[dep];
                  },
                  uid,
                  Object.keys(this.scope.getAllBindings())
                ),
                nodes = _helpers$get.nodes,
                globals = _helpers$get.globals;

              globals.forEach(function(name) {
                if (_this2.path.scope.hasBinding(name, true)) {
                  _this2.path.scope.rename(name);
                }
              });
              nodes.forEach(function(node) {
                node._compact = true;
              });
              this.path.unshiftContainer("body", nodes);
              this.path.get("body").forEach(function(path) {
                if (nodes.indexOf(path.node) === -1) return;
                if (path.isVariableDeclaration())
                  _this2.scope.registerDeclaration(path);
              });
              return uid;
            };

            _proto.addTemplateObject = function addTemplateObject() {
              throw new Error(
                "This function has been moved into the template literal transform itself."
              );
            };

            _proto.buildCodeFrameError = function buildCodeFrameError(
              node,
              msg,
              Error
            ) {
              if (Error === void 0) {
                Error = SyntaxError;
              }

              var loc = node && (node.loc || node._loc);
              msg = this.opts.filename + ": " + msg;

              if (!loc && node) {
                var state = {
                  loc: null,
                };
                (0, _babelTraverse().default)(
                  node,
                  errorVisitor,
                  this.scope,
                  state
                );
                loc = state.loc;
                var txt =
                  "This is an error on an internal node. Probably an internal error.";
                if (loc) txt += " Location has been estimated.";
                msg += " (" + txt + ")";
              }

              if (loc) {
                var _this$opts$highlightC = this.opts.highlightCode,
                  highlightCode =
                    _this$opts$highlightC === void 0
                      ? true
                      : _this$opts$highlightC;
                msg +=
                  "\n" +
                  (0, _babelCodeFrame().codeFrameColumns)(
                    this.code,
                    {
                      start: {
                        line: loc.start.line,
                        column: loc.start.column + 1,
                      },
                    },
                    {
                      highlightCode: highlightCode,
                    }
                  );
              }

              return new Error(msg);
            };

            _gerhobbelt_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(
              File,
              [
                {
                  key: "shebang",
                  get: function get() {
                    var interpreter = this.path.node.interpreter;
                    return interpreter ? interpreter.value : "";
                  },
                  set: function set(value) {
                    if (value) {
                      this.path
                        .get("interpreter")
                        .replaceWith(t().interpreterDirective(value));
                    } else {
                      this.path.get("interpreter").remove();
                    }
                  },
                },
              ]
            );

            return File;
          })();

          exports.default = File;
        },
        /* 134 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.get = get;
          exports.minVersion = minVersion;
          exports.getDependencies = getDependencies;
          exports.default = exports.list = void 0;

          function _babelTraverse() {
            var data = _interopRequireDefault(__webpack_require__(9));

            _babelTraverse = function _babelTraverse() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          var _helpers = _interopRequireDefault(__webpack_require__(399));

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function makePath(path) {
            var parts = [];

            for (; path.parentPath; path = path.parentPath) {
              parts.push(path.key);
              if (path.inList) parts.push(path.listKey);
            }

            return parts.reverse().join(".");
          }

          function getHelperMetadata(file) {
            var globals = new Set();
            var localBindingNames = new Set();
            var dependencies = new Map();
            var exportName;
            var exportPath;
            var exportBindingAssignments = [];
            var importPaths = [];
            var importBindingsReferences = [];
            (0, _babelTraverse().default)(file, {
              ImportDeclaration: function ImportDeclaration(child) {
                var name = child.node.source.value;

                if (!_helpers.default[name]) {
                  throw child.buildCodeFrameError("Unknown helper " + name);
                }

                if (
                  child.get("specifiers").length !== 1 ||
                  !child.get("specifiers.0").isImportDefaultSpecifier()
                ) {
                  throw child.buildCodeFrameError(
                    "Helpers can only import a default value"
                  );
                }

                var bindingIdentifier = child.node.specifiers[0].local;
                dependencies.set(bindingIdentifier, name);
                importPaths.push(makePath(child));
              },
              ExportDefaultDeclaration: function ExportDefaultDeclaration(
                child
              ) {
                var decl = child.get("declaration");

                if (decl.isFunctionDeclaration()) {
                  if (!decl.node.id) {
                    throw decl.buildCodeFrameError(
                      "Helpers should give names to their exported func declaration"
                    );
                  }

                  exportName = decl.node.id.name;
                }

                exportPath = makePath(child);
              },
              ExportAllDeclaration: function ExportAllDeclaration(child) {
                throw child.buildCodeFrameError(
                  "Helpers can only export default"
                );
              },
              ExportNamedDeclaration: function ExportNamedDeclaration(child) {
                throw child.buildCodeFrameError(
                  "Helpers can only export default"
                );
              },
              Statement: function Statement(child) {
                if (child.isModuleDeclaration()) return;
                child.skip();
              },
            });
            (0, _babelTraverse().default)(file, {
              Program: function Program(path) {
                var bindings = path.scope.getAllBindings();
                Object.keys(bindings).forEach(function(name) {
                  if (name === exportName) return;
                  if (dependencies.has(bindings[name].identifier)) return;
                  localBindingNames.add(name);
                });
              },
              ReferencedIdentifier: function ReferencedIdentifier(child) {
                var name = child.node.name;
                var binding = child.scope.getBinding(name, true);

                if (!binding) {
                  globals.add(name);
                } else if (dependencies.has(binding.identifier)) {
                  importBindingsReferences.push(makePath(child));
                }
              },
              AssignmentExpression: function AssignmentExpression(child) {
                var left = child.get("left");
                if (!(exportName in left.getBindingIdentifiers())) return;

                if (!left.isIdentifier()) {
                  throw left.buildCodeFrameError(
                    "Only simple assignments to exports are allowed in helpers"
                  );
                }

                var binding = child.scope.getBinding(exportName);

                if (binding && binding.scope.path.isProgram()) {
                  exportBindingAssignments.push(makePath(child));
                }
              },
            });
            if (!exportPath)
              throw new Error("Helpers must default-export something.");
            exportBindingAssignments.reverse();
            return {
              globals: Array.from(globals),
              localBindingNames: Array.from(localBindingNames),
              dependencies: dependencies,
              exportBindingAssignments: exportBindingAssignments,
              exportPath: exportPath,
              exportName: exportName,
              importBindingsReferences: importBindingsReferences,
              importPaths: importPaths,
            };
          }

          function permuteHelperAST(
            file,
            metadata,
            id,
            localBindings,
            getDependency
          ) {
            if (localBindings && !id) {
              throw new Error(
                "Unexpected local bindings for module-based helpers."
              );
            }

            if (!id) return;
            var localBindingNames = metadata.localBindingNames,
              dependencies = metadata.dependencies,
              exportBindingAssignments = metadata.exportBindingAssignments,
              exportPath = metadata.exportPath,
              exportName = metadata.exportName,
              importBindingsReferences = metadata.importBindingsReferences,
              importPaths = metadata.importPaths;
            var dependenciesRefs = {};
            dependencies.forEach(function(name, id) {
              dependenciesRefs[id.name] =
                (typeof getDependency === "function" && getDependency(name)) ||
                id;
            });
            var toRename = {};
            var bindings = new Set(localBindings || []);
            localBindingNames.forEach(function(name) {
              var newName = name;

              while (bindings.has(newName)) {
                newName = "_" + newName;
              }

              if (newName !== name) toRename[name] = newName;
            });

            if (id.type === "Identifier" && exportName !== id.name) {
              toRename[exportName] = id.name;
            }

            (0, _babelTraverse().default)(file, {
              Program: function Program(path) {
                var exp = path.get(exportPath);
                var imps = importPaths.map(function(p) {
                  return path.get(p);
                });
                var impsBindingRefs = importBindingsReferences.map(function(p) {
                  return path.get(p);
                });
                var decl = exp.get("declaration");

                if (id.type === "Identifier") {
                  if (decl.isFunctionDeclaration()) {
                    exp.replaceWith(decl);
                  } else {
                    exp.replaceWith(
                      t().variableDeclaration("var", [
                        t().variableDeclarator(id, decl.node),
                      ])
                    );
                  }
                } else if (id.type === "MemberExpression") {
                  if (decl.isFunctionDeclaration()) {
                    exportBindingAssignments.forEach(function(assignPath) {
                      var assign = path.get(assignPath);
                      assign.replaceWith(
                        t().assignmentExpression("=", id, assign.node)
                      );
                    });
                    exp.replaceWith(decl);
                    path.pushContainer(
                      "body",
                      t().expressionStatement(
                        t().assignmentExpression(
                          "=",
                          id,
                          t().identifier(exportName)
                        )
                      )
                    );
                  } else {
                    exp.replaceWith(
                      t().expressionStatement(
                        t().assignmentExpression("=", id, decl.node)
                      )
                    );
                  }
                } else {
                  throw new Error("Unexpected helper format.");
                }

                Object.keys(toRename).forEach(function(name) {
                  path.scope.rename(name, toRename[name]);
                });

                for (
                  var _iterator = imps,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray
                      ? _iterator
                      : _iterator[Symbol.iterator]();
                  ;

                ) {
                  var _ref;

                  if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                  } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                  }

                  var _path = _ref;

                  _path.remove();
                }

                for (
                  var _iterator2 = impsBindingRefs,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : _iterator2[Symbol.iterator]();
                  ;

                ) {
                  var _ref2;

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                  } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                  }

                  var _path2 = _ref2;
                  var node = t().cloneNode(dependenciesRefs[_path2.node.name]);

                  _path2.replaceWith(node);
                }

                path.stop();
              },
            });
          }

          var helperData = Object.create(null);

          function loadHelper(name) {
            if (!helperData[name]) {
              var helper = _helpers.default[name];

              if (!helper) {
                throw Object.assign(
                  new ReferenceError("Unknown helper " + name),
                  {
                    code: "BABEL_HELPER_UNKNOWN",
                    helper: name,
                  }
                );
              }

              var fn = function fn() {
                return t().file(helper.ast());
              };

              var metadata = getHelperMetadata(fn());
              helperData[name] = {
                build: function build(getDependency, id, localBindings) {
                  var file = fn();
                  permuteHelperAST(
                    file,
                    metadata,
                    id,
                    localBindings,
                    getDependency
                  );
                  return {
                    nodes: file.program.body,
                    globals: metadata.globals,
                  };
                },
                minVersion: function minVersion() {
                  return helper.minVersion;
                },
                dependencies: metadata.dependencies,
              };
            }

            return helperData[name];
          }

          function get(name, getDependency, id, localBindings) {
            return loadHelper(name).build(getDependency, id, localBindings);
          }

          function minVersion(name) {
            return loadHelper(name).minVersion();
          }

          function getDependencies(name) {
            return Array.from(loadHelper(name).dependencies.values());
          }

          var list = Object.keys(_helpers.default)
            .map(function(name) {
              return name.replace(/^_/, "");
            })
            .filter(function(name) {
              return name !== "__esModule";
            });
          exports.list = list;
          var _default = get;
          exports.default = _default;
        },
        /* 135 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          var ReferencedIdentifier = {
            types: ["Identifier", "JSXIdentifier"],
            checkPath: function checkPath(_ref, opts) {
              var node = _ref.node,
                parent = _ref.parent;

              if (
                !t().isIdentifier(node, opts) &&
                !t().isJSXMemberExpression(parent, opts)
              ) {
                if (t().isJSXIdentifier(node, opts)) {
                  if (t().react.isCompatTag(node.name)) return false;
                } else {
                  return false;
                }
              }

              return t().isReferenced(node, parent);
            },
          };
          exports.ReferencedIdentifier = ReferencedIdentifier;
          var ReferencedMemberExpression = {
            types: ["MemberExpression"],
            checkPath: function checkPath(_ref2) {
              var node = _ref2.node,
                parent = _ref2.parent;
              return (
                t().isMemberExpression(node) && t().isReferenced(node, parent)
              );
            },
          };
          exports.ReferencedMemberExpression = ReferencedMemberExpression;
          var BindingIdentifier = {
            types: ["Identifier"],
            checkPath: function checkPath(_ref3) {
              var node = _ref3.node,
                parent = _ref3.parent;
              return t().isIdentifier(node) && t().isBinding(node, parent);
            },
          };
          exports.BindingIdentifier = BindingIdentifier;
          var Statement = {
            types: ["Statement"],
            checkPath: function checkPath(_ref4) {
              var node = _ref4.node,
                parent = _ref4.parent;

              if (t().isStatement(node)) {
                if (t().isVariableDeclaration(node)) {
                  if (
                    t().isForXStatement(parent, {
                      left: node,
                    })
                  )
                    return false;
                  if (
                    t().isForStatement(parent, {
                      init: node,
                    })
                  )
                    return false;
                }

                return true;
              } else {
                return false;
              }
            },
          };
          exports.Statement = Statement;
          var Expression = {
            types: ["Expression"],
            checkPath: function checkPath(path) {
              if (path.isIdentifier()) {
                return path.isReferencedIdentifier();
              } else {
                return t().isExpression(path.node);
              }
            },
          };
          exports.Expression = Expression;
          var Scope = {
            types: ["Scopable"],
            checkPath: function checkPath(path) {
              return t().isScope(path.node, path.parent);
            },
          };
          exports.Scope = Scope;
          var Referenced = {
            checkPath: function checkPath(path) {
              return t().isReferenced(path.node, path.parent);
            },
          };
          exports.Referenced = Referenced;
          var BlockScoped = {
            checkPath: function checkPath(path) {
              return t().isBlockScoped(path.node);
            },
          };
          exports.BlockScoped = BlockScoped;
          var Var = {
            types: ["VariableDeclaration"],
            checkPath: function checkPath(path) {
              return t().isVar(path.node);
            },
          };
          exports.Var = Var;
          var User = {
            checkPath: function checkPath(path) {
              return path.node && !!path.node.loc;
            },
          };
          exports.User = User;
          var Generated = {
            checkPath: function checkPath(path) {
              return !path.isUser();
            },
          };
          exports.Generated = Generated;
          var Pure = {
            checkPath: function checkPath(path, opts) {
              return path.scope.isPure(path.node, opts);
            },
          };
          exports.Pure = Pure;
          var Flow = {
            types: [
              "Flow",
              "ImportDeclaration",
              "ExportDeclaration",
              "ImportSpecifier",
            ],
            checkPath: function checkPath(_ref5) {
              var node = _ref5.node;

              if (t().isFlow(node)) {
                return true;
              } else if (t().isImportDeclaration(node)) {
                return (
                  node.importKind === "type" || node.importKind === "typeof"
                );
              } else if (t().isExportDeclaration(node)) {
                return node.exportKind === "type";
              } else if (t().isImportSpecifier(node)) {
                return (
                  node.importKind === "type" || node.importKind === "typeof"
                );
              } else {
                return false;
              }
            },
          };
          exports.Flow = Flow;
          var RestProperty = {
            types: ["RestElement"],
            checkPath: function checkPath(path) {
              return path.parentPath && path.parentPath.isObjectPattern();
            },
          };
          exports.RestProperty = RestProperty;
          var SpreadProperty = {
            types: ["RestElement"],
            checkPath: function checkPath(path) {
              return path.parentPath && path.parentPath.isObjectExpression();
            },
          };
          exports.SpreadProperty = SpreadProperty;
          var ExistentialTypeParam = {
            types: ["ExistsTypeAnnotation"],
          };
          exports.ExistentialTypeParam = ExistentialTypeParam;
          var NumericLiteralTypeAnnotation = {
            types: ["NumberLiteralTypeAnnotation"],
          };
          exports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;
          var ForAwaitStatement = {
            types: ["ForOfStatement"],
            checkPath: function checkPath(_ref6) {
              var node = _ref6.node;
              return node.await === true;
            },
          };
          exports.ForAwaitStatement = ForAwaitStatement;
        },
        /* 136 */
        function(module, exports) {
          var s = 1000;
          var m = s * 60;
          var h = m * 60;
          var d = h * 24;
          var y = d * 365.25;

          module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;

            if (type === "string" && val.length > 0) {
              return parse(val);
            } else if (type === "number" && isNaN(val) === false) {
              return options.long ? fmtLong(val) : fmtShort(val);
            }

            throw new Error(
              "val is not a non-empty string or a valid number. val=" +
                JSON.stringify(val)
            );
          };

          function parse(str) {
            str = String(str);

            if (str.length > 100) {
              return;
            }

            var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
              str
            );

            if (!match) {
              return;
            }

            var n = parseFloat(match[1]);
            var type = (match[2] || "ms").toLowerCase();

            switch (type) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return n * y;

              case "days":
              case "day":
              case "d":
                return n * d;

              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return n * h;

              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return n * m;

              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return n * s;

              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return n;

              default:
                return undefined;
            }
          }

          function fmtShort(ms) {
            if (ms >= d) {
              return Math.round(ms / d) + "d";
            }

            if (ms >= h) {
              return Math.round(ms / h) + "h";
            }

            if (ms >= m) {
              return Math.round(ms / m) + "m";
            }

            if (ms >= s) {
              return Math.round(ms / s) + "s";
            }

            return ms + "ms";
          }

          function fmtLong(ms) {
            return (
              plural(ms, d, "day") ||
              plural(ms, h, "hour") ||
              plural(ms, m, "minute") ||
              plural(ms, s, "second") ||
              ms + " ms"
            );
          }

          function plural(ms, n, name) {
            if (ms < n) {
              return;
            }

            if (ms < n * 1.5) {
              return Math.floor(ms / n) + " " + name;
            }

            return Math.ceil(ms / n) + " " + name + "s";
          }
        },
        /* 137 */
        function(module, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _gerhobbelt_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            49
          );
          /* harmony import */ var _gerhobbelt_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
            _gerhobbelt_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__
          );

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function _includes() {
            var data = _interopRequireDefault(__webpack_require__(73));

            _includes = function _includes() {
              return data;
            };

            return data;
          }

          function _repeat() {
            var data = _interopRequireDefault(__webpack_require__(138));

            _repeat = function _repeat() {
              return data;
            };

            return data;
          }

          var _renamer = _interopRequireDefault(__webpack_require__(328));

          var _index = _interopRequireDefault(__webpack_require__(9));

          function _defaults() {
            var data = _interopRequireDefault(__webpack_require__(330));

            _defaults = function _defaults() {
              return data;
            };

            return data;
          }

          var _binding = _interopRequireDefault(__webpack_require__(139));

          function _globals() {
            var data = _interopRequireDefault(__webpack_require__(337));

            _globals = function _globals() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          var _cache = __webpack_require__(43);

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function gatherNodeParts(node, parts) {
            if (t().isModuleDeclaration(node)) {
              if (node.source) {
                gatherNodeParts(node.source, parts);
              } else if (node.specifiers && node.specifiers.length) {
                for (
                  var _iterator = node.specifiers,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray
                      ? _iterator
                      : _iterator[Symbol.iterator]();
                  ;

                ) {
                  var _ref;

                  if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                  } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                  }

                  var specifier = _ref;
                  gatherNodeParts(specifier, parts);
                }
              } else if (node.declaration) {
                gatherNodeParts(node.declaration, parts);
              }
            } else if (t().isModuleSpecifier(node)) {
              gatherNodeParts(node.local, parts);
            } else if (t().isMemberExpression(node)) {
              gatherNodeParts(node.object, parts);
              gatherNodeParts(node.property, parts);
            } else if (t().isIdentifier(node)) {
              parts.push(node.name);
            } else if (t().isLiteral(node)) {
              parts.push(node.value);
            } else if (t().isCallExpression(node)) {
              gatherNodeParts(node.callee, parts);
            } else if (
              t().isObjectExpression(node) ||
              t().isObjectPattern(node)
            ) {
              for (
                var _iterator2 = node.properties,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : _iterator2[Symbol.iterator]();
                ;

              ) {
                var _ref2;

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break;
                  _ref2 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done) break;
                  _ref2 = _i2.value;
                }

                var prop = _ref2;
                gatherNodeParts(prop.key || prop.argument, parts);
              }
            } else if (t().isPrivateName(node)) {
              gatherNodeParts(node.id, parts);
            } else if (t().isThisExpression(node)) {
              parts.push("this");
            } else if (t().isSuper(node)) {
              parts.push("super");
            }
          }

          var collectorVisitor = {
            For: function For(path) {
              for (
                var _iterator3 = t().FOR_INIT_KEYS,
                  _isArray3 = Array.isArray(_iterator3),
                  _i3 = 0,
                  _iterator3 = _isArray3
                    ? _iterator3
                    : _iterator3[Symbol.iterator]();
                ;

              ) {
                var _ref3;

                if (_isArray3) {
                  if (_i3 >= _iterator3.length) break;
                  _ref3 = _iterator3[_i3++];
                } else {
                  _i3 = _iterator3.next();
                  if (_i3.done) break;
                  _ref3 = _i3.value;
                }

                var key = _ref3;
                var declar = path.get(key);

                if (declar.isVar()) {
                  var parentScope =
                    path.scope.getFunctionParent() ||
                    path.scope.getProgramParent();
                  parentScope.registerBinding("var", declar);
                }
              }
            },
            Declaration: function Declaration(path) {
              if (path.isBlockScoped()) return;

              if (
                path.isExportDeclaration() &&
                path.get("declaration").isDeclaration()
              ) {
                return;
              }

              var parent =
                path.scope.getFunctionParent() || path.scope.getProgramParent();
              parent.registerDeclaration(path);
            },
            ReferencedIdentifier: function ReferencedIdentifier(path, state) {
              state.references.push(path);
            },
            ForXStatement: function ForXStatement(path, state) {
              var left = path.get("left");

              if (left.isPattern() || left.isIdentifier()) {
                state.constantViolations.push(path);
              }
            },
            ExportDeclaration: {
              exit: function exit(path) {
                var node = path.node,
                  scope = path.scope;
                var declar = node.declaration;

                if (
                  t().isClassDeclaration(declar) ||
                  t().isFunctionDeclaration(declar)
                ) {
                  var id = declar.id;
                  if (!id) return;
                  var binding = scope.getBinding(id.name);
                  if (binding) binding.reference(path);
                } else if (t().isVariableDeclaration(declar)) {
                  for (
                    var _iterator4 = declar.declarations,
                      _isArray4 = Array.isArray(_iterator4),
                      _i4 = 0,
                      _iterator4 = _isArray4
                        ? _iterator4
                        : _iterator4[Symbol.iterator]();
                    ;

                  ) {
                    var _ref4;

                    if (_isArray4) {
                      if (_i4 >= _iterator4.length) break;
                      _ref4 = _iterator4[_i4++];
                    } else {
                      _i4 = _iterator4.next();
                      if (_i4.done) break;
                      _ref4 = _i4.value;
                    }

                    var decl = _ref4;
                    var ids = t().getBindingIdentifiers(decl);

                    for (var name in ids) {
                      var _binding2 = scope.getBinding(name);

                      if (_binding2) _binding2.reference(path);
                    }
                  }
                }
              },
            },
            LabeledStatement: function LabeledStatement(path) {
              path.scope.getProgramParent().addGlobal(path.node);
              path.scope.getBlockParent().registerDeclaration(path);
            },
            AssignmentExpression: function AssignmentExpression(path, state) {
              state.assignments.push(path);
            },
            UpdateExpression: function UpdateExpression(path, state) {
              state.constantViolations.push(path);
            },
            UnaryExpression: function UnaryExpression(path, state) {
              if (path.node.operator === "delete") {
                state.constantViolations.push(path);
              }
            },
            BlockScoped: function BlockScoped(path) {
              var scope = path.scope;
              if (scope.path === path) scope = scope.parent;
              scope.getBlockParent().registerDeclaration(path);
            },
            ClassDeclaration: function ClassDeclaration(path) {
              var id = path.node.id;
              if (!id) return;
              var name = id.name;
              path.scope.bindings[name] = path.scope.getBinding(name);
            },
            Block: function Block(path) {
              var paths = path.get("body");

              for (
                var _iterator5 = paths,
                  _isArray5 = Array.isArray(_iterator5),
                  _i5 = 0,
                  _iterator5 = _isArray5
                    ? _iterator5
                    : _iterator5[Symbol.iterator]();
                ;

              ) {
                var _ref5;

                if (_isArray5) {
                  if (_i5 >= _iterator5.length) break;
                  _ref5 = _iterator5[_i5++];
                } else {
                  _i5 = _iterator5.next();
                  if (_i5.done) break;
                  _ref5 = _i5.value;
                }

                var bodyPath = _ref5;

                if (bodyPath.isFunctionDeclaration()) {
                  path.scope.getBlockParent().registerDeclaration(bodyPath);
                }
              }
            },
          };
          var uid = 0;

          var Scope = (function() {
            function Scope(path) {
              var node = path.node;

              var cached = _cache.scope.get(node);

              if (cached && cached.path === path) {
                return cached;
              }

              _cache.scope.set(node, this);

              this.uid = uid++;
              this.block = node;
              this.path = path;
              this.labels = new Map();
            }

            var _proto = Scope.prototype;

            _proto.traverse = function traverse(node, opts, state) {
              (0, _index.default)(node, opts, this, state, this.path);
            };

            _proto.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier(
              name
            ) {
              var id = this.generateUidIdentifier(name);
              this.push({
                id: id,
              });
              return t().cloneNode(id);
            };

            _proto.generateUidIdentifier = function generateUidIdentifier(
              name
            ) {
              return t().identifier(this.generateUid(name));
            };

            _proto.generateUid = function generateUid(name) {
              if (name === void 0) {
                name = "temp";
              }

              name = t()
                .toIdentifier(name)
                .replace(/^_+/, "")
                .replace(/[0-9]+$/g, "");
              var uid;
              var i = 0;

              do {
                uid = this._generateUid(name, i);
                i++;
              } while (
                this.hasLabel(uid) ||
                this.hasBinding(uid) ||
                this.hasGlobal(uid) ||
                this.hasReference(uid)
              );

              var program = this.getProgramParent();
              program.references[uid] = true;
              program.uids[uid] = true;
              return uid;
            };

            _proto._generateUid = function _generateUid(name, i) {
              var id = name;
              if (i > 1) id += i;
              return "_" + id;
            };

            _proto.generateUidBasedOnNode = function generateUidBasedOnNode(
              parent,
              defaultName
            ) {
              var node = parent;

              if (t().isAssignmentExpression(parent)) {
                node = parent.left;
              } else if (t().isVariableDeclarator(parent)) {
                node = parent.id;
              } else if (
                t().isObjectProperty(node) ||
                t().isObjectMethod(node)
              ) {
                node = node.key;
              }

              var parts = [];
              gatherNodeParts(node, parts);
              var id = parts.join("$");
              id = id.replace(/^_/, "") || defaultName || "ref";
              return this.generateUid(id.slice(0, 20));
            };

            _proto.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(
              parent,
              defaultName
            ) {
              return t().identifier(
                this.generateUidBasedOnNode(parent, defaultName)
              );
            };

            _proto.isStatic = function isStatic(node) {
              if (t().isThisExpression(node) || t().isSuper(node)) {
                return true;
              }

              if (t().isIdentifier(node)) {
                var binding = this.getBinding(node.name);

                if (binding) {
                  return binding.constant;
                } else {
                  return this.hasBinding(node.name);
                }
              }

              return false;
            };

            _proto.maybeGenerateMemoised = function maybeGenerateMemoised(
              node,
              dontPush
            ) {
              if (this.isStatic(node)) {
                return null;
              } else {
                var id = this.generateUidIdentifierBasedOnNode(node);

                if (!dontPush) {
                  this.push({
                    id: id,
                  });
                  return t().cloneNode(id);
                }

                return id;
              }
            };

            _proto.checkBlockScopedCollisions = function checkBlockScopedCollisions(
              local,
              kind,
              name,
              id
            ) {
              if (kind === "param") return;
              if (local.kind === "local") return;
              if (kind === "hoisted" && local.kind === "let") return;
              var duplicate =
                kind === "let" ||
                local.kind === "let" ||
                local.kind === "const" ||
                local.kind === "module" ||
                (local.kind === "param" &&
                  (kind === "let" || kind === "const"));

              if (duplicate) {
                throw this.hub.buildError(
                  id,
                  'Duplicate declaration "' + name + '"',
                  TypeError
                );
              }
            };

            _proto.rename = function rename(oldName, newName, block) {
              var binding = this.getBinding(oldName);

              if (binding) {
                newName = newName || this.generateUidIdentifier(oldName).name;
                return new _renamer.default(binding, oldName, newName).rename(
                  block
                );
              }
            };

            _proto._renameFromMap = function _renameFromMap(
              map,
              oldName,
              newName,
              value
            ) {
              if (map[oldName]) {
                map[newName] = value;
                map[oldName] = null;
              }
            };

            _proto.dump = function dump() {
              var sep = (0, _repeat().default)("-", 60);
              console.log(sep);
              var scope = this;

              do {
                console.log("#", scope.block.type);

                for (var name in scope.bindings) {
                  var binding = scope.bindings[name];
                  console.log(" -", name, {
                    constant: binding.constant,
                    references: binding.references,
                    violations: binding.constantViolations.length,
                    kind: binding.kind,
                  });
                }
              } while ((scope = scope.parent));

              console.log(sep);
            };

            _proto.toArray = function toArray(node, i) {
              if (t().isIdentifier(node)) {
                var binding = this.getBinding(node.name);

                if (
                  binding &&
                  binding.constant &&
                  binding.path.isGenericType("Array")
                ) {
                  return node;
                }
              }

              if (t().isArrayExpression(node)) {
                return node;
              }

              if (
                t().isIdentifier(node, {
                  name: "arguments",
                })
              ) {
                return t().callExpression(
                  t().memberExpression(
                    t().memberExpression(
                      t().memberExpression(
                        t().identifier("Array"),
                        t().identifier("prototype")
                      ),
                      t().identifier("slice")
                    ),
                    t().identifier("call")
                  ),
                  [node]
                );
              }

              var helperName;
              var args = [node];

              if (i === true) {
                helperName = "toConsumableArray";
              } else if (i) {
                args.push(t().numericLiteral(i));
                helperName = "slicedToArray";
              } else {
                helperName = "toArray";
              }

              return t().callExpression(this.hub.addHelper(helperName), args);
            };

            _proto.hasLabel = function hasLabel(name) {
              return !!this.getLabel(name);
            };

            _proto.getLabel = function getLabel(name) {
              return this.labels.get(name);
            };

            _proto.registerLabel = function registerLabel(path) {
              this.labels.set(path.node.label.name, path);
            };

            _proto.registerDeclaration = function registerDeclaration(path) {
              if (path.isLabeledStatement()) {
                this.registerLabel(path);
              } else if (path.isFunctionDeclaration()) {
                this.registerBinding("hoisted", path.get("id"), path);
              } else if (path.isVariableDeclaration()) {
                var declarations = path.get("declarations");

                for (
                  var _iterator6 = declarations,
                    _isArray6 = Array.isArray(_iterator6),
                    _i6 = 0,
                    _iterator6 = _isArray6
                      ? _iterator6
                      : _iterator6[Symbol.iterator]();
                  ;

                ) {
                  var _ref6;

                  if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                  } else {
                    _i6 = _iterator6.next();
                    if (_i6.done) break;
                    _ref6 = _i6.value;
                  }

                  var declar = _ref6;
                  this.registerBinding(path.node.kind, declar);
                }
              } else if (path.isClassDeclaration()) {
                this.registerBinding("let", path);
              } else if (path.isImportDeclaration()) {
                var specifiers = path.get("specifiers");

                for (
                  var _iterator7 = specifiers,
                    _isArray7 = Array.isArray(_iterator7),
                    _i7 = 0,
                    _iterator7 = _isArray7
                      ? _iterator7
                      : _iterator7[Symbol.iterator]();
                  ;

                ) {
                  var _ref7;

                  if (_isArray7) {
                    if (_i7 >= _iterator7.length) break;
                    _ref7 = _iterator7[_i7++];
                  } else {
                    _i7 = _iterator7.next();
                    if (_i7.done) break;
                    _ref7 = _i7.value;
                  }

                  var specifier = _ref7;
                  this.registerBinding("module", specifier);
                }
              } else if (path.isExportDeclaration()) {
                var _declar = path.get("declaration");

                if (
                  _declar.isClassDeclaration() ||
                  _declar.isFunctionDeclaration() ||
                  _declar.isVariableDeclaration()
                ) {
                  this.registerDeclaration(_declar);
                }
              } else {
                this.registerBinding("unknown", path);
              }
            };

            _proto.buildUndefinedNode = function buildUndefinedNode() {
              if (this.hasBinding("undefined")) {
                return t().unaryExpression("void", t().numericLiteral(0), true);
              } else {
                return t().identifier("undefined");
              }
            };

            _proto.registerConstantViolation = function registerConstantViolation(
              path
            ) {
              var ids = path.getBindingIdentifiers();

              for (var name in ids) {
                var binding = this.getBinding(name);
                if (binding) binding.reassign(path);
              }
            };

            _proto.registerBinding = function registerBinding(
              kind,
              path,
              bindingPath
            ) {
              if (bindingPath === void 0) {
                bindingPath = path;
              }

              if (!kind) throw new ReferenceError("no `kind`");

              if (path.isVariableDeclaration()) {
                var declarators = path.get("declarations");

                for (
                  var _iterator8 = declarators,
                    _isArray8 = Array.isArray(_iterator8),
                    _i8 = 0,
                    _iterator8 = _isArray8
                      ? _iterator8
                      : _iterator8[Symbol.iterator]();
                  ;

                ) {
                  var _ref8;

                  if (_isArray8) {
                    if (_i8 >= _iterator8.length) break;
                    _ref8 = _iterator8[_i8++];
                  } else {
                    _i8 = _iterator8.next();
                    if (_i8.done) break;
                    _ref8 = _i8.value;
                  }

                  var declar = _ref8;
                  this.registerBinding(kind, declar);
                }

                return;
              }

              var parent = this.getProgramParent();
              var ids = path.getBindingIdentifiers(true);

              for (var name in ids) {
                for (
                  var _iterator9 = ids[name],
                    _isArray9 = Array.isArray(_iterator9),
                    _i9 = 0,
                    _iterator9 = _isArray9
                      ? _iterator9
                      : _iterator9[Symbol.iterator]();
                  ;

                ) {
                  var _ref9;

                  if (_isArray9) {
                    if (_i9 >= _iterator9.length) break;
                    _ref9 = _iterator9[_i9++];
                  } else {
                    _i9 = _iterator9.next();
                    if (_i9.done) break;
                    _ref9 = _i9.value;
                  }

                  var id = _ref9;
                  var local = this.getOwnBinding(name);

                  if (local) {
                    if (local.identifier === id) continue;
                    this.checkBlockScopedCollisions(local, kind, name, id);
                  }

                  parent.references[name] = true;

                  if (local) {
                    this.registerConstantViolation(bindingPath);
                  } else {
                    this.bindings[name] = new _binding.default({
                      identifier: id,
                      scope: this,
                      path: bindingPath,
                      kind: kind,
                    });
                  }
                }
              }
            };

            _proto.addGlobal = function addGlobal(node) {
              this.globals[node.name] = node;
            };

            _proto.hasUid = function hasUid(name) {
              var scope = this;

              do {
                if (scope.uids[name]) return true;
              } while ((scope = scope.parent));

              return false;
            };

            _proto.hasGlobal = function hasGlobal(name) {
              var scope = this;

              do {
                if (scope.globals[name]) return true;
              } while ((scope = scope.parent));

              return false;
            };

            _proto.hasReference = function hasReference(name) {
              var scope = this;

              do {
                if (scope.references[name]) return true;
              } while ((scope = scope.parent));

              return false;
            };

            _proto.isPure = function isPure(node, constantsOnly) {
              if (t().isIdentifier(node)) {
                var binding = this.getBinding(node.name);
                if (!binding) return false;
                if (constantsOnly) return binding.constant;
                return true;
              } else if (t().isClass(node)) {
                if (
                  node.superClass &&
                  !this.isPure(node.superClass, constantsOnly)
                ) {
                  return false;
                }

                return this.isPure(node.body, constantsOnly);
              } else if (t().isClassBody(node)) {
                for (
                  var _iterator10 = node.body,
                    _isArray10 = Array.isArray(_iterator10),
                    _i10 = 0,
                    _iterator10 = _isArray10
                      ? _iterator10
                      : _iterator10[Symbol.iterator]();
                  ;

                ) {
                  var _ref10;

                  if (_isArray10) {
                    if (_i10 >= _iterator10.length) break;
                    _ref10 = _iterator10[_i10++];
                  } else {
                    _i10 = _iterator10.next();
                    if (_i10.done) break;
                    _ref10 = _i10.value;
                  }

                  var method = _ref10;
                  if (!this.isPure(method, constantsOnly)) return false;
                }

                return true;
              } else if (t().isBinary(node)) {
                return (
                  this.isPure(node.left, constantsOnly) &&
                  this.isPure(node.right, constantsOnly)
                );
              } else if (t().isArrayExpression(node)) {
                for (
                  var _iterator11 = node.elements,
                    _isArray11 = Array.isArray(_iterator11),
                    _i11 = 0,
                    _iterator11 = _isArray11
                      ? _iterator11
                      : _iterator11[Symbol.iterator]();
                  ;

                ) {
                  var _ref11;

                  if (_isArray11) {
                    if (_i11 >= _iterator11.length) break;
                    _ref11 = _iterator11[_i11++];
                  } else {
                    _i11 = _iterator11.next();
                    if (_i11.done) break;
                    _ref11 = _i11.value;
                  }

                  var elem = _ref11;
                  if (!this.isPure(elem, constantsOnly)) return false;
                }

                return true;
              } else if (t().isObjectExpression(node)) {
                for (
                  var _iterator12 = node.properties,
                    _isArray12 = Array.isArray(_iterator12),
                    _i12 = 0,
                    _iterator12 = _isArray12
                      ? _iterator12
                      : _iterator12[Symbol.iterator]();
                  ;

                ) {
                  var _ref12;

                  if (_isArray12) {
                    if (_i12 >= _iterator12.length) break;
                    _ref12 = _iterator12[_i12++];
                  } else {
                    _i12 = _iterator12.next();
                    if (_i12.done) break;
                    _ref12 = _i12.value;
                  }

                  var prop = _ref12;
                  if (!this.isPure(prop, constantsOnly)) return false;
                }

                return true;
              } else if (t().isClassMethod(node)) {
                if (node.computed && !this.isPure(node.key, constantsOnly))
                  return false;
                if (node.kind === "get" || node.kind === "set") return false;
                return true;
              } else if (t().isProperty(node)) {
                if (node.computed && !this.isPure(node.key, constantsOnly))
                  return false;
                return this.isPure(node.value, constantsOnly);
              } else if (t().isUnaryExpression(node)) {
                return this.isPure(node.argument, constantsOnly);
              } else if (t().isTaggedTemplateExpression(node)) {
                return (
                  t().matchesPattern(node.tag, "String.raw") &&
                  !this.hasBinding("String", true) &&
                  this.isPure(node.quasi, constantsOnly)
                );
              } else if (t().isTemplateLiteral(node)) {
                for (
                  var _iterator13 = node.expressions,
                    _isArray13 = Array.isArray(_iterator13),
                    _i13 = 0,
                    _iterator13 = _isArray13
                      ? _iterator13
                      : _iterator13[Symbol.iterator]();
                  ;

                ) {
                  var _ref13;

                  if (_isArray13) {
                    if (_i13 >= _iterator13.length) break;
                    _ref13 = _iterator13[_i13++];
                  } else {
                    _i13 = _iterator13.next();
                    if (_i13.done) break;
                    _ref13 = _i13.value;
                  }

                  var expression = _ref13;
                  if (!this.isPure(expression, constantsOnly)) return false;
                }

                return true;
              } else {
                return t().isPureish(node);
              }
            };

            _proto.setData = function setData(key, val) {
              return (this.data[key] = val);
            };

            _proto.getData = function getData(key) {
              var scope = this;

              do {
                var data = scope.data[key];
                if (data != null) return data;
              } while ((scope = scope.parent));
            };

            _proto.removeData = function removeData(key) {
              var scope = this;

              do {
                var data = scope.data[key];
                if (data != null) scope.data[key] = null;
              } while ((scope = scope.parent));
            };

            _proto.init = function init() {
              if (!this.references) this.crawl();
            };

            _proto.crawl = function crawl() {
              var path = this.path;
              this.references = Object.create(null);
              this.bindings = Object.create(null);
              this.globals = Object.create(null);
              this.uids = Object.create(null);
              this.data = Object.create(null);

              if (path.isLoop()) {
                for (
                  var _iterator14 = t().FOR_INIT_KEYS,
                    _isArray14 = Array.isArray(_iterator14),
                    _i14 = 0,
                    _iterator14 = _isArray14
                      ? _iterator14
                      : _iterator14[Symbol.iterator]();
                  ;

                ) {
                  var _ref14;

                  if (_isArray14) {
                    if (_i14 >= _iterator14.length) break;
                    _ref14 = _iterator14[_i14++];
                  } else {
                    _i14 = _iterator14.next();
                    if (_i14.done) break;
                    _ref14 = _i14.value;
                  }

                  var key = _ref14;
                  var node = path.get(key);
                  if (node.isBlockScoped())
                    this.registerBinding(node.node.kind, node);
                }
              }

              if (path.isFunctionExpression() && path.has("id")) {
                if (!path.get("id").node[t().NOT_LOCAL_BINDING]) {
                  this.registerBinding("local", path.get("id"), path);
                }
              }

              if (path.isClassExpression() && path.has("id")) {
                if (!path.get("id").node[t().NOT_LOCAL_BINDING]) {
                  this.registerBinding("local", path);
                }
              }

              if (path.isFunction()) {
                var params = path.get("params");

                for (
                  var _iterator15 = params,
                    _isArray15 = Array.isArray(_iterator15),
                    _i15 = 0,
                    _iterator15 = _isArray15
                      ? _iterator15
                      : _iterator15[Symbol.iterator]();
                  ;

                ) {
                  var _ref15;

                  if (_isArray15) {
                    if (_i15 >= _iterator15.length) break;
                    _ref15 = _iterator15[_i15++];
                  } else {
                    _i15 = _iterator15.next();
                    if (_i15.done) break;
                    _ref15 = _i15.value;
                  }

                  var param = _ref15;
                  this.registerBinding("param", param);
                }
              }

              if (path.isCatchClause()) {
                this.registerBinding("let", path);
              }

              var parent = this.getProgramParent();
              if (parent.crawling) return;
              var state = {
                references: [],
                constantViolations: [],
                assignments: [],
              };
              this.crawling = true;
              path.traverse(collectorVisitor, state);
              this.crawling = false;

              for (
                var _iterator16 = state.assignments,
                  _isArray16 = Array.isArray(_iterator16),
                  _i16 = 0,
                  _iterator16 = _isArray16
                    ? _iterator16
                    : _iterator16[Symbol.iterator]();
                ;

              ) {
                var _ref16;

                if (_isArray16) {
                  if (_i16 >= _iterator16.length) break;
                  _ref16 = _iterator16[_i16++];
                } else {
                  _i16 = _iterator16.next();
                  if (_i16.done) break;
                  _ref16 = _i16.value;
                }

                var _path = _ref16;

                var ids = _path.getBindingIdentifiers();

                var programParent = void 0;

                for (var name in ids) {
                  if (_path.scope.getBinding(name)) continue;
                  programParent =
                    programParent || _path.scope.getProgramParent();
                  programParent.addGlobal(ids[name]);
                }

                _path.scope.registerConstantViolation(_path);
              }

              for (
                var _iterator17 = state.references,
                  _isArray17 = Array.isArray(_iterator17),
                  _i17 = 0,
                  _iterator17 = _isArray17
                    ? _iterator17
                    : _iterator17[Symbol.iterator]();
                ;

              ) {
                var _ref17;

                if (_isArray17) {
                  if (_i17 >= _iterator17.length) break;
                  _ref17 = _iterator17[_i17++];
                } else {
                  _i17 = _iterator17.next();
                  if (_i17.done) break;
                  _ref17 = _i17.value;
                }

                var ref = _ref17;
                var binding = ref.scope.getBinding(ref.node.name);

                if (binding) {
                  binding.reference(ref);
                } else {
                  ref.scope.getProgramParent().addGlobal(ref.node);
                }
              }

              for (
                var _iterator18 = state.constantViolations,
                  _isArray18 = Array.isArray(_iterator18),
                  _i18 = 0,
                  _iterator18 = _isArray18
                    ? _iterator18
                    : _iterator18[Symbol.iterator]();
                ;

              ) {
                var _ref18;

                if (_isArray18) {
                  if (_i18 >= _iterator18.length) break;
                  _ref18 = _iterator18[_i18++];
                } else {
                  _i18 = _iterator18.next();
                  if (_i18.done) break;
                  _ref18 = _i18.value;
                }

                var _path2 = _ref18;

                _path2.scope.registerConstantViolation(_path2);
              }
            };

            _proto.push = function push(opts) {
              var path = this.path;

              if (!path.isBlockStatement() && !path.isProgram()) {
                path = this.getBlockParent().path;
              }

              if (path.isSwitchStatement()) {
                path = (this.getFunctionParent() || this.getProgramParent())
                  .path;
              }

              if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
                path.ensureBlock();
                path = path.get("body");
              }

              var unique = opts.unique;
              var kind = opts.kind || "var";
              var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
              var dataKey = "declaration:" + kind + ":" + blockHoist;
              var declarPath = !unique && path.getData(dataKey);

              if (!declarPath) {
                var declar = t().variableDeclaration(kind, []);
                declar._blockHoist = blockHoist;

                var _path$unshiftContaine = path.unshiftContainer("body", [
                  declar,
                ]);

                declarPath = _path$unshiftContaine[0];
                if (!unique) path.setData(dataKey, declarPath);
              }

              var declarator = t().variableDeclarator(opts.id, opts.init);
              declarPath.node.declarations.push(declarator);
              this.registerBinding(kind, declarPath.get("declarations").pop());
            };

            _proto.getProgramParent = function getProgramParent() {
              var scope = this;

              do {
                if (scope.path.isProgram()) {
                  return scope;
                }
              } while ((scope = scope.parent));

              throw new Error("Couldn't find a Program");
            };

            _proto.getFunctionParent = function getFunctionParent() {
              var scope = this;

              do {
                if (scope.path.isFunctionParent()) {
                  return scope;
                }
              } while ((scope = scope.parent));

              return null;
            };

            _proto.getBlockParent = function getBlockParent() {
              var scope = this;

              do {
                if (scope.path.isBlockParent()) {
                  return scope;
                }
              } while ((scope = scope.parent));

              throw new Error(
                "We couldn't find a BlockStatement, For, Switch, Function, Loop or Program..."
              );
            };

            _proto.getAllBindings = function getAllBindings() {
              var ids = Object.create(null);
              var scope = this;

              do {
                (0, _defaults().default)(ids, scope.bindings);
                scope = scope.parent;
              } while (scope);

              return ids;
            };

            _proto.getAllBindingsOfKind = function getAllBindingsOfKind() {
              var ids = Object.create(null);

              for (
                var _iterator19 = arguments,
                  _isArray19 = Array.isArray(_iterator19),
                  _i19 = 0,
                  _iterator19 = _isArray19
                    ? _iterator19
                    : _iterator19[Symbol.iterator]();
                ;

              ) {
                var _ref19;

                if (_isArray19) {
                  if (_i19 >= _iterator19.length) break;
                  _ref19 = _iterator19[_i19++];
                } else {
                  _i19 = _iterator19.next();
                  if (_i19.done) break;
                  _ref19 = _i19.value;
                }

                var kind = _ref19;
                var scope = this;

                do {
                  for (var name in scope.bindings) {
                    var binding = scope.bindings[name];
                    if (binding.kind === kind) ids[name] = binding;
                  }

                  scope = scope.parent;
                } while (scope);
              }

              return ids;
            };

            _proto.bindingIdentifierEquals = function bindingIdentifierEquals(
              name,
              node
            ) {
              return this.getBindingIdentifier(name) === node;
            };

            _proto.getBinding = function getBinding(name) {
              var scope = this;

              do {
                var binding = scope.getOwnBinding(name);
                if (binding) return binding;
              } while ((scope = scope.parent));
            };

            _proto.getOwnBinding = function getOwnBinding(name) {
              return this.bindings[name];
            };

            _proto.getBindingIdentifier = function getBindingIdentifier(name) {
              var info = this.getBinding(name);
              return info && info.identifier;
            };

            _proto.getOwnBindingIdentifier = function getOwnBindingIdentifier(
              name
            ) {
              var binding = this.bindings[name];
              return binding && binding.identifier;
            };

            _proto.hasOwnBinding = function hasOwnBinding(name) {
              return !!this.getOwnBinding(name);
            };

            _proto.hasBinding = function hasBinding(name, noGlobals) {
              if (!name) return false;
              if (this.hasOwnBinding(name)) return true;
              if (this.parentHasBinding(name, noGlobals)) return true;
              if (this.hasUid(name)) return true;
              if (!noGlobals && (0, _includes().default)(Scope.globals, name))
                return true;
              if (
                !noGlobals &&
                (0, _includes().default)(Scope.contextVariables, name)
              )
                return true;
              return false;
            };

            _proto.parentHasBinding = function parentHasBinding(
              name,
              noGlobals
            ) {
              return this.parent && this.parent.hasBinding(name, noGlobals);
            };

            _proto.updateOwnBinding = function updateOwnBinding(
              id,
              kind,
              path
            ) {
              if (!kind) throw new ReferenceError("no `kind`");
              var binding = this.getOwnBinding(id.name);
              if (!binding)
                throw new ReferenceError("Unknown binding: " + id.name);
              binding.identifier = id;
              binding.kind = kind;
              binding.path = path;
            };

            _proto.moveBindingTo = function moveBindingTo(name, scope) {
              var info = this.getBinding(name);

              if (info) {
                info.scope.removeOwnBinding(name);
                info.scope = scope;
                scope.bindings[name] = info;
              }
            };

            _proto.removeOwnBinding = function removeOwnBinding(name) {
              delete this.bindings[name];
            };

            _proto.removeBinding = function removeBinding(name) {
              var info = this.getBinding(name);

              if (info) {
                info.scope.removeOwnBinding(name);
              }

              var scope = this;

              do {
                if (scope.uids[name]) {
                  scope.uids[name] = false;
                }
              } while ((scope = scope.parent));
            };

            _gerhobbelt_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(
              Scope,
              [
                {
                  key: "parent",
                  get: function get() {
                    var parent = this.path.findParent(function(p) {
                      return p.isScope();
                    });
                    return parent && parent.scope;
                  },
                },
                {
                  key: "parentBlock",
                  get: function get() {
                    return this.path.parent;
                  },
                },
                {
                  key: "hub",
                  get: function get() {
                    return this.path.hub;
                  },
                },
              ]
            );

            return Scope;
          })();

          exports.default = Scope;
          Scope.globals = Object.keys(_globals().default.builtin);
          Scope.contextVariables = [
            "arguments",
            "undefined",
            "Infinity",
            "NaN",
          ];
        },
        /* 138 */
        function(module, exports, __webpack_require__) {
          var baseRepeat = __webpack_require__(326),
            isIterateeCall = __webpack_require__(76),
            toInteger = __webpack_require__(74),
            toString = __webpack_require__(77);

          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
              n = 1;
            } else {
              n = toInteger(n);
            }

            return baseRepeat(toString(string), n);
          }

          module.exports = repeat;
        },
        /* 139 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          var Binding = (function() {
            function Binding(_ref) {
              var identifier = _ref.identifier,
                scope = _ref.scope,
                path = _ref.path,
                kind = _ref.kind;
              this.identifier = identifier;
              this.scope = scope;
              this.path = path;
              this.kind = kind;
              this.constantViolations = [];
              this.constant = true;
              this.referencePaths = [];
              this.referenced = false;
              this.references = 0;
              this.clearValue();
            }

            var _proto = Binding.prototype;

            _proto.deoptValue = function deoptValue() {
              this.clearValue();
              this.hasDeoptedValue = true;
            };

            _proto.setValue = function setValue(value) {
              if (this.hasDeoptedValue) return;
              this.hasValue = true;
              this.value = value;
            };

            _proto.clearValue = function clearValue() {
              this.hasDeoptedValue = false;
              this.hasValue = false;
              this.value = null;
            };

            _proto.reassign = function reassign(path) {
              this.constant = false;

              if (this.constantViolations.indexOf(path) !== -1) {
                return;
              }

              this.constantViolations.push(path);
            };

            _proto.reference = function reference(path) {
              if (this.referencePaths.indexOf(path) !== -1) {
                return;
              }

              this.referenced = true;
              this.references++;
              this.referencePaths.push(path);
            };

            _proto.dereference = function dereference() {
              this.references--;
              this.referenced = !!this.references;
            };

            return Binding;
          })();

          exports.default = Binding;
        },
        /* 140 */
        function(module, exports, __webpack_require__) {
          var identity = __webpack_require__(42),
            overRest = __webpack_require__(331),
            setToString = __webpack_require__(333);

          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }

          module.exports = baseRest;
        },
        /* 141 */
        function(module, exports, __webpack_require__) {
          exports.SourceMapGenerator = __webpack_require__(
            142
          ).SourceMapGenerator;
          exports.SourceMapConsumer = __webpack_require__(
            342
          ).SourceMapConsumer;
          exports.SourceNode = __webpack_require__(345).SourceNode;
        },
        /* 142 */
        function(module, exports, __webpack_require__) {
          var base64VLQ = __webpack_require__(143);

          var util = __webpack_require__(30);

          var ArraySet = __webpack_require__(144).ArraySet;

          var MappingList = __webpack_require__(341).MappingList;

          function SourceMapGenerator(aArgs) {
            if (!aArgs) {
              aArgs = {};
            }

            this._file = util.getArg(aArgs, "file", null);
            this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
            this._skipValidation = util.getArg(aArgs, "skipValidation", false);
            this._sources = new ArraySet();
            this._names = new ArraySet();
            this._mappings = new MappingList();
            this._sourcesContents = null;
          }

          SourceMapGenerator.prototype._version = 3;

          SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(
            aSourceMapConsumer
          ) {
            var sourceRoot = aSourceMapConsumer.sourceRoot;
            var generator = new SourceMapGenerator({
              file: aSourceMapConsumer.file,
              sourceRoot: sourceRoot,
            });
            aSourceMapConsumer.eachMapping(function(mapping) {
              var newMapping = {
                generated: {
                  line: mapping.generatedLine,
                  column: mapping.generatedColumn,
                },
              };

              if (mapping.source != null) {
                newMapping.source = mapping.source;

                if (sourceRoot != null) {
                  newMapping.source = util.relative(
                    sourceRoot,
                    newMapping.source
                  );
                }

                newMapping.original = {
                  line: mapping.originalLine,
                  column: mapping.originalColumn,
                };

                if (mapping.name != null) {
                  newMapping.name = mapping.name;
                }
              }

              generator.addMapping(newMapping);
            });
            aSourceMapConsumer.sources.forEach(function(sourceFile) {
              var sourceRelative = sourceFile;

              if (sourceRoot !== null) {
                sourceRelative = util.relative(sourceRoot, sourceFile);
              }

              if (!generator._sources.has(sourceRelative)) {
                generator._sources.add(sourceRelative);
              }

              var content = aSourceMapConsumer.sourceContentFor(sourceFile);

              if (content != null) {
                generator.setSourceContent(sourceFile, content);
              }
            });
            return generator;
          };

          SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(
            aArgs
          ) {
            var generated = util.getArg(aArgs, "generated");
            var original = util.getArg(aArgs, "original", null);
            var source = util.getArg(aArgs, "source", null);
            var name = util.getArg(aArgs, "name", null);

            if (!this._skipValidation) {
              this._validateMapping(generated, original, source, name);
            }

            if (source != null) {
              source = String(source);

              if (!this._sources.has(source)) {
                this._sources.add(source);
              }
            }

            if (name != null) {
              name = String(name);

              if (!this._names.has(name)) {
                this._names.add(name);
              }
            }

            this._mappings.add({
              generatedLine: generated.line,
              generatedColumn: generated.column,
              originalLine: original != null && original.line,
              originalColumn: original != null && original.column,
              source: source,
              name: name,
            });
          };

          SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(
            aSourceFile,
            aSourceContent
          ) {
            var source = aSourceFile;

            if (this._sourceRoot != null) {
              source = util.relative(this._sourceRoot, source);
            }

            if (aSourceContent != null) {
              if (!this._sourcesContents) {
                this._sourcesContents = Object.create(null);
              }

              this._sourcesContents[util.toSetString(source)] = aSourceContent;
            } else if (this._sourcesContents) {
              delete this._sourcesContents[util.toSetString(source)];

              if (Object.keys(this._sourcesContents).length === 0) {
                this._sourcesContents = null;
              }
            }
          };

          SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(
            aSourceMapConsumer,
            aSourceFile,
            aSourceMapPath
          ) {
            var sourceFile = aSourceFile;

            if (aSourceFile == null) {
              if (aSourceMapConsumer.file == null) {
                throw new Error(
                  "SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
                    'or the source map\'s "file" property. Both were omitted.'
                );
              }

              sourceFile = aSourceMapConsumer.file;
            }

            var sourceRoot = this._sourceRoot;

            if (sourceRoot != null) {
              sourceFile = util.relative(sourceRoot, sourceFile);
            }

            var newSources = new ArraySet();
            var newNames = new ArraySet();

            this._mappings.unsortedForEach(function(mapping) {
              if (
                mapping.source === sourceFile &&
                mapping.originalLine != null
              ) {
                var original = aSourceMapConsumer.originalPositionFor({
                  line: mapping.originalLine,
                  column: mapping.originalColumn,
                });

                if (original.source != null) {
                  mapping.source = original.source;

                  if (aSourceMapPath != null) {
                    mapping.source = util.join(aSourceMapPath, mapping.source);
                  }

                  if (sourceRoot != null) {
                    mapping.source = util.relative(sourceRoot, mapping.source);
                  }

                  mapping.originalLine = original.line;
                  mapping.originalColumn = original.column;

                  if (original.name != null) {
                    mapping.name = original.name;
                  }
                }
              }

              var source = mapping.source;

              if (source != null && !newSources.has(source)) {
                newSources.add(source);
              }

              var name = mapping.name;

              if (name != null && !newNames.has(name)) {
                newNames.add(name);
              }
            }, this);

            this._sources = newSources;
            this._names = newNames;
            aSourceMapConsumer.sources.forEach(function(sourceFile) {
              var content = aSourceMapConsumer.sourceContentFor(sourceFile);

              if (content != null) {
                if (aSourceMapPath != null) {
                  sourceFile = util.join(aSourceMapPath, sourceFile);
                }

                if (sourceRoot != null) {
                  sourceFile = util.relative(sourceRoot, sourceFile);
                }

                this.setSourceContent(sourceFile, content);
              }
            }, this);
          };

          SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(
            aGenerated,
            aOriginal,
            aSource,
            aName
          ) {
            if (
              aOriginal &&
              typeof aOriginal.line !== "number" &&
              typeof aOriginal.column !== "number"
            ) {
              throw new Error(
                "original.line and original.column are not numbers -- you probably meant to omit " +
                  "the original mapping entirely and only map the generated position. If so, pass " +
                  "null for the original mapping instead of an object with empty or null values."
              );
            }

            if (
              aGenerated &&
              "line" in aGenerated &&
              "column" in aGenerated &&
              aGenerated.line > 0 &&
              aGenerated.column >= 0 &&
              !aOriginal &&
              !aSource &&
              !aName
            ) {
              return;
            } else if (
              aGenerated &&
              "line" in aGenerated &&
              "column" in aGenerated &&
              aOriginal &&
              "line" in aOriginal &&
              "column" in aOriginal &&
              aGenerated.line > 0 &&
              aGenerated.column >= 0 &&
              aOriginal.line > 0 &&
              aOriginal.column >= 0 &&
              aSource
            ) {
              return;
            } else {
              throw new Error(
                "Invalid mapping: " +
                  JSON.stringify({
                    generated: aGenerated,
                    source: aSource,
                    original: aOriginal,
                    name: aName,
                  })
              );
            }
          };

          SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
            var previousGeneratedColumn = 0;
            var previousGeneratedLine = 1;
            var previousOriginalColumn = 0;
            var previousOriginalLine = 0;
            var previousName = 0;
            var previousSource = 0;
            var result = "";
            var next;
            var mapping;
            var nameIdx;
            var sourceIdx;

            var mappings = this._mappings.toArray();

            for (var i = 0, len = mappings.length; i < len; i++) {
              mapping = mappings[i];
              next = "";

              if (mapping.generatedLine !== previousGeneratedLine) {
                previousGeneratedColumn = 0;

                while (mapping.generatedLine !== previousGeneratedLine) {
                  next += ";";
                  previousGeneratedLine++;
                }
              } else {
                if (i > 0) {
                  if (
                    !util.compareByGeneratedPositionsInflated(
                      mapping,
                      mappings[i - 1]
                    )
                  ) {
                    continue;
                  }

                  next += ",";
                }
              }

              next += base64VLQ.encode(
                mapping.generatedColumn - previousGeneratedColumn
              );
              previousGeneratedColumn = mapping.generatedColumn;

              if (mapping.source != null) {
                sourceIdx = this._sources.indexOf(mapping.source);
                next += base64VLQ.encode(sourceIdx - previousSource);
                previousSource = sourceIdx;
                next += base64VLQ.encode(
                  mapping.originalLine - 1 - previousOriginalLine
                );
                previousOriginalLine = mapping.originalLine - 1;
                next += base64VLQ.encode(
                  mapping.originalColumn - previousOriginalColumn
                );
                previousOriginalColumn = mapping.originalColumn;

                if (mapping.name != null) {
                  nameIdx = this._names.indexOf(mapping.name);
                  next += base64VLQ.encode(nameIdx - previousName);
                  previousName = nameIdx;
                }
              }

              result += next;
            }

            return result;
          };

          SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(
            aSources,
            aSourceRoot
          ) {
            return aSources.map(function(source) {
              if (!this._sourcesContents) {
                return null;
              }

              if (aSourceRoot != null) {
                source = util.relative(aSourceRoot, source);
              }

              var key = util.toSetString(source);
              return Object.prototype.hasOwnProperty.call(
                this._sourcesContents,
                key
              )
                ? this._sourcesContents[key]
                : null;
            }, this);
          };

          SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
            var map = {
              version: this._version,
              sources: this._sources.toArray(),
              names: this._names.toArray(),
              mappings: this._serializeMappings(),
            };

            if (this._file != null) {
              map.file = this._file;
            }

            if (this._sourceRoot != null) {
              map.sourceRoot = this._sourceRoot;
            }

            if (this._sourcesContents) {
              map.sourcesContent = this._generateSourcesContent(
                map.sources,
                map.sourceRoot
              );
            }

            return map;
          };

          SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
            return JSON.stringify(this.toJSON());
          };

          exports.SourceMapGenerator = SourceMapGenerator;
        },
        /* 143 */
        function(module, exports, __webpack_require__) {
          var base64 = __webpack_require__(340);

          var VLQ_BASE_SHIFT = 5;
          var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
          var VLQ_BASE_MASK = VLQ_BASE - 1;
          var VLQ_CONTINUATION_BIT = VLQ_BASE;

          function toVLQSigned(aValue) {
            return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
          }

          function fromVLQSigned(aValue) {
            var isNegative = (aValue & 1) === 1;
            var shifted = aValue >> 1;
            return isNegative ? -shifted : shifted;
          }

          exports.encode = function base64VLQ_encode(aValue) {
            var encoded = "";
            var digit;
            var vlq = toVLQSigned(aValue);

            do {
              digit = vlq & VLQ_BASE_MASK;
              vlq >>>= VLQ_BASE_SHIFT;

              if (vlq > 0) {
                digit |= VLQ_CONTINUATION_BIT;
              }

              encoded += base64.encode(digit);
            } while (vlq > 0);

            return encoded;
          };

          exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
            var strLen = aStr.length;
            var result = 0;
            var shift = 0;
            var continuation, digit;

            do {
              if (aIndex >= strLen) {
                throw new Error("Expected more digits in base 64 VLQ value.");
              }

              digit = base64.decode(aStr.charCodeAt(aIndex++));

              if (digit === -1) {
                throw new Error(
                  "Invalid base64 digit: " + aStr.charAt(aIndex - 1)
                );
              }

              continuation = !!(digit & VLQ_CONTINUATION_BIT);
              digit &= VLQ_BASE_MASK;
              result = result + (digit << shift);
              shift += VLQ_BASE_SHIFT;
            } while (continuation);

            aOutParam.value = fromVLQSigned(result);
            aOutParam.rest = aIndex;
          };
        },
        /* 144 */
        function(module, exports, __webpack_require__) {
          var util = __webpack_require__(30);

          var has = Object.prototype.hasOwnProperty;
          var hasNativeMap = typeof Map !== "undefined";

          function ArraySet() {
            this._array = [];
            this._set = hasNativeMap ? new Map() : Object.create(null);
          }

          ArraySet.fromArray = function ArraySet_fromArray(
            aArray,
            aAllowDuplicates
          ) {
            var set = new ArraySet();

            for (var i = 0, len = aArray.length; i < len; i++) {
              set.add(aArray[i], aAllowDuplicates);
            }

            return set;
          };

          ArraySet.prototype.size = function ArraySet_size() {
            return hasNativeMap
              ? this._set.size
              : Object.getOwnPropertyNames(this._set).length;
          };

          ArraySet.prototype.add = function ArraySet_add(
            aStr,
            aAllowDuplicates
          ) {
            var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
            var isDuplicate = hasNativeMap
              ? this.has(aStr)
              : has.call(this._set, sStr);
            var idx = this._array.length;

            if (!isDuplicate || aAllowDuplicates) {
              this._array.push(aStr);
            }

            if (!isDuplicate) {
              if (hasNativeMap) {
                this._set.set(aStr, idx);
              } else {
                this._set[sStr] = idx;
              }
            }
          };

          ArraySet.prototype.has = function ArraySet_has(aStr) {
            if (hasNativeMap) {
              return this._set.has(aStr);
            } else {
              var sStr = util.toSetString(aStr);
              return has.call(this._set, sStr);
            }
          };

          ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
            if (hasNativeMap) {
              var idx = this._set.get(aStr);

              if (idx >= 0) {
                return idx;
              }
            } else {
              var sStr = util.toSetString(aStr);

              if (has.call(this._set, sStr)) {
                return this._set[sStr];
              }
            }

            throw new Error('"' + aStr + '" is not in the set.');
          };

          ArraySet.prototype.at = function ArraySet_at(aIdx) {
            if (aIdx >= 0 && aIdx < this._array.length) {
              return this._array[aIdx];
            }

            throw new Error("No element indexed by " + aIdx);
          };

          ArraySet.prototype.toArray = function ArraySet_toArray() {
            return this._array.slice();
          };

          exports.ArraySet = ArraySet;
        },
        /* 145 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.needsWhitespace = needsWhitespace;
          exports.needsWhitespaceBefore = needsWhitespaceBefore;
          exports.needsWhitespaceAfter = needsWhitespaceAfter;
          exports.needsParens = needsParens;

          var whitespace = _interopRequireWildcard(__webpack_require__(350));

          var parens = _interopRequireWildcard(__webpack_require__(351));

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function expandAliases(obj) {
            var newObj = {};

            function add(type, func) {
              var fn = newObj[type];
              newObj[type] = fn
                ? function(node, parent, stack) {
                    var result = fn(node, parent, stack);
                    return result == null ? func(node, parent, stack) : result;
                  }
                : func;
            }

            var _arr = Object.keys(obj);

            for (var _i = 0; _i < _arr.length; _i++) {
              var type = _arr[_i];
              var aliases = t().FLIPPED_ALIAS_KEYS[type];

              if (aliases) {
                for (
                  var _iterator = aliases,
                    _isArray = Array.isArray(_iterator),
                    _i2 = 0,
                    _iterator = _isArray
                      ? _iterator
                      : _iterator[Symbol.iterator]();
                  ;

                ) {
                  var _ref;

                  if (_isArray) {
                    if (_i2 >= _iterator.length) break;
                    _ref = _iterator[_i2++];
                  } else {
                    _i2 = _iterator.next();
                    if (_i2.done) break;
                    _ref = _i2.value;
                  }

                  var alias = _ref;
                  add(alias, obj[type]);
                }
              } else {
                add(type, obj[type]);
              }
            }

            return newObj;
          }

          var expandedParens = expandAliases(parens);
          var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
          var expandedWhitespaceList = expandAliases(whitespace.list);

          function find(obj, node, parent, printStack) {
            var fn = obj[node.type];
            return fn ? fn(node, parent, printStack) : null;
          }

          function isOrHasCallExpression(node) {
            if (t().isCallExpression(node)) {
              return true;
            }

            if (t().isMemberExpression(node)) {
              return (
                isOrHasCallExpression(node.object) ||
                (!node.computed && isOrHasCallExpression(node.property))
              );
            } else {
              return false;
            }
          }

          function needsWhitespace(node, parent, type) {
            if (!node) return 0;

            if (t().isExpressionStatement(node)) {
              node = node.expression;
            }

            var linesInfo = find(expandedWhitespaceNodes, node, parent);

            if (!linesInfo) {
              var items = find(expandedWhitespaceList, node, parent);

              if (items) {
                for (var i = 0; i < items.length; i++) {
                  linesInfo = needsWhitespace(items[i], node, type);
                  if (linesInfo) break;
                }
              }
            }

            if (typeof linesInfo === "object" && linesInfo !== null) {
              return linesInfo[type] || 0;
            }

            return 0;
          }

          function needsWhitespaceBefore(node, parent) {
            return needsWhitespace(node, parent, "before");
          }

          function needsWhitespaceAfter(node, parent) {
            return needsWhitespace(node, parent, "after");
          }

          function needsParens(node, parent, printStack) {
            if (!parent) return false;

            if (t().isNewExpression(parent) && parent.callee === node) {
              if (isOrHasCallExpression(node)) return true;
            }

            return find(expandedParens, node, parent, printStack);
          }
        },
        /* 146 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.ImportSpecifier = ImportSpecifier;
          exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
          exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
          exports.ExportSpecifier = ExportSpecifier;
          exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
          exports.ExportAllDeclaration = ExportAllDeclaration;
          exports.ExportNamedDeclaration = ExportNamedDeclaration;
          exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
          exports.ImportDeclaration = ImportDeclaration;
          exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function ImportSpecifier(node) {
            if (node.importKind === "type" || node.importKind === "typeof") {
              this.word(node.importKind);
              this.space();
            }

            this.print(node.imported, node);

            if (node.local && node.local.name !== node.imported.name) {
              this.space();
              this.word("as");
              this.space();
              this.print(node.local, node);
            }
          }

          function ImportDefaultSpecifier(node) {
            this.print(node.local, node);
          }

          function ExportDefaultSpecifier(node) {
            this.print(node.exported, node);
          }

          function ExportSpecifier(node) {
            this.print(node.local, node);

            if (node.exported && node.local.name !== node.exported.name) {
              this.space();
              this.word("as");
              this.space();
              this.print(node.exported, node);
            }
          }

          function ExportNamespaceSpecifier(node) {
            this.token("*");
            this.space();
            this.word("as");
            this.space();
            this.print(node.exported, node);
          }

          function ExportAllDeclaration(node) {
            this.word("export");
            this.space();

            if (node.exportKind === "type") {
              this.word("type");
              this.space();
            }

            this.token("*");
            this.space();
            this.word("from");
            this.space();
            this.print(node.source, node);
            this.semicolon();
          }

          function ExportNamedDeclaration(node) {
            if (
              this.format.decoratorsBeforeExport &&
              t().isClassDeclaration(node.declaration)
            ) {
              this.printJoin(node.declaration.decorators, node);
            }

            this.word("export");
            this.space();
            ExportDeclaration.apply(this, arguments);
          }

          function ExportDefaultDeclaration(node) {
            if (
              this.format.decoratorsBeforeExport &&
              t().isClassDeclaration(node.declaration)
            ) {
              this.printJoin(node.declaration.decorators, node);
            }

            this.word("export");
            this.space();
            this.word("default");
            this.space();
            ExportDeclaration.apply(this, arguments);
          }

          function ExportDeclaration(node) {
            if (node.declaration) {
              var declar = node.declaration;
              this.print(declar, node);
              if (!t().isStatement(declar)) this.semicolon();
            } else {
              if (node.exportKind === "type") {
                this.word("type");
                this.space();
              }

              var specifiers = node.specifiers.slice(0);
              var hasSpecial = false;

              while (true) {
                var first = specifiers[0];

                if (
                  t().isExportDefaultSpecifier(first) ||
                  t().isExportNamespaceSpecifier(first)
                ) {
                  hasSpecial = true;
                  this.print(specifiers.shift(), node);

                  if (specifiers.length) {
                    this.token(",");
                    this.space();
                  }
                } else {
                  break;
                }
              }

              if (specifiers.length || (!specifiers.length && !hasSpecial)) {
                this.token("{");

                if (specifiers.length) {
                  this.space();
                  this.printList(specifiers, node);
                  this.space();
                }

                this.token("}");
              }

              if (node.source) {
                this.space();
                this.word("from");
                this.space();
                this.print(node.source, node);
              }

              this.semicolon();
            }
          }

          function ImportDeclaration(node) {
            this.word("import");
            this.space();

            if (node.importKind === "type" || node.importKind === "typeof") {
              this.word(node.importKind);
              this.space();
            }

            var specifiers = node.specifiers.slice(0);

            if (specifiers && specifiers.length) {
              while (true) {
                var first = specifiers[0];

                if (
                  t().isImportDefaultSpecifier(first) ||
                  t().isImportNamespaceSpecifier(first)
                ) {
                  this.print(specifiers.shift(), node);

                  if (specifiers.length) {
                    this.token(",");
                    this.space();
                  }
                } else {
                  break;
                }
              }

              if (specifiers.length) {
                this.token("{");
                this.space();
                this.printList(specifiers, node);
                this.space();
                this.token("}");
              }

              this.space();
              this.word("from");
              this.space();
            }

            this.print(node.source, node);
            this.semicolon();
          }

          function ImportNamespaceSpecifier(node) {
            this.token("*");
            this.space();
            this.word("as");
            this.space();
            this.print(node.local, node);
          }
        },
        /* 147 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(global) {
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

            var base64 = __webpack_require__(359);

            var ieee754 = __webpack_require__(360);

            var isArray = __webpack_require__(361);

            exports.Buffer = Buffer;
            exports.SlowBuffer = SlowBuffer;
            exports.INSPECT_MAX_BYTES = 50;
            Buffer.TYPED_ARRAY_SUPPORT =
              global.TYPED_ARRAY_SUPPORT !== undefined
                ? global.TYPED_ARRAY_SUPPORT
                : typedArraySupport();
            exports.kMaxLength = kMaxLength();

            function typedArraySupport() {
              try {
                var arr = new Uint8Array(1);
                arr.__proto__ = {
                  __proto__: Uint8Array.prototype,
                  foo: function foo() {
                    return 42;
                  },
                };
                return (
                  arr.foo() === 42 &&
                  typeof arr.subarray === "function" &&
                  arr.subarray(1, 1).byteLength === 0
                );
              } catch (e) {
                return false;
              }
            }

            function kMaxLength() {
              return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
            }

            function createBuffer(that, length) {
              if (kMaxLength() < length) {
                throw new RangeError("Invalid typed array length");
              }

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                that = new Uint8Array(length);
                that.__proto__ = Buffer.prototype;
              } else {
                if (that === null) {
                  that = new Buffer(length);
                }

                that.length = length;
              }

              return that;
            }

            function Buffer(arg, encodingOrOffset, length) {
              if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                return new Buffer(arg, encodingOrOffset, length);
              }

              if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                  throw new Error(
                    "If encoding is specified then the first argument must be a string"
                  );
                }

                return allocUnsafe(this, arg);
              }

              return from(this, arg, encodingOrOffset, length);
            }

            Buffer.poolSize = 8192;

            Buffer._augment = function(arr) {
              arr.__proto__ = Buffer.prototype;
              return arr;
            };

            function from(that, value, encodingOrOffset, length) {
              if (typeof value === "number") {
                throw new TypeError('"value" argument must not be a number');
              }

              if (
                typeof ArrayBuffer !== "undefined" &&
                value instanceof ArrayBuffer
              ) {
                return fromArrayBuffer(that, value, encodingOrOffset, length);
              }

              if (typeof value === "string") {
                return fromString(that, value, encodingOrOffset);
              }

              return fromObject(that, value);
            }

            Buffer.from = function(value, encodingOrOffset, length) {
              return from(null, value, encodingOrOffset, length);
            };

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              Buffer.prototype.__proto__ = Uint8Array.prototype;
              Buffer.__proto__ = Uint8Array;

              if (
                typeof Symbol !== "undefined" &&
                Symbol.species &&
                Buffer[Symbol.species] === Buffer
              ) {
                Object.defineProperty(Buffer, Symbol.species, {
                  value: null,
                  configurable: true,
                });
              }
            }

            function assertSize(size) {
              if (typeof size !== "number") {
                throw new TypeError('"size" argument must be a number');
              } else if (size < 0) {
                throw new RangeError('"size" argument must not be negative');
              }
            }

            function alloc(that, size, fill, encoding) {
              assertSize(size);

              if (size <= 0) {
                return createBuffer(that, size);
              }

              if (fill !== undefined) {
                return typeof encoding === "string"
                  ? createBuffer(that, size).fill(fill, encoding)
                  : createBuffer(that, size).fill(fill);
              }

              return createBuffer(that, size);
            }

            Buffer.alloc = function(size, fill, encoding) {
              return alloc(null, size, fill, encoding);
            };

            function allocUnsafe(that, size) {
              assertSize(size);
              that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

              if (!Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < size; ++i) {
                  that[i] = 0;
                }
              }

              return that;
            }

            Buffer.allocUnsafe = function(size) {
              return allocUnsafe(null, size);
            };

            Buffer.allocUnsafeSlow = function(size) {
              return allocUnsafe(null, size);
            };

            function fromString(that, string, encoding) {
              if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
              }

              if (!Buffer.isEncoding(encoding)) {
                throw new TypeError(
                  '"encoding" must be a valid string encoding'
                );
              }

              var length = byteLength(string, encoding) | 0;
              that = createBuffer(that, length);
              var actual = that.write(string, encoding);

              if (actual !== length) {
                that = that.slice(0, actual);
              }

              return that;
            }

            function fromArrayLike(that, array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              that = createBuffer(that, length);

              for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
              }

              return that;
            }

            function fromArrayBuffer(that, array, byteOffset, length) {
              array.byteLength;

              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError("'offset' is out of bounds");
              }

              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError("'length' is out of bounds");
              }

              if (byteOffset === undefined && length === undefined) {
                array = new Uint8Array(array);
              } else if (length === undefined) {
                array = new Uint8Array(array, byteOffset);
              } else {
                array = new Uint8Array(array, byteOffset, length);
              }

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                that = array;
                that.__proto__ = Buffer.prototype;
              } else {
                that = fromArrayLike(that, array);
              }

              return that;
            }

            function fromObject(that, obj) {
              if (Buffer.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                that = createBuffer(that, len);

                if (that.length === 0) {
                  return that;
                }

                obj.copy(that, 0, 0, len);
                return that;
              }

              if (obj) {
                if (
                  (typeof ArrayBuffer !== "undefined" &&
                    obj.buffer instanceof ArrayBuffer) ||
                  "length" in obj
                ) {
                  if (typeof obj.length !== "number" || isnan(obj.length)) {
                    return createBuffer(that, 0);
                  }

                  return fromArrayLike(that, obj);
                }

                if (obj.type === "Buffer" && isArray(obj.data)) {
                  return fromArrayLike(that, obj.data);
                }
              }

              throw new TypeError(
                "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
              );
            }

            function checked(length) {
              if (length >= kMaxLength()) {
                throw new RangeError(
                  "Attempt to allocate Buffer larger than maximum " +
                    "size: 0x" +
                    kMaxLength().toString(16) +
                    " bytes"
                );
              }

              return length | 0;
            }

            function SlowBuffer(length) {
              if (+length != length) {
                length = 0;
              }

              return Buffer.alloc(+length);
            }

            Buffer.isBuffer = function isBuffer(b) {
              return !!(b != null && b._isBuffer);
            };

            Buffer.compare = function compare(a, b) {
              if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                throw new TypeError("Arguments must be Buffers");
              }

              if (a === b) return 0;
              var x = a.length;
              var y = b.length;

              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break;
                }
              }

              if (x < y) return -1;
              if (y < x) return 1;
              return 0;
            };

            Buffer.isEncoding = function isEncoding(encoding) {
              switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;

                default:
                  return false;
              }
            };

            Buffer.concat = function concat(list, length) {
              if (!isArray(list)) {
                throw new TypeError(
                  '"list" argument must be an Array of Buffers'
                );
              }

              if (list.length === 0) {
                return Buffer.alloc(0);
              }

              var i;

              if (length === undefined) {
                length = 0;

                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }

              var buffer = Buffer.allocUnsafe(length);
              var pos = 0;

              for (i = 0; i < list.length; ++i) {
                var buf = list[i];

                if (!Buffer.isBuffer(buf)) {
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                }

                buf.copy(buffer, pos);
                pos += buf.length;
              }

              return buffer;
            };

            function byteLength(string, encoding) {
              if (Buffer.isBuffer(string)) {
                return string.length;
              }

              if (
                typeof ArrayBuffer !== "undefined" &&
                typeof ArrayBuffer.isView === "function" &&
                (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)
              ) {
                return string.byteLength;
              }

              if (typeof string !== "string") {
                string = "" + string;
              }

              var len = string.length;
              if (len === 0) return 0;
              var loweredCase = false;

              for (;;) {
                switch (encoding) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;

                  case "utf8":
                  case "utf-8":
                  case undefined:
                    return utf8ToBytes(string).length;

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;

                  case "hex":
                    return len >>> 1;

                  case "base64":
                    return base64ToBytes(string).length;

                  default:
                    if (loweredCase) return utf8ToBytes(string).length;
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }

            Buffer.byteLength = byteLength;

            function slowToString(encoding, start, end) {
              var loweredCase = false;

              if (start === undefined || start < 0) {
                start = 0;
              }

              if (start > this.length) {
                return "";
              }

              if (end === undefined || end > this.length) {
                end = this.length;
              }

              if (end <= 0) {
                return "";
              }

              end >>>= 0;
              start >>>= 0;

              if (end <= start) {
                return "";
              }

              if (!encoding) encoding = "utf8";

              while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);

                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);

                  case "ascii":
                    return asciiSlice(this, start, end);

                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);

                  case "base64":
                    return base64Slice(this, start, end);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);

                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
              }
            }

            Buffer.prototype._isBuffer = true;

            function swap(b, n, m) {
              var i = b[n];
              b[n] = b[m];
              b[m] = i;
            }

            Buffer.prototype.swap16 = function swap16() {
              var len = this.length;

              if (len % 2 !== 0) {
                throw new RangeError(
                  "Buffer size must be a multiple of 16-bits"
                );
              }

              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }

              return this;
            };

            Buffer.prototype.swap32 = function swap32() {
              var len = this.length;

              if (len % 4 !== 0) {
                throw new RangeError(
                  "Buffer size must be a multiple of 32-bits"
                );
              }

              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }

              return this;
            };

            Buffer.prototype.swap64 = function swap64() {
              var len = this.length;

              if (len % 8 !== 0) {
                throw new RangeError(
                  "Buffer size must be a multiple of 64-bits"
                );
              }

              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }

              return this;
            };

            Buffer.prototype.toString = function toString() {
              var length = this.length | 0;
              if (length === 0) return "";
              if (arguments.length === 0) return utf8Slice(this, 0, length);
              return slowToString.apply(this, arguments);
            };

            Buffer.prototype.equals = function equals(b) {
              if (!Buffer.isBuffer(b))
                throw new TypeError("Argument must be a Buffer");
              if (this === b) return true;
              return Buffer.compare(this, b) === 0;
            };

            Buffer.prototype.inspect = function inspect() {
              var str = "";
              var max = exports.INSPECT_MAX_BYTES;

              if (this.length > 0) {
                str = this.toString("hex", 0, max)
                  .match(/.{2}/g)
                  .join(" ");
                if (this.length > max) str += " ... ";
              }

              return "<Buffer " + str + ">";
            };

            Buffer.prototype.compare = function compare(
              target,
              start,
              end,
              thisStart,
              thisEnd
            ) {
              if (!Buffer.isBuffer(target)) {
                throw new TypeError("Argument must be a Buffer");
              }

              if (start === undefined) {
                start = 0;
              }

              if (end === undefined) {
                end = target ? target.length : 0;
              }

              if (thisStart === undefined) {
                thisStart = 0;
              }

              if (thisEnd === undefined) {
                thisEnd = this.length;
              }

              if (
                start < 0 ||
                end > target.length ||
                thisStart < 0 ||
                thisEnd > this.length
              ) {
                throw new RangeError("out of range index");
              }

              if (thisStart >= thisEnd && start >= end) {
                return 0;
              }

              if (thisStart >= thisEnd) {
                return -1;
              }

              if (start >= end) {
                return 1;
              }

              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;
              if (this === target) return 0;
              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);
              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);

              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break;
                }
              }

              if (x < y) return -1;
              if (y < x) return 1;
              return 0;
            };

            function bidirectionalIndexOf(
              buffer,
              val,
              byteOffset,
              encoding,
              dir
            ) {
              if (buffer.length === 0) return -1;

              if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 0x7fffffff) {
                byteOffset = 0x7fffffff;
              } else if (byteOffset < -0x80000000) {
                byteOffset = -0x80000000;
              }

              byteOffset = +byteOffset;

              if (isNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer.length - 1;
              }

              if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

              if (byteOffset >= buffer.length) {
                if (dir) return -1;
                else byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir) byteOffset = 0;
                else return -1;
              }

              if (typeof val === "string") {
                val = Buffer.from(val, encoding);
              }

              if (Buffer.isBuffer(val)) {
                if (val.length === 0) {
                  return -1;
                }

                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
              } else if (typeof val === "number") {
                val = val & 0xff;

                if (
                  Buffer.TYPED_ARRAY_SUPPORT &&
                  typeof Uint8Array.prototype.indexOf === "function"
                ) {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(
                      buffer,
                      val,
                      byteOffset
                    );
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(
                      buffer,
                      val,
                      byteOffset
                    );
                  }
                }

                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
              }

              throw new TypeError("val must be string, number or Buffer");
            }

            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;

              if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase();

                if (
                  encoding === "ucs2" ||
                  encoding === "ucs-2" ||
                  encoding === "utf16le" ||
                  encoding === "utf-16le"
                ) {
                  if (arr.length < 2 || val.length < 2) {
                    return -1;
                  }

                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }

              function read(buf, i) {
                if (indexSize === 1) {
                  return buf[i];
                } else {
                  return buf.readUInt16BE(i * indexSize);
                }
              }

              var i;

              if (dir) {
                var foundIndex = -1;

                for (i = byteOffset; i < arrLength; i++) {
                  if (
                    read(arr, i) ===
                    read(val, foundIndex === -1 ? 0 : i - foundIndex)
                  ) {
                    if (foundIndex === -1) foundIndex = i;
                    if (i - foundIndex + 1 === valLength)
                      return foundIndex * indexSize;
                  } else {
                    if (foundIndex !== -1) i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength)
                  byteOffset = arrLength - valLength;

                for (i = byteOffset; i >= 0; i--) {
                  var found = true;

                  for (var j = 0; j < valLength; j++) {
                    if (read(arr, i + j) !== read(val, j)) {
                      found = false;
                      break;
                    }
                  }

                  if (found) return i;
                }
              }

              return -1;
            }

            Buffer.prototype.includes = function includes(
              val,
              byteOffset,
              encoding
            ) {
              return this.indexOf(val, byteOffset, encoding) !== -1;
            };

            Buffer.prototype.indexOf = function indexOf(
              val,
              byteOffset,
              encoding
            ) {
              return bidirectionalIndexOf(
                this,
                val,
                byteOffset,
                encoding,
                true
              );
            };

            Buffer.prototype.lastIndexOf = function lastIndexOf(
              val,
              byteOffset,
              encoding
            ) {
              return bidirectionalIndexOf(
                this,
                val,
                byteOffset,
                encoding,
                false
              );
            };

            function hexWrite(buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;

              if (!length) {
                length = remaining;
              } else {
                length = Number(length);

                if (length > remaining) {
                  length = remaining;
                }
              }

              var strLen = string.length;
              if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");

              if (length > strLen / 2) {
                length = strLen / 2;
              }

              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (isNaN(parsed)) return i;
                buf[offset + i] = parsed;
              }

              return i;
            }

            function utf8Write(buf, string, offset, length) {
              return blitBuffer(
                utf8ToBytes(string, buf.length - offset),
                buf,
                offset,
                length
              );
            }

            function asciiWrite(buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length);
            }

            function latin1Write(buf, string, offset, length) {
              return asciiWrite(buf, string, offset, length);
            }

            function base64Write(buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length);
            }

            function ucs2Write(buf, string, offset, length) {
              return blitBuffer(
                utf16leToBytes(string, buf.length - offset),
                buf,
                offset,
                length
              );
            }

            Buffer.prototype.write = function write(
              string,
              offset,
              length,
              encoding
            ) {
              if (offset === undefined) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
              } else if (length === undefined && typeof offset === "string") {
                encoding = offset;
                length = this.length;
                offset = 0;
              } else if (isFinite(offset)) {
                offset = offset | 0;

                if (isFinite(length)) {
                  length = length | 0;
                  if (encoding === undefined) encoding = "utf8";
                } else {
                  encoding = length;
                  length = undefined;
                }
              } else {
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              }

              var remaining = this.length - offset;
              if (length === undefined || length > remaining)
                length = remaining;

              if (
                (string.length > 0 && (length < 0 || offset < 0)) ||
                offset > this.length
              ) {
                throw new RangeError("Attempt to write outside buffer bounds");
              }

              if (!encoding) encoding = "utf8";
              var loweredCase = false;

              for (;;) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset, length);

                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset, length);

                  case "ascii":
                    return asciiWrite(this, string, offset, length);

                  case "latin1":
                  case "binary":
                    return latin1Write(this, string, offset, length);

                  case "base64":
                    return base64Write(this, string, offset, length);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset, length);

                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };

            Buffer.prototype.toJSON = function toJSON() {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0),
              };
            };

            function base64Slice(buf, start, end) {
              if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
              } else {
                return base64.fromByteArray(buf.slice(start, end));
              }
            }

            function utf8Slice(buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];
              var i = start;

              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence =
                  firstByte > 0xef
                    ? 4
                    : firstByte > 0xdf
                      ? 3
                      : firstByte > 0xbf
                        ? 2
                        : 1;

                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;

                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 0x80) {
                        codePoint = firstByte;
                      }

                      break;

                    case 2:
                      secondByte = buf[i + 1];

                      if ((secondByte & 0xc0) === 0x80) {
                        tempCodePoint =
                          ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);

                        if (tempCodePoint > 0x7f) {
                          codePoint = tempCodePoint;
                        }
                      }

                      break;

                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];

                      if (
                        (secondByte & 0xc0) === 0x80 &&
                        (thirdByte & 0xc0) === 0x80
                      ) {
                        tempCodePoint =
                          ((firstByte & 0xf) << 0xc) |
                          ((secondByte & 0x3f) << 0x6) |
                          (thirdByte & 0x3f);

                        if (
                          tempCodePoint > 0x7ff &&
                          (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
                        ) {
                          codePoint = tempCodePoint;
                        }
                      }

                      break;

                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];

                      if (
                        (secondByte & 0xc0) === 0x80 &&
                        (thirdByte & 0xc0) === 0x80 &&
                        (fourthByte & 0xc0) === 0x80
                      ) {
                        tempCodePoint =
                          ((firstByte & 0xf) << 0x12) |
                          ((secondByte & 0x3f) << 0xc) |
                          ((thirdByte & 0x3f) << 0x6) |
                          (fourthByte & 0x3f);

                        if (
                          tempCodePoint > 0xffff &&
                          tempCodePoint < 0x110000
                        ) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }

                if (codePoint === null) {
                  codePoint = 0xfffd;
                  bytesPerSequence = 1;
                } else if (codePoint > 0xffff) {
                  codePoint -= 0x10000;
                  res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
                  codePoint = 0xdc00 | (codePoint & 0x3ff);
                }

                res.push(codePoint);
                i += bytesPerSequence;
              }

              return decodeCodePointsArray(res);
            }

            var MAX_ARGUMENTS_LENGTH = 0x1000;

            function decodeCodePointsArray(codePoints) {
              var len = codePoints.length;

              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
              }

              var res = "";
              var i = 0;

              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
                );
              }

              return res;
            }

            function asciiSlice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 0x7f);
              }

              return ret;
            }

            function latin1Slice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }

              return ret;
            }

            function hexSlice(buf, start, end) {
              var len = buf.length;
              if (!start || start < 0) start = 0;
              if (!end || end < 0 || end > len) end = len;
              var out = "";

              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }

              return out;
            }

            function utf16leSlice(buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = "";

              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }

              return res;
            }

            Buffer.prototype.slice = function slice(start, end) {
              var len = this.length;
              start = ~~start;
              end = end === undefined ? len : ~~end;

              if (start < 0) {
                start += len;
                if (start < 0) start = 0;
              } else if (start > len) {
                start = len;
              }

              if (end < 0) {
                end += len;
                if (end < 0) end = 0;
              } else if (end > len) {
                end = len;
              }

              if (end < start) end = start;
              var newBuf;

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = this.subarray(start, end);
                newBuf.__proto__ = Buffer.prototype;
              } else {
                var sliceLen = end - start;
                newBuf = new Buffer(sliceLen, undefined);

                for (var i = 0; i < sliceLen; ++i) {
                  newBuf[i] = this[i + start];
                }
              }

              return newBuf;
            };

            function checkOffset(offset, ext, length) {
              if (offset % 1 !== 0 || offset < 0)
                throw new RangeError("offset is not uint");
              if (offset + ext > length)
                throw new RangeError("Trying to access beyond buffer length");
            }

            Buffer.prototype.readUIntLE = function readUIntLE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);
              var val = this[offset];
              var mul = 1;
              var i = 0;

              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }

              return val;
            };

            Buffer.prototype.readUIntBE = function readUIntBE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset | 0;
              byteLength = byteLength | 0;

              if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
              }

              var val = this[offset + --byteLength];
              var mul = 1;

              while (byteLength > 0 && (mul *= 0x100)) {
                val += this[offset + --byteLength] * mul;
              }

              return val;
            };

            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              return this[offset];
            };

            Buffer.prototype.readUInt16LE = function readUInt16LE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return this[offset] | (this[offset + 1] << 8);
            };

            Buffer.prototype.readUInt16BE = function readUInt16BE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return (this[offset] << 8) | this[offset + 1];
            };

            Buffer.prototype.readUInt32LE = function readUInt32LE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return (
                (this[offset] |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16)) +
                this[offset + 3] * 0x1000000
              );
            };

            Buffer.prototype.readUInt32BE = function readUInt32BE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return (
                this[offset] * 0x1000000 +
                ((this[offset + 1] << 16) |
                  (this[offset + 2] << 8) |
                  this[offset + 3])
              );
            };

            Buffer.prototype.readIntLE = function readIntLE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);
              var val = this[offset];
              var mul = 1;
              var i = 0;

              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }

              mul *= 0x80;
              if (val >= mul) val -= Math.pow(2, 8 * byteLength);
              return val;
            };

            Buffer.prototype.readIntBE = function readIntBE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);
              var i = byteLength;
              var mul = 1;
              var val = this[offset + --i];

              while (i > 0 && (mul *= 0x100)) {
                val += this[offset + --i] * mul;
              }

              mul *= 0x80;
              if (val >= mul) val -= Math.pow(2, 8 * byteLength);
              return val;
            };

            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              if (!(this[offset] & 0x80)) return this[offset];
              return (0xff - this[offset] + 1) * -1;
            };

            Buffer.prototype.readInt16LE = function readInt16LE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset] | (this[offset + 1] << 8);
              return val & 0x8000 ? val | 0xffff0000 : val;
            };

            Buffer.prototype.readInt16BE = function readInt16BE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | (this[offset] << 8);
              return val & 0x8000 ? val | 0xffff0000 : val;
            };

            Buffer.prototype.readInt32LE = function readInt32LE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return (
                this[offset] |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
              );
            };

            Buffer.prototype.readInt32BE = function readInt32BE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return (
                (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3]
              );
            };

            Buffer.prototype.readFloatLE = function readFloatLE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, true, 23, 4);
            };

            Buffer.prototype.readFloatBE = function readFloatBE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, false, 23, 4);
            };

            Buffer.prototype.readDoubleLE = function readDoubleLE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, true, 52, 8);
            };

            Buffer.prototype.readDoubleBE = function readDoubleBE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, false, 52, 8);
            };

            function checkInt(buf, value, offset, ext, max, min) {
              if (!Buffer.isBuffer(buf))
                throw new TypeError(
                  '"buffer" argument must be a Buffer instance'
                );
              if (value > max || value < min)
                throw new RangeError('"value" argument is out of bounds');
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
            }

            Buffer.prototype.writeUIntLE = function writeUIntLE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;

              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var mul = 1;
              var i = 0;
              this[offset] = value & 0xff;

              while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeUIntBE = function writeUIntBE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;

              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var i = byteLength - 1;
              var mul = 1;
              this[offset + i] = value & 0xff;

              while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeUInt8 = function writeUInt8(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              this[offset] = value & 0xff;
              return offset + 1;
            };

            function objectWriteUInt16(buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffff + value + 1;

              for (
                var i = 0, j = Math.min(buf.length - offset, 2);
                i < j;
                ++i
              ) {
                buf[offset + i] =
                  (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                  ((littleEndian ? i : 1 - i) * 8);
              }
            }

            Buffer.prototype.writeUInt16LE = function writeUInt16LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value & 0xff;
                this[offset + 1] = value >>> 8;
              } else {
                objectWriteUInt16(this, value, offset, true);
              }

              return offset + 2;
            };

            Buffer.prototype.writeUInt16BE = function writeUInt16BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = value & 0xff;
              } else {
                objectWriteUInt16(this, value, offset, false);
              }

              return offset + 2;
            };

            function objectWriteUInt32(buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffffffff + value + 1;

              for (
                var i = 0, j = Math.min(buf.length - offset, 4);
                i < j;
                ++i
              ) {
                buf[offset + i] =
                  (value >>> ((littleEndian ? i : 3 - i) * 8)) & 0xff;
              }
            }

            Buffer.prototype.writeUInt32LE = function writeUInt32LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = value >>> 24;
                this[offset + 2] = value >>> 16;
                this[offset + 1] = value >>> 8;
                this[offset] = value & 0xff;
              } else {
                objectWriteUInt32(this, value, offset, true);
              }

              return offset + 4;
            };

            Buffer.prototype.writeUInt32BE = function writeUInt32BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 0xff;
              } else {
                objectWriteUInt32(this, value, offset, false);
              }

              return offset + 4;
            };

            Buffer.prototype.writeIntLE = function writeIntLE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;

              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 0xff;

              while (++i < byteLength && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }

                this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeIntBE = function writeIntBE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;

              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = byteLength - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 0xff;

              while (--i >= 0 && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }

                this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeInt8 = function writeInt8(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              if (value < 0) value = 0xff + value + 1;
              this[offset] = value & 0xff;
              return offset + 1;
            };

            Buffer.prototype.writeInt16LE = function writeInt16LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value & 0xff;
                this[offset + 1] = value >>> 8;
              } else {
                objectWriteUInt16(this, value, offset, true);
              }

              return offset + 2;
            };

            Buffer.prototype.writeInt16BE = function writeInt16BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = value & 0xff;
              } else {
                objectWriteUInt16(this, value, offset, false);
              }

              return offset + 2;
            };

            Buffer.prototype.writeInt32LE = function writeInt32LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value & 0xff;
                this[offset + 1] = value >>> 8;
                this[offset + 2] = value >>> 16;
                this[offset + 3] = value >>> 24;
              } else {
                objectWriteUInt32(this, value, offset, true);
              }

              return offset + 4;
            };

            Buffer.prototype.writeInt32BE = function writeInt32BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (value < 0) value = 0xffffffff + value + 1;

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 0xff;
              } else {
                objectWriteUInt32(this, value, offset, false);
              }

              return offset + 4;
            };

            function checkIEEE754(buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
              if (offset < 0) throw new RangeError("Index out of range");
            }

            function writeFloat(buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(
                  buf,
                  value,
                  offset,
                  4,
                  3.4028234663852886e38,
                  -3.4028234663852886e38
                );
              }

              ieee754.write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4;
            }

            Buffer.prototype.writeFloatLE = function writeFloatLE(
              value,
              offset,
              noAssert
            ) {
              return writeFloat(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeFloatBE = function writeFloatBE(
              value,
              offset,
              noAssert
            ) {
              return writeFloat(this, value, offset, false, noAssert);
            };

            function writeDouble(buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(
                  buf,
                  value,
                  offset,
                  8,
                  1.7976931348623157e308,
                  -1.7976931348623157e308
                );
              }

              ieee754.write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8;
            }

            Buffer.prototype.writeDoubleLE = function writeDoubleLE(
              value,
              offset,
              noAssert
            ) {
              return writeDouble(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeDoubleBE = function writeDoubleBE(
              value,
              offset,
              noAssert
            ) {
              return writeDouble(this, value, offset, false, noAssert);
            };

            Buffer.prototype.copy = function copy(
              target,
              targetStart,
              start,
              end
            ) {
              if (!start) start = 0;
              if (!end && end !== 0) end = this.length;
              if (targetStart >= target.length) targetStart = target.length;
              if (!targetStart) targetStart = 0;
              if (end > 0 && end < start) end = start;
              if (end === start) return 0;
              if (target.length === 0 || this.length === 0) return 0;

              if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
              }

              if (start < 0 || start >= this.length)
                throw new RangeError("sourceStart out of bounds");
              if (end < 0) throw new RangeError("sourceEnd out of bounds");
              if (end > this.length) end = this.length;

              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }

              var len = end - start;
              var i;

              if (this === target && start < targetStart && targetStart < end) {
                for (i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                for (i = 0; i < len; ++i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, start + len),
                  targetStart
                );
              }

              return len;
            };

            Buffer.prototype.fill = function fill(val, start, end, encoding) {
              if (typeof val === "string") {
                if (typeof start === "string") {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === "string") {
                  encoding = end;
                  end = this.length;
                }

                if (val.length === 1) {
                  var code = val.charCodeAt(0);

                  if (code < 256) {
                    val = code;
                  }
                }

                if (encoding !== undefined && typeof encoding !== "string") {
                  throw new TypeError("encoding must be a string");
                }

                if (
                  typeof encoding === "string" &&
                  !Buffer.isEncoding(encoding)
                ) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
              } else if (typeof val === "number") {
                val = val & 255;
              }

              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
              }

              if (end <= start) {
                return this;
              }

              start = start >>> 0;
              end = end === undefined ? this.length : end >>> 0;
              if (!val) val = 0;
              var i;

              if (typeof val === "number") {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = Buffer.isBuffer(val)
                  ? val
                  : utf8ToBytes(new Buffer(val, encoding).toString());
                var len = bytes.length;

                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }

              return this;
            };

            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

            function base64clean(str) {
              str = stringtrim(str).replace(INVALID_BASE64_RE, "");
              if (str.length < 2) return "";

              while (str.length % 4 !== 0) {
                str = str + "=";
              }

              return str;
            }

            function stringtrim(str) {
              if (str.trim) return str.trim();
              return str.replace(/^\s+|\s+$/g, "");
            }

            function toHex(n) {
              if (n < 16) return "0" + n.toString(16);
              return n.toString(16);
            }

            function utf8ToBytes(string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];

              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);

                if (codePoint > 0xd7ff && codePoint < 0xe000) {
                  if (!leadSurrogate) {
                    if (codePoint > 0xdbff) {
                      if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                      continue;
                    } else if (i + 1 === length) {
                      if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                      continue;
                    }

                    leadSurrogate = codePoint;
                    continue;
                  }

                  if (codePoint < 0xdc00) {
                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                    leadSurrogate = codePoint;
                    continue;
                  }

                  codePoint =
                    (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +
                    0x10000;
                } else if (leadSurrogate) {
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                }

                leadSurrogate = null;

                if (codePoint < 0x80) {
                  if ((units -= 1) < 0) break;
                  bytes.push(codePoint);
                } else if (codePoint < 0x800) {
                  if ((units -= 2) < 0) break;
                  bytes.push(
                    (codePoint >> 0x6) | 0xc0,
                    (codePoint & 0x3f) | 0x80
                  );
                } else if (codePoint < 0x10000) {
                  if ((units -= 3) < 0) break;
                  bytes.push(
                    (codePoint >> 0xc) | 0xe0,
                    ((codePoint >> 0x6) & 0x3f) | 0x80,
                    (codePoint & 0x3f) | 0x80
                  );
                } else if (codePoint < 0x110000) {
                  if ((units -= 4) < 0) break;
                  bytes.push(
                    (codePoint >> 0x12) | 0xf0,
                    ((codePoint >> 0xc) & 0x3f) | 0x80,
                    ((codePoint >> 0x6) & 0x3f) | 0x80,
                    (codePoint & 0x3f) | 0x80
                  );
                } else {
                  throw new Error("Invalid code point");
                }
              }

              return bytes;
            }

            function asciiToBytes(str) {
              var byteArray = [];

              for (var i = 0; i < str.length; ++i) {
                byteArray.push(str.charCodeAt(i) & 0xff);
              }

              return byteArray;
            }

            function utf16leToBytes(str, units) {
              var c, hi, lo;
              var byteArray = [];

              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }

              return byteArray;
            }

            function base64ToBytes(str) {
              return base64.toByteArray(base64clean(str));
            }

            function blitBuffer(src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src.length) break;
                dst[i + offset] = src[i];
              }

              return i;
            }

            function isnan(val) {
              return val !== val;
            }
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(24)));
        },
        /* 148 */
        function(module, exports, __webpack_require__) {
          var cssKeywords = __webpack_require__(377);

          var reverseKeywords = {};

          for (var key in cssKeywords) {
            if (cssKeywords.hasOwnProperty(key)) {
              reverseKeywords[cssKeywords[key]] = key;
            }
          }

          var convert = (module.exports = {
            rgb: {
              channels: 3,
              labels: "rgb",
            },
            hsl: {
              channels: 3,
              labels: "hsl",
            },
            hsv: {
              channels: 3,
              labels: "hsv",
            },
            hwb: {
              channels: 3,
              labels: "hwb",
            },
            cmyk: {
              channels: 4,
              labels: "cmyk",
            },
            xyz: {
              channels: 3,
              labels: "xyz",
            },
            lab: {
              channels: 3,
              labels: "lab",
            },
            lch: {
              channels: 3,
              labels: "lch",
            },
            hex: {
              channels: 1,
              labels: ["hex"],
            },
            keyword: {
              channels: 1,
              labels: ["keyword"],
            },
            ansi16: {
              channels: 1,
              labels: ["ansi16"],
            },
            ansi256: {
              channels: 1,
              labels: ["ansi256"],
            },
            hcg: {
              channels: 3,
              labels: ["h", "c", "g"],
            },
            apple: {
              channels: 3,
              labels: ["r16", "g16", "b16"],
            },
            gray: {
              channels: 1,
              labels: ["gray"],
            },
          });

          for (var model in convert) {
            if (convert.hasOwnProperty(model)) {
              if (!("channels" in convert[model])) {
                throw new Error("missing channels property: " + model);
              }

              if (!("labels" in convert[model])) {
                throw new Error("missing channel labels property: " + model);
              }

              if (convert[model].labels.length !== convert[model].channels) {
                throw new Error("channel and label counts mismatch: " + model);
              }

              var channels = convert[model].channels;
              var labels = convert[model].labels;
              delete convert[model].channels;
              delete convert[model].labels;
              Object.defineProperty(convert[model], "channels", {
                value: channels,
              });
              Object.defineProperty(convert[model], "labels", {
                value: labels,
              });
            }
          }

          convert.rgb.hsl = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var min = Math.min(r, g, b);
            var max = Math.max(r, g, b);
            var delta = max - min;
            var h;
            var s;
            var l;

            if (max === min) {
              h = 0;
            } else if (r === max) {
              h = (g - b) / delta;
            } else if (g === max) {
              h = 2 + (b - r) / delta;
            } else if (b === max) {
              h = 4 + (r - g) / delta;
            }

            h = Math.min(h * 60, 360);

            if (h < 0) {
              h += 360;
            }

            l = (min + max) / 2;

            if (max === min) {
              s = 0;
            } else if (l <= 0.5) {
              s = delta / (max + min);
            } else {
              s = delta / (2 - max - min);
            }

            return [h, s * 100, l * 100];
          };

          convert.rgb.hsv = function(rgb) {
            var rdif;
            var gdif;
            var bdif;
            var h;
            var s;
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var v = Math.max(r, g, b);
            var diff = v - Math.min(r, g, b);

            var diffc = function diffc(c) {
              return (v - c) / 6 / diff + 1 / 2;
            };

            if (diff === 0) {
              h = s = 0;
            } else {
              s = diff / v;
              rdif = diffc(r);
              gdif = diffc(g);
              bdif = diffc(b);

              if (r === v) {
                h = bdif - gdif;
              } else if (g === v) {
                h = 1 / 3 + rdif - bdif;
              } else if (b === v) {
                h = 2 / 3 + gdif - rdif;
              }

              if (h < 0) {
                h += 1;
              } else if (h > 1) {
                h -= 1;
              }
            }

            return [h * 360, s * 100, v * 100];
          };

          convert.rgb.hwb = function(rgb) {
            var r = rgb[0];
            var g = rgb[1];
            var b = rgb[2];
            var h = convert.rgb.hsl(rgb)[0];
            var w = (1 / 255) * Math.min(r, Math.min(g, b));
            b = 1 - (1 / 255) * Math.max(r, Math.max(g, b));
            return [h, w * 100, b * 100];
          };

          convert.rgb.cmyk = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var c;
            var m;
            var y;
            var k;
            k = Math.min(1 - r, 1 - g, 1 - b);
            c = (1 - r - k) / (1 - k) || 0;
            m = (1 - g - k) / (1 - k) || 0;
            y = (1 - b - k) / (1 - k) || 0;
            return [c * 100, m * 100, y * 100, k * 100];
          };

          function comparativeDistance(x, y) {
            return (
              Math.pow(x[0] - y[0], 2) +
              Math.pow(x[1] - y[1], 2) +
              Math.pow(x[2] - y[2], 2)
            );
          }

          convert.rgb.keyword = function(rgb) {
            var reversed = reverseKeywords[rgb];

            if (reversed) {
              return reversed;
            }

            var currentClosestDistance = Infinity;
            var currentClosestKeyword;

            for (var keyword in cssKeywords) {
              if (cssKeywords.hasOwnProperty(keyword)) {
                var value = cssKeywords[keyword];
                var distance = comparativeDistance(rgb, value);

                if (distance < currentClosestDistance) {
                  currentClosestDistance = distance;
                  currentClosestKeyword = keyword;
                }
              }
            }

            return currentClosestKeyword;
          };

          convert.keyword.rgb = function(keyword) {
            return cssKeywords[keyword];
          };

          convert.rgb.xyz = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
            var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
            var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
            return [x * 100, y * 100, z * 100];
          };

          convert.rgb.lab = function(rgb) {
            var xyz = convert.rgb.xyz(rgb);
            var x = xyz[0];
            var y = xyz[1];
            var z = xyz[2];
            var l;
            var a;
            var b;
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
            y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
            z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
            l = 116 * y - 16;
            a = 500 * (x - y);
            b = 200 * (y - z);
            return [l, a, b];
          };

          convert.hsl.rgb = function(hsl) {
            var h = hsl[0] / 360;
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var t1;
            var t2;
            var t3;
            var rgb;
            var val;

            if (s === 0) {
              val = l * 255;
              return [val, val, val];
            }

            if (l < 0.5) {
              t2 = l * (1 + s);
            } else {
              t2 = l + s - l * s;
            }

            t1 = 2 * l - t2;
            rgb = [0, 0, 0];

            for (var i = 0; i < 3; i++) {
              t3 = h + (1 / 3) * -(i - 1);

              if (t3 < 0) {
                t3++;
              }

              if (t3 > 1) {
                t3--;
              }

              if (6 * t3 < 1) {
                val = t1 + (t2 - t1) * 6 * t3;
              } else if (2 * t3 < 1) {
                val = t2;
              } else if (3 * t3 < 2) {
                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
              } else {
                val = t1;
              }

              rgb[i] = val * 255;
            }

            return rgb;
          };

          convert.hsl.hsv = function(hsl) {
            var h = hsl[0];
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var smin = s;
            var lmin = Math.max(l, 0.01);
            var sv;
            var v;
            l *= 2;
            s *= l <= 1 ? l : 2 - l;
            smin *= lmin <= 1 ? lmin : 2 - lmin;
            v = (l + s) / 2;
            sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
            return [h, sv * 100, v * 100];
          };

          convert.hsv.rgb = function(hsv) {
            var h = hsv[0] / 60;
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var hi = Math.floor(h) % 6;
            var f = h - Math.floor(h);
            var p = 255 * v * (1 - s);
            var q = 255 * v * (1 - s * f);
            var t = 255 * v * (1 - s * (1 - f));
            v *= 255;

            switch (hi) {
              case 0:
                return [v, t, p];

              case 1:
                return [q, v, p];

              case 2:
                return [p, v, t];

              case 3:
                return [p, q, v];

              case 4:
                return [t, p, v];

              case 5:
                return [v, p, q];
            }
          };

          convert.hsv.hsl = function(hsv) {
            var h = hsv[0];
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var vmin = Math.max(v, 0.01);
            var lmin;
            var sl;
            var l;
            l = (2 - s) * v;
            lmin = (2 - s) * vmin;
            sl = s * vmin;
            sl /= lmin <= 1 ? lmin : 2 - lmin;
            sl = sl || 0;
            l /= 2;
            return [h, sl * 100, l * 100];
          };

          convert.hwb.rgb = function(hwb) {
            var h = hwb[0] / 360;
            var wh = hwb[1] / 100;
            var bl = hwb[2] / 100;
            var ratio = wh + bl;
            var i;
            var v;
            var f;
            var n;

            if (ratio > 1) {
              wh /= ratio;
              bl /= ratio;
            }

            i = Math.floor(6 * h);
            v = 1 - bl;
            f = 6 * h - i;

            if ((i & 0x01) !== 0) {
              f = 1 - f;
            }

            n = wh + f * (v - wh);
            var r;
            var g;
            var b;

            switch (i) {
              default:
              case 6:
              case 0:
                r = v;
                g = n;
                b = wh;
                break;

              case 1:
                r = n;
                g = v;
                b = wh;
                break;

              case 2:
                r = wh;
                g = v;
                b = n;
                break;

              case 3:
                r = wh;
                g = n;
                b = v;
                break;

              case 4:
                r = n;
                g = wh;
                b = v;
                break;

              case 5:
                r = v;
                g = wh;
                b = n;
                break;
            }

            return [r * 255, g * 255, b * 255];
          };

          convert.cmyk.rgb = function(cmyk) {
            var c = cmyk[0] / 100;
            var m = cmyk[1] / 100;
            var y = cmyk[2] / 100;
            var k = cmyk[3] / 100;
            var r;
            var g;
            var b;
            r = 1 - Math.min(1, c * (1 - k) + k);
            g = 1 - Math.min(1, m * (1 - k) + k);
            b = 1 - Math.min(1, y * (1 - k) + k);
            return [r * 255, g * 255, b * 255];
          };

          convert.xyz.rgb = function(xyz) {
            var x = xyz[0] / 100;
            var y = xyz[1] / 100;
            var z = xyz[2] / 100;
            var r;
            var g;
            var b;
            r = x * 3.2406 + y * -1.5372 + z * -0.4986;
            g = x * -0.9689 + y * 1.8758 + z * 0.0415;
            b = x * 0.0557 + y * -0.204 + z * 1.057;
            r =
              r > 0.0031308
                ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055
                : r * 12.92;
            g =
              g > 0.0031308
                ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055
                : g * 12.92;
            b =
              b > 0.0031308
                ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055
                : b * 12.92;
            r = Math.min(Math.max(0, r), 1);
            g = Math.min(Math.max(0, g), 1);
            b = Math.min(Math.max(0, b), 1);
            return [r * 255, g * 255, b * 255];
          };

          convert.xyz.lab = function(xyz) {
            var x = xyz[0];
            var y = xyz[1];
            var z = xyz[2];
            var l;
            var a;
            var b;
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
            y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
            z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
            l = 116 * y - 16;
            a = 500 * (x - y);
            b = 200 * (y - z);
            return [l, a, b];
          };

          convert.lab.xyz = function(lab) {
            var l = lab[0];
            var a = lab[1];
            var b = lab[2];
            var x;
            var y;
            var z;
            y = (l + 16) / 116;
            x = a / 500 + y;
            z = y - b / 200;
            var y2 = Math.pow(y, 3);
            var x2 = Math.pow(x, 3);
            var z2 = Math.pow(z, 3);
            y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
            x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
            z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
            x *= 95.047;
            y *= 100;
            z *= 108.883;
            return [x, y, z];
          };

          convert.lab.lch = function(lab) {
            var l = lab[0];
            var a = lab[1];
            var b = lab[2];
            var hr;
            var h;
            var c;
            hr = Math.atan2(b, a);
            h = (hr * 360) / 2 / Math.PI;

            if (h < 0) {
              h += 360;
            }

            c = Math.sqrt(a * a + b * b);
            return [l, c, h];
          };

          convert.lch.lab = function(lch) {
            var l = lch[0];
            var c = lch[1];
            var h = lch[2];
            var a;
            var b;
            var hr;
            hr = (h / 360) * 2 * Math.PI;
            a = c * Math.cos(hr);
            b = c * Math.sin(hr);
            return [l, a, b];
          };

          convert.rgb.ansi16 = function(args) {
            var r = args[0];
            var g = args[1];
            var b = args[2];
            var value =
              1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
            value = Math.round(value / 50);

            if (value === 0) {
              return 30;
            }

            var ansi =
              30 +
              ((Math.round(b / 255) << 2) |
                (Math.round(g / 255) << 1) |
                Math.round(r / 255));

            if (value === 2) {
              ansi += 60;
            }

            return ansi;
          };

          convert.hsv.ansi16 = function(args) {
            return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
          };

          convert.rgb.ansi256 = function(args) {
            var r = args[0];
            var g = args[1];
            var b = args[2];

            if (r === g && g === b) {
              if (r < 8) {
                return 16;
              }

              if (r > 248) {
                return 231;
              }

              return Math.round(((r - 8) / 247) * 24) + 232;
            }

            var ansi =
              16 +
              36 * Math.round((r / 255) * 5) +
              6 * Math.round((g / 255) * 5) +
              Math.round((b / 255) * 5);
            return ansi;
          };

          convert.ansi16.rgb = function(args) {
            var color = args % 10;

            if (color === 0 || color === 7) {
              if (args > 50) {
                color += 3.5;
              }

              color = (color / 10.5) * 255;
              return [color, color, color];
            }

            var mult = (~~(args > 50) + 1) * 0.5;
            var r = (color & 1) * mult * 255;
            var g = ((color >> 1) & 1) * mult * 255;
            var b = ((color >> 2) & 1) * mult * 255;
            return [r, g, b];
          };

          convert.ansi256.rgb = function(args) {
            if (args >= 232) {
              var c = (args - 232) * 10 + 8;
              return [c, c, c];
            }

            args -= 16;
            var rem;
            var r = (Math.floor(args / 36) / 5) * 255;
            var g = (Math.floor((rem = args % 36) / 6) / 5) * 255;
            var b = ((rem % 6) / 5) * 255;
            return [r, g, b];
          };

          convert.rgb.hex = function(args) {
            var integer =
              ((Math.round(args[0]) & 0xff) << 16) +
              ((Math.round(args[1]) & 0xff) << 8) +
              (Math.round(args[2]) & 0xff);
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };

          convert.hex.rgb = function(args) {
            var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

            if (!match) {
              return [0, 0, 0];
            }

            var colorString = match[0];

            if (match[0].length === 3) {
              colorString = colorString
                .split("")
                .map(function(char) {
                  return char + char;
                })
                .join("");
            }

            var integer = parseInt(colorString, 16);
            var r = (integer >> 16) & 0xff;
            var g = (integer >> 8) & 0xff;
            var b = integer & 0xff;
            return [r, g, b];
          };

          convert.rgb.hcg = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var max = Math.max(Math.max(r, g), b);
            var min = Math.min(Math.min(r, g), b);
            var chroma = max - min;
            var grayscale;
            var hue;

            if (chroma < 1) {
              grayscale = min / (1 - chroma);
            } else {
              grayscale = 0;
            }

            if (chroma <= 0) {
              hue = 0;
            } else if (max === r) {
              hue = ((g - b) / chroma) % 6;
            } else if (max === g) {
              hue = 2 + (b - r) / chroma;
            } else {
              hue = 4 + (r - g) / chroma + 4;
            }

            hue /= 6;
            hue %= 1;
            return [hue * 360, chroma * 100, grayscale * 100];
          };

          convert.hsl.hcg = function(hsl) {
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var c = 1;
            var f = 0;

            if (l < 0.5) {
              c = 2.0 * s * l;
            } else {
              c = 2.0 * s * (1.0 - l);
            }

            if (c < 1.0) {
              f = (l - 0.5 * c) / (1.0 - c);
            }

            return [hsl[0], c * 100, f * 100];
          };

          convert.hsv.hcg = function(hsv) {
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var c = s * v;
            var f = 0;

            if (c < 1.0) {
              f = (v - c) / (1 - c);
            }

            return [hsv[0], c * 100, f * 100];
          };

          convert.hcg.rgb = function(hcg) {
            var h = hcg[0] / 360;
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;

            if (c === 0.0) {
              return [g * 255, g * 255, g * 255];
            }

            var pure = [0, 0, 0];
            var hi = (h % 1) * 6;
            var v = hi % 1;
            var w = 1 - v;
            var mg = 0;

            switch (Math.floor(hi)) {
              case 0:
                pure[0] = 1;
                pure[1] = v;
                pure[2] = 0;
                break;

              case 1:
                pure[0] = w;
                pure[1] = 1;
                pure[2] = 0;
                break;

              case 2:
                pure[0] = 0;
                pure[1] = 1;
                pure[2] = v;
                break;

              case 3:
                pure[0] = 0;
                pure[1] = w;
                pure[2] = 1;
                break;

              case 4:
                pure[0] = v;
                pure[1] = 0;
                pure[2] = 1;
                break;

              default:
                pure[0] = 1;
                pure[1] = 0;
                pure[2] = w;
            }

            mg = (1.0 - c) * g;
            return [
              (c * pure[0] + mg) * 255,
              (c * pure[1] + mg) * 255,
              (c * pure[2] + mg) * 255,
            ];
          };

          convert.hcg.hsv = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var v = c + g * (1.0 - c);
            var f = 0;

            if (v > 0.0) {
              f = c / v;
            }

            return [hcg[0], f * 100, v * 100];
          };

          convert.hcg.hsl = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var l = g * (1.0 - c) + 0.5 * c;
            var s = 0;

            if (l > 0.0 && l < 0.5) {
              s = c / (2 * l);
            } else if (l >= 0.5 && l < 1.0) {
              s = c / (2 * (1 - l));
            }

            return [hcg[0], s * 100, l * 100];
          };

          convert.hcg.hwb = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var v = c + g * (1.0 - c);
            return [hcg[0], (v - c) * 100, (1 - v) * 100];
          };

          convert.hwb.hcg = function(hwb) {
            var w = hwb[1] / 100;
            var b = hwb[2] / 100;
            var v = 1 - b;
            var c = v - w;
            var g = 0;

            if (c < 1) {
              g = (v - c) / (1 - c);
            }

            return [hwb[0], c * 100, g * 100];
          };

          convert.apple.rgb = function(apple) {
            return [
              (apple[0] / 65535) * 255,
              (apple[1] / 65535) * 255,
              (apple[2] / 65535) * 255,
            ];
          };

          convert.rgb.apple = function(rgb) {
            return [
              (rgb[0] / 255) * 65535,
              (rgb[1] / 255) * 65535,
              (rgb[2] / 255) * 65535,
            ];
          };

          convert.gray.rgb = function(args) {
            return [
              (args[0] / 100) * 255,
              (args[0] / 100) * 255,
              (args[0] / 100) * 255,
            ];
          };

          convert.gray.hsl = convert.gray.hsv = function(args) {
            return [0, 0, args[0]];
          };

          convert.gray.hwb = function(gray) {
            return [0, 100, gray[0]];
          };

          convert.gray.cmyk = function(gray) {
            return [0, 0, 0, gray[0]];
          };

          convert.gray.lab = function(gray) {
            return [gray[0], 0, 0];
          };

          convert.gray.hex = function(gray) {
            var val = Math.round((gray[0] / 100) * 255) & 0xff;
            var integer = (val << 16) + (val << 8) + val;
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };

          convert.rgb.gray = function(rgb) {
            var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
            return [(val / 255) * 100];
          };
        },
        /* 149 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = parseAndBuildMetadata;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _babelParser() {
            var data = __webpack_require__(80);

            _babelParser = function _babelParser() {
              return data;
            };

            return data;
          }

          function _babelCodeFrame() {
            var data = __webpack_require__(44);

            _babelCodeFrame = function _babelCodeFrame() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          var PATTERN = /^[_$A-Z0-9]+$/;

          function parseAndBuildMetadata(formatter, code, opts) {
            var ast = parseWithCodeFrame(code, opts.parser);
            var placeholderWhitelist = opts.placeholderWhitelist,
              _opts$placeholderPatt = opts.placeholderPattern,
              placeholderPattern =
                _opts$placeholderPatt === void 0
                  ? PATTERN
                  : _opts$placeholderPatt,
              preserveComments = opts.preserveComments;
            t().removePropertiesDeep(ast, {
              preserveComments: preserveComments,
            });
            formatter.validate(ast);
            var placeholders = [];
            var placeholderNames = new Set();
            t().traverse(ast, placeholderVisitorHandler, {
              placeholders: placeholders,
              placeholderNames: placeholderNames,
              placeholderWhitelist: placeholderWhitelist,
              placeholderPattern: placeholderPattern,
            });
            return {
              ast: ast,
              placeholders: placeholders,
              placeholderNames: placeholderNames,
            };
          }

          function placeholderVisitorHandler(node, ancestors, state) {
            var name;

            if (t().isIdentifier(node) || t().isJSXIdentifier(node)) {
              name = node.name;
            } else if (t().isStringLiteral(node)) {
              name = node.value;
            } else {
              return;
            }

            if (
              (!state.placeholderPattern ||
                !state.placeholderPattern.test(name)) &&
              (!state.placeholderWhitelist ||
                !state.placeholderWhitelist.has(name))
            ) {
              return;
            }

            ancestors = ancestors.slice();
            var _ancestors = ancestors[ancestors.length - 1],
              parent = _ancestors.node,
              key = _ancestors.key;
            var type;

            if (t().isStringLiteral(node)) {
              type = "string";
            } else if (
              (t().isNewExpression(parent) && key === "arguments") ||
              (t().isCallExpression(parent) && key === "arguments") ||
              (t().isFunction(parent) && key === "params")
            ) {
              type = "param";
            } else if (t().isExpressionStatement(parent)) {
              type = "statement";
              ancestors = ancestors.slice(0, -1);
            } else {
              type = "other";
            }

            state.placeholders.push({
              name: name,
              type: type,
              resolve: function resolve(ast) {
                return resolveAncestors(ast, ancestors);
              },
              isDuplicate: state.placeholderNames.has(name),
            });
            state.placeholderNames.add(name);
          }

          function resolveAncestors(ast, ancestors) {
            var parent = ast;

            for (var i = 0; i < ancestors.length - 1; i++) {
              var _ancestors$i = ancestors[i],
                _key = _ancestors$i.key,
                _index = _ancestors$i.index;

              if (_index === undefined) {
                parent = parent[_key];
              } else {
                parent = parent[_key][_index];
              }
            }

            var _ancestors2 = ancestors[ancestors.length - 1],
              key = _ancestors2.key,
              index = _ancestors2.index;
            return {
              parent: parent,
              key: key,
              index: index,
            };
          }

          function parseWithCodeFrame(code, parserOpts) {
            parserOpts = Object.assign(
              {
                allowReturnOutsideFunction: true,
                allowSuperOutsideMethod: true,
                sourceType: "module",
              },
              parserOpts
            );

            try {
              return (0, _babelParser().parse)(code, parserOpts);
            } catch (err) {
              var loc = err.loc;

              if (loc) {
                err.message +=
                  "\n" +
                  (0, _babelCodeFrame().codeFrameColumns)(code, {
                    start: loc,
                  });
                err.code = "BABEL_TEMPLATE_PARSE_ERROR";
              }

              throw err;
            }
          }
        },
        /* 150 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = populatePlaceholders;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function populatePlaceholders(metadata, replacements) {
            var ast = t().cloneNode(metadata.ast);

            if (replacements) {
              metadata.placeholders.forEach(function(placeholder) {
                if (
                  !Object.prototype.hasOwnProperty.call(
                    replacements,
                    placeholder.name
                  )
                ) {
                  var placeholderName = placeholder.name;
                  throw new Error(
                    'Error: No substitution given for "' +
                      placeholderName +
                      "\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @gerhobbelt/babel-template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['" +
                      placeholderName +
                      "'])}\n            - { placeholderPattern: /^" +
                      placeholderName +
                      "$/ }"
                  );
                }
              });
              Object.keys(replacements).forEach(function(key) {
                if (!metadata.placeholderNames.has(key)) {
                  throw new Error('Unknown substitution "' + key + '" given');
                }
              });
            }

            metadata.placeholders
              .slice()
              .reverse()
              .forEach(function(placeholder) {
                try {
                  applyReplacement(
                    placeholder,
                    ast,
                    (replacements && replacements[placeholder.name]) || null
                  );
                } catch (e) {
                  e.message =
                    '@gerhobbelt/babel-template placeholder "' +
                    placeholder.name +
                    '": ' +
                    e.message;
                  throw e;
                }
              });
            return ast;
          }

          function applyReplacement(placeholder, ast, replacement) {
            if (placeholder.isDuplicate) {
              if (Array.isArray(replacement)) {
                replacement = replacement.map(function(node) {
                  return t().cloneNode(node);
                });
              } else if (typeof replacement === "object") {
                replacement = t().cloneNode(replacement);
              }
            }

            var _placeholder$resolve = placeholder.resolve(ast),
              parent = _placeholder$resolve.parent,
              key = _placeholder$resolve.key,
              index = _placeholder$resolve.index;

            if (placeholder.type === "string") {
              if (typeof replacement === "string") {
                replacement = t().stringLiteral(replacement);
              }

              if (!replacement || !t().isStringLiteral(replacement)) {
                throw new Error("Expected string substitution");
              }
            } else if (placeholder.type === "statement") {
              if (index === undefined) {
                if (!replacement) {
                  replacement = t().emptyStatement();
                } else if (Array.isArray(replacement)) {
                  replacement = t().blockStatement(replacement);
                } else if (typeof replacement === "string") {
                  replacement = t().expressionStatement(
                    t().identifier(replacement)
                  );
                } else if (!t().isStatement(replacement)) {
                  replacement = t().expressionStatement(replacement);
                }
              } else {
                if (replacement && !Array.isArray(replacement)) {
                  if (typeof replacement === "string") {
                    replacement = t().identifier(replacement);
                  }

                  if (!t().isStatement(replacement)) {
                    replacement = t().expressionStatement(replacement);
                  }
                }
              }
            } else if (placeholder.type === "param") {
              if (typeof replacement === "string") {
                replacement = t().identifier(replacement);
              }

              if (index === undefined) throw new Error("Assertion failure.");
            } else {
              if (typeof replacement === "string") {
                replacement = t().identifier(replacement);
              }

              if (Array.isArray(replacement)) {
                throw new Error(
                  "Cannot replace single expression with an array."
                );
              }
            }

            if (index === undefined) {
              t().validate(parent, key, replacement);
              parent[key] = replacement;
            } else {
              var items = parent[key].slice();

              if (
                placeholder.type === "statement" ||
                placeholder.type === "param"
              ) {
                if (replacement == null) {
                  items.splice(index, 1);
                } else if (Array.isArray(replacement)) {
                  items.splice.apply(items, [index, 1].concat(replacement));
                } else {
                  items[index] = replacement;
                }
              } else {
                items[index] = replacement;
              }

              t().validate(parent, key, items);
              parent[key] = items;
            }
          }
        },
        /* 151 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.getEnv = getEnv;

          function getEnv(defaultValue) {
            if (defaultValue === void 0) {
              defaultValue = "development";
            }

            return "development" || "development" || defaultValue;
          }
        },
        /* 152 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.createCachedDescriptors = createCachedDescriptors;
          exports.createUncachedDescriptors = createUncachedDescriptors;
          exports.createDescriptor = createDescriptor;

          var _files = __webpack_require__(82);

          var _item = __webpack_require__(46);

          var _caching = __webpack_require__(47);

          function isEqualDescriptor(a, b) {
            return (
              a.name === b.name &&
              a.value === b.value &&
              a.options === b.options &&
              a.dirname === b.dirname &&
              a.alias === b.alias &&
              a.ownPass === b.ownPass &&
              (a.file && a.file.request) === (b.file && b.file.request) &&
              (a.file && a.file.resolved) === (b.file && b.file.resolved)
            );
          }

          function createCachedDescriptors(dirname, options, alias) {
            var plugins = options.plugins,
              presets = options.presets,
              passPerPreset = options.passPerPreset;
            return {
              options: options,
              plugins: plugins
                ? function() {
                    return createCachedPluginDescriptors(plugins, dirname)(
                      alias
                    );
                  }
                : function() {
                    return [];
                  },
              presets: presets
                ? function() {
                    return createCachedPresetDescriptors(presets, dirname)(
                      alias
                    )(!!passPerPreset);
                  }
                : function() {
                    return [];
                  },
            };
          }

          function createUncachedDescriptors(dirname, options, alias) {
            var _plugins;

            var _presets;

            return {
              options: options,
              plugins: function plugins() {
                if (!_plugins) {
                  _plugins = createPluginDescriptors(
                    options.plugins || [],
                    dirname,
                    alias
                  );
                }

                return _plugins;
              },
              presets: function presets() {
                if (!_presets) {
                  _presets = createPresetDescriptors(
                    options.presets || [],
                    dirname,
                    alias,
                    !!options.passPerPreset
                  );
                }

                return _presets;
              },
            };
          }

          var PRESET_DESCRIPTOR_CACHE = new WeakMap();
          var createCachedPresetDescriptors = (0, _caching.makeWeakCache)(
            function(items, cache) {
              var dirname = cache.using(function(dir) {
                return dir;
              });
              return (0, _caching.makeStrongCache)(function(alias) {
                return (0, _caching.makeStrongCache)(function(passPerPreset) {
                  return createPresetDescriptors(
                    items,
                    dirname,
                    alias,
                    passPerPreset
                  ).map(function(desc) {
                    return loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc);
                  });
                });
              });
            }
          );
          var PLUGIN_DESCRIPTOR_CACHE = new WeakMap();
          var createCachedPluginDescriptors = (0, _caching.makeWeakCache)(
            function(items, cache) {
              var dirname = cache.using(function(dir) {
                return dir;
              });
              return (0, _caching.makeStrongCache)(function(alias) {
                return createPluginDescriptors(items, dirname, alias).map(
                  function(desc) {
                    return loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc);
                  }
                );
              });
            }
          );
          var DEFAULT_OPTIONS = {};

          function loadCachedDescriptor(cache, desc) {
            var value = desc.value,
              _desc$options = desc.options,
              options =
                _desc$options === void 0 ? DEFAULT_OPTIONS : _desc$options;
            if (options === false) return desc;
            var cacheByOptions = cache.get(value);

            if (!cacheByOptions) {
              cacheByOptions = new WeakMap();
              cache.set(value, cacheByOptions);
            }

            var possibilities = cacheByOptions.get(options);

            if (!possibilities) {
              possibilities = [];
              cacheByOptions.set(options, possibilities);
            }

            if (possibilities.indexOf(desc) === -1) {
              var matches = possibilities.filter(function(possibility) {
                return isEqualDescriptor(possibility, desc);
              });

              if (matches.length > 0) {
                return matches[0];
              }

              possibilities.push(desc);
            }

            return desc;
          }

          function createPresetDescriptors(
            items,
            dirname,
            alias,
            passPerPreset
          ) {
            return createDescriptors(
              "preset",
              items,
              dirname,
              alias,
              passPerPreset
            );
          }

          function createPluginDescriptors(items, dirname, alias) {
            return createDescriptors("plugin", items, dirname, alias);
          }

          function createDescriptors(type, items, dirname, alias, ownPass) {
            var descriptors = items.map(function(item, index) {
              return createDescriptor(item, dirname, {
                type: type,
                alias: alias + "$" + index,
                ownPass: !!ownPass,
              });
            });
            assertNoDuplicates(descriptors);
            return descriptors;
          }

          function createDescriptor(pair, dirname, _ref) {
            var type = _ref.type,
              alias = _ref.alias,
              ownPass = _ref.ownPass;
            var desc = (0, _item.getItemDescriptor)(pair);

            if (desc) {
              return desc;
            }

            var name;
            var options;
            var value = pair;

            if (Array.isArray(value)) {
              if (value.length === 3) {
                var _value = value;
                value = _value[0];
                options = _value[1];
                name = _value[2];
              } else {
                var _value2 = value;
                value = _value2[0];
                options = _value2[1];
              }
            }

            var file = undefined;
            var filepath = null;

            if (typeof value === "string") {
              if (typeof type !== "string") {
                throw new Error(
                  "To resolve a string-based item, the type of item must be given"
                );
              }

              var resolver =
                type === "plugin" ? _files.loadPlugin : _files.loadPreset;
              var request = value;

              var _resolver = resolver(value, dirname);

              filepath = _resolver.filepath;
              value = _resolver.value;
              file = {
                request: request,
                resolved: filepath,
              };
            }

            if (!value) {
              throw new Error("Unexpected falsy value: " + String(value));
            }

            if (typeof value === "object" && value.__esModule) {
              if (value.default) {
                value = value.default;
              } else {
                throw new Error(
                  "Must export a default export when using ES6 modules."
                );
              }
            }

            if (typeof value !== "object" && typeof value !== "function") {
              throw new Error(
                "Unsupported format: " +
                  typeof value +
                  ". Expected an object or a function."
              );
            }

            if (filepath !== null && typeof value === "object" && value) {
              throw new Error(
                "Plugin/Preset files are not allowed to export objects, only functions. In " +
                  filepath
              );
            }

            return {
              name: name,
              alias: filepath || alias,
              value: value,
              options: options,
              dirname: dirname,
              ownPass: ownPass,
              file: file,
            };
          }

          function assertNoDuplicates(items) {
            var map = new Map();

            for (
              var _iterator = items,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref2;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref2 = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref2 = _i.value;
              }

              var item = _ref2;
              if (typeof item.value !== "function") continue;
              var nameMap = map.get(item.value);

              if (!nameMap) {
                nameMap = new Set();
                map.set(item.value, nameMap);
              }

              if (nameMap.has(item.name)) {
                throw new Error(
                  [
                    "Duplicate plugin/preset detected.",
                    "If you'd like to use two separate instances of a plugin,",
                    "they need separate names, e.g.",
                    "",
                    "  plugins: [",
                    "    ['some-plugin', {}],",
                    "    ['some-plugin', {}, 'some unique name'],",
                    "  ]",
                  ].join("\n")
                );
              }

              nameMap.add(item.name);
            }
          }
        },
        /* 153 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.mergeOptions = mergeOptions;

          function mergeOptions(target, source) {
            var _arr = Object.keys(source);

            for (var _i = 0; _i < _arr.length; _i++) {
              var k = _arr[_i];

              if (k === "parserOpts" && source.parserOpts) {
                var parserOpts = source.parserOpts;
                var targetObj = (target.parserOpts = target.parserOpts || {});
                mergeDefaultFields(targetObj, parserOpts);
              } else if (k === "generatorOpts" && source.generatorOpts) {
                var generatorOpts = source.generatorOpts;

                var _targetObj = (target.generatorOpts =
                  target.generatorOpts || {});

                mergeDefaultFields(_targetObj, generatorOpts);
              } else {
                var val = source[k];
                if (val !== undefined) target[k] = val;
              }
            }
          }

          function mergeDefaultFields(target, source) {
            var _arr2 = Object.keys(source);

            for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
              var k = _arr2[_i2];
              var val = source[k];
              if (val !== undefined) target[k] = val;
            }
          }
        },
        /* 154 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.buildPresetChain = buildPresetChain;
          exports.buildRootChain = buildRootChain;
          exports.buildPresetChainWalker = void 0;

          function _path() {
            var data = _interopRequireDefault(__webpack_require__(15));

            _path = function _path() {
              return data;
            };

            return data;
          }

          function _debug() {
            var data = _interopRequireDefault(__webpack_require__(155));

            _debug = function _debug() {
              return data;
            };

            return data;
          }

          var _options = __webpack_require__(84);

          var _patternToRegex = _interopRequireDefault(
            __webpack_require__(405)
          );

          var _files = __webpack_require__(82);

          var _caching = __webpack_require__(47);

          var _configDescriptors = __webpack_require__(152);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var debug = (0, _debug().default)("babel:config:config-chain");

          function buildPresetChain(arg, context) {
            var chain = buildPresetChainWalker(arg, context);
            if (!chain) return null;
            return {
              plugins: dedupDescriptors(chain.plugins),
              presets: dedupDescriptors(chain.presets),
              options: chain.options,
            };
          }

          var buildPresetChainWalker = makeChainWalker({
            init: function init(arg) {
              return arg;
            },
            root: function root(preset) {
              return loadPresetDescriptors(preset);
            },
            env: function env(preset, envName) {
              return loadPresetEnvDescriptors(preset)(envName);
            },
            overrides: function overrides(preset, index) {
              return loadPresetOverridesDescriptors(preset)(index);
            },
            overridesEnv: function overridesEnv(preset, index, envName) {
              return loadPresetOverridesEnvDescriptors(preset)(index)(envName);
            },
          });
          exports.buildPresetChainWalker = buildPresetChainWalker;
          var loadPresetDescriptors = (0, _caching.makeWeakCache)(function(
            preset
          ) {
            return buildRootDescriptors(
              preset,
              preset.alias,
              _configDescriptors.createUncachedDescriptors
            );
          });
          var loadPresetEnvDescriptors = (0, _caching.makeWeakCache)(function(
            preset
          ) {
            return (0, _caching.makeStrongCache)(function(envName) {
              return buildEnvDescriptors(
                preset,
                preset.alias,
                _configDescriptors.createUncachedDescriptors,
                envName
              );
            });
          });
          var loadPresetOverridesDescriptors = (0, _caching.makeWeakCache)(
            function(preset) {
              return (0, _caching.makeStrongCache)(function(index) {
                return buildOverrideDescriptors(
                  preset,
                  preset.alias,
                  _configDescriptors.createUncachedDescriptors,
                  index
                );
              });
            }
          );
          var loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCache)(
            function(preset) {
              return (0, _caching.makeStrongCache)(function(index) {
                return (0, _caching.makeStrongCache)(function(envName) {
                  return buildOverrideEnvDescriptors(
                    preset,
                    preset.alias,
                    _configDescriptors.createUncachedDescriptors,
                    index,
                    envName
                  );
                });
              });
            }
          );

          function buildRootChain(opts, context) {
            var programmaticChain = loadProgrammaticChain(
              {
                options: opts,
                dirname: context.cwd,
              },
              context
            );
            if (!programmaticChain) return null;
            var configFile;

            if (typeof opts.configFile === "string") {
              configFile = (0, _files.loadConfig)(
                opts.configFile,
                context.cwd,
                context.envName,
                context.caller
              );
            } else if (opts.configFile !== false) {
              configFile = (0, _files.findRootConfig)(
                context.root,
                context.envName,
                context.caller
              );
            }

            var babelrc = opts.babelrc,
              babelrcRoots = opts.babelrcRoots;
            var configFileChain = emptyChain();

            if (configFile) {
              var validatedFile = validateConfigFile(configFile);
              var result = loadFileChain(validatedFile, context);
              if (!result) return null;

              if (babelrc === undefined) {
                babelrc = validatedFile.options.babelrc;
              }

              if (babelrcRoots === undefined) {
                babelrcRoots = validatedFile.options.babelrcRoots;
              }

              mergeChain(configFileChain, result);
            }

            var pkgData =
              typeof context.filename === "string"
                ? (0, _files.findPackageData)(context.filename)
                : null;
            var ignoreFile, babelrcFile;
            var fileChain = emptyChain();

            if (
              (babelrc === true || babelrc === undefined) &&
              pkgData &&
              babelrcLoadEnabled(context, pkgData, babelrcRoots)
            ) {
              var _ref = (0, _files.findRelativeConfig)(
                pkgData,
                context.envName,
                context.caller
              );

              ignoreFile = _ref.ignore;
              babelrcFile = _ref.config;

              if (
                ignoreFile &&
                shouldIgnore(
                  context,
                  ignoreFile.ignore,
                  null,
                  ignoreFile.dirname
                )
              ) {
                return null;
              }

              if (babelrcFile) {
                var _result = loadFileChain(
                  validateBabelrcFile(babelrcFile),
                  context
                );

                if (!_result) return null;
                mergeChain(fileChain, _result);
              }
            }

            var chain = mergeChain(
              mergeChain(mergeChain(emptyChain(), configFileChain), fileChain),
              programmaticChain
            );
            return {
              plugins: dedupDescriptors(chain.plugins),
              presets: dedupDescriptors(chain.presets),
              options: chain.options.map(function(o) {
                return normalizeOptions(o);
              }),
              ignore: ignoreFile || undefined,
              babelrc: babelrcFile || undefined,
              config: configFile || undefined,
            };
          }

          function babelrcLoadEnabled(context, pkgData, babelrcRoots) {
            if (typeof babelrcRoots === "boolean") return babelrcRoots;
            var absoluteRoot = context.root;

            if (babelrcRoots === undefined) {
              return pkgData.directories.indexOf(absoluteRoot) !== -1;
            }

            var babelrcPatterns = babelrcRoots;
            if (!Array.isArray(babelrcPatterns))
              babelrcPatterns = [babelrcPatterns];
            babelrcPatterns = babelrcPatterns.map(function(pat) {
              return typeof pat === "string"
                ? _path().default.resolve(context.cwd, pat)
                : pat;
            });

            if (
              babelrcPatterns.length === 1 &&
              babelrcPatterns[0] === absoluteRoot
            ) {
              return pkgData.directories.indexOf(absoluteRoot) !== -1;
            }

            return babelrcPatterns.some(function(pat) {
              if (typeof pat === "string")
                pat = (0, _patternToRegex.default)(pat, context.cwd);
              return pkgData.directories.some(function(directory) {
                return matchPattern(pat, context.cwd, directory, context);
              });
            });
          }

          var validateConfigFile = (0, _caching.makeWeakCache)(function(file) {
            return {
              filepath: file.filepath,
              dirname: file.dirname,
              options: (0, _options.validate)("configfile", file.options),
            };
          });
          var validateBabelrcFile = (0, _caching.makeWeakCache)(function(file) {
            return {
              filepath: file.filepath,
              dirname: file.dirname,
              options: (0, _options.validate)("babelrcfile", file.options),
            };
          });
          var validateExtendFile = (0, _caching.makeWeakCache)(function(file) {
            return {
              filepath: file.filepath,
              dirname: file.dirname,
              options: (0, _options.validate)("extendsfile", file.options),
            };
          });
          var loadProgrammaticChain = makeChainWalker({
            root: function root(input) {
              return buildRootDescriptors(
                input,
                "base",
                _configDescriptors.createCachedDescriptors
              );
            },
            env: function env(input, envName) {
              return buildEnvDescriptors(
                input,
                "base",
                _configDescriptors.createCachedDescriptors,
                envName
              );
            },
            overrides: function overrides(input, index) {
              return buildOverrideDescriptors(
                input,
                "base",
                _configDescriptors.createCachedDescriptors,
                index
              );
            },
            overridesEnv: function overridesEnv(input, index, envName) {
              return buildOverrideEnvDescriptors(
                input,
                "base",
                _configDescriptors.createCachedDescriptors,
                index,
                envName
              );
            },
          });
          var loadFileChain = makeChainWalker({
            root: function root(file) {
              return loadFileDescriptors(file);
            },
            env: function env(file, envName) {
              return loadFileEnvDescriptors(file)(envName);
            },
            overrides: function overrides(file, index) {
              return loadFileOverridesDescriptors(file)(index);
            },
            overridesEnv: function overridesEnv(file, index, envName) {
              return loadFileOverridesEnvDescriptors(file)(index)(envName);
            },
          });
          var loadFileDescriptors = (0, _caching.makeWeakCache)(function(file) {
            return buildRootDescriptors(
              file,
              file.filepath,
              _configDescriptors.createUncachedDescriptors
            );
          });
          var loadFileEnvDescriptors = (0, _caching.makeWeakCache)(function(
            file
          ) {
            return (0, _caching.makeStrongCache)(function(envName) {
              return buildEnvDescriptors(
                file,
                file.filepath,
                _configDescriptors.createUncachedDescriptors,
                envName
              );
            });
          });
          var loadFileOverridesDescriptors = (0, _caching.makeWeakCache)(
            function(file) {
              return (0, _caching.makeStrongCache)(function(index) {
                return buildOverrideDescriptors(
                  file,
                  file.filepath,
                  _configDescriptors.createUncachedDescriptors,
                  index
                );
              });
            }
          );
          var loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCache)(
            function(file) {
              return (0, _caching.makeStrongCache)(function(index) {
                return (0, _caching.makeStrongCache)(function(envName) {
                  return buildOverrideEnvDescriptors(
                    file,
                    file.filepath,
                    _configDescriptors.createUncachedDescriptors,
                    index,
                    envName
                  );
                });
              });
            }
          );

          function buildRootDescriptors(_ref2, alias, descriptors) {
            var dirname = _ref2.dirname,
              options = _ref2.options;
            return descriptors(dirname, options, alias);
          }

          function buildEnvDescriptors(_ref3, alias, descriptors, envName) {
            var dirname = _ref3.dirname,
              options = _ref3.options;
            var opts = options.env && options.env[envName];
            return opts
              ? descriptors(dirname, opts, alias + '.env["' + envName + '"]')
              : null;
          }

          function buildOverrideDescriptors(_ref4, alias, descriptors, index) {
            var dirname = _ref4.dirname,
              options = _ref4.options;
            var opts = options.overrides && options.overrides[index];
            if (!opts) throw new Error("Assertion failure - missing override");
            return descriptors(
              dirname,
              opts,
              alias + ".overrides[" + index + "]"
            );
          }

          function buildOverrideEnvDescriptors(
            _ref5,
            alias,
            descriptors,
            index,
            envName
          ) {
            var dirname = _ref5.dirname,
              options = _ref5.options;
            var override = options.overrides && options.overrides[index];
            if (!override)
              throw new Error("Assertion failure - missing override");
            var opts = override.env && override.env[envName];
            return opts
              ? descriptors(
                  dirname,
                  opts,
                  alias + ".overrides[" + index + '].env["' + envName + '"]'
                )
              : null;
          }

          function makeChainWalker(_ref6) {
            var root = _ref6.root,
              env = _ref6.env,
              overrides = _ref6.overrides,
              overridesEnv = _ref6.overridesEnv;
            return function(input, context, files) {
              if (files === void 0) {
                files = new Set();
              }

              var dirname = input.dirname;
              var flattenedConfigs = [];
              var rootOpts = root(input);

              if (configIsApplicable(rootOpts, dirname, context)) {
                flattenedConfigs.push(rootOpts);
                var envOpts = env(input, context.envName);

                if (envOpts && configIsApplicable(envOpts, dirname, context)) {
                  flattenedConfigs.push(envOpts);
                }

                (rootOpts.options.overrides || []).forEach(function(_, index) {
                  var overrideOps = overrides(input, index);

                  if (configIsApplicable(overrideOps, dirname, context)) {
                    flattenedConfigs.push(overrideOps);
                    var overrideEnvOpts = overridesEnv(
                      input,
                      index,
                      context.envName
                    );

                    if (
                      overrideEnvOpts &&
                      configIsApplicable(overrideEnvOpts, dirname, context)
                    ) {
                      flattenedConfigs.push(overrideEnvOpts);
                    }
                  }
                });
              }

              if (
                flattenedConfigs.some(function(_ref7) {
                  var _ref7$options = _ref7.options,
                    ignore = _ref7$options.ignore,
                    only = _ref7$options.only;
                  return shouldIgnore(context, ignore, only, dirname);
                })
              ) {
                return null;
              }

              var chain = emptyChain();

              for (var _i = 0; _i < flattenedConfigs.length; _i++) {
                var op = flattenedConfigs[_i];

                if (
                  !mergeExtendsChain(chain, op.options, dirname, context, files)
                ) {
                  return null;
                }

                mergeChainOpts(chain, op);
              }

              return chain;
            };
          }

          function mergeExtendsChain(chain, opts, dirname, context, files) {
            if (opts.extends === undefined) return true;
            var file = (0, _files.loadConfig)(
              opts.extends,
              dirname,
              context.envName,
              context.caller
            );

            if (files.has(file)) {
              throw new Error(
                "Configuration cycle detected loading " +
                  file.filepath +
                  ".\n" +
                  "File already loaded following the config chain:\n" +
                  Array.from(files, function(file) {
                    return " - " + file.filepath;
                  }).join("\n")
              );
            }

            files.add(file);
            var fileChain = loadFileChain(
              validateExtendFile(file),
              context,
              files
            );
            files.delete(file);
            if (!fileChain) return false;
            mergeChain(chain, fileChain);
            return true;
          }

          function mergeChain(target, source) {
            var _target$options, _target$plugins, _target$presets;

            (_target$options = target.options).push.apply(
              _target$options,
              source.options
            );

            (_target$plugins = target.plugins).push.apply(
              _target$plugins,
              source.plugins
            );

            (_target$presets = target.presets).push.apply(
              _target$presets,
              source.presets
            );

            return target;
          }

          function mergeChainOpts(target, _ref8) {
            var _target$plugins2, _target$presets2;

            var options = _ref8.options,
              plugins = _ref8.plugins,
              presets = _ref8.presets;
            target.options.push(options);

            (_target$plugins2 = target.plugins).push.apply(
              _target$plugins2,
              plugins()
            );

            (_target$presets2 = target.presets).push.apply(
              _target$presets2,
              presets()
            );

            return target;
          }

          function emptyChain() {
            return {
              options: [],
              presets: [],
              plugins: [],
            };
          }

          function normalizeOptions(opts) {
            var options = Object.assign({}, opts);
            delete options.extends;
            delete options.env;
            delete options.overrides;
            delete options.plugins;
            delete options.presets;
            delete options.passPerPreset;
            delete options.ignore;
            delete options.only;
            delete options.test;
            delete options.include;
            delete options.exclude;

            if (options.hasOwnProperty("sourceMap")) {
              options.sourceMaps = options.sourceMap;
              delete options.sourceMap;
            }

            return options;
          }

          function dedupDescriptors(items) {
            var map = new Map();
            var descriptors = [];

            for (
              var _iterator = items,
                _isArray = Array.isArray(_iterator),
                _i2 = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref9;

              if (_isArray) {
                if (_i2 >= _iterator.length) break;
                _ref9 = _iterator[_i2++];
              } else {
                _i2 = _iterator.next();
                if (_i2.done) break;
                _ref9 = _i2.value;
              }

              var item = _ref9;

              if (typeof item.value === "function") {
                var fnKey = item.value;
                var nameMap = map.get(fnKey);

                if (!nameMap) {
                  nameMap = new Map();
                  map.set(fnKey, nameMap);
                }

                var desc = nameMap.get(item.name);

                if (!desc) {
                  desc = {
                    value: item,
                  };
                  descriptors.push(desc);
                  if (!item.ownPass) nameMap.set(item.name, desc);
                } else {
                  desc.value = item;
                }
              } else {
                descriptors.push({
                  value: item,
                });
              }
            }

            return descriptors.reduce(function(acc, desc) {
              acc.push(desc.value);
              return acc;
            }, []);
          }

          function configIsApplicable(_ref10, dirname, context) {
            var options = _ref10.options;
            return (
              (options.test === undefined ||
                configFieldIsApplicable(context, options.test, dirname)) &&
              (options.include === undefined ||
                configFieldIsApplicable(context, options.include, dirname)) &&
              (options.exclude === undefined ||
                !configFieldIsApplicable(context, options.exclude, dirname))
            );
          }

          function configFieldIsApplicable(context, test, dirname) {
            var patterns = Array.isArray(test) ? test : [test];
            return matchesPatterns(context, patterns, dirname);
          }

          function shouldIgnore(context, ignore, only, dirname) {
            if (ignore && matchesPatterns(context, ignore, dirname)) {
              debug(
                "Ignored %o because it matched one of %O from %o",
                context.filename,
                ignore,
                dirname
              );
              return true;
            }

            if (only && !matchesPatterns(context, only, dirname)) {
              debug(
                "Ignored %o because it failed to match one of %O from %o",
                context.filename,
                only,
                dirname
              );
              return true;
            }

            return false;
          }

          function matchesPatterns(context, patterns, dirname) {
            return patterns.some(function(pattern) {
              return matchPattern(pattern, dirname, context.filename, context);
            });
          }

          function matchPattern(pattern, dirname, pathToTest, context) {
            if (typeof pattern === "function") {
              return !!pattern(pathToTest, {
                dirname: dirname,
                envName: context.envName,
                caller: context.caller,
              });
            }

            if (typeof pathToTest !== "string") {
              throw new Error(
                "Configuration contains string/RegExp pattern, but no filename was passed to Babel"
              );
            }

            if (typeof pattern === "string") {
              pattern = (0, _patternToRegex.default)(pattern, dirname);
            }

            return pattern.test(pathToTest);
          }
        },
        /* 155 */
        function(module, exports, __webpack_require__) {
          /* WEBPACK VAR INJECTION */ (function(process) {
            exports = module.exports = __webpack_require__(403);
            exports.log = log;
            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.storage =
              "undefined" != typeof chrome &&
              "undefined" != typeof chrome.storage
                ? chrome.storage.local
                : localstorage();
            exports.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33",
            ];

            function useColors() {
              if (
                typeof window !== "undefined" &&
                window.process &&
                window.process.type === "renderer"
              ) {
                return true;
              }

              if (
                typeof navigator !== "undefined" &&
                navigator.userAgent &&
                navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
              ) {
                return false;
              }

              return (
                (typeof document !== "undefined" &&
                  document.documentElement &&
                  document.documentElement.style &&
                  document.documentElement.style.WebkitAppearance) ||
                (typeof window !== "undefined" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
              );
            }

            exports.formatters.j = function(v) {
              try {
                return JSON.stringify(v);
              } catch (err) {
                return "[UnexpectedJSONParseError]: " + err.message;
              }
            };

            function formatArgs(args) {
              var useColors = this.useColors;
              args[0] =
                (useColors ? "%c" : "") +
                this.namespace +
                (useColors ? " %c" : " ") +
                args[0] +
                (useColors ? "%c " : " ") +
                "+" +
                exports.humanize(this.diff);
              if (!useColors) return;
              var c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");
              var index = 0;
              var lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, function(match) {
                if ("%%" === match) return;
                index++;

                if ("%c" === match) {
                  lastC = index;
                }
              });
              args.splice(lastC, 0, c);
            }

            function log() {
              return (
                "object" === typeof console &&
                console.log &&
                Function.prototype.apply.call(console.log, console, arguments)
              );
            }

            function save(namespaces) {
              try {
                if (null == namespaces) {
                  exports.storage.removeItem("debug");
                } else {
                  exports.storage.debug = namespaces;
                }
              } catch (e) {}
            }

            function load() {
              var r;

              try {
                r = exports.storage.debug;
              } catch (e) {}

              if (!r && typeof process !== "undefined" && "env" in process) {
                r = undefined;
              }

              return r;
            }

            exports.enable(load());

            function localstorage() {
              try {
                return window.localStorage;
              } catch (e) {}
            }
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(3)));
        },
        /* 156 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.msg = msg;
          exports.access = access;
          exports.assertSourceMaps = assertSourceMaps;
          exports.assertCompact = assertCompact;
          exports.assertSourceType = assertSourceType;
          exports.assertCallerMetadata = assertCallerMetadata;
          exports.assertInputSourceMap = assertInputSourceMap;
          exports.assertString = assertString;
          exports.assertFunction = assertFunction;
          exports.assertBoolean = assertBoolean;
          exports.assertObject = assertObject;
          exports.assertArray = assertArray;
          exports.assertIgnoreList = assertIgnoreList;
          exports.assertConfigApplicableTest = assertConfigApplicableTest;
          exports.assertConfigFileSearch = assertConfigFileSearch;
          exports.assertBabelrcSearch = assertBabelrcSearch;
          exports.assertPluginList = assertPluginList;

          function msg(loc) {
            switch (loc.type) {
              case "root":
                return "";

              case "env":
                return msg(loc.parent) + '.env["' + loc.name + '"]';

              case "overrides":
                return msg(loc.parent) + ".overrides[" + loc.index + "]";

              case "option":
                return msg(loc.parent) + "." + loc.name;

              case "access":
                return msg(loc.parent) + "[" + JSON.stringify(loc.name) + "]";

              default:
                throw new Error("Assertion failure: Unknown type " + loc.type);
            }
          }

          function access(loc, name) {
            return {
              type: "access",
              name: name,
              parent: loc,
            };
          }

          function assertSourceMaps(loc, value) {
            if (
              value !== undefined &&
              typeof value !== "boolean" &&
              value !== "inline" &&
              value !== "both"
            ) {
              throw new Error(
                msg(loc) + ' must be a boolean, "inline", "both", or undefined'
              );
            }

            return value;
          }

          function assertCompact(loc, value) {
            if (
              value !== undefined &&
              typeof value !== "boolean" &&
              value !== "auto"
            ) {
              throw new Error(
                msg(loc) + ' must be a boolean, "auto", or undefined'
              );
            }

            return value;
          }

          function assertSourceType(loc, value) {
            if (
              value !== undefined &&
              value !== "module" &&
              value !== "script" &&
              value !== "unambiguous"
            ) {
              throw new Error(
                msg(loc) +
                  ' must be "module", "script", "unambiguous", or undefined'
              );
            }

            return value;
          }

          function assertCallerMetadata(loc, value) {
            var obj = assertObject(loc, value);

            if (obj) {
              if (typeof obj["name"] !== "string") {
                throw new Error(
                  msg(loc) + ' set but does not contain "name" property string'
                );
              }

              var _arr = Object.keys(obj);

              for (var _i = 0; _i < _arr.length; _i++) {
                var prop = _arr[_i];
                var propLoc = access(loc, prop);
                var _value = obj[prop];

                if (
                  _value != null &&
                  typeof _value !== "boolean" &&
                  typeof _value !== "string" &&
                  typeof _value !== "number"
                ) {
                  throw new Error(
                    msg(propLoc) +
                      " must be null, undefined, a boolean, a string, or a number."
                  );
                }
              }
            }

            return value;
          }

          function assertInputSourceMap(loc, value) {
            if (
              value !== undefined &&
              typeof value !== "boolean" &&
              (typeof value !== "object" || !value)
            ) {
              throw new Error(
                msg(loc) + " must be a boolean, object, or undefined"
              );
            }

            return value;
          }

          function assertString(loc, value) {
            if (value !== undefined && typeof value !== "string") {
              throw new Error(msg(loc) + " must be a string, or undefined");
            }

            return value;
          }

          function assertFunction(loc, value) {
            if (value !== undefined && typeof value !== "function") {
              throw new Error(msg(loc) + " must be a function, or undefined");
            }

            return value;
          }

          function assertBoolean(loc, value) {
            if (value !== undefined && typeof value !== "boolean") {
              throw new Error(msg(loc) + " must be a boolean, or undefined");
            }

            return value;
          }

          function assertObject(loc, value) {
            if (
              value !== undefined &&
              (typeof value !== "object" || Array.isArray(value) || !value)
            ) {
              throw new Error(msg(loc) + " must be an object, or undefined");
            }

            return value;
          }

          function assertArray(loc, value) {
            if (value != null && !Array.isArray(value)) {
              throw new Error(msg(loc) + " must be an array, or undefined");
            }

            return value;
          }

          function assertIgnoreList(loc, value) {
            var arr = assertArray(loc, value);

            if (arr) {
              arr.forEach(function(item, i) {
                return assertIgnoreItem(access(loc, i), item);
              });
            }

            return arr;
          }

          function assertIgnoreItem(loc, value) {
            if (
              typeof value !== "string" &&
              typeof value !== "function" &&
              !(value instanceof RegExp)
            ) {
              throw new Error(
                msg(loc) +
                  " must be an array of string/Funtion/RegExp values, or undefined"
              );
            }

            return value;
          }

          function assertConfigApplicableTest(loc, value) {
            if (value === undefined) return value;

            if (Array.isArray(value)) {
              value.forEach(function(item, i) {
                if (!checkValidTest(item)) {
                  throw new Error(
                    msg(access(loc, i)) + " must be a string/Function/RegExp."
                  );
                }
              });
            } else if (!checkValidTest(value)) {
              throw new Error(
                msg(loc) +
                  " must be a string/Function/RegExp, or an array of those"
              );
            }

            return value;
          }

          function checkValidTest(value) {
            return (
              typeof value === "string" ||
              typeof value === "function" ||
              value instanceof RegExp
            );
          }

          function assertConfigFileSearch(loc, value) {
            if (
              value !== undefined &&
              typeof value !== "boolean" &&
              typeof value !== "string"
            ) {
              throw new Error(
                msg(loc) +
                  " must be a undefined, a boolean, a string, " +
                  ("got " + JSON.stringify(value))
              );
            }

            return value;
          }

          function assertBabelrcSearch(loc, value) {
            if (value === undefined || typeof value === "boolean") return value;

            if (Array.isArray(value)) {
              value.forEach(function(item, i) {
                if (!checkValidTest(item)) {
                  throw new Error(
                    msg(access(loc, i)) + " must be a string/Function/RegExp."
                  );
                }
              });
            } else if (!checkValidTest(value)) {
              throw new Error(
                msg(loc) +
                  " must be a undefined, a boolean, a string/Function/RegExp " +
                  ("or an array of those, got " + JSON.stringify(value))
              );
            }

            return value;
          }

          function assertPluginList(loc, value) {
            var arr = assertArray(loc, value);

            if (arr) {
              arr.forEach(function(item, i) {
                return assertPluginItem(access(loc, i), item);
              });
            }

            return arr;
          }

          function assertPluginItem(loc, value) {
            if (Array.isArray(value)) {
              if (value.length === 0) {
                throw new Error(msg(loc) + " must include an object");
              }

              if (value.length > 3) {
                throw new Error(
                  msg(loc) + " may only be a two-tuple or three-tuple"
                );
              }

              assertPluginTarget(access(loc, 0), value[0]);

              if (value.length > 1) {
                var opts = value[1];

                if (
                  opts !== undefined &&
                  opts !== false &&
                  (typeof opts !== "object" || Array.isArray(opts))
                ) {
                  throw new Error(
                    msg(access(loc, 1)) +
                      " must be an object, false, or undefined"
                  );
                }
              }

              if (value.length === 3) {
                var name = value[2];

                if (name !== undefined && typeof name !== "string") {
                  throw new Error(
                    msg(access(loc, 2)) + " must be a string, or undefined"
                  );
                }
              }
            } else {
              assertPluginTarget(loc, value);
            }

            return value;
          }

          function assertPluginTarget(loc, value) {
            if (
              (typeof value !== "object" || !value) &&
              typeof value !== "string" &&
              typeof value !== "function"
            ) {
              throw new Error(msg(loc) + " must be a string, object, function");
            }

            return value;
          }
        },
        /* 157 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = loadPrivatePartialConfig;
          exports.loadPartialConfig = loadPartialConfig;

          function _path() {
            var data = _interopRequireDefault(__webpack_require__(15));

            _path = function _path() {
              return data;
            };

            return data;
          }

          var _plugin = _interopRequireDefault(__webpack_require__(83));

          var _util = __webpack_require__(153);

          var _item = __webpack_require__(46);

          var _configChain = __webpack_require__(154);

          var _environment = __webpack_require__(151);

          var _options = __webpack_require__(84);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function loadPrivatePartialConfig(inputOpts) {
            if (
              inputOpts != null &&
              (typeof inputOpts !== "object" || Array.isArray(inputOpts))
            ) {
              throw new Error(
                "Babel options must be an object, null, or undefined"
              );
            }

            var args = inputOpts
              ? (0, _options.validate)("arguments", inputOpts)
              : {};
            var _args$envName = args.envName,
              envName =
                _args$envName === void 0
                  ? (0, _environment.getEnv)()
                  : _args$envName,
              _args$cwd = args.cwd,
              cwd = _args$cwd === void 0 ? "." : _args$cwd,
              _args$root = args.root,
              rootDir = _args$root === void 0 ? "." : _args$root,
              caller = args.caller;

            var absoluteCwd = _path().default.resolve(cwd);

            var absoluteRootDir = _path().default.resolve(absoluteCwd, rootDir);

            var context = {
              filename:
                typeof args.filename === "string"
                  ? _path().default.resolve(cwd, args.filename)
                  : undefined,
              cwd: absoluteCwd,
              root: absoluteRootDir,
              envName: envName,
              caller: caller,
            };
            var configChain = (0, _configChain.buildRootChain)(args, context);
            if (!configChain) return null;
            var options = {};
            configChain.options.forEach(function(opts) {
              (0, _util.mergeOptions)(options, opts);
            });
            options.babelrc = false;
            options.configFile = false;
            options.passPerPreset = false;
            options.envName = context.envName;
            options.cwd = context.cwd;
            options.root = context.root;
            options.filename =
              typeof context.filename === "string"
                ? context.filename
                : undefined;
            options.plugins = configChain.plugins.map(function(descriptor) {
              return (0, _item.createItemFromDescriptor)(descriptor);
            });
            options.presets = configChain.presets.map(function(descriptor) {
              return (0, _item.createItemFromDescriptor)(descriptor);
            });
            return {
              options: options,
              context: context,
              ignore: configChain.ignore,
              babelrc: configChain.babelrc,
              config: configChain.config,
            };
          }

          function loadPartialConfig(inputOpts) {
            var result = loadPrivatePartialConfig(inputOpts);
            if (!result) return null;
            var options = result.options,
              babelrc = result.babelrc,
              ignore = result.ignore,
              config = result.config;
            (options.plugins || []).forEach(function(item) {
              if (item.value instanceof _plugin.default) {
                throw new Error(
                  "Passing cached plugin instances is not supported in " +
                    "babel.loadPartialConfig()"
                );
              }
            });
            return new PartialConfig(
              options,
              babelrc ? babelrc.filepath : undefined,
              ignore ? ignore.filepath : undefined,
              config ? config.filepath : undefined
            );
          }

          var PartialConfig = (function() {
            function PartialConfig(options, babelrc, ignore, config) {
              this.options = options;
              this.babelignore = ignore;
              this.babelrc = babelrc;
              this.config = config;
              Object.freeze(this);
            }

            var _proto = PartialConfig.prototype;

            _proto.hasFilesystemConfig = function hasFilesystemConfig() {
              return this.babelrc !== undefined || this.config !== undefined;
            };

            return PartialConfig;
          })();

          Object.freeze(PartialConfig.prototype);
        },
        /* 158 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.runAsync = runAsync;
          exports.runSync = runSync;

          function _babelTraverse() {
            var data = _interopRequireDefault(__webpack_require__(9));

            _babelTraverse = function _babelTraverse() {
              return data;
            };

            return data;
          }

          var _pluginPass = _interopRequireDefault(__webpack_require__(410));

          var _blockHoistPlugin = _interopRequireDefault(
            __webpack_require__(411)
          );

          var _normalizeOpts = _interopRequireDefault(__webpack_require__(165));

          var _normalizeFile = _interopRequireDefault(__webpack_require__(166));

          var _generate = _interopRequireDefault(__webpack_require__(449));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function runAsync(config, code, ast, callback) {
            var result;

            try {
              result = runSync(config, code, ast);
            } catch (err) {
              return callback(err);
            }

            return callback(null, result);
          }

          function runSync(config, code, ast) {
            var file = (0, _normalizeFile.default)(
              config.passes,
              (0, _normalizeOpts.default)(config),
              code,
              ast
            );
            transformFile(file, config.passes);
            var opts = file.opts;

            var _ref =
                opts.code !== false
                  ? (0, _generate.default)(config.passes, file)
                  : {},
              outputCode = _ref.outputCode,
              outputMap = _ref.outputMap;

            return {
              metadata: file.metadata,
              options: opts,
              ast: opts.ast === true ? file.ast : null,
              code: outputCode === undefined ? null : outputCode,
              map: outputMap === undefined ? null : outputMap,
              sourceType: file.ast.program.sourceType,
            };
          }

          function transformFile(file, pluginPasses) {
            for (
              var _iterator = pluginPasses,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref2;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref2 = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref2 = _i.value;
              }

              var pluginPairs = _ref2;
              var passPairs = [];
              var passes = [];
              var visitors = [];

              for (
                var _iterator2 = pluginPairs.concat([
                    (0, _blockHoistPlugin.default)(),
                  ]),
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : _iterator2[Symbol.iterator]();
                ;

              ) {
                var _ref3;

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break;
                  _ref3 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done) break;
                  _ref3 = _i2.value;
                }

                var plugin = _ref3;
                var pass = new _pluginPass.default(
                  file,
                  plugin.key,
                  plugin.options
                );
                passPairs.push([plugin, pass]);
                passes.push(pass);
                visitors.push(plugin.visitor);
              }

              for (var _i3 = 0; _i3 < passPairs.length; _i3++) {
                var _passPairs$_i = passPairs[_i3],
                  _plugin = _passPairs$_i[0],
                  _pass = _passPairs$_i[1];
                var fn = _plugin.pre;

                if (fn) {
                  var result = fn.call(_pass, file);

                  if (isThenable(result)) {
                    throw new Error(
                      "You appear to be using an plugin with an async .pre, " +
                        "which your current version of Babel does not support." +
                        "If you're using a published plugin, you may need to upgrade " +
                        "your @gerhobbelt/babel-core version."
                    );
                  }
                }
              }

              var visitor = _babelTraverse().default.visitors.merge(
                visitors,
                passes,
                file.opts.wrapPluginVisitorMethod
              );

              (0, _babelTraverse().default)(file.ast, visitor, file.scope);

              for (var _i4 = 0; _i4 < passPairs.length; _i4++) {
                var _passPairs$_i2 = passPairs[_i4],
                  _plugin2 = _passPairs$_i2[0],
                  _pass2 = _passPairs$_i2[1];
                var _fn = _plugin2.post;

                if (_fn) {
                  var _result = _fn.call(_pass2, file);

                  if (isThenable(_result)) {
                    throw new Error(
                      "You appear to be using an plugin with an async .post, " +
                        "which your current version of Babel does not support." +
                        "If you're using a published plugin, you may need to upgrade " +
                        "your @gerhobbelt/babel-core version."
                    );
                  }
                }
              }
            }
          }

          function isThenable(val) {
            return (
              !!val &&
              (typeof val === "object" || typeof val === "function") &&
              typeof val.then === "function"
            );
          }
        },
        /* 159 */
        function(module, exports, __webpack_require__) {
          var baseIsEqualDeep = __webpack_require__(419),
            isObjectLike = __webpack_require__(7);

          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }

            if (
              value == null ||
              other == null ||
              (!isObjectLike(value) && !isObjectLike(other))
            ) {
              return value !== value && other !== other;
            }

            return baseIsEqualDeep(
              value,
              other,
              bitmask,
              customizer,
              baseIsEqual,
              stack
            );
          }

          module.exports = baseIsEqual;
        },
        /* 160 */
        function(module, exports, __webpack_require__) {
          var SetCache = __webpack_require__(114),
            arraySome = __webpack_require__(420),
            cacheHas = __webpack_require__(116);

          var COMPARE_PARTIAL_FLAG = 1,
            COMPARE_UNORDERED_FLAG = 2;

          function equalArrays(
            array,
            other,
            bitmask,
            customizer,
            equalFunc,
            stack
          ) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              arrLength = array.length,
              othLength = other.length;

            if (
              arrLength != othLength &&
              !(isPartial && othLength > arrLength)
            ) {
              return false;
            }

            var stacked = stack.get(array);

            if (stacked && stack.get(other)) {
              return stacked == other;
            }

            var index = -1,
              result = true,
              seen =
                bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
            stack.set(array, other);
            stack.set(other, array);

            while (++index < arrLength) {
              var arrValue = array[index],
                othValue = other[index];

              if (customizer) {
                var compared = isPartial
                  ? customizer(othValue, arrValue, index, other, array, stack)
                  : customizer(arrValue, othValue, index, array, other, stack);
              }

              if (compared !== undefined) {
                if (compared) {
                  continue;
                }

                result = false;
                break;
              }

              if (seen) {
                if (
                  !arraySome(other, function(othValue, othIndex) {
                    if (
                      !cacheHas(seen, othIndex) &&
                      (arrValue === othValue ||
                        equalFunc(
                          arrValue,
                          othValue,
                          bitmask,
                          customizer,
                          stack
                        ))
                    ) {
                      return seen.push(othIndex);
                    }
                  })
                ) {
                  result = false;
                  break;
                }
              } else if (
                !(
                  arrValue === othValue ||
                  equalFunc(arrValue, othValue, bitmask, customizer, stack)
                )
              ) {
                result = false;
                break;
              }
            }

            stack["delete"](array);
            stack["delete"](other);
            return result;
          }

          module.exports = equalArrays;
        },
        /* 161 */
        function(module, exports, __webpack_require__) {
          var isObject = __webpack_require__(11);

          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }

          module.exports = isStrictComparable;
        },
        /* 162 */
        function(module, exports) {
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }

              return (
                object[key] === srcValue &&
                (srcValue !== undefined || key in Object(object))
              );
            };
          }

          module.exports = matchesStrictComparable;
        },
        /* 163 */
        function(module, exports, __webpack_require__) {
          var castPath = __webpack_require__(164),
            toKey = __webpack_require__(48);

          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0,
              length = path.length;

            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }

            return index && index == length ? object : undefined;
          }

          module.exports = baseGet;
        },
        /* 164 */
        function(module, exports, __webpack_require__) {
          var isArray = __webpack_require__(5),
            isKey = __webpack_require__(85),
            stringToPath = __webpack_require__(427),
            toString = __webpack_require__(77);

          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }

            return isKey(value, object)
              ? [value]
              : stringToPath(toString(value));
          }

          module.exports = castPath;
        },
        /* 165 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = normalizeOptions;

          function _path() {
            var data = _interopRequireDefault(__webpack_require__(15));

            _path = function _path() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function normalizeOptions(config) {
            var _config$options = config.options,
              filename = _config$options.filename,
              cwd = _config$options.cwd,
              _config$options$filen = _config$options.filenameRelative,
              filenameRelative =
                _config$options$filen === void 0
                  ? typeof filename === "string"
                    ? _path().default.relative(cwd, filename)
                    : "unknown"
                  : _config$options$filen,
              _config$options$sourc = _config$options.sourceType,
              sourceType =
                _config$options$sourc === void 0
                  ? "module"
                  : _config$options$sourc,
              inputSourceMap = _config$options.inputSourceMap,
              _config$options$sourc2 = _config$options.sourceMaps,
              sourceMaps =
                _config$options$sourc2 === void 0
                  ? !!inputSourceMap
                  : _config$options$sourc2,
              moduleRoot = _config$options.moduleRoot,
              _config$options$sourc3 = _config$options.sourceRoot,
              sourceRoot =
                _config$options$sourc3 === void 0
                  ? moduleRoot
                  : _config$options$sourc3,
              _config$options$sourc4 = _config$options.sourceFileName,
              sourceFileName =
                _config$options$sourc4 === void 0
                  ? _path().default.basename(filenameRelative)
                  : _config$options$sourc4,
              _config$options$comme = _config$options.comments,
              comments =
                _config$options$comme === void 0 ? true : _config$options$comme,
              _config$options$compa = _config$options.compact,
              compact =
                _config$options$compa === void 0
                  ? "auto"
                  : _config$options$compa;
            var opts = config.options;
            var options = Object.assign({}, opts, {
              parserOpts: Object.assign(
                {
                  sourceType:
                    _path().default.extname(filenameRelative) === ".mjs"
                      ? "module"
                      : sourceType,
                  sourceFileName: filename,
                  plugins: [],
                },
                opts.parserOpts
              ),
              generatorOpts: Object.assign(
                {
                  filename: filename,
                  auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
                  auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
                  retainLines: opts.retainLines,
                  comments: comments,
                  shouldPrintComment: opts.shouldPrintComment,
                  compact: compact,
                  minified: opts.minified,
                  sourceMaps: sourceMaps,
                  sourceRoot: sourceRoot,
                  sourceFileName: sourceFileName,
                },
                opts.generatorOpts
              ),
            });

            for (
              var _iterator = config.passes,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var plugins = _ref;

              for (
                var _iterator2 = plugins,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : _iterator2[Symbol.iterator]();
                ;

              ) {
                var _ref2;

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break;
                  _ref2 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done) break;
                  _ref2 = _i2.value;
                }

                var plugin = _ref2;

                if (plugin.manipulateOptions) {
                  plugin.manipulateOptions(options, options.parserOpts);
                }
              }
            }

            return options;
          }
        },
        /* 166 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = normalizeFile;

          function _path() {
            var data = _interopRequireDefault(__webpack_require__(15));

            _path = function _path() {
              return data;
            };

            return data;
          }

          function _debug() {
            var data = _interopRequireDefault(__webpack_require__(155));

            _debug = function _debug() {
              return data;
            };

            return data;
          }

          function _cloneDeep() {
            var data = _interopRequireDefault(__webpack_require__(445));

            _cloneDeep = function _cloneDeep() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _convertSourceMap() {
            var data = _interopRequireDefault(__webpack_require__(167));

            _convertSourceMap = function _convertSourceMap() {
              return data;
            };

            return data;
          }

          function _babelParser() {
            var data = __webpack_require__(80);

            _babelParser = function _babelParser() {
              return data;
            };

            return data;
          }

          function _babelCodeFrame() {
            var data = __webpack_require__(44);

            _babelCodeFrame = function _babelCodeFrame() {
              return data;
            };

            return data;
          }

          var _file = _interopRequireDefault(__webpack_require__(133));

          var _missingPluginHelper = _interopRequireDefault(
            __webpack_require__(448)
          );

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var debug = (0, _debug().default)("babel:transform:file");

          function normalizeFile(pluginPasses, options, code, ast) {
            code = "" + (code || "");
            var inputMap = null;

            if (options.inputSourceMap !== false) {
              if (typeof options.inputSourceMap === "object") {
                inputMap = _convertSourceMap().default.fromObject(
                  options.inputSourceMap
                );
              }

              if (!inputMap) {
                try {
                  inputMap = _convertSourceMap().default.fromSource(code);

                  if (inputMap) {
                    code = _convertSourceMap().default.removeComments(code);
                  }
                } catch (err) {
                  debug("discarding unknown inline input sourcemap", err);
                  code = _convertSourceMap().default.removeComments(code);
                }
              }

              if (!inputMap) {
                if (typeof options.filename === "string") {
                  try {
                    inputMap = _convertSourceMap().default.fromMapFileSource(
                      code,
                      _path().default.dirname(options.filename)
                    );

                    if (inputMap) {
                      code = _convertSourceMap().default.removeMapFileComments(
                        code
                      );
                    }
                  } catch (err) {
                    debug("discarding unknown file input sourcemap", err);
                    code = _convertSourceMap().default.removeMapFileComments(
                      code
                    );
                  }
                } else {
                  debug("discarding un-loadable file input sourcemap");
                  code = _convertSourceMap().default.removeMapFileComments(
                    code
                  );
                }
              }
            }

            if (ast) {
              if (ast.type === "Program") {
                ast = t().file(ast, [], []);
              } else if (ast.type !== "File") {
                throw new Error("AST root must be a Program or File node");
              }

              ast = (0, _cloneDeep().default)(ast);
            } else {
              ast = parser(pluginPasses, options, code);
            }

            return new _file.default(options, {
              code: code,
              ast: ast,
              inputMap: inputMap,
            });
          }

          function parser(pluginPasses, _ref, code) {
            var parserOpts = _ref.parserOpts,
              _ref$highlightCode = _ref.highlightCode,
              highlightCode =
                _ref$highlightCode === void 0 ? true : _ref$highlightCode,
              _ref$filename = _ref.filename,
              filename = _ref$filename === void 0 ? "unknown" : _ref$filename;

            try {
              var results = [];

              for (
                var _iterator = pluginPasses,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref2;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref2 = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref2 = _i.value;
                }

                var plugins = _ref2;

                for (
                  var _iterator2 = plugins,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : _iterator2[Symbol.iterator]();
                  ;

                ) {
                  var _ref3;

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref3 = _iterator2[_i2++];
                  } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref3 = _i2.value;
                  }

                  var plugin = _ref3;
                  var parserOverride = plugin.parserOverride;

                  if (parserOverride) {
                    var ast = parserOverride(
                      code,
                      parserOpts,
                      _babelParser().parse
                    );
                    if (ast !== undefined) results.push(ast);
                  }
                }
              }

              if (results.length === 0) {
                return (0, _babelParser().parse)(code, parserOpts);
              } else if (results.length === 1) {
                if (typeof results[0].then === "function") {
                  throw new Error(
                    "You appear to be using an async codegen plugin, " +
                      "which your current version of Babel does not support. " +
                      "If you're using a published plugin, you may need to upgrade " +
                      "your @gerhobbelt/babel-core version."
                  );
                }

                return results[0];
              }

              throw new Error(
                "More than one plugin attempted to override parsing."
              );
            } catch (err) {
              if (err.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
                err.message +=
                  "\nConsider renaming the file to '.mjs', or setting sourceType:module " +
                  "or sourceType:unambiguous in your Babel config for this file.";
              }

              var loc = err.loc,
                missingPlugin = err.missingPlugin;

              if (loc) {
                var codeFrame = (0, _babelCodeFrame().codeFrameColumns)(
                  code,
                  {
                    start: {
                      line: loc.line,
                      column: loc.column + 1,
                    },
                  },
                  {
                    highlightCode: highlightCode,
                  }
                );

                if (missingPlugin) {
                  err.message =
                    filename +
                    ": " +
                    (0, _missingPluginHelper.default)(
                      missingPlugin[0],
                      loc,
                      codeFrame
                    );
                } else {
                  err.message =
                    filename + ": " + err.message + "\n\n" + codeFrame;
                }

                err.code = "BABEL_PARSE_ERROR";
              }

              throw err;
            }
          }
        },
        /* 167 */
        function(module, exports, __webpack_require__) {
          "use strict";

          var fs = __webpack_require__(446);

          var path = __webpack_require__(15);

          var SafeBuffer = __webpack_require__(447);

          Object.defineProperty(exports, "commentRegex", {
            get: function getCommentRegex() {
              return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/gm;
            },
          });
          Object.defineProperty(exports, "mapFileCommentRegex", {
            get: function getMapFileCommentRegex() {
              return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/gm;
            },
          });

          function decodeBase64(base64) {
            return SafeBuffer.Buffer.from(base64, "base64").toString();
          }

          function stripComment(sm) {
            return sm.split(",").pop();
          }

          function readFromFileMap(sm, dir) {
            var r = exports.mapFileCommentRegex.exec(sm);
            var filename = r[1] || r[2];
            var filepath = path.resolve(dir, filename);

            try {
              return fs.readFileSync(filepath, "utf8");
            } catch (e) {
              throw new Error(
                "An error occurred while trying to read the map file at " +
                  filepath +
                  "\n" +
                  e
              );
            }
          }

          function Converter(sm, opts) {
            opts = opts || {};
            if (opts.isFileComment)
              sm = readFromFileMap(sm, opts.commentFileDir);
            if (opts.hasComment) sm = stripComment(sm);
            if (opts.isEncoded) sm = decodeBase64(sm);
            if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);
            this.sourcemap = sm;
          }

          Converter.prototype.toJSON = function(space) {
            return JSON.stringify(this.sourcemap, null, space);
          };

          Converter.prototype.toBase64 = function() {
            var json = this.toJSON();
            return SafeBuffer.Buffer.from(json, "utf8").toString("base64");
          };

          Converter.prototype.toComment = function(options) {
            var base64 = this.toBase64();
            var data =
              "sourceMappingURL=data:application/json;charset=utf-8;base64," +
              base64;
            return options && options.multiline
              ? "/*# " + data + " */"
              : "//# " + data;
          };

          Converter.prototype.toObject = function() {
            return JSON.parse(this.toJSON());
          };

          Converter.prototype.addProperty = function(key, value) {
            if (this.sourcemap.hasOwnProperty(key))
              throw new Error(
                'property "' +
                  key +
                  '" already exists on the sourcemap, use set property instead'
              );
            return this.setProperty(key, value);
          };

          Converter.prototype.setProperty = function(key, value) {
            this.sourcemap[key] = value;
            return this;
          };

          Converter.prototype.getProperty = function(key) {
            return this.sourcemap[key];
          };

          exports.fromObject = function(obj) {
            return new Converter(obj);
          };

          exports.fromJSON = function(json) {
            return new Converter(json, {
              isJSON: true,
            });
          };

          exports.fromBase64 = function(base64) {
            return new Converter(base64, {
              isEncoded: true,
            });
          };

          exports.fromComment = function(comment) {
            comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
            return new Converter(comment, {
              isEncoded: true,
              hasComment: true,
            });
          };

          exports.fromMapFileComment = function(comment, dir) {
            return new Converter(comment, {
              commentFileDir: dir,
              isFileComment: true,
              isJSON: true,
            });
          };

          exports.fromSource = function(content) {
            var m = content.match(exports.commentRegex);
            return m ? exports.fromComment(m.pop()) : null;
          };

          exports.fromMapFileSource = function(content, dir) {
            var m = content.match(exports.mapFileCommentRegex);
            return m ? exports.fromMapFileComment(m.pop(), dir) : null;
          };

          exports.removeComments = function(src) {
            return src.replace(exports.commentRegex, "");
          };

          exports.removeMapFileComments = function(src) {
            return src.replace(exports.mapFileCommentRegex, "");
          };

          exports.generateMapFileComment = function(file, options) {
            var data = "sourceMappingURL=" + file;
            return options && options.multiline
              ? "/*# " + data + " */"
              : "//# " + data;
          };
        },
        /* 168 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = exports.transformIncludesAndExcludes = exports.isPluginRequired = void 0;

          function _semver() {
            var data = _interopRequireDefault(__webpack_require__(16));

            _semver = function _semver() {
              return data;
            };

            return data;
          }

          var _builtIns = _interopRequireDefault(__webpack_require__(86));

          var _debug = __webpack_require__(50);

          var _defaults = __webpack_require__(311);

          var _moduleTransformations = _interopRequireDefault(
            __webpack_require__(130)
          );

          var _normalizeOptions = _interopRequireDefault(
            __webpack_require__(129)
          );

          var _plugins = _interopRequireDefault(__webpack_require__(131));

          var _shippedProposals = __webpack_require__(312);

          var _useBuiltInsEntryPlugin = _interopRequireDefault(
            __webpack_require__(313)
          );

          var _useBuiltInsPlugin = _interopRequireDefault(
            __webpack_require__(314)
          );

          var _targetsParser = _interopRequireDefault(__webpack_require__(71));

          var _availablePlugins = _interopRequireDefault(
            __webpack_require__(316)
          );

          var _utils = __webpack_require__(17);

          function _babelHelperPluginUtils() {
            var data = __webpack_require__(41);

            _babelHelperPluginUtils = function _babelHelperPluginUtils() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var getPlugin = function getPlugin(pluginName) {
            var plugin = _availablePlugins.default[pluginName];

            if (!plugin) {
              throw new Error(
                'Could not find plugin "' +
                  pluginName +
                  '". Ensure there is an entry in ./available-plugins.js for it.'
              );
            }

            return plugin;
          };

          var builtInsListWithoutProposals = (0, _utils.filterStageFromList)(
            _builtIns.default,
            _shippedProposals.builtIns
          );
          var pluginListWithoutProposals = (0, _utils.filterStageFromList)(
            _plugins.default,
            _shippedProposals.features
          );

          var isPluginRequired = function isPluginRequired(
            supportedEnvironments,
            plugin
          ) {
            var targetEnvironments = Object.keys(supportedEnvironments);

            if (targetEnvironments.length === 0) {
              return true;
            }

            var isRequiredForEnvironments = targetEnvironments.filter(function(
              environment
            ) {
              if (!plugin[environment]) {
                return true;
              }

              var lowestImplementedVersion = plugin[environment];
              var lowestTargetedVersion = supportedEnvironments[environment];

              if (
                (0, _utils.isUnreleasedVersion)(
                  lowestTargetedVersion,
                  environment
                )
              ) {
                return false;
              } else if (
                (0, _utils.isUnreleasedVersion)(
                  lowestImplementedVersion,
                  environment
                )
              ) {
                return true;
              }

              if (!_semver().default.valid(lowestTargetedVersion)) {
                throw new Error(
                  'Invalid version passed for target "' +
                    environment +
                    '": "' +
                    lowestTargetedVersion +
                    '". ' +
                    "Versions must be in semver format (major.minor.patch)"
                );
              }

              return _semver().default.gt(
                (0, _utils.semverify)(lowestImplementedVersion),
                lowestTargetedVersion
              );
            });
            return isRequiredForEnvironments.length > 0;
          };

          exports.isPluginRequired = isPluginRequired;

          var transformIncludesAndExcludes = function transformIncludesAndExcludes(
            opts
          ) {
            return opts.reduce(
              function(result, opt) {
                var target = opt.match(/^(es\d+|web)\./)
                  ? "builtIns"
                  : "plugins";
                result[target].add(opt);
                return result;
              },
              {
                all: opts,
                plugins: new Set(),
                builtIns: new Set(),
              }
            );
          };

          exports.transformIncludesAndExcludes = transformIncludesAndExcludes;

          var filterItems = function filterItems(
            list,
            includes,
            excludes,
            targets,
            defaultIncludes,
            defaultExcludes
          ) {
            var result = new Set();

            for (var item in list) {
              if (
                !excludes.has(item) &&
                (isPluginRequired(targets, list[item]) || includes.has(item))
              ) {
                result.add(item);
              } else {
                var shippedProposalsSyntax = _shippedProposals.pluginSyntaxMap.get(
                  item
                );

                if (shippedProposalsSyntax) {
                  result.add(shippedProposalsSyntax);
                }
              }
            }

            if (defaultIncludes) {
              defaultIncludes.forEach(function(item) {
                return !excludes.has(item) && result.add(item);
              });
            }

            if (defaultExcludes) {
              defaultExcludes.forEach(function(item) {
                return !includes.has(item) && result.delete(item);
              });
            }

            return result;
          };

          function supportsStaticESM(caller) {
            return !!(caller && caller.supportsStaticESM);
          }

          var _default = (0, _babelHelperPluginUtils().declare)(function(
            api,
            opts
          ) {
            api.assertVersion(7);

            var _ref = (0, _normalizeOptions.default)(opts),
              configPath = _ref.configPath,
              debug = _ref.debug,
              optionsExclude = _ref.exclude,
              forceAllTransforms = _ref.forceAllTransforms,
              ignoreBrowserslistConfig = _ref.ignoreBrowserslistConfig,
              optionsInclude = _ref.include,
              loose = _ref.loose,
              modules = _ref.modules,
              shippedProposals = _ref.shippedProposals,
              spec = _ref.spec,
              optionsTargets = _ref.targets,
              useBuiltIns = _ref.useBuiltIns;

            if (optionsTargets && optionsTargets.uglify) {
              throw new Error(
                "The uglify target has been removed. Set the top level" +
                  " option `forceAllTransforms: true` instead."
              );
            }

            if (
              optionsTargets &&
              optionsTargets.esmodules &&
              optionsTargets.browsers
            ) {
              console.log("");
              console.log(
                "@gerhobbelt/babel-preset-env: esmodules and browsers targets have been specified together."
              );
              console.log(
                "`browsers` target, `" +
                  optionsTargets.browsers +
                  "` will be ignored."
              );
              console.log("");
            }

            var targets = (0, _targetsParser.default)(optionsTargets, {
              ignoreBrowserslistConfig: ignoreBrowserslistConfig,
              configPath: configPath,
            });
            var include = transformIncludesAndExcludes(optionsInclude);
            var exclude = transformIncludesAndExcludes(optionsExclude);
            var transformTargets = forceAllTransforms ? {} : targets;
            var transformations = filterItems(
              shippedProposals ? _plugins.default : pluginListWithoutProposals,
              include.plugins,
              exclude.plugins,
              transformTargets,
              null,
              (0, _defaults.getOptionSpecificExcludesFor)({
                loose: loose,
              })
            );
            var polyfills;

            if (useBuiltIns) {
              polyfills = filterItems(
                shippedProposals
                  ? _builtIns.default
                  : builtInsListWithoutProposals,
                include.builtIns,
                exclude.builtIns,
                targets,
                (0, _defaults.getPlatformSpecificDefaultFor)(targets)
              );
            }

            var plugins = [];
            var pluginUseBuiltIns = useBuiltIns !== false;

            if (
              modules !== false &&
              _moduleTransformations.default[modules] &&
              (modules !== "auto" ||
                !api.caller ||
                !api.caller(supportsStaticESM))
            ) {
              plugins.push([
                getPlugin(_moduleTransformations.default[modules]),
                {
                  loose: loose,
                },
              ]);
            }

            transformations.forEach(function(pluginName) {
              return plugins.push([
                getPlugin(pluginName),
                {
                  spec: spec,
                  loose: loose,
                  useBuiltIns: pluginUseBuiltIns,
                },
              ]);
            });
            var regenerator = transformations.has("transform-regenerator");

            if (debug) {
              console.log("@gerhobbelt/babel-preset-env: `DEBUG` option");
              console.log("\nUsing targets:");
              console.log(
                JSON.stringify((0, _utils.prettifyTargets)(targets), null, 2)
              );
              console.log("\nUsing modules transform: " + modules.toString());
              console.log("\nUsing plugins:");
              transformations.forEach(function(transform) {
                (0, _debug.logPlugin)(transform, targets, _plugins.default);
              });

              if (!useBuiltIns) {
                console.log(
                  "\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set."
                );
              } else {
                console.log(
                  "\nUsing polyfills with `" + useBuiltIns + "` option:"
                );
              }
            }

            if (useBuiltIns === "usage" || useBuiltIns === "entry") {
              var pluginOptions = {
                debug: debug,
                polyfills: polyfills,
                regenerator: regenerator,
                onDebug: function onDebug(polyfills, context) {
                  polyfills.forEach(function(polyfill) {
                    return (0,
                    _debug.logPlugin)(polyfill, targets, _builtIns.default, context);
                  });
                },
              };
              plugins.push([
                useBuiltIns === "usage"
                  ? _useBuiltInsPlugin.default
                  : _useBuiltInsEntryPlugin.default,
                pluginOptions,
              ]);
            }

            return {
              plugins: plugins,
            };
          });

          exports.default = _default;
        },
        /* 169 */
        function(module, exports) {
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          module.exports = _inheritsLoose;
        },
        /* 170 */
        function(module, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            "version",
            function() {
              return version;
            }
          );
          /* harmony import */ var _gerhobbelt_babel_standalone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            22
          );
          /* harmony import */ var _gerhobbelt_babel_standalone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
            _gerhobbelt_babel_standalone__WEBPACK_IMPORTED_MODULE_0__
          );
          /* harmony import */ var _gerhobbelt_babel_preset_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            168
          );
          /* harmony import */ var _gerhobbelt_babel_preset_env__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
            _gerhobbelt_babel_preset_env__WEBPACK_IMPORTED_MODULE_1__
          );

          Object(
            _gerhobbelt_babel_standalone__WEBPACK_IMPORTED_MODULE_0__[
              "registerPreset"
            ]
          )(
            "env",
            _gerhobbelt_babel_preset_env__WEBPACK_IMPORTED_MODULE_1___default.a
          );
          var version = "7.0.1-16";
        },
        /* 171 */
        function(module, exports, __webpack_require__) {
          /* WEBPACK VAR INJECTION */ (function(global, process) {
            var formatRegExp = /%[sdj%]/g;

            exports.format = function(f) {
              if (!isString(f)) {
                var objects = [];

                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }

                return objects.join(" ");
              }

              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f).replace(formatRegExp, function(x) {
                if (x === "%%") return "%";
                if (i >= len) return x;

                switch (x) {
                  case "%s":
                    return String(args[i++]);

                  case "%d":
                    return Number(args[i++]);

                  case "%j":
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return "[Circular]";
                    }

                  default:
                    return x;
                }
              });

              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                  str += " " + x;
                } else {
                  str += " " + inspect(x);
                }
              }

              return str;
            };

            exports.deprecate = function(fn, msg) {
              if (isUndefined(global.process)) {
                return function() {
                  return exports.deprecate(fn, msg).apply(this, arguments);
                };
              }

              if (process.noDeprecation === true) {
                return fn;
              }

              var warned = false;

              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }

                  warned = true;
                }

                return fn.apply(this, arguments);
              }

              return deprecated;
            };

            var debugs = {};
            var debugEnviron;

            exports.debuglog = function(set) {
              if (isUndefined(debugEnviron)) debugEnviron = undefined || "";
              set = set.toUpperCase();

              if (!debugs[set]) {
                if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                  var pid = process.pid;

                  debugs[set] = function() {
                    var msg = exports.format.apply(exports, arguments);
                    console.error("%s %d: %s", set, pid, msg);
                  };
                } else {
                  debugs[set] = function() {};
                }
              }

              return debugs[set];
            };

            function inspect(obj, opts) {
              var ctx = {
                seen: [],
                stylize: stylizeNoColor,
              };
              if (arguments.length >= 3) ctx.depth = arguments[2];
              if (arguments.length >= 4) ctx.colors = arguments[3];

              if (isBoolean(opts)) {
                ctx.showHidden = opts;
              } else if (opts) {
                exports._extend(ctx, opts);
              }

              if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
              if (isUndefined(ctx.depth)) ctx.depth = 2;
              if (isUndefined(ctx.colors)) ctx.colors = false;
              if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
              if (ctx.colors) ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }

            exports.inspect = inspect;
            inspect.colors = {
              bold: [1, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              white: [37, 39],
              grey: [90, 39],
              black: [30, 39],
              blue: [34, 39],
              cyan: [36, 39],
              green: [32, 39],
              magenta: [35, 39],
              red: [31, 39],
              yellow: [33, 39],
            };
            inspect.styles = {
              special: "cyan",
              number: "yellow",
              boolean: "yellow",
              undefined: "grey",
              null: "bold",
              string: "green",
              date: "magenta",
              regexp: "red",
            };

            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];

              if (style) {
                return (
                  "\x1B[" +
                  inspect.colors[style][0] +
                  "m" +
                  str +
                  "\x1B[" +
                  inspect.colors[style][1] +
                  "m"
                );
              } else {
                return str;
              }
            }

            function stylizeNoColor(str, styleType) {
              return str;
            }

            function arrayToHash(array) {
              var hash = {};
              array.forEach(function(val, idx) {
                hash[val] = true;
              });
              return hash;
            }

            function formatValue(ctx, value, recurseTimes) {
              if (
                ctx.customInspect &&
                value &&
                isFunction(value.inspect) &&
                value.inspect !== exports.inspect &&
                !(value.constructor && value.constructor.prototype === value)
              ) {
                var ret = value.inspect(recurseTimes, ctx);

                if (!isString(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }

                return ret;
              }

              var primitive = formatPrimitive(ctx, value);

              if (primitive) {
                return primitive;
              }

              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);

              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }

              if (
                isError(value) &&
                (keys.indexOf("message") >= 0 ||
                  keys.indexOf("description") >= 0)
              ) {
                return formatError(value);
              }

              if (keys.length === 0) {
                if (isFunction(value)) {
                  var name = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name + "]", "special");
                }

                if (isRegExp(value)) {
                  return ctx.stylize(
                    RegExp.prototype.toString.call(value),
                    "regexp"
                  );
                }

                if (isDate(value)) {
                  return ctx.stylize(
                    Date.prototype.toString.call(value),
                    "date"
                  );
                }

                if (isError(value)) {
                  return formatError(value);
                }
              }

              var base = "",
                array = false,
                braces = ["{", "}"];

              if (isArray(value)) {
                array = true;
                braces = ["[", "]"];
              }

              if (isFunction(value)) {
                var n = value.name ? ": " + value.name : "";
                base = " [Function" + n + "]";
              }

              if (isRegExp(value)) {
                base = " " + RegExp.prototype.toString.call(value);
              }

              if (isDate(value)) {
                base = " " + Date.prototype.toUTCString.call(value);
              }

              if (isError(value)) {
                base = " " + formatError(value);
              }

              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }

              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(
                    RegExp.prototype.toString.call(value),
                    "regexp"
                  );
                } else {
                  return ctx.stylize("[Object]", "special");
                }
              }

              ctx.seen.push(value);
              var output;

              if (array) {
                output = formatArray(
                  ctx,
                  value,
                  recurseTimes,
                  visibleKeys,
                  keys
                );
              } else {
                output = keys.map(function(key) {
                  return formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    key,
                    array
                  );
                });
              }

              ctx.seen.pop();
              return reduceToSingleString(output, base, braces);
            }

            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize("undefined", "undefined");

              if (isString(value)) {
                var simple =
                  "'" +
                  JSON.stringify(value)
                    .replace(/^"|"$/g, "")
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"') +
                  "'";
                return ctx.stylize(simple, "string");
              }

              if (isNumber(value)) return ctx.stylize("" + value, "number");
              if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
              if (isNull(value)) return ctx.stylize("null", "null");
            }

            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }

            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];

              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                  output.push(
                    formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      String(i),
                      true
                    )
                  );
                } else {
                  output.push("");
                }
              }

              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(
                    formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      key,
                      true
                    )
                  );
                }
              });
              return output;
            }

            function formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              array
            ) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || {
                value: value[key],
              };

              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize("[Getter/Setter]", "special");
                } else {
                  str = ctx.stylize("[Getter]", "special");
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize("[Setter]", "special");
                }
              }

              if (!hasOwnProperty(visibleKeys, key)) {
                name = "[" + key + "]";
              }

              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }

                  if (str.indexOf("\n") > -1) {
                    if (array) {
                      str = str
                        .split("\n")
                        .map(function(line) {
                          return "  " + line;
                        })
                        .join("\n")
                        .substr(2);
                    } else {
                      str =
                        "\n" +
                        str
                          .split("\n")
                          .map(function(line) {
                            return "   " + line;
                          })
                          .join("\n");
                    }
                  }
                } else {
                  str = ctx.stylize("[Circular]", "special");
                }
              }

              if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }

                name = JSON.stringify("" + key);

                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2);
                  name = ctx.stylize(name, "name");
                } else {
                  name = name
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"')
                    .replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, "string");
                }
              }

              return name + ": " + str;
            }

            function reduceToSingleString(output, base, braces) {
              var numLinesEst = 0;
              var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf("\n") >= 0) numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);

              if (length > 60) {
                return (
                  braces[0] +
                  (base === "" ? "" : base + "\n ") +
                  " " +
                  output.join(",\n  ") +
                  " " +
                  braces[1]
                );
              }

              return (
                braces[0] + base + " " + output.join(", ") + " " + braces[1]
              );
            }

            function isArray(ar) {
              return Array.isArray(ar);
            }

            exports.isArray = isArray;

            function isBoolean(arg) {
              return typeof arg === "boolean";
            }

            exports.isBoolean = isBoolean;

            function isNull(arg) {
              return arg === null;
            }

            exports.isNull = isNull;

            function isNullOrUndefined(arg) {
              return arg == null;
            }

            exports.isNullOrUndefined = isNullOrUndefined;

            function isNumber(arg) {
              return typeof arg === "number";
            }

            exports.isNumber = isNumber;

            function isString(arg) {
              return typeof arg === "string";
            }

            exports.isString = isString;

            function isSymbol(arg) {
              return typeof arg === "symbol";
            }

            exports.isSymbol = isSymbol;

            function isUndefined(arg) {
              return arg === void 0;
            }

            exports.isUndefined = isUndefined;

            function isRegExp(re) {
              return isObject(re) && objectToString(re) === "[object RegExp]";
            }

            exports.isRegExp = isRegExp;

            function isObject(arg) {
              return typeof arg === "object" && arg !== null;
            }

            exports.isObject = isObject;

            function isDate(d) {
              return isObject(d) && objectToString(d) === "[object Date]";
            }

            exports.isDate = isDate;

            function isError(e) {
              return (
                isObject(e) &&
                (objectToString(e) === "[object Error]" || e instanceof Error)
              );
            }

            exports.isError = isError;

            function isFunction(arg) {
              return typeof arg === "function";
            }

            exports.isFunction = isFunction;

            function isPrimitive(arg) {
              return (
                arg === null ||
                typeof arg === "boolean" ||
                typeof arg === "number" ||
                typeof arg === "string" ||
                typeof arg === "symbol" ||
                typeof arg === "undefined"
              );
            }

            exports.isPrimitive = isPrimitive;
            exports.isBuffer = __webpack_require__(172);

            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }

            function pad(n) {
              return n < 10 ? "0" + n.toString(10) : n.toString(10);
            }

            var months = [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec",
            ];

            function timestamp() {
              var d = new Date();
              var time = [
                pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds()),
              ].join(":");
              return [d.getDate(), months[d.getMonth()], time].join(" ");
            }

            exports.log = function() {
              console.log(
                "%s - %s",
                timestamp(),
                exports.format.apply(exports, arguments)
              );
            };

            exports.inherits = __webpack_require__(173);

            exports._extend = function(origin, add) {
              if (!add || !isObject(add)) return origin;
              var keys = Object.keys(add);
              var i = keys.length;

              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }

              return origin;
            };

            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(24), __webpack_require__(3)));
        },
        /* 172 */
        function(module, exports) {
          module.exports = function isBuffer(arg) {
            return (
              arg &&
              typeof arg === "object" &&
              typeof arg.copy === "function" &&
              typeof arg.fill === "function" &&
              typeof arg.readUInt8 === "function"
            );
          };
        },
        /* 173 */
        function(module, exports) {
          if (typeof Object.create === "function") {
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              });
            };
          } else {
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;

              var TempCtor = function TempCtor() {};

              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            };
          }
        },
        /* 174 */
        function(module, exports, __webpack_require__) {
          "use strict";

          module.exports = (function() {
            function _min(d0, d1, d2, bx, ay) {
              return d0 < d1 || d2 < d1
                ? d0 > d2
                  ? d2 + 1
                  : d0 + 1
                : bx === ay
                  ? d1
                  : d1 + 1;
            }

            return function(a, b) {
              if (a === b) {
                return 0;
              }

              if (a.length > b.length) {
                var tmp = a;
                a = b;
                b = tmp;
              }

              var la = a.length;
              var lb = b.length;

              while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {
                la--;
                lb--;
              }

              var offset = 0;

              while (
                offset < la &&
                a.charCodeAt(offset) === b.charCodeAt(offset)
              ) {
                offset++;
              }

              la -= offset;
              lb -= offset;

              if (la === 0 || lb === 1) {
                return lb;
              }

              var x = 0;
              var y;
              var d0;
              var d1;
              var d2;
              var d3;
              var dd;
              var dy;
              var ay;
              var bx0;
              var bx1;
              var bx2;
              var bx3;
              var vector = [];

              for (y = 0; y < la; y++) {
                vector.push(y + 1);
                vector.push(a.charCodeAt(offset + y));
              }

              for (; x + 3 < lb; ) {
                bx0 = b.charCodeAt(offset + (d0 = x));
                bx1 = b.charCodeAt(offset + (d1 = x + 1));
                bx2 = b.charCodeAt(offset + (d2 = x + 2));
                bx3 = b.charCodeAt(offset + (d3 = x + 3));
                dd = x += 4;

                for (y = 0; y < vector.length; y += 2) {
                  dy = vector[y];
                  ay = vector[y + 1];
                  d0 = _min(dy, d0, d1, bx0, ay);
                  d1 = _min(d0, d1, d2, bx1, ay);
                  d2 = _min(d1, d2, d3, bx2, ay);
                  dd = _min(d2, d3, dd, bx3, ay);
                  vector[y] = dd;
                  d3 = d2;
                  d2 = d1;
                  d1 = d0;
                  d0 = dy;
                }
              }

              for (; x < lb; ) {
                bx0 = b.charCodeAt(offset + (d0 = x));
                dd = ++x;

                for (y = 0; y < vector.length; y += 2) {
                  dy = vector[y];
                  vector[y] = dd =
                    dy < d0 || dd < d0
                      ? dy > dd
                        ? dd + 1
                        : dy + 1
                      : bx0 === vector[y + 1]
                        ? d0
                        : d0 + 1;
                  d0 = dy;
                }
              }

              return dd;
            };
          })();
        },
        /* 175 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.addDefault = addDefault;
          exports.addNamed = addNamed;
          exports.addNamespace = addNamespace;
          exports.addSideEffect = addSideEffect;
          Object.defineProperty(exports, "ImportInjector", {
            enumerable: true,
            get: function get() {
              return _importInjector.default;
            },
          });
          Object.defineProperty(exports, "isModule", {
            enumerable: true,
            get: function get() {
              return _isModule.default;
            },
          });

          var _importInjector = _interopRequireDefault(
            __webpack_require__(176)
          );

          var _isModule = _interopRequireDefault(__webpack_require__(126));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function addDefault(path, importedSource, opts) {
            return new _importInjector.default(path).addDefault(
              importedSource,
              opts
            );
          }

          function addNamed(path, name, importedSource, opts) {
            return new _importInjector.default(path).addNamed(
              name,
              importedSource,
              opts
            );
          }

          function addNamespace(path, importedSource, opts) {
            return new _importInjector.default(path).addNamespace(
              importedSource,
              opts
            );
          }

          function addSideEffect(path, importedSource, opts) {
            return new _importInjector.default(path).addSideEffect(
              importedSource,
              opts
            );
          }
        },
        /* 176 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function _assert() {
            var data = _interopRequireDefault(__webpack_require__(23));

            _assert = function _assert() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          var _importBuilder = _interopRequireDefault(__webpack_require__(296));

          var _isModule = _interopRequireDefault(__webpack_require__(126));

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var ImportInjector = (function() {
            function ImportInjector(path, importedSource, opts) {
              this._defaultOpts = {
                importedSource: null,
                importedType: "commonjs",
                importedInterop: "babel",
                importingInterop: "babel",
                ensureLiveReference: false,
                ensureNoContext: false,
              };
              var programPath = path.find(function(p) {
                return p.isProgram();
              });
              this._programPath = programPath;
              this._programScope = programPath.scope;
              this._hub = programPath.hub;
              this._defaultOpts = this._applyDefaults(
                importedSource,
                opts,
                true
              );
            }

            var _proto = ImportInjector.prototype;

            _proto.addDefault = function addDefault(importedSourceIn, opts) {
              return this.addNamed("default", importedSourceIn, opts);
            };

            _proto.addNamed = function addNamed(
              importName,
              importedSourceIn,
              opts
            ) {
              (0, _assert().default)(typeof importName === "string");
              return this._generateImport(
                this._applyDefaults(importedSourceIn, opts),
                importName
              );
            };

            _proto.addNamespace = function addNamespace(
              importedSourceIn,
              opts
            ) {
              return this._generateImport(
                this._applyDefaults(importedSourceIn, opts),
                null
              );
            };

            _proto.addSideEffect = function addSideEffect(
              importedSourceIn,
              opts
            ) {
              return this._generateImport(
                this._applyDefaults(importedSourceIn, opts),
                false
              );
            };

            _proto._applyDefaults = function _applyDefaults(
              importedSource,
              opts,
              isInit
            ) {
              if (isInit === void 0) {
                isInit = false;
              }

              var optsList = [];

              if (typeof importedSource === "string") {
                optsList.push({
                  importedSource: importedSource,
                });
                optsList.push(opts);
              } else {
                (0, _assert().default)(
                  !opts,
                  "Unexpected secondary arguments."
                );
                optsList.push(importedSource);
              }

              var newOpts = Object.assign({}, this._defaultOpts);

              var _loop = function _loop() {
                var opts = optsList[_i];
                if (!opts) return "continue";
                Object.keys(newOpts).forEach(function(key) {
                  if (opts[key] !== undefined) newOpts[key] = opts[key];
                });

                if (!isInit) {
                  if (opts.nameHint !== undefined)
                    newOpts.nameHint = opts.nameHint;
                  if (opts.blockHoist !== undefined)
                    newOpts.blockHoist = opts.blockHoist;
                }
              };

              for (var _i = 0; _i < optsList.length; _i++) {
                var _ret = _loop();

                if (_ret === "continue") continue;
              }

              return newOpts;
            };

            _proto._generateImport = function _generateImport(
              opts,
              importName
            ) {
              var isDefault = importName === "default";
              var isNamed = !!importName && !isDefault;
              var isNamespace = importName === null;
              var importedSource = opts.importedSource,
                importedType = opts.importedType,
                importedInterop = opts.importedInterop,
                importingInterop = opts.importingInterop,
                ensureLiveReference = opts.ensureLiveReference,
                ensureNoContext = opts.ensureNoContext,
                nameHint = opts.nameHint,
                blockHoist = opts.blockHoist;
              var name = nameHint || importName;
              var isMod = (0, _isModule.default)(this._programPath);
              var isModuleForNode = isMod && importingInterop === "node";
              var isModuleForBabel = isMod && importingInterop === "babel";
              var builder = new _importBuilder.default(
                importedSource,
                this._programScope,
                this._hub
              );

              if (importedType === "es6") {
                if (!isModuleForNode && !isModuleForBabel) {
                  throw new Error("Cannot import an ES6 module from CommonJS");
                }

                builder.import();

                if (isNamespace) {
                  builder.namespace(nameHint || importedSource);
                } else if (isDefault || isNamed) {
                  builder.named(name, importName);
                }
              } else if (importedType !== "commonjs") {
                throw new Error(
                  'Unexpected interopType "' + importedType + '"'
                );
              } else if (importedInterop === "babel") {
                if (isModuleForNode) {
                  name = name !== "default" ? name : importedSource;
                  var es6Default = importedSource + "$es6Default";
                  builder.import();

                  if (isNamespace) {
                    builder
                      .default(es6Default)
                      .var(name || importedSource)
                      .wildcardInterop();
                  } else if (isDefault) {
                    if (ensureLiveReference) {
                      builder
                        .default(es6Default)
                        .var(name || importedSource)
                        .defaultInterop()
                        .read("default");
                    } else {
                      builder
                        .default(es6Default)
                        .var(name)
                        .defaultInterop()
                        .prop(importName);
                    }
                  } else if (isNamed) {
                    builder.default(es6Default).read(importName);
                  }
                } else if (isModuleForBabel) {
                  builder.import();

                  if (isNamespace) {
                    builder.namespace(name || importedSource);
                  } else if (isDefault || isNamed) {
                    builder.named(name, importName);
                  }
                } else {
                  builder.require();

                  if (isNamespace) {
                    builder.var(name || importedSource).wildcardInterop();
                  } else if ((isDefault || isNamed) && ensureLiveReference) {
                    if (isDefault) {
                      name = name !== "default" ? name : importedSource;
                      builder.var(name).read(importName);
                      builder.defaultInterop();
                    } else {
                      builder.var(importedSource).read(importName);
                    }
                  } else if (isDefault) {
                    builder
                      .var(name)
                      .defaultInterop()
                      .prop(importName);
                  } else if (isNamed) {
                    builder.var(name).prop(importName);
                  }
                }
              } else if (importedInterop === "compiled") {
                if (isModuleForNode) {
                  builder.import();

                  if (isNamespace) {
                    builder.default(name || importedSource);
                  } else if (isDefault || isNamed) {
                    builder.default(importedSource).read(name);
                  }
                } else if (isModuleForBabel) {
                  builder.import();

                  if (isNamespace) {
                    builder.namespace(name || importedSource);
                  } else if (isDefault || isNamed) {
                    builder.named(name, importName);
                  }
                } else {
                  builder.require();

                  if (isNamespace) {
                    builder.var(name || importedSource);
                  } else if (isDefault || isNamed) {
                    if (ensureLiveReference) {
                      builder.var(importedSource).read(name);
                    } else {
                      builder.prop(importName).var(name);
                    }
                  }
                }
              } else if (importedInterop === "uncompiled") {
                if (isDefault && ensureLiveReference) {
                  throw new Error("No live reference for commonjs default");
                }

                if (isModuleForNode) {
                  builder.import();

                  if (isNamespace) {
                    builder.default(name || importedSource);
                  } else if (isDefault) {
                    builder.default(name);
                  } else if (isNamed) {
                    builder.default(importedSource).read(name);
                  }
                } else if (isModuleForBabel) {
                  builder.import();

                  if (isNamespace) {
                    builder.default(name || importedSource);
                  } else if (isDefault) {
                    builder.default(name);
                  } else if (isNamed) {
                    builder.named(name, importName);
                  }
                } else {
                  builder.require();

                  if (isNamespace) {
                    builder.var(name || importedSource);
                  } else if (isDefault) {
                    builder.var(name);
                  } else if (isNamed) {
                    if (ensureLiveReference) {
                      builder.var(importedSource).read(name);
                    } else {
                      builder.var(name).prop(importName);
                    }
                  }
                }
              } else {
                throw new Error(
                  'Unknown importedInterop "' + importedInterop + '".'
                );
              }

              var _builder$done = builder.done(),
                statements = _builder$done.statements,
                resultName = _builder$done.resultName;

              this._insertStatements(statements, blockHoist);

              if (
                (isDefault || isNamed) &&
                ensureNoContext &&
                resultName.type !== "Identifier"
              ) {
                return t().sequenceExpression([
                  t().numericLiteral(0),
                  resultName,
                ]);
              }

              return resultName;
            };

            _proto._insertStatements = function _insertStatements(
              statements,
              blockHoist
            ) {
              if (blockHoist === void 0) {
                blockHoist = 3;
              }

              statements.forEach(function(node) {
                node._blockHoist = blockHoist;
              });

              var targetPath = this._programPath
                .get("body")
                .filter(function(p) {
                  var val = p.node._blockHoist;
                  return Number.isFinite(val) && val < 4;
                })[0];

              if (targetPath) {
                targetPath.insertBefore(statements);
              } else {
                this._programPath.unshiftContainer("body", statements);
              }
            };

            return ImportInjector;
          })();

          exports.default = ImportInjector;
        },
        /* 177 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          var _buildMatchMemberExpression = _interopRequireDefault(
            __webpack_require__(87)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var isReactComponent = (0, _buildMatchMemberExpression.default)(
            "React.Component"
          );
          var _default = isReactComponent;
          exports.default = _default;
        },
        /* 178 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isCompatTag;

          function isCompatTag(tagName) {
            return !!tagName && /^[a-z]/.test(tagName);
          }
        },
        /* 179 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = buildChildren;

          var _generated = __webpack_require__(2);

          var _cleanJSXElementLiteralChild = _interopRequireDefault(
            __webpack_require__(180)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function buildChildren(node) {
            var elements = [];

            for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];

              if ((0, _generated.isJSXText)(child)) {
                (0, _cleanJSXElementLiteralChild.default)(child, elements);
                continue;
              }

              if ((0, _generated.isJSXExpressionContainer)(child))
                child = child.expression;
              if ((0, _generated.isJSXEmptyExpression)(child)) continue;
              elements.push(child);
            }

            return elements;
          }
        },
        /* 180 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = cleanJSXElementLiteralChild;

          var _generated = __webpack_require__(4);

          function cleanJSXElementLiteralChild(child, args) {
            var lines = child.value.split(/\r\n|\n|\r/);
            var lastNonEmptyLine = 0;

            for (var i = 0; i < lines.length; i++) {
              if (lines[i].match(/[^ \t]/)) {
                lastNonEmptyLine = i;
              }
            }

            var str = "";

            for (var _i = 0; _i < lines.length; _i++) {
              var line = lines[_i];
              var isFirstLine = _i === 0;
              var isLastLine = _i === lines.length - 1;
              var isLastNonEmptyLine = _i === lastNonEmptyLine;
              var trimmedLine = line.replace(/\t/g, " ");

              if (!isFirstLine) {
                trimmedLine = trimmedLine.replace(/^[ ]+/, "");
              }

              if (!isLastLine) {
                trimmedLine = trimmedLine.replace(/[ ]+$/, "");
              }

              if (trimmedLine) {
                if (!isLastNonEmptyLine) {
                  trimmedLine += " ";
                }

                str += trimmedLine;
              }
            }

            if (str) args.push((0, _generated.stringLiteral)(str));
          }
        },
        /* 181 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = builder;

          function _clone() {
            var data = _interopRequireDefault(__webpack_require__(89));

            _clone = function _clone() {
              return data;
            };

            return data;
          }

          var _definitions = __webpack_require__(8);

          var _validate = _interopRequireDefault(__webpack_require__(108));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function builder(type) {
            for (
              var _len = arguments.length,
                args = new Array(_len > 1 ? _len - 1 : 0),
                _key = 1;
              _key < _len;
              _key++
            ) {
              args[_key - 1] = arguments[_key];
            }

            var keys = _definitions.BUILDER_KEYS[type];
            var countArgs = args.length;

            if (countArgs > keys.length) {
              throw new Error(
                type +
                  ": Too many arguments passed. Received " +
                  countArgs +
                  " but can receive no more than " +
                  keys.length
              );
            }

            var node = {
              type: type,
            };
            var i = 0;
            keys.forEach(function(key) {
              var field = _definitions.NODE_FIELDS[type][key];
              var arg;
              if (i < countArgs) arg = args[i];
              if (arg === undefined) arg = (0, _clone().default)(field.default);
              node[key] = arg;
              i++;
            });

            for (var key in node) {
              (0, _validate.default)(node, key, node[key]);
            }

            return node;
          }
        },
        /* 182 */
        function(module, exports) {
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }

          module.exports = listCacheClear;
        },
        /* 183 */
        function(module, exports, __webpack_require__) {
          var assocIndexOf = __webpack_require__(33);

          var arrayProto = Array.prototype;
          var splice = arrayProto.splice;

          function listCacheDelete(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);

            if (index < 0) {
              return false;
            }

            var lastIndex = data.length - 1;

            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }

            --this.size;
            return true;
          }

          module.exports = listCacheDelete;
        },
        /* 184 */
        function(module, exports, __webpack_require__) {
          var assocIndexOf = __webpack_require__(33);

          function listCacheGet(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }

          module.exports = listCacheGet;
        },
        /* 185 */
        function(module, exports, __webpack_require__) {
          var assocIndexOf = __webpack_require__(33);

          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }

          module.exports = listCacheHas;
        },
        /* 186 */
        function(module, exports, __webpack_require__) {
          var assocIndexOf = __webpack_require__(33);

          function listCacheSet(key, value) {
            var data = this.__data__,
              index = assocIndexOf(data, key);

            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }

            return this;
          }

          module.exports = listCacheSet;
        },
        /* 187 */
        function(module, exports, __webpack_require__) {
          var ListCache = __webpack_require__(32);

          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }

          module.exports = stackClear;
        },
        /* 188 */
        function(module, exports) {
          function stackDelete(key) {
            var data = this.__data__,
              result = data["delete"](key);
            this.size = data.size;
            return result;
          }

          module.exports = stackDelete;
        },
        /* 189 */
        function(module, exports) {
          function stackGet(key) {
            return this.__data__.get(key);
          }

          module.exports = stackGet;
        },
        /* 190 */
        function(module, exports) {
          function stackHas(key) {
            return this.__data__.has(key);
          }

          module.exports = stackHas;
        },
        /* 191 */
        function(module, exports, __webpack_require__) {
          var ListCache = __webpack_require__(32),
            Map = __webpack_require__(53),
            MapCache = __webpack_require__(54);

          var LARGE_ARRAY_SIZE = 200;

          function stackSet(key, value) {
            var data = this.__data__;

            if (data instanceof ListCache) {
              var pairs = data.__data__;

              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }

              data = this.__data__ = new MapCache(pairs);
            }

            data.set(key, value);
            this.size = data.size;
            return this;
          }

          module.exports = stackSet;
        },
        /* 192 */
        function(module, exports, __webpack_require__) {
          var isFunction = __webpack_require__(91),
            isMasked = __webpack_require__(195),
            isObject = __webpack_require__(11),
            toSource = __webpack_require__(93);

          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
          var reIsHostCtor = /^\[object .+?Constructor\]$/;
          var funcProto = Function.prototype,
            objectProto = Object.prototype;
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var reIsNative = RegExp(
            "^" +
              funcToString
                .call(hasOwnProperty)
                .replace(reRegExpChar, "\\$&")
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  "$1.*?"
                ) +
              "$"
          );

          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }

            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }

          module.exports = baseIsNative;
        },
        /* 193 */
        function(module, exports, __webpack_require__) {
          var Symbol = __webpack_require__(18);

          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var nativeObjectToString = objectProto.toString;
          var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag];

            try {
              value[symToStringTag] = undefined;
              var unmasked = true;
            } catch (e) {}

            var result = nativeObjectToString.call(value);

            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }

            return result;
          }

          module.exports = getRawTag;
        },
        /* 194 */
        function(module, exports) {
          var objectProto = Object.prototype;
          var nativeObjectToString = objectProto.toString;

          function objectToString(value) {
            return nativeObjectToString.call(value);
          }

          module.exports = objectToString;
        },
        /* 195 */
        function(module, exports, __webpack_require__) {
          var coreJsData = __webpack_require__(196);

          var maskSrcKey = (function() {
            var uid = /[^.]+$/.exec(
              (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ""
            );
            return uid ? "Symbol(src)_1." + uid : "";
          })();

          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }

          module.exports = isMasked;
        },
        /* 196 */
        function(module, exports, __webpack_require__) {
          var root = __webpack_require__(6);

          var coreJsData = root["__core-js_shared__"];
          module.exports = coreJsData;
        },
        /* 197 */
        function(module, exports) {
          function getValue(object, key) {
            return object == null ? undefined : object[key];
          }

          module.exports = getValue;
        },
        /* 198 */
        function(module, exports, __webpack_require__) {
          var Hash = __webpack_require__(199),
            ListCache = __webpack_require__(32),
            Map = __webpack_require__(53);

          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              hash: new Hash(),
              map: new (Map || ListCache)(),
              string: new Hash(),
            };
          }

          module.exports = mapCacheClear;
        },
        /* 199 */
        function(module, exports, __webpack_require__) {
          var hashClear = __webpack_require__(200),
            hashDelete = __webpack_require__(201),
            hashGet = __webpack_require__(202),
            hashHas = __webpack_require__(203),
            hashSet = __webpack_require__(204);

          function Hash(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();

            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          module.exports = Hash;
        },
        /* 200 */
        function(module, exports, __webpack_require__) {
          var nativeCreate = __webpack_require__(34);

          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }

          module.exports = hashClear;
        },
        /* 201 */
        function(module, exports) {
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }

          module.exports = hashDelete;
        },
        /* 202 */
        function(module, exports, __webpack_require__) {
          var nativeCreate = __webpack_require__(34);

          var HASH_UNDEFINED = "__lodash_hash_undefined__";
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;

          function hashGet(key) {
            var data = this.__data__;

            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }

            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }

          module.exports = hashGet;
        },
        /* 203 */
        function(module, exports, __webpack_require__) {
          var nativeCreate = __webpack_require__(34);

          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;

          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate
              ? data[key] !== undefined
              : hasOwnProperty.call(data, key);
          }

          module.exports = hashHas;
        },
        /* 204 */
        function(module, exports, __webpack_require__) {
          var nativeCreate = __webpack_require__(34);

          var HASH_UNDEFINED = "__lodash_hash_undefined__";

          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] =
              nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }

          module.exports = hashSet;
        },
        /* 205 */
        function(module, exports, __webpack_require__) {
          var getMapData = __webpack_require__(35);

          function mapCacheDelete(key) {
            var result = getMapData(this, key)["delete"](key);
            this.size -= result ? 1 : 0;
            return result;
          }

          module.exports = mapCacheDelete;
        },
        /* 206 */
        function(module, exports) {
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" ||
              type == "number" ||
              type == "symbol" ||
              type == "boolean"
              ? value !== "__proto__"
              : value === null;
          }

          module.exports = isKeyable;
        },
        /* 207 */
        function(module, exports, __webpack_require__) {
          var getMapData = __webpack_require__(35);

          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }

          module.exports = mapCacheGet;
        },
        /* 208 */
        function(module, exports, __webpack_require__) {
          var getMapData = __webpack_require__(35);

          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }

          module.exports = mapCacheHas;
        },
        /* 209 */
        function(module, exports, __webpack_require__) {
          var getMapData = __webpack_require__(35);

          function mapCacheSet(key, value) {
            var data = getMapData(this, key),
              size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          }

          module.exports = mapCacheSet;
        },
        /* 210 */
        function(module, exports) {
          function arrayEach(array, iteratee) {
            var index = -1,
              length = array == null ? 0 : array.length;

            while (++index < length) {
              if (iteratee(array[index], index, array) === false) {
                break;
              }
            }

            return array;
          }

          module.exports = arrayEach;
        },
        /* 211 */
        function(module, exports, __webpack_require__) {
          var copyObject = __webpack_require__(36),
            keys = __webpack_require__(19);

          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }

          module.exports = baseAssign;
        },
        /* 212 */
        function(module, exports) {
          function baseTimes(n, iteratee) {
            var index = -1,
              result = Array(n);

            while (++index < n) {
              result[index] = iteratee(index);
            }

            return result;
          }

          module.exports = baseTimes;
        },
        /* 213 */
        function(module, exports, __webpack_require__) {
          var baseGetTag = __webpack_require__(10),
            isObjectLike = __webpack_require__(7);

          var argsTag = "[object Arguments]";

          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }

          module.exports = baseIsArguments;
        },
        /* 214 */
        function(module, exports) {
          function stubFalse() {
            return false;
          }

          module.exports = stubFalse;
        },
        /* 215 */
        function(module, exports, __webpack_require__) {
          var baseGetTag = __webpack_require__(10),
            isLength = __webpack_require__(58),
            isObjectLike = __webpack_require__(7);

          var argsTag = "[object Arguments]",
            arrayTag = "[object Array]",
            boolTag = "[object Boolean]",
            dateTag = "[object Date]",
            errorTag = "[object Error]",
            funcTag = "[object Function]",
            mapTag = "[object Map]",
            numberTag = "[object Number]",
            objectTag = "[object Object]",
            regexpTag = "[object RegExp]",
            setTag = "[object Set]",
            stringTag = "[object String]",
            weakMapTag = "[object WeakMap]";
          var arrayBufferTag = "[object ArrayBuffer]",
            dataViewTag = "[object DataView]",
            float32Tag = "[object Float32Array]",
            float64Tag = "[object Float64Array]",
            int8Tag = "[object Int8Array]",
            int16Tag = "[object Int16Array]",
            int32Tag = "[object Int32Array]",
            uint8Tag = "[object Uint8Array]",
            uint8ClampedTag = "[object Uint8ClampedArray]",
            uint16Tag = "[object Uint16Array]",
            uint32Tag = "[object Uint32Array]";
          var typedArrayTags = {};
          typedArrayTags[float32Tag] = typedArrayTags[
            float64Tag
          ] = typedArrayTags[int8Tag] = typedArrayTags[
            int16Tag
          ] = typedArrayTags[int32Tag] = typedArrayTags[
            uint8Tag
          ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
            uint16Tag
          ] = typedArrayTags[uint32Tag] = true;
          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
            arrayBufferTag
          ] = typedArrayTags[boolTag] = typedArrayTags[
            dataViewTag
          ] = typedArrayTags[dateTag] = typedArrayTags[
            errorTag
          ] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[
            numberTag
          ] = typedArrayTags[objectTag] = typedArrayTags[
            regexpTag
          ] = typedArrayTags[setTag] = typedArrayTags[
            stringTag
          ] = typedArrayTags[weakMapTag] = false;

          function baseIsTypedArray(value) {
            return (
              isObjectLike(value) &&
              isLength(value.length) &&
              !!typedArrayTags[baseGetTag(value)]
            );
          }

          module.exports = baseIsTypedArray;
        },
        /* 216 */
        function(module, exports, __webpack_require__) {
          var isPrototype = __webpack_require__(59),
            nativeKeys = __webpack_require__(217);

          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;

          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }

            var result = [];

            for (var key in Object(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result.push(key);
              }
            }

            return result;
          }

          module.exports = baseKeys;
        },
        /* 217 */
        function(module, exports, __webpack_require__) {
          var overArg = __webpack_require__(99);

          var nativeKeys = overArg(Object.keys, Object);
          module.exports = nativeKeys;
        },
        /* 218 */
        function(module, exports, __webpack_require__) {
          var copyObject = __webpack_require__(36),
            keysIn = __webpack_require__(60);

          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }

          module.exports = baseAssignIn;
        },
        /* 219 */
        function(module, exports, __webpack_require__) {
          var isObject = __webpack_require__(11),
            isPrototype = __webpack_require__(59),
            nativeKeysIn = __webpack_require__(220);

          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;

          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }

            var isProto = isPrototype(object),
              result = [];

            for (var key in object) {
              if (
                !(
                  key == "constructor" &&
                  (isProto || !hasOwnProperty.call(object, key))
                )
              ) {
                result.push(key);
              }
            }

            return result;
          }

          module.exports = baseKeysIn;
        },
        /* 220 */
        function(module, exports) {
          function nativeKeysIn(object) {
            var result = [];

            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }

            return result;
          }

          module.exports = nativeKeysIn;
        },
        /* 221 */
        function(module, exports, __webpack_require__) {
          /* WEBPACK VAR INJECTION */ (function(module) {
            var root = __webpack_require__(6);

            var freeExports =
              typeof exports == "object" &&
              exports &&
              !exports.nodeType &&
              exports;
            var freeModule =
              freeExports &&
              typeof module == "object" &&
              module &&
              !module.nodeType &&
              module;
            var moduleExports =
              freeModule && freeModule.exports === freeExports;
            var Buffer = moduleExports ? root.Buffer : undefined,
              allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

            function cloneBuffer(buffer, isDeep) {
              if (isDeep) {
                return buffer.slice();
              }

              var length = buffer.length,
                result = allocUnsafe
                  ? allocUnsafe(length)
                  : new buffer.constructor(length);
              buffer.copy(result);
              return result;
            }

            module.exports = cloneBuffer;
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(37)(module)));
        },
        /* 222 */
        function(module, exports) {
          function copyArray(source, array) {
            var index = -1,
              length = source.length;
            array || (array = Array(length));

            while (++index < length) {
              array[index] = source[index];
            }

            return array;
          }

          module.exports = copyArray;
        },
        /* 223 */
        function(module, exports, __webpack_require__) {
          var copyObject = __webpack_require__(36),
            getSymbols = __webpack_require__(61);

          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }

          module.exports = copySymbols;
        },
        /* 224 */
        function(module, exports) {
          function arrayFilter(array, predicate) {
            var index = -1,
              length = array == null ? 0 : array.length,
              resIndex = 0,
              result = [];

            while (++index < length) {
              var value = array[index];

              if (predicate(value, index, array)) {
                result[resIndex++] = value;
              }
            }

            return result;
          }

          module.exports = arrayFilter;
        },
        /* 225 */
        function(module, exports, __webpack_require__) {
          var copyObject = __webpack_require__(36),
            getSymbolsIn = __webpack_require__(101);

          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }

          module.exports = copySymbolsIn;
        },
        /* 226 */
        function(module, exports, __webpack_require__) {
          var baseGetAllKeys = __webpack_require__(103),
            getSymbolsIn = __webpack_require__(101),
            keysIn = __webpack_require__(60);

          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }

          module.exports = getAllKeysIn;
        },
        /* 227 */
        function(module, exports, __webpack_require__) {
          var getNative = __webpack_require__(13),
            root = __webpack_require__(6);

          var DataView = getNative(root, "DataView");
          module.exports = DataView;
        },
        /* 228 */
        function(module, exports, __webpack_require__) {
          var getNative = __webpack_require__(13),
            root = __webpack_require__(6);

          var Promise = getNative(root, "Promise");
          module.exports = Promise;
        },
        /* 229 */
        function(module, exports, __webpack_require__) {
          var getNative = __webpack_require__(13),
            root = __webpack_require__(6);

          var WeakMap = getNative(root, "WeakMap");
          module.exports = WeakMap;
        },
        /* 230 */
        function(module, exports) {
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;

          function initCloneArray(array) {
            var length = array.length,
              result = new array.constructor(length);

            if (
              length &&
              typeof array[0] == "string" &&
              hasOwnProperty.call(array, "index")
            ) {
              result.index = array.index;
              result.input = array.input;
            }

            return result;
          }

          module.exports = initCloneArray;
        },
        /* 231 */
        function(module, exports, __webpack_require__) {
          var cloneArrayBuffer = __webpack_require__(64),
            cloneDataView = __webpack_require__(232),
            cloneRegExp = __webpack_require__(233),
            cloneSymbol = __webpack_require__(234),
            cloneTypedArray = __webpack_require__(235);

          var boolTag = "[object Boolean]",
            dateTag = "[object Date]",
            mapTag = "[object Map]",
            numberTag = "[object Number]",
            regexpTag = "[object RegExp]",
            setTag = "[object Set]",
            stringTag = "[object String]",
            symbolTag = "[object Symbol]";
          var arrayBufferTag = "[object ArrayBuffer]",
            dataViewTag = "[object DataView]",
            float32Tag = "[object Float32Array]",
            float64Tag = "[object Float64Array]",
            int8Tag = "[object Int8Array]",
            int16Tag = "[object Int16Array]",
            int32Tag = "[object Int32Array]",
            uint8Tag = "[object Uint8Array]",
            uint8ClampedTag = "[object Uint8ClampedArray]",
            uint16Tag = "[object Uint16Array]",
            uint32Tag = "[object Uint32Array]";

          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;

            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);

              case boolTag:
              case dateTag:
                return new Ctor(+object);

              case dataViewTag:
                return cloneDataView(object, isDeep);

              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);

              case mapTag:
                return new Ctor();

              case numberTag:
              case stringTag:
                return new Ctor(object);

              case regexpTag:
                return cloneRegExp(object);

              case setTag:
                return new Ctor();

              case symbolTag:
                return cloneSymbol(object);
            }
          }

          module.exports = initCloneByTag;
        },
        /* 232 */
        function(module, exports, __webpack_require__) {
          var cloneArrayBuffer = __webpack_require__(64);

          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep
              ? cloneArrayBuffer(dataView.buffer)
              : dataView.buffer;
            return new dataView.constructor(
              buffer,
              dataView.byteOffset,
              dataView.byteLength
            );
          }

          module.exports = cloneDataView;
        },
        /* 233 */
        function(module, exports) {
          var reFlags = /\w*$/;

          function cloneRegExp(regexp) {
            var result = new regexp.constructor(
              regexp.source,
              reFlags.exec(regexp)
            );
            result.lastIndex = regexp.lastIndex;
            return result;
          }

          module.exports = cloneRegExp;
        },
        /* 234 */
        function(module, exports, __webpack_require__) {
          var Symbol = __webpack_require__(18);

          var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

          function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
          }

          module.exports = cloneSymbol;
        },
        /* 235 */
        function(module, exports, __webpack_require__) {
          var cloneArrayBuffer = __webpack_require__(64);

          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep
              ? cloneArrayBuffer(typedArray.buffer)
              : typedArray.buffer;
            return new typedArray.constructor(
              buffer,
              typedArray.byteOffset,
              typedArray.length
            );
          }

          module.exports = cloneTypedArray;
        },
        /* 236 */
        function(module, exports, __webpack_require__) {
          var baseCreate = __webpack_require__(237),
            getPrototype = __webpack_require__(63),
            isPrototype = __webpack_require__(59);

          function initCloneObject(object) {
            return typeof object.constructor == "function" &&
              !isPrototype(object)
              ? baseCreate(getPrototype(object))
              : {};
          }

          module.exports = initCloneObject;
        },
        /* 237 */
        function(module, exports, __webpack_require__) {
          var isObject = __webpack_require__(11);

          var objectCreate = Object.create;

          var baseCreate = (function() {
            function object() {}

            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }

              if (objectCreate) {
                return objectCreate(proto);
              }

              object.prototype = proto;
              var result = new object();
              object.prototype = undefined;
              return result;
            };
          })();

          module.exports = baseCreate;
        },
        /* 238 */
        function(module, exports, __webpack_require__) {
          var baseIsMap = __webpack_require__(239),
            baseUnary = __webpack_require__(26),
            nodeUtil = __webpack_require__(38);

          var nodeIsMap = nodeUtil && nodeUtil.isMap;
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          module.exports = isMap;
        },
        /* 239 */
        function(module, exports, __webpack_require__) {
          var getTag = __webpack_require__(39),
            isObjectLike = __webpack_require__(7);

          var mapTag = "[object Map]";

          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }

          module.exports = baseIsMap;
        },
        /* 240 */
        function(module, exports, __webpack_require__) {
          var baseIsSet = __webpack_require__(241),
            baseUnary = __webpack_require__(26),
            nodeUtil = __webpack_require__(38);

          var nodeIsSet = nodeUtil && nodeUtil.isSet;
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          module.exports = isSet;
        },
        /* 241 */
        function(module, exports, __webpack_require__) {
          var getTag = __webpack_require__(39),
            isObjectLike = __webpack_require__(7);

          var setTag = "[object Set]";

          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }

          module.exports = baseIsSet;
        },
        /* 242 */
        function(module, exports, __webpack_require__) {
          "use strict";

          var fastProto = null;

          function FastObject(o) {
            if (fastProto !== null && typeof fastProto.property) {
              var result = fastProto;
              fastProto = FastObject.prototype = null;
              return result;
            }

            fastProto = FastObject.prototype =
              o == null ? Object.create(null) : o;
            return new FastObject();
          }

          FastObject();

          module.exports = function toFastproperties(o) {
            return FastObject(o);
          };
        },
        /* 243 */
        function(module, exports) {
          (function() {
            "use strict";

            function isExpression(node) {
              if (node == null) {
                return false;
              }

              switch (node.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }

              return false;
            }

            function isIterationStatement(node) {
              if (node == null) {
                return false;
              }

              switch (node.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }

              return false;
            }

            function isStatement(node) {
              if (node == null) {
                return false;
              }

              switch (node.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return true;
              }

              return false;
            }

            function isSourceElement(node) {
              return (
                isStatement(node) ||
                (node != null && node.type === "FunctionDeclaration")
              );
            }

            function trailingStatement(node) {
              switch (node.type) {
                case "IfStatement":
                  if (node.alternate != null) {
                    return node.alternate;
                  }

                  return node.consequent;

                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return node.body;
              }

              return null;
            }

            function isProblematicIfStatement(node) {
              var current;

              if (node.type !== "IfStatement") {
                return false;
              }

              if (node.alternate == null) {
                return false;
              }

              current = node.consequent;

              do {
                if (current.type === "IfStatement") {
                  if (current.alternate == null) {
                    return true;
                  }
                }

                current = trailingStatement(current);
              } while (current);

              return false;
            }

            module.exports = {
              isExpression: isExpression,
              isStatement: isStatement,
              isIterationStatement: isIterationStatement,
              isSourceElement: isSourceElement,
              isProblematicIfStatement: isProblematicIfStatement,
              trailingStatement: trailingStatement,
            };
          })();
        },
        /* 244 */
        function(module, exports, __webpack_require__) {
          (function() {
            "use strict";

            var code = __webpack_require__(107);

            function isStrictModeReservedWordES6(id) {
              switch (id) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;

                default:
                  return false;
              }
            }

            function isKeywordES5(id, strict) {
              if (!strict && id === "yield") {
                return false;
              }

              return isKeywordES6(id, strict);
            }

            function isKeywordES6(id, strict) {
              if (strict && isStrictModeReservedWordES6(id)) {
                return true;
              }

              switch (id.length) {
                case 2:
                  return id === "if" || id === "in" || id === "do";

                case 3:
                  return (
                    id === "var" || id === "for" || id === "new" || id === "try"
                  );

                case 4:
                  return (
                    id === "this" ||
                    id === "else" ||
                    id === "case" ||
                    id === "void" ||
                    id === "with" ||
                    id === "enum"
                  );

                case 5:
                  return (
                    id === "while" ||
                    id === "break" ||
                    id === "catch" ||
                    id === "throw" ||
                    id === "const" ||
                    id === "yield" ||
                    id === "class" ||
                    id === "super"
                  );

                case 6:
                  return (
                    id === "return" ||
                    id === "typeof" ||
                    id === "delete" ||
                    id === "switch" ||
                    id === "export" ||
                    id === "import"
                  );

                case 7:
                  return (
                    id === "default" || id === "finally" || id === "extends"
                  );

                case 8:
                  return (
                    id === "function" || id === "continue" || id === "debugger"
                  );

                case 10:
                  return id === "instanceof";

                default:
                  return false;
              }
            }

            function isReservedWordES5(id, strict) {
              return (
                id === "null" ||
                id === "true" ||
                id === "false" ||
                isKeywordES5(id, strict)
              );
            }

            function isReservedWordES6(id, strict) {
              return (
                id === "null" ||
                id === "true" ||
                id === "false" ||
                isKeywordES6(id, strict)
              );
            }

            function isRestrictedWord(id) {
              return id === "eval" || id === "arguments";
            }

            function isIdentifierNameES5(id) {
              var i, iz, ch;

              if (id.length === 0) {
                return false;
              }

              ch = id.charCodeAt(0);

              if (!code.isIdentifierStartES5(ch)) {
                return false;
              }

              for (i = 1, iz = id.length; i < iz; ++i) {
                ch = id.charCodeAt(i);

                if (!code.isIdentifierPartES5(ch)) {
                  return false;
                }
              }

              return true;
            }

            function decodeUtf16(lead, trail) {
              return (lead - 0xd800) * 0x400 + (trail - 0xdc00) + 0x10000;
            }

            function isIdentifierNameES6(id) {
              var i, iz, ch, lowCh, check;

              if (id.length === 0) {
                return false;
              }

              check = code.isIdentifierStartES6;

              for (i = 0, iz = id.length; i < iz; ++i) {
                ch = id.charCodeAt(i);

                if (0xd800 <= ch && ch <= 0xdbff) {
                  ++i;

                  if (i >= iz) {
                    return false;
                  }

                  lowCh = id.charCodeAt(i);

                  if (!(0xdc00 <= lowCh && lowCh <= 0xdfff)) {
                    return false;
                  }

                  ch = decodeUtf16(ch, lowCh);
                }

                if (!check(ch)) {
                  return false;
                }

                check = code.isIdentifierPartES6;
              }

              return true;
            }

            function isIdentifierES5(id, strict) {
              return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
            }

            function isIdentifierES6(id, strict) {
              return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
            }

            module.exports = {
              isKeywordES5: isKeywordES5,
              isKeywordES6: isKeywordES6,
              isReservedWordES5: isReservedWordES5,
              isReservedWordES6: isReservedWordES6,
              isRestrictedWord: isRestrictedWord,
              isIdentifierNameES5: isIdentifierNameES5,
              isIdentifierNameES6: isIdentifierNameES6,
              isIdentifierES5: isIdentifierES5,
              isIdentifierES6: isIdentifierES6,
            };
          })();
        },
        /* 245 */
        function(module, exports, __webpack_require__) {
          "use strict";

          var _utils = _interopRequireWildcard(__webpack_require__(12));

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          var defineInterfaceishType = function defineInterfaceishType(
            name,
            typeParameterType
          ) {
            if (typeParameterType === void 0) {
              typeParameterType = "TypeParameterDeclaration";
            }

            (0, _utils.default)(name, {
              builder: ["id", "typeParameters", "extends", "body"],
              visitor: [
                "id",
                "typeParameters",
                "extends",
                "mixins",
                "implements",
                "body",
              ],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: {
                id: (0, _utils.validateType)("Identifier"),
                typeParameters: (0, _utils.validateOptionalType)(
                  typeParameterType
                ),
                extends: (0, _utils.validateOptional)(
                  (0, _utils.arrayOfType)("InterfaceExtends")
                ),
                mixins: (0, _utils.validateOptional)(
                  (0, _utils.arrayOfType)("InterfaceExtends")
                ),
                implements: (0, _utils.validateOptional)(
                  (0, _utils.arrayOfType)("ClassImplements")
                ),
                body: (0, _utils.validateType)("ObjectTypeAnnotation"),
              },
            });
          };

          (0, _utils.default)("AnyTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
          });
          (0, _utils.default)("ArrayTypeAnnotation", {
            visitor: ["elementType"],
            aliases: ["Flow", "FlowType"],
            fields: {
              elementType: (0, _utils.validateType)("FlowType"),
            },
          });
          (0, _utils.default)("BooleanTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
          });
          (0, _utils.default)("BooleanLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["Flow", "FlowType"],
            fields: {
              value: (0, _utils.validate)(
                (0, _utils.assertValueType)("boolean")
              ),
            },
          });
          (0, _utils.default)("NullLiteralTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
          });
          (0, _utils.default)("ClassImplements", {
            visitor: ["id", "typeParameters"],
            aliases: ["Flow"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TypeParameterInstantiation"
              ),
            },
          });
          defineInterfaceishType("DeclareClass", "TypeParameterInstantiation");
          (0, _utils.default)("DeclareFunction", {
            visitor: ["id"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
              predicate: (0, _utils.validateOptionalType)("DeclaredPredicate"),
            },
          });
          defineInterfaceishType("DeclareInterface");
          (0, _utils.default)("DeclareModule", {
            builder: ["id", "body", "kind"],
            visitor: ["id", "body"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
              id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
              body: (0, _utils.validateType)("BlockStatement"),
              kind: (0, _utils.validateOptional)(
                (0, _utils.assertOneOf)("CommonJS", "ES")
              ),
            },
          });
          (0, _utils.default)("DeclareModuleExports", {
            visitor: ["typeAnnotation"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
              typeAnnotation: (0, _utils.validateType)("TypeAnnotation"),
            },
          });
          (0, _utils.default)("DeclareTypeAlias", {
            visitor: ["id", "typeParameters", "right"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TypeParameterDeclaration"
              ),
              right: (0, _utils.validateType)("FlowType"),
            },
          });
          (0, _utils.default)("DeclareOpaqueType", {
            visitor: ["id", "typeParameters", "supertype"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TypeParameterDeclaration"
              ),
              supertype: (0, _utils.validateOptionalType)("FlowType"),
            },
          });
          (0, _utils.default)("DeclareVariable", {
            visitor: ["id"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
            },
          });
          (0, _utils.default)("DeclareExportDeclaration", {
            visitor: ["declaration", "specifiers", "source"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
              declaration: (0, _utils.validateOptionalType)("Flow"),
              specifiers: (0, _utils.validateOptional)(
                (0, _utils.arrayOfType)([
                  "ExportSpecifier",
                  "ExportNamespaceSpecifier",
                ])
              ),
              source: (0, _utils.validateOptionalType)("StringLiteral"),
              default: (0, _utils.validateOptional)(
                (0, _utils.assertValueType)("boolean")
              ),
            },
          });
          (0, _utils.default)("DeclareExportAllDeclaration", {
            visitor: ["source"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
              source: (0, _utils.validateType)("StringLiteral"),
              exportKind: (0, _utils.validateOptional)(
                (0, _utils.assertOneOf)(["type", "value"])
              ),
            },
          });
          (0, _utils.default)("DeclaredPredicate", {
            visitor: ["value"],
            aliases: ["Flow", "FlowPredicate"],
            fields: {
              value: (0, _utils.validateType)("Flow"),
            },
          });
          (0, _utils.default)("ExistsTypeAnnotation", {
            aliases: ["Flow", "FlowType"],
          });
          (0, _utils.default)("FunctionTypeAnnotation", {
            visitor: ["typeParameters", "params", "rest", "returnType"],
            aliases: ["Flow", "FlowType"],
            fields: {
              typeParameters: (0, _utils.validateOptionalType)(
                "TypeParameterDeclaration"
              ),
              params: (0, _utils.validate)(
                (0, _utils.arrayOfType)("FunctionTypeParam")
              ),
              rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
              returnType: (0, _utils.validateType)("FlowType"),
            },
          });
          (0, _utils.default)("FunctionTypeParam", {
            visitor: ["name", "typeAnnotation"],
            aliases: ["Flow"],
            fields: {
              name: (0, _utils.validateOptionalType)("Identifier"),
              typeAnnotation: (0, _utils.validateType)("FlowType"),
              optional: (0, _utils.validateOptional)(
                (0, _utils.assertValueType)("boolean")
              ),
            },
          });
          (0, _utils.default)("GenericTypeAnnotation", {
            visitor: ["id", "typeParameters"],
            aliases: ["Flow", "FlowType"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TypeParameterInstantiation"
              ),
            },
          });
          (0, _utils.default)("InferredPredicate", {
            aliases: ["Flow", "FlowPredicate"],
          });
          (0, _utils.default)("InterfaceExtends", {
            visitor: ["id", "typeParameters"],
            aliases: ["Flow"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TypeParameterInstantiation"
              ),
            },
          });
          defineInterfaceishType("InterfaceDeclaration");
          (0, _utils.default)("InterfaceTypeAnnotation", {
            visitor: ["extends", "body"],
            aliases: ["Flow", "FlowType"],
            fields: {
              extends: (0, _utils.validateOptional)(
                (0, _utils.arrayOfType)("InterfaceExtends")
              ),
              body: (0, _utils.validateType)("ObjectTypeAnnotation"),
            },
          });
          (0, _utils.default)("IntersectionTypeAnnotation", {
            visitor: ["types"],
            aliases: ["Flow", "FlowType"],
            fields: {
              types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
            },
          });
          (0, _utils.default)("MixedTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
          });
          (0, _utils.default)("EmptyTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
          });
          (0, _utils.default)("NullableTypeAnnotation", {
            visitor: ["typeAnnotation"],
            aliases: ["Flow", "FlowType"],
            fields: {
              typeAnnotation: (0, _utils.validateType)("FlowType"),
            },
          });
          (0, _utils.default)("NumberLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["Flow", "FlowType"],
            fields: {
              value: (0, _utils.validate)(
                (0, _utils.assertValueType)("number")
              ),
            },
          });
          (0, _utils.default)("NumberTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
          });
          (0, _utils.default)("ObjectTypeAnnotation", {
            visitor: [
              "properties",
              "indexers",
              "callProperties",
              "internalSlots",
            ],
            aliases: ["Flow", "FlowType"],
            builder: [
              "properties",
              "indexers",
              "callProperties",
              "internalSlots",
              "exact",
            ],
            fields: {
              properties: (0, _utils.validate)(
                (0, _utils.arrayOfType)([
                  "ObjectTypeProperty",
                  "ObjectTypeSpreadProperty",
                ])
              ),
              indexers: (0, _utils.validateOptional)(
                (0, _utils.arrayOfType)("ObjectTypeIndexer")
              ),
              callProperties: (0, _utils.validateOptional)(
                (0, _utils.arrayOfType)("ObjectTypeCallProperty")
              ),
              internalSlots: (0, _utils.validateOptional)(
                (0, _utils.arrayOfType)("ObjectTypeInternalSlot")
              ),
              exact: {
                validate: (0, _utils.assertValueType)("boolean"),
                default: false,
              },
            },
          });
          (0, _utils.default)("ObjectTypeInternalSlot", {
            visitor: ["id", "value", "optional", "static", "method"],
            aliases: ["Flow", "UserWhitespacable"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
              value: (0, _utils.validateType)("FlowType"),
              optional: (0, _utils.validate)(
                (0, _utils.assertValueType)("boolean")
              ),
              static: (0, _utils.validate)(
                (0, _utils.assertValueType)("boolean")
              ),
              method: (0, _utils.validate)(
                (0, _utils.assertValueType)("boolean")
              ),
            },
          });
          (0, _utils.default)("ObjectTypeCallProperty", {
            visitor: ["value"],
            aliases: ["Flow", "UserWhitespacable"],
            fields: {
              value: (0, _utils.validateType)("FlowType"),
              static: (0, _utils.validate)(
                (0, _utils.assertValueType)("boolean")
              ),
            },
          });
          (0, _utils.default)("ObjectTypeIndexer", {
            visitor: ["id", "key", "value", "variance"],
            aliases: ["Flow", "UserWhitespacable"],
            fields: {
              id: (0, _utils.validateOptionalType)("Identifier"),
              key: (0, _utils.validateType)("FlowType"),
              value: (0, _utils.validateType)("FlowType"),
              static: (0, _utils.validate)(
                (0, _utils.assertValueType)("boolean")
              ),
              variance: (0, _utils.validateOptionalType)("Variance"),
            },
          });
          (0, _utils.default)("ObjectTypeProperty", {
            visitor: ["key", "value", "variance"],
            aliases: ["Flow", "UserWhitespacable"],
            fields: {
              key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
              value: (0, _utils.validateType)("FlowType"),
              kind: (0, _utils.validate)(
                (0, _utils.assertOneOf)("init", "get", "set")
              ),
              static: (0, _utils.validate)(
                (0, _utils.assertValueType)("boolean")
              ),
              proto: (0, _utils.validate)(
                (0, _utils.assertValueType)("boolean")
              ),
              optional: (0, _utils.validate)(
                (0, _utils.assertValueType)("boolean")
              ),
              variance: (0, _utils.validateOptionalType)("Variance"),
            },
          });
          (0, _utils.default)("ObjectTypeSpreadProperty", {
            visitor: ["argument"],
            aliases: ["Flow", "UserWhitespacable"],
            fields: {
              argument: (0, _utils.validateType)("FlowType"),
            },
          });
          (0, _utils.default)("OpaqueType", {
            visitor: ["id", "typeParameters", "supertype", "impltype"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TypeParameterDeclaration"
              ),
              supertype: (0, _utils.validateOptionalType)("FlowType"),
              impltype: (0, _utils.validateType)("FlowType"),
            },
          });
          (0, _utils.default)("QualifiedTypeIdentifier", {
            visitor: ["id", "qualification"],
            aliases: ["Flow"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
              qualification: (0, _utils.validateType)([
                "Identifier",
                "QualifiedTypeIdentifier",
              ]),
            },
          });
          (0, _utils.default)("StringLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["Flow", "FlowType"],
            fields: {
              value: (0, _utils.validate)(
                (0, _utils.assertValueType)("string")
              ),
            },
          });
          (0, _utils.default)("StringTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
          });
          (0, _utils.default)("ThisTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
          });
          (0, _utils.default)("TupleTypeAnnotation", {
            visitor: ["types"],
            aliases: ["Flow", "FlowType"],
            fields: {
              types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
            },
          });
          (0, _utils.default)("TypeofTypeAnnotation", {
            visitor: ["argument"],
            aliases: ["Flow", "FlowType"],
            fields: {
              argument: (0, _utils.validateType)("FlowType"),
            },
          });
          (0, _utils.default)("TypeAlias", {
            visitor: ["id", "typeParameters", "right"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TypeParameterDeclaration"
              ),
              right: (0, _utils.validateType)("FlowType"),
            },
          });
          (0, _utils.default)("TypeAnnotation", {
            aliases: ["Flow"],
            visitor: ["typeAnnotation"],
            fields: {
              typeAnnotation: (0, _utils.validateType)("FlowType"),
            },
          });
          (0, _utils.default)("TypeCastExpression", {
            visitor: ["expression", "typeAnnotation"],
            aliases: ["Flow", "ExpressionWrapper", "Expression"],
            fields: {
              expression: (0, _utils.validateType)("Expression"),
              typeAnnotation: (0, _utils.validateType)("TypeAnnotation"),
            },
          });
          (0, _utils.default)("TypeParameter", {
            aliases: ["Flow"],
            visitor: ["bound", "default", "variance"],
            fields: {
              name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
              bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
              default: (0, _utils.validateOptionalType)("FlowType"),
              variance: (0, _utils.validateOptionalType)("Variance"),
            },
          });
          (0, _utils.default)("TypeParameterDeclaration", {
            aliases: ["Flow"],
            visitor: ["params"],
            fields: {
              params: (0, _utils.validate)(
                (0, _utils.arrayOfType)("TypeParameter")
              ),
            },
          });
          (0, _utils.default)("TypeParameterInstantiation", {
            aliases: ["Flow"],
            visitor: ["params"],
            fields: {
              params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
            },
          });
          (0, _utils.default)("UnionTypeAnnotation", {
            visitor: ["types"],
            aliases: ["Flow", "FlowType"],
            fields: {
              types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
            },
          });
          (0, _utils.default)("Variance", {
            aliases: ["Flow"],
            builder: ["kind"],
            fields: {
              kind: (0, _utils.validate)(
                (0, _utils.assertOneOf)("minus", "plus")
              ),
            },
          });
          (0, _utils.default)("VoidTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
          });
        },
        /* 246 */
        function(module, exports, __webpack_require__) {
          "use strict";

          var _utils = _interopRequireWildcard(__webpack_require__(12));

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          (0, _utils.default)("JSXAttribute", {
            visitor: ["name", "value"],
            aliases: ["JSX", "Immutable"],
            fields: {
              name: {
                validate: (0, _utils.assertNodeType)(
                  "JSXIdentifier",
                  "JSXNamespacedName"
                ),
              },
              value: {
                optional: true,
                validate: (0, _utils.assertNodeType)(
                  "JSXElement",
                  "JSXFragment",
                  "StringLiteral",
                  "JSXExpressionContainer"
                ),
              },
            },
          });
          (0, _utils.default)("JSXClosingElement", {
            visitor: ["name"],
            aliases: ["JSX", "Immutable"],
            fields: {
              name: {
                validate: (0, _utils.assertNodeType)(
                  "JSXIdentifier",
                  "JSXMemberExpression"
                ),
              },
            },
          });
          (0, _utils.default)("JSXElement", {
            builder: [
              "openingElement",
              "closingElement",
              "children",
              "selfClosing",
            ],
            visitor: ["openingElement", "children", "closingElement"],
            aliases: ["JSX", "Immutable", "Expression"],
            fields: {
              openingElement: {
                validate: (0, _utils.assertNodeType)("JSXOpeningElement"),
              },
              closingElement: {
                optional: true,
                validate: (0, _utils.assertNodeType)("JSXClosingElement"),
              },
              children: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)(
                      "JSXText",
                      "JSXExpressionContainer",
                      "JSXSpreadChild",
                      "JSXElement",
                      "JSXFragment"
                    )
                  )
                ),
              },
            },
          });
          (0, _utils.default)("JSXEmptyExpression", {
            aliases: ["JSX"],
          });
          (0, _utils.default)("JSXExpressionContainer", {
            visitor: ["expression"],
            aliases: ["JSX", "Immutable"],
            fields: {
              expression: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
          });
          (0, _utils.default)("JSXSpreadChild", {
            visitor: ["expression"],
            aliases: ["JSX", "Immutable"],
            fields: {
              expression: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
          });
          (0, _utils.default)("JSXIdentifier", {
            builder: ["name"],
            aliases: ["JSX"],
            fields: {
              name: {
                validate: (0, _utils.assertValueType)("string"),
              },
            },
          });
          (0, _utils.default)("JSXMemberExpression", {
            visitor: ["object", "property"],
            aliases: ["JSX"],
            fields: {
              object: {
                validate: (0, _utils.assertNodeType)(
                  "JSXMemberExpression",
                  "JSXIdentifier"
                ),
              },
              property: {
                validate: (0, _utils.assertNodeType)("JSXIdentifier"),
              },
            },
          });
          (0, _utils.default)("JSXNamespacedName", {
            visitor: ["namespace", "name"],
            aliases: ["JSX"],
            fields: {
              namespace: {
                validate: (0, _utils.assertNodeType)("JSXIdentifier"),
              },
              name: {
                validate: (0, _utils.assertNodeType)("JSXIdentifier"),
              },
            },
          });
          (0, _utils.default)("JSXOpeningElement", {
            builder: ["name", "attributes", "selfClosing"],
            visitor: ["name", "attributes"],
            aliases: ["JSX", "Immutable"],
            fields: {
              name: {
                validate: (0, _utils.assertNodeType)(
                  "JSXIdentifier",
                  "JSXMemberExpression"
                ),
              },
              selfClosing: {
                default: false,
                validate: (0, _utils.assertValueType)("boolean"),
              },
              attributes: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)(
                      "JSXAttribute",
                      "JSXSpreadAttribute"
                    )
                  )
                ),
              },
              typeParameters: {
                validate: (0, _utils.assertNodeType)(
                  "TypeParameterInstantiation",
                  "TSTypeParameterInstantiation"
                ),
                optional: true,
              },
            },
          });
          (0, _utils.default)("JSXSpreadAttribute", {
            visitor: ["argument"],
            aliases: ["JSX"],
            fields: {
              argument: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
          });
          (0, _utils.default)("JSXText", {
            aliases: ["JSX", "Immutable"],
            builder: ["value"],
            fields: {
              value: {
                validate: (0, _utils.assertValueType)("string"),
              },
            },
          });
          (0, _utils.default)("JSXFragment", {
            builder: ["openingFragment", "closingFragment", "children"],
            visitor: ["openingFragment", "children", "closingFragment"],
            aliases: ["JSX", "Immutable", "Expression"],
            fields: {
              openingFragment: {
                validate: (0, _utils.assertNodeType)("JSXOpeningFragment"),
              },
              closingFragment: {
                validate: (0, _utils.assertNodeType)("JSXClosingFragment"),
              },
              children: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)(
                      "JSXText",
                      "JSXExpressionContainer",
                      "JSXSpreadChild",
                      "JSXElement",
                      "JSXFragment"
                    )
                  )
                ),
              },
            },
          });
          (0, _utils.default)("JSXOpeningFragment", {
            aliases: ["JSX", "Immutable"],
          });
          (0, _utils.default)("JSXClosingFragment", {
            aliases: ["JSX", "Immutable"],
          });
        },
        /* 247 */
        function(module, exports, __webpack_require__) {
          "use strict";

          var _utils = _interopRequireWildcard(__webpack_require__(12));

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          (0, _utils.default)("Noop", {
            visitor: [],
          });
          (0, _utils.default)("ParenthesizedExpression", {
            visitor: ["expression"],
            aliases: ["Expression", "ExpressionWrapper"],
            fields: {
              expression: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
          });
        },
        /* 248 */
        function(module, exports, __webpack_require__) {
          "use strict";

          var _utils = _interopRequireWildcard(__webpack_require__(12));

          var _es = __webpack_require__(68);

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          (0, _utils.default)("AwaitExpression", {
            builder: ["argument"],
            visitor: ["argument"],
            aliases: ["Expression", "Terminatorless"],
            fields: {
              argument: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
          });
          (0, _utils.default)("BindExpression", {
            visitor: ["object", "callee"],
            aliases: ["Expression"],
            fields: {},
          });
          (0, _utils.default)("ClassProperty", {
            visitor: ["key", "value", "typeAnnotation", "decorators"],
            builder: [
              "key",
              "value",
              "typeAnnotation",
              "decorators",
              "computed",
            ],
            aliases: ["Property"],
            fields: Object.assign({}, _es.classMethodOrPropertyCommon, {
              value: {
                validate: (0, _utils.assertNodeType)("Expression"),
                optional: true,
              },
              definite: {
                validate: (0, _utils.assertValueType)("boolean"),
                optional: true,
              },
              typeAnnotation: {
                validate: (0, _utils.assertNodeType)(
                  "TypeAnnotation",
                  "TSTypeAnnotation",
                  "Noop"
                ),
                optional: true,
              },
              decorators: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("Decorator")
                  )
                ),
                optional: true,
              },
              readonly: {
                validate: (0, _utils.assertValueType)("boolean"),
                optional: true,
              },
            }),
          });
          (0, _utils.default)("OptionalMemberExpression", {
            builder: ["object", "property", "computed", "optional"],
            visitor: ["object", "property"],
            aliases: ["Expression"],
            fields: {
              object: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              property: {
                validate: (function() {
                  var normal = (0, _utils.assertNodeType)("Identifier");
                  var computed = (0, _utils.assertNodeType)("Expression");
                  return function(node, key, val) {
                    var validator = node.computed ? computed : normal;
                    validator(node, key, val);
                  };
                })(),
              },
              computed: {
                default: false,
              },
              optional: {
                validate: (0, _utils.assertValueType)("boolean"),
              },
            },
          });
          (0, _utils.default)("OptionalCallExpression", {
            visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
            builder: ["callee", "arguments", "optional"],
            aliases: ["Expression"],
            fields: {
              callee: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
              arguments: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)(
                      "Expression",
                      "SpreadElement",
                      "JSXNamespacedName"
                    )
                  )
                ),
              },
              optional: {
                validate: (0, _utils.assertValueType)("boolean"),
              },
              typeArguments: {
                validate: (0, _utils.assertNodeType)(
                  "TypeParameterInstantiation"
                ),
                optional: true,
              },
              typeParameters: {
                validate: (0, _utils.assertNodeType)(
                  "TSTypeParameterInstantiation"
                ),
                optional: true,
              },
            },
          });
          (0, _utils.default)("ClassPrivateProperty", {
            visitor: ["key", "value"],
            builder: ["key", "value"],
            aliases: ["Property", "Private"],
            fields: {
              key: {
                validate: (0, _utils.assertNodeType)("PrivateName"),
              },
              value: {
                validate: (0, _utils.assertNodeType)("Expression"),
                optional: true,
              },
            },
          });
          (0, _utils.default)("Import", {
            aliases: ["Expression"],
          });
          (0, _utils.default)("Decorator", {
            visitor: ["expression"],
            fields: {
              expression: {
                validate: (0, _utils.assertNodeType)("Expression"),
              },
            },
          });
          (0, _utils.default)("DoExpression", {
            visitor: ["body"],
            aliases: ["Expression"],
            fields: {
              body: {
                validate: (0, _utils.assertNodeType)("BlockStatement"),
              },
            },
          });
          (0, _utils.default)("ExportDefaultSpecifier", {
            visitor: ["exported"],
            aliases: ["ModuleSpecifier"],
            fields: {
              exported: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
            },
          });
          (0, _utils.default)("ExportNamespaceSpecifier", {
            visitor: ["exported"],
            aliases: ["ModuleSpecifier"],
            fields: {
              exported: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
            },
          });
          (0, _utils.default)("PrivateName", {
            visitor: ["id"],
            aliases: ["Private"],
            fields: {
              id: {
                validate: (0, _utils.assertNodeType)("Identifier"),
              },
            },
          });
          (0, _utils.default)("BigIntLiteral", {
            builder: ["value"],
            fields: {
              value: {
                validate: (0, _utils.assertValueType)("string"),
              },
            },
            aliases: ["Expression", "Pureish", "Literal", "Immutable"],
          });
        },
        /* 249 */
        function(module, exports, __webpack_require__) {
          "use strict";

          var _utils = _interopRequireWildcard(__webpack_require__(12));

          var _core = __webpack_require__(65);

          var _es = __webpack_require__(68);

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          var bool = (0, _utils.assertValueType)("boolean");
          var tSFunctionTypeAnnotationCommon = {
            returnType: {
              validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
              optional: true,
            },
            typeParameters: {
              validate: (0, _utils.assertNodeType)(
                "TSTypeParameterDeclaration",
                "Noop"
              ),
              optional: true,
            },
          };
          (0, _utils.default)("TSParameterProperty", {
            aliases: ["LVal"],
            visitor: ["parameter"],
            fields: {
              accessibility: {
                validate: (0, _utils.assertOneOf)(
                  "public",
                  "private",
                  "protected"
                ),
                optional: true,
              },
              readonly: {
                validate: (0, _utils.assertValueType)("boolean"),
                optional: true,
              },
              parameter: {
                validate: (0, _utils.assertNodeType)(
                  "Identifier",
                  "AssignmentPattern"
                ),
              },
            },
          });
          (0, _utils.default)("TSDeclareFunction", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "params", "returnType"],
            fields: Object.assign(
              {},
              _core.functionDeclarationCommon,
              tSFunctionTypeAnnotationCommon
            ),
          });
          (0, _utils.default)("TSDeclareMethod", {
            visitor: [
              "decorators",
              "key",
              "typeParameters",
              "params",
              "returnType",
            ],
            fields: Object.assign(
              {},
              _es.classMethodOrDeclareMethodCommon,
              tSFunctionTypeAnnotationCommon
            ),
          });
          (0, _utils.default)("TSQualifiedName", {
            aliases: ["TSEntityName"],
            visitor: ["left", "right"],
            fields: {
              left: (0, _utils.validateType)("TSEntityName"),
              right: (0, _utils.validateType)("Identifier"),
            },
          });
          var signatureDeclarationCommon = {
            typeParameters: (0, _utils.validateOptionalType)(
              "TSTypeParameterDeclaration"
            ),
            parameters: (0, _utils.validateArrayOfType)([
              "Identifier",
              "RestElement",
            ]),
            typeAnnotation: (0, _utils.validateOptionalType)(
              "TSTypeAnnotation"
            ),
          };
          var callConstructSignatureDeclaration = {
            aliases: ["TSTypeElement"],
            visitor: ["typeParameters", "parameters", "typeAnnotation"],
            fields: signatureDeclarationCommon,
          };
          (0, _utils.default)(
            "TSCallSignatureDeclaration",
            callConstructSignatureDeclaration
          );
          (0, _utils.default)(
            "TSConstructSignatureDeclaration",
            callConstructSignatureDeclaration
          );
          var namedTypeElementCommon = {
            key: (0, _utils.validateType)("Expression"),
            computed: (0, _utils.validate)(bool),
            optional: (0, _utils.validateOptional)(bool),
          };
          (0, _utils.default)("TSPropertySignature", {
            aliases: ["TSTypeElement"],
            visitor: ["key", "typeAnnotation", "initializer"],
            fields: Object.assign({}, namedTypeElementCommon, {
              readonly: (0, _utils.validateOptional)(bool),
              typeAnnotation: (0, _utils.validateOptionalType)(
                "TSTypeAnnotation"
              ),
              initializer: (0, _utils.validateOptionalType)("Expression"),
            }),
          });
          (0, _utils.default)("TSMethodSignature", {
            aliases: ["TSTypeElement"],
            visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
            fields: Object.assign(
              {},
              signatureDeclarationCommon,
              namedTypeElementCommon
            ),
          });
          (0, _utils.default)("TSIndexSignature", {
            aliases: ["TSTypeElement"],
            visitor: ["parameters", "typeAnnotation"],
            fields: {
              readonly: (0, _utils.validateOptional)(bool),
              parameters: (0, _utils.validateArrayOfType)("Identifier"),
              typeAnnotation: (0, _utils.validateOptionalType)(
                "TSTypeAnnotation"
              ),
            },
          });
          var tsKeywordTypes = [
            "TSAnyKeyword",
            "TSNumberKeyword",
            "TSObjectKeyword",
            "TSBooleanKeyword",
            "TSStringKeyword",
            "TSSymbolKeyword",
            "TSVoidKeyword",
            "TSUndefinedKeyword",
            "TSNullKeyword",
            "TSNeverKeyword",
          ];

          for (var _i = 0; _i < tsKeywordTypes.length; _i++) {
            var type = tsKeywordTypes[_i];
            (0, _utils.default)(type, {
              aliases: ["TSType"],
              visitor: [],
              fields: {},
            });
          }

          (0, _utils.default)("TSThisType", {
            aliases: ["TSType"],
            visitor: [],
            fields: {},
          });
          var fnOrCtr = {
            aliases: ["TSType"],
            visitor: ["typeParameters", "typeAnnotation"],
            fields: signatureDeclarationCommon,
          };
          (0, _utils.default)("TSFunctionType", fnOrCtr);
          (0, _utils.default)("TSConstructorType", fnOrCtr);
          (0, _utils.default)("TSTypeReference", {
            aliases: ["TSType"],
            visitor: ["typeName", "typeParameters"],
            fields: {
              typeName: (0, _utils.validateType)("TSEntityName"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TSTypeParameterInstantiation"
              ),
            },
          });
          (0, _utils.default)("TSTypePredicate", {
            aliases: ["TSType"],
            visitor: ["parameterName", "typeAnnotation"],
            fields: {
              parameterName: (0, _utils.validateType)([
                "Identifier",
                "TSThisType",
              ]),
              typeAnnotation: (0, _utils.validateType)("TSTypeAnnotation"),
            },
          });
          (0, _utils.default)("TSTypeQuery", {
            aliases: ["TSType"],
            visitor: ["exprName"],
            fields: {
              exprName: (0, _utils.validateType)("TSEntityName"),
            },
          });
          (0, _utils.default)("TSTypeLiteral", {
            aliases: ["TSType"],
            visitor: ["members"],
            fields: {
              members: (0, _utils.validateArrayOfType)("TSTypeElement"),
            },
          });
          (0, _utils.default)("TSArrayType", {
            aliases: ["TSType"],
            visitor: ["elementType"],
            fields: {
              elementType: (0, _utils.validateType)("TSType"),
            },
          });
          (0, _utils.default)("TSTupleType", {
            aliases: ["TSType"],
            visitor: ["elementTypes"],
            fields: {
              elementTypes: (0, _utils.validateArrayOfType)("TSType"),
            },
          });
          var unionOrIntersection = {
            aliases: ["TSType"],
            visitor: ["types"],
            fields: {
              types: (0, _utils.validateArrayOfType)("TSType"),
            },
          };
          (0, _utils.default)("TSUnionType", unionOrIntersection);
          (0, _utils.default)("TSIntersectionType", unionOrIntersection);
          (0, _utils.default)("TSConditionalType", {
            aliases: ["TSType"],
            visitor: ["checkType", "extendsType", "trueType", "falseType"],
            fields: {
              checkType: (0, _utils.validateType)("TSType"),
              extendsType: (0, _utils.validateType)("TSType"),
              trueType: (0, _utils.validateType)("TSType"),
              falseType: (0, _utils.validateType)("TSType"),
            },
          });
          (0, _utils.default)("TSInferType", {
            aliases: ["TSType"],
            visitor: ["typeParameter"],
            fields: {
              typeParameter: (0, _utils.validateType)("TSTypeParameter"),
            },
          });
          (0, _utils.default)("TSParenthesizedType", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
              typeAnnotation: (0, _utils.validateType)("TSType"),
            },
          });
          (0, _utils.default)("TSTypeOperator", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
              operator: (0, _utils.validate)(
                (0, _utils.assertValueType)("string")
              ),
              typeAnnotation: (0, _utils.validateType)("TSType"),
            },
          });
          (0, _utils.default)("TSIndexedAccessType", {
            aliases: ["TSType"],
            visitor: ["objectType", "indexType"],
            fields: {
              objectType: (0, _utils.validateType)("TSType"),
              indexType: (0, _utils.validateType)("TSType"),
            },
          });
          (0, _utils.default)("TSMappedType", {
            aliases: ["TSType"],
            visitor: ["typeParameter", "typeAnnotation"],
            fields: {
              readonly: (0, _utils.validateOptional)(bool),
              typeParameter: (0, _utils.validateType)("TSTypeParameter"),
              optional: (0, _utils.validateOptional)(bool),
              typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
            },
          });
          (0, _utils.default)("TSLiteralType", {
            aliases: ["TSType"],
            visitor: ["literal"],
            fields: {
              literal: (0, _utils.validateType)([
                "NumericLiteral",
                "StringLiteral",
                "BooleanLiteral",
              ]),
            },
          });
          (0, _utils.default)("TSExpressionWithTypeArguments", {
            aliases: ["TSType"],
            visitor: ["expression", "typeParameters"],
            fields: {
              expression: (0, _utils.validateType)("TSEntityName"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TSTypeParameterInstantiation"
              ),
            },
          });
          (0, _utils.default)("TSInterfaceDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "extends", "body"],
            fields: {
              declare: (0, _utils.validateOptional)(bool),
              id: (0, _utils.validateType)("Identifier"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TSTypeParameterDeclaration"
              ),
              extends: (0, _utils.validateOptional)(
                (0, _utils.arrayOfType)("TSExpressionWithTypeArguments")
              ),
              body: (0, _utils.validateType)("TSInterfaceBody"),
            },
          });
          (0, _utils.default)("TSInterfaceBody", {
            visitor: ["body"],
            fields: {
              body: (0, _utils.validateArrayOfType)("TSTypeElement"),
            },
          });
          (0, _utils.default)("TSTypeAliasDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "typeAnnotation"],
            fields: {
              declare: (0, _utils.validateOptional)(bool),
              id: (0, _utils.validateType)("Identifier"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TSTypeParameterDeclaration"
              ),
              typeAnnotation: (0, _utils.validateType)("TSType"),
            },
          });
          (0, _utils.default)("TSAsExpression", {
            aliases: ["Expression"],
            visitor: ["expression", "typeAnnotation"],
            fields: {
              expression: (0, _utils.validateType)("Expression"),
              typeAnnotation: (0, _utils.validateType)("TSType"),
            },
          });
          (0, _utils.default)("TSTypeAssertion", {
            aliases: ["Expression"],
            visitor: ["typeAnnotation", "expression"],
            fields: {
              typeAnnotation: (0, _utils.validateType)("TSType"),
              expression: (0, _utils.validateType)("Expression"),
            },
          });
          (0, _utils.default)("TSEnumDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "members"],
            fields: {
              declare: (0, _utils.validateOptional)(bool),
              const: (0, _utils.validateOptional)(bool),
              id: (0, _utils.validateType)("Identifier"),
              members: (0, _utils.validateArrayOfType)("TSEnumMember"),
              initializer: (0, _utils.validateOptionalType)("Expression"),
            },
          });
          (0, _utils.default)("TSEnumMember", {
            visitor: ["id", "initializer"],
            fields: {
              id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
              initializer: (0, _utils.validateOptionalType)("Expression"),
            },
          });
          (0, _utils.default)("TSModuleDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "body"],
            fields: {
              declare: (0, _utils.validateOptional)(bool),
              global: (0, _utils.validateOptional)(bool),
              id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
              body: (0, _utils.validateType)([
                "TSModuleBlock",
                "TSModuleDeclaration",
              ]),
            },
          });
          (0, _utils.default)("TSModuleBlock", {
            visitor: ["body"],
            fields: {
              body: (0, _utils.validateArrayOfType)("Statement"),
            },
          });
          (0, _utils.default)("TSImportEqualsDeclaration", {
            aliases: ["Statement"],
            visitor: ["id", "moduleReference"],
            fields: {
              isExport: (0, _utils.validate)(bool),
              id: (0, _utils.validateType)("Identifier"),
              moduleReference: (0, _utils.validateType)([
                "TSEntityName",
                "TSExternalModuleReference",
              ]),
            },
          });
          (0, _utils.default)("TSExternalModuleReference", {
            visitor: ["expression"],
            fields: {
              expression: (0, _utils.validateType)("StringLiteral"),
            },
          });
          (0, _utils.default)("TSNonNullExpression", {
            aliases: ["Expression"],
            visitor: ["expression"],
            fields: {
              expression: (0, _utils.validateType)("Expression"),
            },
          });
          (0, _utils.default)("TSExportAssignment", {
            aliases: ["Statement"],
            visitor: ["expression"],
            fields: {
              expression: (0, _utils.validateType)("Expression"),
            },
          });
          (0, _utils.default)("TSNamespaceExportDeclaration", {
            aliases: ["Statement"],
            visitor: ["id"],
            fields: {
              id: (0, _utils.validateType)("Identifier"),
            },
          });
          (0, _utils.default)("TSTypeAnnotation", {
            visitor: ["typeAnnotation"],
            fields: {
              typeAnnotation: {
                validate: (0, _utils.assertNodeType)("TSType"),
              },
            },
          });
          (0, _utils.default)("TSTypeParameterInstantiation", {
            visitor: ["params"],
            fields: {
              params: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType"))
                ),
              },
            },
          });
          (0, _utils.default)("TSTypeParameterDeclaration", {
            visitor: ["params"],
            fields: {
              params: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("array"),
                  (0, _utils.assertEach)(
                    (0, _utils.assertNodeType)("TSTypeParameter")
                  )
                ),
              },
            },
          });
          (0, _utils.default)("TSTypeParameter", {
            visitor: ["constraint", "default"],
            fields: {
              name: {
                validate: (0, _utils.assertValueType)("string"),
              },
              constraint: {
                validate: (0, _utils.assertNodeType)("TSType"),
                optional: true,
              },
              default: {
                validate: (0, _utils.assertNodeType)("TSType"),
                optional: true,
              },
            },
          });
        },
        /* 250 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = assertNode;

          var _isNode = _interopRequireDefault(__webpack_require__(109));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function assertNode(node) {
            if (!(0, _isNode.default)(node)) {
              var type = (node && node.type) || JSON.stringify(node);
              throw new TypeError('Not a valid node of type "' + type + '"');
            }
          }
        },
        /* 251 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.assertArrayExpression = assertArrayExpression;
          exports.assertAssignmentExpression = assertAssignmentExpression;
          exports.assertBinaryExpression = assertBinaryExpression;
          exports.assertInterpreterDirective = assertInterpreterDirective;
          exports.assertDirective = assertDirective;
          exports.assertDirectiveLiteral = assertDirectiveLiteral;
          exports.assertBlockStatement = assertBlockStatement;
          exports.assertBreakStatement = assertBreakStatement;
          exports.assertCallExpression = assertCallExpression;
          exports.assertCatchClause = assertCatchClause;
          exports.assertConditionalExpression = assertConditionalExpression;
          exports.assertContinueStatement = assertContinueStatement;
          exports.assertDebuggerStatement = assertDebuggerStatement;
          exports.assertDoWhileStatement = assertDoWhileStatement;
          exports.assertEmptyStatement = assertEmptyStatement;
          exports.assertExpressionStatement = assertExpressionStatement;
          exports.assertFile = assertFile;
          exports.assertForInStatement = assertForInStatement;
          exports.assertForStatement = assertForStatement;
          exports.assertFunctionDeclaration = assertFunctionDeclaration;
          exports.assertFunctionExpression = assertFunctionExpression;
          exports.assertIdentifier = assertIdentifier;
          exports.assertIfStatement = assertIfStatement;
          exports.assertLabeledStatement = assertLabeledStatement;
          exports.assertStringLiteral = assertStringLiteral;
          exports.assertNumericLiteral = assertNumericLiteral;
          exports.assertNullLiteral = assertNullLiteral;
          exports.assertBooleanLiteral = assertBooleanLiteral;
          exports.assertRegExpLiteral = assertRegExpLiteral;
          exports.assertLogicalExpression = assertLogicalExpression;
          exports.assertMemberExpression = assertMemberExpression;
          exports.assertNewExpression = assertNewExpression;
          exports.assertProgram = assertProgram;
          exports.assertObjectExpression = assertObjectExpression;
          exports.assertObjectMethod = assertObjectMethod;
          exports.assertObjectProperty = assertObjectProperty;
          exports.assertRestElement = assertRestElement;
          exports.assertReturnStatement = assertReturnStatement;
          exports.assertSequenceExpression = assertSequenceExpression;
          exports.assertSwitchCase = assertSwitchCase;
          exports.assertSwitchStatement = assertSwitchStatement;
          exports.assertThisExpression = assertThisExpression;
          exports.assertThrowStatement = assertThrowStatement;
          exports.assertTryStatement = assertTryStatement;
          exports.assertUnaryExpression = assertUnaryExpression;
          exports.assertUpdateExpression = assertUpdateExpression;
          exports.assertVariableDeclaration = assertVariableDeclaration;
          exports.assertVariableDeclarator = assertVariableDeclarator;
          exports.assertWhileStatement = assertWhileStatement;
          exports.assertWithStatement = assertWithStatement;
          exports.assertAssignmentPattern = assertAssignmentPattern;
          exports.assertArrayPattern = assertArrayPattern;
          exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
          exports.assertClassBody = assertClassBody;
          exports.assertClassDeclaration = assertClassDeclaration;
          exports.assertClassExpression = assertClassExpression;
          exports.assertExportAllDeclaration = assertExportAllDeclaration;
          exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
          exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
          exports.assertExportSpecifier = assertExportSpecifier;
          exports.assertForOfStatement = assertForOfStatement;
          exports.assertImportDeclaration = assertImportDeclaration;
          exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
          exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
          exports.assertImportSpecifier = assertImportSpecifier;
          exports.assertMetaProperty = assertMetaProperty;
          exports.assertClassMethod = assertClassMethod;
          exports.assertObjectPattern = assertObjectPattern;
          exports.assertSpreadElement = assertSpreadElement;
          exports.assertSuper = assertSuper;
          exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
          exports.assertTemplateElement = assertTemplateElement;
          exports.assertTemplateLiteral = assertTemplateLiteral;
          exports.assertYieldExpression = assertYieldExpression;
          exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
          exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
          exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
          exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
          exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
          exports.assertClassImplements = assertClassImplements;
          exports.assertDeclareClass = assertDeclareClass;
          exports.assertDeclareFunction = assertDeclareFunction;
          exports.assertDeclareInterface = assertDeclareInterface;
          exports.assertDeclareModule = assertDeclareModule;
          exports.assertDeclareModuleExports = assertDeclareModuleExports;
          exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
          exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
          exports.assertDeclareVariable = assertDeclareVariable;
          exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
          exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
          exports.assertDeclaredPredicate = assertDeclaredPredicate;
          exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
          exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
          exports.assertFunctionTypeParam = assertFunctionTypeParam;
          exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
          exports.assertInferredPredicate = assertInferredPredicate;
          exports.assertInterfaceExtends = assertInterfaceExtends;
          exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
          exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
          exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
          exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
          exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
          exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
          exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
          exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
          exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
          exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
          exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
          exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
          exports.assertObjectTypeProperty = assertObjectTypeProperty;
          exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
          exports.assertOpaqueType = assertOpaqueType;
          exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
          exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
          exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
          exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
          exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
          exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
          exports.assertTypeAlias = assertTypeAlias;
          exports.assertTypeAnnotation = assertTypeAnnotation;
          exports.assertTypeCastExpression = assertTypeCastExpression;
          exports.assertTypeParameter = assertTypeParameter;
          exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
          exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
          exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
          exports.assertVariance = assertVariance;
          exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
          exports.assertJSXAttribute = assertJSXAttribute;
          exports.assertJSXClosingElement = assertJSXClosingElement;
          exports.assertJSXElement = assertJSXElement;
          exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
          exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
          exports.assertJSXSpreadChild = assertJSXSpreadChild;
          exports.assertJSXIdentifier = assertJSXIdentifier;
          exports.assertJSXMemberExpression = assertJSXMemberExpression;
          exports.assertJSXNamespacedName = assertJSXNamespacedName;
          exports.assertJSXOpeningElement = assertJSXOpeningElement;
          exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
          exports.assertJSXText = assertJSXText;
          exports.assertJSXFragment = assertJSXFragment;
          exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
          exports.assertJSXClosingFragment = assertJSXClosingFragment;
          exports.assertNoop = assertNoop;
          exports.assertParenthesizedExpression = assertParenthesizedExpression;
          exports.assertAwaitExpression = assertAwaitExpression;
          exports.assertBindExpression = assertBindExpression;
          exports.assertClassProperty = assertClassProperty;
          exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
          exports.assertOptionalCallExpression = assertOptionalCallExpression;
          exports.assertClassPrivateProperty = assertClassPrivateProperty;
          exports.assertImport = assertImport;
          exports.assertDecorator = assertDecorator;
          exports.assertDoExpression = assertDoExpression;
          exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
          exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
          exports.assertPrivateName = assertPrivateName;
          exports.assertBigIntLiteral = assertBigIntLiteral;
          exports.assertTSParameterProperty = assertTSParameterProperty;
          exports.assertTSDeclareFunction = assertTSDeclareFunction;
          exports.assertTSDeclareMethod = assertTSDeclareMethod;
          exports.assertTSQualifiedName = assertTSQualifiedName;
          exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
          exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
          exports.assertTSPropertySignature = assertTSPropertySignature;
          exports.assertTSMethodSignature = assertTSMethodSignature;
          exports.assertTSIndexSignature = assertTSIndexSignature;
          exports.assertTSAnyKeyword = assertTSAnyKeyword;
          exports.assertTSNumberKeyword = assertTSNumberKeyword;
          exports.assertTSObjectKeyword = assertTSObjectKeyword;
          exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
          exports.assertTSStringKeyword = assertTSStringKeyword;
          exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
          exports.assertTSVoidKeyword = assertTSVoidKeyword;
          exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
          exports.assertTSNullKeyword = assertTSNullKeyword;
          exports.assertTSNeverKeyword = assertTSNeverKeyword;
          exports.assertTSThisType = assertTSThisType;
          exports.assertTSFunctionType = assertTSFunctionType;
          exports.assertTSConstructorType = assertTSConstructorType;
          exports.assertTSTypeReference = assertTSTypeReference;
          exports.assertTSTypePredicate = assertTSTypePredicate;
          exports.assertTSTypeQuery = assertTSTypeQuery;
          exports.assertTSTypeLiteral = assertTSTypeLiteral;
          exports.assertTSArrayType = assertTSArrayType;
          exports.assertTSTupleType = assertTSTupleType;
          exports.assertTSUnionType = assertTSUnionType;
          exports.assertTSIntersectionType = assertTSIntersectionType;
          exports.assertTSConditionalType = assertTSConditionalType;
          exports.assertTSInferType = assertTSInferType;
          exports.assertTSParenthesizedType = assertTSParenthesizedType;
          exports.assertTSTypeOperator = assertTSTypeOperator;
          exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
          exports.assertTSMappedType = assertTSMappedType;
          exports.assertTSLiteralType = assertTSLiteralType;
          exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
          exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
          exports.assertTSInterfaceBody = assertTSInterfaceBody;
          exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
          exports.assertTSAsExpression = assertTSAsExpression;
          exports.assertTSTypeAssertion = assertTSTypeAssertion;
          exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
          exports.assertTSEnumMember = assertTSEnumMember;
          exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
          exports.assertTSModuleBlock = assertTSModuleBlock;
          exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
          exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
          exports.assertTSNonNullExpression = assertTSNonNullExpression;
          exports.assertTSExportAssignment = assertTSExportAssignment;
          exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
          exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
          exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
          exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
          exports.assertTSTypeParameter = assertTSTypeParameter;
          exports.assertExpression = assertExpression;
          exports.assertBinary = assertBinary;
          exports.assertScopable = assertScopable;
          exports.assertBlockParent = assertBlockParent;
          exports.assertBlock = assertBlock;
          exports.assertStatement = assertStatement;
          exports.assertTerminatorless = assertTerminatorless;
          exports.assertCompletionStatement = assertCompletionStatement;
          exports.assertConditional = assertConditional;
          exports.assertLoop = assertLoop;
          exports.assertWhile = assertWhile;
          exports.assertExpressionWrapper = assertExpressionWrapper;
          exports.assertFor = assertFor;
          exports.assertForXStatement = assertForXStatement;
          exports.assertFunction = assertFunction;
          exports.assertFunctionParent = assertFunctionParent;
          exports.assertPureish = assertPureish;
          exports.assertDeclaration = assertDeclaration;
          exports.assertPatternLike = assertPatternLike;
          exports.assertLVal = assertLVal;
          exports.assertTSEntityName = assertTSEntityName;
          exports.assertLiteral = assertLiteral;
          exports.assertImmutable = assertImmutable;
          exports.assertUserWhitespacable = assertUserWhitespacable;
          exports.assertMethod = assertMethod;
          exports.assertObjectMember = assertObjectMember;
          exports.assertProperty = assertProperty;
          exports.assertUnaryLike = assertUnaryLike;
          exports.assertPattern = assertPattern;
          exports.assertClass = assertClass;
          exports.assertModuleDeclaration = assertModuleDeclaration;
          exports.assertExportDeclaration = assertExportDeclaration;
          exports.assertModuleSpecifier = assertModuleSpecifier;
          exports.assertFlow = assertFlow;
          exports.assertFlowType = assertFlowType;
          exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
          exports.assertFlowDeclaration = assertFlowDeclaration;
          exports.assertFlowPredicate = assertFlowPredicate;
          exports.assertJSX = assertJSX;
          exports.assertPrivate = assertPrivate;
          exports.assertTSTypeElement = assertTSTypeElement;
          exports.assertTSType = assertTSType;
          exports.assertNumberLiteral = assertNumberLiteral;
          exports.assertRegexLiteral = assertRegexLiteral;
          exports.assertRestProperty = assertRestProperty;
          exports.assertSpreadProperty = assertSpreadProperty;

          var _is = _interopRequireDefault(__webpack_require__(66));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function assert(type, node, opts) {
            if (!(0, _is.default)(type, node, opts)) {
              throw new Error(
                'Expected type "' +
                  type +
                  '" with option ' +
                  JSON.stringify(opts) +
                  ', but instead got "' +
                  node.type +
                  '".'
              );
            }
          }

          function assertArrayExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ArrayExpression", node, opts);
          }

          function assertAssignmentExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("AssignmentExpression", node, opts);
          }

          function assertBinaryExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("BinaryExpression", node, opts);
          }

          function assertInterpreterDirective(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("InterpreterDirective", node, opts);
          }

          function assertDirective(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Directive", node, opts);
          }

          function assertDirectiveLiteral(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DirectiveLiteral", node, opts);
          }

          function assertBlockStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("BlockStatement", node, opts);
          }

          function assertBreakStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("BreakStatement", node, opts);
          }

          function assertCallExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("CallExpression", node, opts);
          }

          function assertCatchClause(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("CatchClause", node, opts);
          }

          function assertConditionalExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ConditionalExpression", node, opts);
          }

          function assertContinueStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ContinueStatement", node, opts);
          }

          function assertDebuggerStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DebuggerStatement", node, opts);
          }

          function assertDoWhileStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DoWhileStatement", node, opts);
          }

          function assertEmptyStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("EmptyStatement", node, opts);
          }

          function assertExpressionStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ExpressionStatement", node, opts);
          }

          function assertFile(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("File", node, opts);
          }

          function assertForInStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ForInStatement", node, opts);
          }

          function assertForStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ForStatement", node, opts);
          }

          function assertFunctionDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("FunctionDeclaration", node, opts);
          }

          function assertFunctionExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("FunctionExpression", node, opts);
          }

          function assertIdentifier(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Identifier", node, opts);
          }

          function assertIfStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("IfStatement", node, opts);
          }

          function assertLabeledStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("LabeledStatement", node, opts);
          }

          function assertStringLiteral(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("StringLiteral", node, opts);
          }

          function assertNumericLiteral(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("NumericLiteral", node, opts);
          }

          function assertNullLiteral(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("NullLiteral", node, opts);
          }

          function assertBooleanLiteral(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("BooleanLiteral", node, opts);
          }

          function assertRegExpLiteral(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("RegExpLiteral", node, opts);
          }

          function assertLogicalExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("LogicalExpression", node, opts);
          }

          function assertMemberExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("MemberExpression", node, opts);
          }

          function assertNewExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("NewExpression", node, opts);
          }

          function assertProgram(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Program", node, opts);
          }

          function assertObjectExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ObjectExpression", node, opts);
          }

          function assertObjectMethod(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ObjectMethod", node, opts);
          }

          function assertObjectProperty(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ObjectProperty", node, opts);
          }

          function assertRestElement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("RestElement", node, opts);
          }

          function assertReturnStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ReturnStatement", node, opts);
          }

          function assertSequenceExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("SequenceExpression", node, opts);
          }

          function assertSwitchCase(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("SwitchCase", node, opts);
          }

          function assertSwitchStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("SwitchStatement", node, opts);
          }

          function assertThisExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ThisExpression", node, opts);
          }

          function assertThrowStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ThrowStatement", node, opts);
          }

          function assertTryStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TryStatement", node, opts);
          }

          function assertUnaryExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("UnaryExpression", node, opts);
          }

          function assertUpdateExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("UpdateExpression", node, opts);
          }

          function assertVariableDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("VariableDeclaration", node, opts);
          }

          function assertVariableDeclarator(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("VariableDeclarator", node, opts);
          }

          function assertWhileStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("WhileStatement", node, opts);
          }

          function assertWithStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("WithStatement", node, opts);
          }

          function assertAssignmentPattern(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("AssignmentPattern", node, opts);
          }

          function assertArrayPattern(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ArrayPattern", node, opts);
          }

          function assertArrowFunctionExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ArrowFunctionExpression", node, opts);
          }

          function assertClassBody(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ClassBody", node, opts);
          }

          function assertClassDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ClassDeclaration", node, opts);
          }

          function assertClassExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ClassExpression", node, opts);
          }

          function assertExportAllDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ExportAllDeclaration", node, opts);
          }

          function assertExportDefaultDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ExportDefaultDeclaration", node, opts);
          }

          function assertExportNamedDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ExportNamedDeclaration", node, opts);
          }

          function assertExportSpecifier(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ExportSpecifier", node, opts);
          }

          function assertForOfStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ForOfStatement", node, opts);
          }

          function assertImportDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ImportDeclaration", node, opts);
          }

          function assertImportDefaultSpecifier(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ImportDefaultSpecifier", node, opts);
          }

          function assertImportNamespaceSpecifier(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ImportNamespaceSpecifier", node, opts);
          }

          function assertImportSpecifier(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ImportSpecifier", node, opts);
          }

          function assertMetaProperty(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("MetaProperty", node, opts);
          }

          function assertClassMethod(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ClassMethod", node, opts);
          }

          function assertObjectPattern(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ObjectPattern", node, opts);
          }

          function assertSpreadElement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("SpreadElement", node, opts);
          }

          function assertSuper(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Super", node, opts);
          }

          function assertTaggedTemplateExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TaggedTemplateExpression", node, opts);
          }

          function assertTemplateElement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TemplateElement", node, opts);
          }

          function assertTemplateLiteral(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TemplateLiteral", node, opts);
          }

          function assertYieldExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("YieldExpression", node, opts);
          }

          function assertAnyTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("AnyTypeAnnotation", node, opts);
          }

          function assertArrayTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ArrayTypeAnnotation", node, opts);
          }

          function assertBooleanTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("BooleanTypeAnnotation", node, opts);
          }

          function assertBooleanLiteralTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("BooleanLiteralTypeAnnotation", node, opts);
          }

          function assertNullLiteralTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("NullLiteralTypeAnnotation", node, opts);
          }

          function assertClassImplements(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ClassImplements", node, opts);
          }

          function assertDeclareClass(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DeclareClass", node, opts);
          }

          function assertDeclareFunction(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DeclareFunction", node, opts);
          }

          function assertDeclareInterface(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DeclareInterface", node, opts);
          }

          function assertDeclareModule(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DeclareModule", node, opts);
          }

          function assertDeclareModuleExports(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DeclareModuleExports", node, opts);
          }

          function assertDeclareTypeAlias(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DeclareTypeAlias", node, opts);
          }

          function assertDeclareOpaqueType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DeclareOpaqueType", node, opts);
          }

          function assertDeclareVariable(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DeclareVariable", node, opts);
          }

          function assertDeclareExportDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DeclareExportDeclaration", node, opts);
          }

          function assertDeclareExportAllDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DeclareExportAllDeclaration", node, opts);
          }

          function assertDeclaredPredicate(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DeclaredPredicate", node, opts);
          }

          function assertExistsTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ExistsTypeAnnotation", node, opts);
          }

          function assertFunctionTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("FunctionTypeAnnotation", node, opts);
          }

          function assertFunctionTypeParam(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("FunctionTypeParam", node, opts);
          }

          function assertGenericTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("GenericTypeAnnotation", node, opts);
          }

          function assertInferredPredicate(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("InferredPredicate", node, opts);
          }

          function assertInterfaceExtends(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("InterfaceExtends", node, opts);
          }

          function assertInterfaceDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("InterfaceDeclaration", node, opts);
          }

          function assertInterfaceTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("InterfaceTypeAnnotation", node, opts);
          }

          function assertIntersectionTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("IntersectionTypeAnnotation", node, opts);
          }

          function assertMixedTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("MixedTypeAnnotation", node, opts);
          }

          function assertEmptyTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("EmptyTypeAnnotation", node, opts);
          }

          function assertNullableTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("NullableTypeAnnotation", node, opts);
          }

          function assertNumberLiteralTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("NumberLiteralTypeAnnotation", node, opts);
          }

          function assertNumberTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("NumberTypeAnnotation", node, opts);
          }

          function assertObjectTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ObjectTypeAnnotation", node, opts);
          }

          function assertObjectTypeInternalSlot(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ObjectTypeInternalSlot", node, opts);
          }

          function assertObjectTypeCallProperty(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ObjectTypeCallProperty", node, opts);
          }

          function assertObjectTypeIndexer(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ObjectTypeIndexer", node, opts);
          }

          function assertObjectTypeProperty(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ObjectTypeProperty", node, opts);
          }

          function assertObjectTypeSpreadProperty(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ObjectTypeSpreadProperty", node, opts);
          }

          function assertOpaqueType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("OpaqueType", node, opts);
          }

          function assertQualifiedTypeIdentifier(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("QualifiedTypeIdentifier", node, opts);
          }

          function assertStringLiteralTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("StringLiteralTypeAnnotation", node, opts);
          }

          function assertStringTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("StringTypeAnnotation", node, opts);
          }

          function assertThisTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ThisTypeAnnotation", node, opts);
          }

          function assertTupleTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TupleTypeAnnotation", node, opts);
          }

          function assertTypeofTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TypeofTypeAnnotation", node, opts);
          }

          function assertTypeAlias(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TypeAlias", node, opts);
          }

          function assertTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TypeAnnotation", node, opts);
          }

          function assertTypeCastExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TypeCastExpression", node, opts);
          }

          function assertTypeParameter(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TypeParameter", node, opts);
          }

          function assertTypeParameterDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TypeParameterDeclaration", node, opts);
          }

          function assertTypeParameterInstantiation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TypeParameterInstantiation", node, opts);
          }

          function assertUnionTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("UnionTypeAnnotation", node, opts);
          }

          function assertVariance(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Variance", node, opts);
          }

          function assertVoidTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("VoidTypeAnnotation", node, opts);
          }

          function assertJSXAttribute(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXAttribute", node, opts);
          }

          function assertJSXClosingElement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXClosingElement", node, opts);
          }

          function assertJSXElement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXElement", node, opts);
          }

          function assertJSXEmptyExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXEmptyExpression", node, opts);
          }

          function assertJSXExpressionContainer(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXExpressionContainer", node, opts);
          }

          function assertJSXSpreadChild(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXSpreadChild", node, opts);
          }

          function assertJSXIdentifier(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXIdentifier", node, opts);
          }

          function assertJSXMemberExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXMemberExpression", node, opts);
          }

          function assertJSXNamespacedName(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXNamespacedName", node, opts);
          }

          function assertJSXOpeningElement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXOpeningElement", node, opts);
          }

          function assertJSXSpreadAttribute(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXSpreadAttribute", node, opts);
          }

          function assertJSXText(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXText", node, opts);
          }

          function assertJSXFragment(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXFragment", node, opts);
          }

          function assertJSXOpeningFragment(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXOpeningFragment", node, opts);
          }

          function assertJSXClosingFragment(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSXClosingFragment", node, opts);
          }

          function assertNoop(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Noop", node, opts);
          }

          function assertParenthesizedExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ParenthesizedExpression", node, opts);
          }

          function assertAwaitExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("AwaitExpression", node, opts);
          }

          function assertBindExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("BindExpression", node, opts);
          }

          function assertClassProperty(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ClassProperty", node, opts);
          }

          function assertOptionalMemberExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("OptionalMemberExpression", node, opts);
          }

          function assertOptionalCallExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("OptionalCallExpression", node, opts);
          }

          function assertClassPrivateProperty(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ClassPrivateProperty", node, opts);
          }

          function assertImport(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Import", node, opts);
          }

          function assertDecorator(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Decorator", node, opts);
          }

          function assertDoExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("DoExpression", node, opts);
          }

          function assertExportDefaultSpecifier(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ExportDefaultSpecifier", node, opts);
          }

          function assertExportNamespaceSpecifier(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ExportNamespaceSpecifier", node, opts);
          }

          function assertPrivateName(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("PrivateName", node, opts);
          }

          function assertBigIntLiteral(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("BigIntLiteral", node, opts);
          }

          function assertTSParameterProperty(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSParameterProperty", node, opts);
          }

          function assertTSDeclareFunction(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSDeclareFunction", node, opts);
          }

          function assertTSDeclareMethod(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSDeclareMethod", node, opts);
          }

          function assertTSQualifiedName(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSQualifiedName", node, opts);
          }

          function assertTSCallSignatureDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSCallSignatureDeclaration", node, opts);
          }

          function assertTSConstructSignatureDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSConstructSignatureDeclaration", node, opts);
          }

          function assertTSPropertySignature(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSPropertySignature", node, opts);
          }

          function assertTSMethodSignature(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSMethodSignature", node, opts);
          }

          function assertTSIndexSignature(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSIndexSignature", node, opts);
          }

          function assertTSAnyKeyword(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSAnyKeyword", node, opts);
          }

          function assertTSNumberKeyword(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSNumberKeyword", node, opts);
          }

          function assertTSObjectKeyword(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSObjectKeyword", node, opts);
          }

          function assertTSBooleanKeyword(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSBooleanKeyword", node, opts);
          }

          function assertTSStringKeyword(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSStringKeyword", node, opts);
          }

          function assertTSSymbolKeyword(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSSymbolKeyword", node, opts);
          }

          function assertTSVoidKeyword(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSVoidKeyword", node, opts);
          }

          function assertTSUndefinedKeyword(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSUndefinedKeyword", node, opts);
          }

          function assertTSNullKeyword(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSNullKeyword", node, opts);
          }

          function assertTSNeverKeyword(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSNeverKeyword", node, opts);
          }

          function assertTSThisType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSThisType", node, opts);
          }

          function assertTSFunctionType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSFunctionType", node, opts);
          }

          function assertTSConstructorType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSConstructorType", node, opts);
          }

          function assertTSTypeReference(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypeReference", node, opts);
          }

          function assertTSTypePredicate(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypePredicate", node, opts);
          }

          function assertTSTypeQuery(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypeQuery", node, opts);
          }

          function assertTSTypeLiteral(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypeLiteral", node, opts);
          }

          function assertTSArrayType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSArrayType", node, opts);
          }

          function assertTSTupleType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTupleType", node, opts);
          }

          function assertTSUnionType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSUnionType", node, opts);
          }

          function assertTSIntersectionType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSIntersectionType", node, opts);
          }

          function assertTSConditionalType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSConditionalType", node, opts);
          }

          function assertTSInferType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSInferType", node, opts);
          }

          function assertTSParenthesizedType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSParenthesizedType", node, opts);
          }

          function assertTSTypeOperator(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypeOperator", node, opts);
          }

          function assertTSIndexedAccessType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSIndexedAccessType", node, opts);
          }

          function assertTSMappedType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSMappedType", node, opts);
          }

          function assertTSLiteralType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSLiteralType", node, opts);
          }

          function assertTSExpressionWithTypeArguments(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSExpressionWithTypeArguments", node, opts);
          }

          function assertTSInterfaceDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSInterfaceDeclaration", node, opts);
          }

          function assertTSInterfaceBody(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSInterfaceBody", node, opts);
          }

          function assertTSTypeAliasDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypeAliasDeclaration", node, opts);
          }

          function assertTSAsExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSAsExpression", node, opts);
          }

          function assertTSTypeAssertion(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypeAssertion", node, opts);
          }

          function assertTSEnumDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSEnumDeclaration", node, opts);
          }

          function assertTSEnumMember(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSEnumMember", node, opts);
          }

          function assertTSModuleDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSModuleDeclaration", node, opts);
          }

          function assertTSModuleBlock(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSModuleBlock", node, opts);
          }

          function assertTSImportEqualsDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSImportEqualsDeclaration", node, opts);
          }

          function assertTSExternalModuleReference(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSExternalModuleReference", node, opts);
          }

          function assertTSNonNullExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSNonNullExpression", node, opts);
          }

          function assertTSExportAssignment(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSExportAssignment", node, opts);
          }

          function assertTSNamespaceExportDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSNamespaceExportDeclaration", node, opts);
          }

          function assertTSTypeAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypeAnnotation", node, opts);
          }

          function assertTSTypeParameterInstantiation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypeParameterInstantiation", node, opts);
          }

          function assertTSTypeParameterDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypeParameterDeclaration", node, opts);
          }

          function assertTSTypeParameter(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypeParameter", node, opts);
          }

          function assertExpression(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Expression", node, opts);
          }

          function assertBinary(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Binary", node, opts);
          }

          function assertScopable(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Scopable", node, opts);
          }

          function assertBlockParent(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("BlockParent", node, opts);
          }

          function assertBlock(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Block", node, opts);
          }

          function assertStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Statement", node, opts);
          }

          function assertTerminatorless(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Terminatorless", node, opts);
          }

          function assertCompletionStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("CompletionStatement", node, opts);
          }

          function assertConditional(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Conditional", node, opts);
          }

          function assertLoop(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Loop", node, opts);
          }

          function assertWhile(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("While", node, opts);
          }

          function assertExpressionWrapper(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ExpressionWrapper", node, opts);
          }

          function assertFor(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("For", node, opts);
          }

          function assertForXStatement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ForXStatement", node, opts);
          }

          function assertFunction(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Function", node, opts);
          }

          function assertFunctionParent(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("FunctionParent", node, opts);
          }

          function assertPureish(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Pureish", node, opts);
          }

          function assertDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Declaration", node, opts);
          }

          function assertPatternLike(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("PatternLike", node, opts);
          }

          function assertLVal(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("LVal", node, opts);
          }

          function assertTSEntityName(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSEntityName", node, opts);
          }

          function assertLiteral(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Literal", node, opts);
          }

          function assertImmutable(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Immutable", node, opts);
          }

          function assertUserWhitespacable(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("UserWhitespacable", node, opts);
          }

          function assertMethod(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Method", node, opts);
          }

          function assertObjectMember(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ObjectMember", node, opts);
          }

          function assertProperty(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Property", node, opts);
          }

          function assertUnaryLike(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("UnaryLike", node, opts);
          }

          function assertPattern(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Pattern", node, opts);
          }

          function assertClass(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Class", node, opts);
          }

          function assertModuleDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ModuleDeclaration", node, opts);
          }

          function assertExportDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ExportDeclaration", node, opts);
          }

          function assertModuleSpecifier(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("ModuleSpecifier", node, opts);
          }

          function assertFlow(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Flow", node, opts);
          }

          function assertFlowType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("FlowType", node, opts);
          }

          function assertFlowBaseAnnotation(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("FlowBaseAnnotation", node, opts);
          }

          function assertFlowDeclaration(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("FlowDeclaration", node, opts);
          }

          function assertFlowPredicate(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("FlowPredicate", node, opts);
          }

          function assertJSX(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("JSX", node, opts);
          }

          function assertPrivate(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("Private", node, opts);
          }

          function assertTSTypeElement(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSTypeElement", node, opts);
          }

          function assertTSType(node, opts) {
            if (opts === void 0) {
              opts = {};
            }

            assert("TSType", node, opts);
          }

          function assertNumberLiteral(node, opts) {
            console.trace(
              "The node type NumberLiteral has been renamed to NumericLiteral"
            );
            assert("NumberLiteral", node, opts);
          }

          function assertRegexLiteral(node, opts) {
            console.trace(
              "The node type RegexLiteral has been renamed to RegExpLiteral"
            );
            assert("RegexLiteral", node, opts);
          }

          function assertRestProperty(node, opts) {
            console.trace(
              "The node type RestProperty has been renamed to RestElement"
            );
            assert("RestProperty", node, opts);
          }

          function assertSpreadProperty(node, opts) {
            console.trace(
              "The node type SpreadProperty has been renamed to SpreadElement"
            );
            assert("SpreadProperty", node, opts);
          }
        },
        /* 252 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = createTypeAnnotationBasedOnTypeof;

          var _generated = __webpack_require__(4);

          function createTypeAnnotationBasedOnTypeof(type) {
            if (type === "string") {
              return (0, _generated.stringTypeAnnotation)();
            } else if (type === "number") {
              return (0, _generated.numberTypeAnnotation)();
            } else if (type === "undefined") {
              return (0, _generated.voidTypeAnnotation)();
            } else if (type === "boolean") {
              return (0, _generated.booleanTypeAnnotation)();
            } else if (type === "function") {
              return (0, _generated.genericTypeAnnotation)(
                (0, _generated.identifier)("Function")
              );
            } else if (type === "object") {
              return (0, _generated.genericTypeAnnotation)(
                (0, _generated.identifier)("Object")
              );
            } else if (type === "symbol") {
              return (0, _generated.genericTypeAnnotation)(
                (0, _generated.identifier)("Symbol")
              );
            } else {
              throw new Error("Invalid typeof value");
            }
          }
        },
        /* 253 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = createUnionTypeAnnotation;

          var _generated = __webpack_require__(4);

          var _removeTypeDuplicates = _interopRequireDefault(
            __webpack_require__(110)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function createUnionTypeAnnotation(types) {
            var flattened = (0, _removeTypeDuplicates.default)(types);

            if (flattened.length === 1) {
              return flattened[0];
            } else {
              return (0, _generated.unionTypeAnnotation)(flattened);
            }
          }
        },
        /* 254 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = cloneDeep;

          var _cloneNode = _interopRequireDefault(__webpack_require__(28));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function cloneDeep(node) {
            return (0, _cloneNode.default)(node);
          }
        },
        /* 255 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = cloneWithoutLoc;

          var _clone = _interopRequireDefault(__webpack_require__(111));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function cloneWithoutLoc(node) {
            var newNode = (0, _clone.default)(node);
            newNode.loc = null;
            return newNode;
          }
        },
        /* 256 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = addComment;

          var _addComments = _interopRequireDefault(__webpack_require__(112));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function addComment(node, type, content, line) {
            return (0, _addComments.default)(node, type, [
              {
                type: line ? "CommentLine" : "CommentBlock",
                value: content,
              },
            ]);
          }
        },
        /* 257 */
        function(module, exports, __webpack_require__) {
          var baseUniq = __webpack_require__(258);

          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }

          module.exports = uniq;
        },
        /* 258 */
        function(module, exports, __webpack_require__) {
          var SetCache = __webpack_require__(114),
            arrayIncludes = __webpack_require__(261),
            arrayIncludesWith = __webpack_require__(265),
            cacheHas = __webpack_require__(116),
            createSet = __webpack_require__(266),
            setToArray = __webpack_require__(70);

          var LARGE_ARRAY_SIZE = 200;

          function baseUniq(array, iteratee, comparator) {
            var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = true,
              result = [],
              seen = result;

            if (comparator) {
              isCommon = false;
              includes = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set = iteratee ? null : createSet(array);

              if (set) {
                return setToArray(set);
              }

              isCommon = false;
              includes = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee ? [] : result;
            }

            outer: while (++index < length) {
              var value = array[index],
                computed = iteratee ? iteratee(value) : value;
              value = comparator || value !== 0 ? value : 0;

              if (isCommon && computed === computed) {
                var seenIndex = seen.length;

                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }

                if (iteratee) {
                  seen.push(computed);
                }

                result.push(value);
              } else if (!includes(seen, computed, comparator)) {
                if (seen !== result) {
                  seen.push(computed);
                }

                result.push(value);
              }
            }

            return result;
          }

          module.exports = baseUniq;
        },
        /* 259 */
        function(module, exports) {
          var HASH_UNDEFINED = "__lodash_hash_undefined__";

          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);

            return this;
          }

          module.exports = setCacheAdd;
        },
        /* 260 */
        function(module, exports) {
          function setCacheHas(value) {
            return this.__data__.has(value);
          }

          module.exports = setCacheHas;
        },
        /* 261 */
        function(module, exports, __webpack_require__) {
          var baseIndexOf = __webpack_require__(115);

          function arrayIncludes(array, value) {
            var length = array == null ? 0 : array.length;
            return !!length && baseIndexOf(array, value, 0) > -1;
          }

          module.exports = arrayIncludes;
        },
        /* 262 */
        function(module, exports) {
          function baseFindIndex(array, predicate, fromIndex, fromRight) {
            var length = array.length,
              index = fromIndex + (fromRight ? 1 : -1);

            while (fromRight ? index-- : ++index < length) {
              if (predicate(array[index], index, array)) {
                return index;
              }
            }

            return -1;
          }

          module.exports = baseFindIndex;
        },
        /* 263 */
        function(module, exports) {
          function baseIsNaN(value) {
            return value !== value;
          }

          module.exports = baseIsNaN;
        },
        /* 264 */
        function(module, exports) {
          function strictIndexOf(array, value, fromIndex) {
            var index = fromIndex - 1,
              length = array.length;

            while (++index < length) {
              if (array[index] === value) {
                return index;
              }
            }

            return -1;
          }

          module.exports = strictIndexOf;
        },
        /* 265 */
        function(module, exports) {
          function arrayIncludesWith(array, value, comparator) {
            var index = -1,
              length = array == null ? 0 : array.length;

            while (++index < length) {
              if (comparator(value, array[index])) {
                return true;
              }
            }

            return false;
          }

          module.exports = arrayIncludesWith;
        },
        /* 266 */
        function(module, exports, __webpack_require__) {
          var Set = __webpack_require__(104),
            noop = __webpack_require__(267),
            setToArray = __webpack_require__(70);

          var INFINITY = 1 / 0;
          var createSet = !(
            Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY
          )
            ? noop
            : function(values) {
                return new Set(values);
              };
          module.exports = createSet;
        },
        /* 267 */
        function(module, exports) {
          function noop() {}

          module.exports = noop;
        },
        /* 268 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = removeComments;

          var _constants = __webpack_require__(14);

          function removeComments(node) {
            _constants.COMMENT_KEYS.forEach(function(key) {
              node[key] = null;
            });

            return node;
          }
        },
        /* 269 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.PRIVATE_TYPES = exports.JSX_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;

          var _definitions = __webpack_require__(8);

          var EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
          exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
          var BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
          exports.BINARY_TYPES = BINARY_TYPES;
          var SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
          exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
          var BLOCKPARENT_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
          exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
          var BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
          exports.BLOCK_TYPES = BLOCK_TYPES;
          var STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
          exports.STATEMENT_TYPES = STATEMENT_TYPES;
          var TERMINATORLESS_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
          exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
          var COMPLETIONSTATEMENT_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
          exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
          var CONDITIONAL_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
          exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
          var LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
          exports.LOOP_TYPES = LOOP_TYPES;
          var WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
          exports.WHILE_TYPES = WHILE_TYPES;
          var EXPRESSIONWRAPPER_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
          exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
          var FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
          exports.FOR_TYPES = FOR_TYPES;
          var FORXSTATEMENT_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
          exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
          var FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
          exports.FUNCTION_TYPES = FUNCTION_TYPES;
          var FUNCTIONPARENT_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
          exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
          var PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
          exports.PUREISH_TYPES = PUREISH_TYPES;
          var DECLARATION_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
          exports.DECLARATION_TYPES = DECLARATION_TYPES;
          var PATTERNLIKE_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
          exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
          var LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
          exports.LVAL_TYPES = LVAL_TYPES;
          var TSENTITYNAME_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
          exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
          var LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
          exports.LITERAL_TYPES = LITERAL_TYPES;
          var IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
          exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
          var USERWHITESPACABLE_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
          exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
          var METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
          exports.METHOD_TYPES = METHOD_TYPES;
          var OBJECTMEMBER_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
          exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
          var PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
          exports.PROPERTY_TYPES = PROPERTY_TYPES;
          var UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
          exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
          var PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
          exports.PATTERN_TYPES = PATTERN_TYPES;
          var CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
          exports.CLASS_TYPES = CLASS_TYPES;
          var MODULEDECLARATION_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
          exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
          var EXPORTDECLARATION_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
          exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
          var MODULESPECIFIER_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
          exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
          var FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
          exports.FLOW_TYPES = FLOW_TYPES;
          var FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
          exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
          var FLOWBASEANNOTATION_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
          exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
          var FLOWDECLARATION_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
          exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
          var FLOWPREDICATE_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
          exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
          var JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
          exports.JSX_TYPES = JSX_TYPES;
          var PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
          exports.PRIVATE_TYPES = PRIVATE_TYPES;
          var TSTYPEELEMENT_TYPES =
            _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
          exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
          var TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
          exports.TSTYPE_TYPES = TSTYPE_TYPES;
        },
        /* 270 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = ensureBlock;

          var _toBlock = _interopRequireDefault(__webpack_require__(120));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function ensureBlock(node, key) {
            if (key === void 0) {
              key = "body";
            }

            return (node[key] = (0, _toBlock.default)(node[key], node));
          }
        },
        /* 271 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = toBindingIdentifierName;

          var _toIdentifier = _interopRequireDefault(__webpack_require__(121));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function toBindingIdentifierName(name) {
            name = (0, _toIdentifier.default)(name);
            if (name === "eval" || name === "arguments") name = "_" + name;
            return name;
          }
        },
        /* 272 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = toComputedKey;

          var _generated = __webpack_require__(2);

          var _generated2 = __webpack_require__(4);

          function toComputedKey(node, key) {
            if (key === void 0) {
              key = node.key || node.property;
            }

            if (!node.computed && (0, _generated.isIdentifier)(key))
              key = (0, _generated2.stringLiteral)(key.name);
            return key;
          }
        },
        /* 273 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = toExpression;

          var _generated = __webpack_require__(2);

          function toExpression(node) {
            if ((0, _generated.isExpressionStatement)(node)) {
              node = node.expression;
            }

            if ((0, _generated.isExpression)(node)) {
              return node;
            }

            if ((0, _generated.isClass)(node)) {
              node.type = "ClassExpression";
            } else if ((0, _generated.isFunction)(node)) {
              node.type = "FunctionExpression";
            }

            if (!(0, _generated.isExpression)(node)) {
              throw new Error("cannot turn " + node.type + " to an expression");
            }

            return node;
          }
        },
        /* 274 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = toKeyAlias;

          var _generated = __webpack_require__(2);

          var _cloneNode = _interopRequireDefault(__webpack_require__(28));

          var _removePropertiesDeep = _interopRequireDefault(
            __webpack_require__(122)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function toKeyAlias(node, key) {
            if (key === void 0) {
              key = node.key;
            }

            var alias;

            if (node.kind === "method") {
              return toKeyAlias.increment() + "";
            } else if ((0, _generated.isIdentifier)(key)) {
              alias = key.name;
            } else if ((0, _generated.isStringLiteral)(key)) {
              alias = JSON.stringify(key.value);
            } else {
              alias = JSON.stringify(
                (0, _removePropertiesDeep.default)((0, _cloneNode.default)(key))
              );
            }

            if (node.computed) {
              alias = "[" + alias + "]";
            }

            if (node.static) {
              alias = "static:" + alias;
            }

            return alias;
          }

          toKeyAlias.uid = 0;

          toKeyAlias.increment = function() {
            if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
              return (toKeyAlias.uid = 0);
            } else {
              return toKeyAlias.uid++;
            }
          };
        },
        /* 275 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = toSequenceExpression;

          var _gatherSequenceExpressions = _interopRequireDefault(
            __webpack_require__(276)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function toSequenceExpression(nodes, scope) {
            if (!nodes || !nodes.length) return;
            var declars = [];
            var result = (0, _gatherSequenceExpressions.default)(
              nodes,
              scope,
              declars
            );
            if (!result) return;

            for (var _i = 0; _i < declars.length; _i++) {
              var declar = declars[_i];
              scope.push(declar);
            }

            return result;
          }
        },
        /* 276 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = gatherSequenceExpressions;

          var _getBindingIdentifiers = _interopRequireDefault(
            __webpack_require__(40)
          );

          var _generated = __webpack_require__(2);

          var _generated2 = __webpack_require__(4);

          var _cloneNode = _interopRequireDefault(__webpack_require__(28));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function gatherSequenceExpressions(nodes, scope, declars) {
            var exprs = [];
            var ensureLastUndefined = true;

            for (
              var _iterator = nodes,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var node = _ref;
              ensureLastUndefined = false;

              if ((0, _generated.isExpression)(node)) {
                exprs.push(node);
              } else if ((0, _generated.isExpressionStatement)(node)) {
                exprs.push(node.expression);
              } else if ((0, _generated.isVariableDeclaration)(node)) {
                if (node.kind !== "var") return;

                for (
                  var _iterator2 = node.declarations,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : _iterator2[Symbol.iterator]();
                  ;

                ) {
                  var _ref2;

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                  } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                  }

                  var declar = _ref2;
                  var bindings = (0, _getBindingIdentifiers.default)(declar);

                  for (var key in bindings) {
                    declars.push({
                      kind: node.kind,
                      id: (0, _cloneNode.default)(bindings[key]),
                    });
                  }

                  if (declar.init) {
                    exprs.push(
                      (0, _generated2.assignmentExpression)(
                        "=",
                        declar.id,
                        declar.init
                      )
                    );
                  }
                }

                ensureLastUndefined = true;
              } else if ((0, _generated.isIfStatement)(node)) {
                var consequent = node.consequent
                  ? gatherSequenceExpressions([node.consequent], scope, declars)
                  : scope.buildUndefinedNode();
                var alternate = node.alternate
                  ? gatherSequenceExpressions([node.alternate], scope, declars)
                  : scope.buildUndefinedNode();
                if (!consequent || !alternate) return;
                exprs.push(
                  (0, _generated2.conditionalExpression)(
                    node.test,
                    consequent,
                    alternate
                  )
                );
              } else if ((0, _generated.isBlockStatement)(node)) {
                var body = gatherSequenceExpressions(node.body, scope, declars);
                if (!body) return;
                exprs.push(body);
              } else if ((0, _generated.isEmptyStatement)(node)) {
                ensureLastUndefined = true;
              } else {
                return;
              }
            }

            if (ensureLastUndefined) {
              exprs.push(scope.buildUndefinedNode());
            }

            if (exprs.length === 1) {
              return exprs[0];
            } else {
              return (0, _generated2.sequenceExpression)(exprs);
            }
          }
        },
        /* 277 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = toStatement;

          var _generated = __webpack_require__(2);

          var _generated2 = __webpack_require__(4);

          function toStatement(node, ignore) {
            if ((0, _generated.isStatement)(node)) {
              return node;
            }

            var mustHaveId = false;
            var newType;

            if ((0, _generated.isClass)(node)) {
              mustHaveId = true;
              newType = "ClassDeclaration";
            } else if ((0, _generated.isFunction)(node)) {
              mustHaveId = true;
              newType = "FunctionDeclaration";
            } else if ((0, _generated.isAssignmentExpression)(node)) {
              return (0, _generated2.expressionStatement)(node);
            }

            if (mustHaveId && !node.id) {
              newType = false;
            }

            if (!newType) {
              if (ignore) {
                return false;
              } else {
                throw new Error("cannot turn " + node.type + " to a statement");
              }
            }

            node.type = newType;
            return node;
          }
        },
        /* 278 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = valueToNode;

          function _isPlainObject() {
            var data = _interopRequireDefault(__webpack_require__(279));

            _isPlainObject = function _isPlainObject() {
              return data;
            };

            return data;
          }

          function _isRegExp() {
            var data = _interopRequireDefault(__webpack_require__(280));

            _isRegExp = function _isRegExp() {
              return data;
            };

            return data;
          }

          var _isValidIdentifier = _interopRequireDefault(
            __webpack_require__(27)
          );

          var _generated = __webpack_require__(4);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function valueToNode(value) {
            if (value === undefined) {
              return (0, _generated.identifier)("undefined");
            }

            if (value === true || value === false) {
              return (0, _generated.booleanLiteral)(value);
            }

            if (value === null) {
              return (0, _generated.nullLiteral)();
            }

            if (typeof value === "string") {
              return (0, _generated.stringLiteral)(value);
            }

            if (typeof value === "number") {
              var result;

              if (Number.isFinite(value)) {
                result = (0, _generated.numericLiteral)(Math.abs(value));
              } else {
                var numerator;

                if (Number.isNaN(value)) {
                  numerator = (0, _generated.numericLiteral)(0);
                } else {
                  numerator = (0, _generated.numericLiteral)(1);
                }

                result = (0, _generated.binaryExpression)(
                  "/",
                  numerator,
                  (0, _generated.numericLiteral)(0)
                );
              }

              if (value < 0 || Object.is(value, -0)) {
                result = (0, _generated.unaryExpression)("-", result);
              }

              return result;
            }

            if ((0, _isRegExp().default)(value)) {
              var pattern = value.source;
              var flags = value.toString().match(/\/([a-z]+|)$/)[1];
              return (0, _generated.regExpLiteral)(pattern, flags);
            }

            if (Array.isArray(value)) {
              return (0, _generated.arrayExpression)(value.map(valueToNode));
            }

            if ((0, _isPlainObject().default)(value)) {
              var props = [];

              for (var key in value) {
                var nodeKey = void 0;

                if ((0, _isValidIdentifier.default)(key)) {
                  nodeKey = (0, _generated.identifier)(key);
                } else {
                  nodeKey = (0, _generated.stringLiteral)(key);
                }

                props.push(
                  (0, _generated.objectProperty)(
                    nodeKey,
                    valueToNode(value[key])
                  )
                );
              }

              return (0, _generated.objectExpression)(props);
            }

            throw new Error("don't know how to turn this value into a node");
          }
        },
        /* 279 */
        function(module, exports, __webpack_require__) {
          var baseGetTag = __webpack_require__(10),
            getPrototype = __webpack_require__(63),
            isObjectLike = __webpack_require__(7);

          var objectTag = "[object Object]";
          var funcProto = Function.prototype,
            objectProto = Object.prototype;
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var objectCtorString = funcToString.call(Object);

          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }

            var proto = getPrototype(value);

            if (proto === null) {
              return true;
            }

            var Ctor =
              hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return (
              typeof Ctor == "function" &&
              Ctor instanceof Ctor &&
              funcToString.call(Ctor) == objectCtorString
            );
          }

          module.exports = isPlainObject;
        },
        /* 280 */
        function(module, exports, __webpack_require__) {
          var baseIsRegExp = __webpack_require__(281),
            baseUnary = __webpack_require__(26),
            nodeUtil = __webpack_require__(38);

          var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          module.exports = isRegExp;
        },
        /* 281 */
        function(module, exports, __webpack_require__) {
          var baseGetTag = __webpack_require__(10),
            isObjectLike = __webpack_require__(7);

          var regexpTag = "[object RegExp]";

          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }

          module.exports = baseIsRegExp;
        },
        /* 282 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = appendToMemberExpression;

          var _generated = __webpack_require__(4);

          function appendToMemberExpression(member, append, computed) {
            if (computed === void 0) {
              computed = false;
            }

            member.object = (0, _generated.memberExpression)(
              member.object,
              member.property,
              member.computed
            );
            member.property = append;
            member.computed = !!computed;
            return member;
          }
        },
        /* 283 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = inherits;

          var _constants = __webpack_require__(14);

          var _inheritsComments = _interopRequireDefault(
            __webpack_require__(118)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function inherits(child, parent) {
            if (!child || !parent) return child;

            for (
              var _iterator = _constants.INHERIT_KEYS.optional,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var _key = _ref;

              if (child[_key] == null) {
                child[_key] = parent[_key];
              }
            }

            for (var key in parent) {
              if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
            }

            for (
              var _iterator2 = _constants.INHERIT_KEYS.force,
                _isArray2 = Array.isArray(_iterator2),
                _i2 = 0,
                _iterator2 = _isArray2
                  ? _iterator2
                  : _iterator2[Symbol.iterator]();
              ;

            ) {
              var _ref2;

              if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
              } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
              }

              var _key2 = _ref2;
              child[_key2] = parent[_key2];
            }

            (0, _inheritsComments.default)(child, parent);
            return child;
          }
        },
        /* 284 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = prependToMemberExpression;

          var _generated = __webpack_require__(4);

          function prependToMemberExpression(member, prepend) {
            member.object = (0, _generated.memberExpression)(
              prepend,
              member.object
            );
            return member;
          }
        },
        /* 285 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = getOuterBindingIdentifiers;

          var _getBindingIdentifiers = _interopRequireDefault(
            __webpack_require__(40)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function getOuterBindingIdentifiers(node, duplicates) {
            return (0, _getBindingIdentifiers.default)(node, duplicates, true);
          }
        },
        /* 286 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = traverse;

          var _definitions = __webpack_require__(8);

          function traverse(node, handlers, state) {
            if (typeof handlers === "function") {
              handlers = {
                enter: handlers,
              };
            }

            var _handlers = handlers,
              enter = _handlers.enter,
              exit = _handlers.exit;
            traverseSimpleImpl(node, enter, exit, state, []);
          }

          function traverseSimpleImpl(node, enter, exit, state, ancestors) {
            var keys = _definitions.VISITOR_KEYS[node.type];
            if (!keys) return;
            if (enter) enter(node, ancestors, state);

            for (
              var _iterator = keys,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var key = _ref;
              var subNode = node[key];

              if (Array.isArray(subNode)) {
                for (var i = 0; i < subNode.length; i++) {
                  var child = subNode[i];
                  if (!child) continue;
                  ancestors.push({
                    node: node,
                    key: key,
                    index: i,
                  });
                  traverseSimpleImpl(child, enter, exit, state, ancestors);
                  ancestors.pop();
                }
              } else if (subNode) {
                ancestors.push({
                  node: node,
                  key: key,
                });
                traverseSimpleImpl(subNode, enter, exit, state, ancestors);
                ancestors.pop();
              }
            }

            if (exit) exit(node, ancestors, state);
          }
        },
        /* 287 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isBinding;

          var _getBindingIdentifiers = _interopRequireDefault(
            __webpack_require__(40)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function isBinding(node, parent) {
            var keys = _getBindingIdentifiers.default.keys[parent.type];

            if (keys) {
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var val = parent[key];

                if (Array.isArray(val)) {
                  if (val.indexOf(node) >= 0) return true;
                } else {
                  if (val === node) return true;
                }
              }
            }

            return false;
          }
        },
        /* 288 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isBlockScoped;

          var _generated = __webpack_require__(2);

          var _isLet = _interopRequireDefault(__webpack_require__(125));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function isBlockScoped(node) {
            return (
              (0, _generated.isFunctionDeclaration)(node) ||
              (0, _generated.isClassDeclaration)(node) ||
              (0, _isLet.default)(node)
            );
          }
        },
        /* 289 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isImmutable;

          var _isType = _interopRequireDefault(__webpack_require__(67));

          var _generated = __webpack_require__(2);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function isImmutable(node) {
            if ((0, _isType.default)(node.type, "Immutable")) return true;

            if ((0, _generated.isIdentifier)(node)) {
              if (node.name === "undefined") {
                return true;
              } else {
                return false;
              }
            }

            return false;
          }
        },
        /* 290 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isNodesEquivalent;

          var _definitions = __webpack_require__(8);

          function isNodesEquivalent(a, b) {
            if (
              typeof a !== "object" ||
              typeof b !== "object" ||
              a == null ||
              b == null
            ) {
              return a === b;
            }

            if (a.type !== b.type) {
              return false;
            }

            var fields = Object.keys(
              _definitions.NODE_FIELDS[a.type] || a.type
            );
            var visitorKeys = _definitions.VISITOR_KEYS[a.type];

            for (var _i = 0; _i < fields.length; _i++) {
              var field = fields[_i];

              if (typeof a[field] !== typeof b[field]) {
                return false;
              }

              if (Array.isArray(a[field])) {
                if (!Array.isArray(b[field])) {
                  return false;
                }

                if (a[field].length !== b[field].length) {
                  return false;
                }

                for (var i = 0; i < a[field].length; i++) {
                  if (!isNodesEquivalent(a[field][i], b[field][i])) {
                    return false;
                  }
                }

                continue;
              }

              if (
                typeof a[field] === "object" &&
                (!visitorKeys || !visitorKeys.includes(field))
              ) {
                for (var key in a[field]) {
                  if (a[field][key] !== b[field][key]) {
                    return false;
                  }
                }

                continue;
              }

              if (!isNodesEquivalent(a[field], b[field])) {
                return false;
              }
            }

            return true;
          }
        },
        /* 291 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isReferenced;

          function isReferenced(node, parent) {
            switch (parent.type) {
              case "MemberExpression":
              case "JSXMemberExpression":
              case "OptionalMemberExpression":
                if (parent.property === node) {
                  return !!parent.computed;
                }

                return parent.object === node;

              case "VariableDeclarator":
                return parent.init === node;

              case "ArrowFunctionExpression":
                return parent.body === node;

              case "ExportSpecifier":
                if (parent.source) {
                  return false;
                }

                return parent.local === node;

              case "ObjectProperty":
              case "ClassProperty":
              case "ClassPrivateProperty":
              case "ClassMethod":
              case "ObjectMethod":
                if (parent.key === node) {
                  return !!parent.computed;
                }

                return parent.value === node;

              case "ClassDeclaration":
              case "ClassExpression":
                return parent.superClass === node;

              case "AssignmentExpression":
                return parent.right === node;

              case "AssignmentPattern":
                return parent.right === node;

              case "LabeledStatement":
                return false;

              case "CatchClause":
                return false;

              case "RestElement":
                return false;

              case "BreakStatement":
              case "ContinueStatement":
                return false;

              case "FunctionDeclaration":
              case "FunctionExpression":
                return false;

              case "ExportNamespaceSpecifier":
              case "ExportDefaultSpecifier":
                return false;

              case "ImportDefaultSpecifier":
              case "ImportNamespaceSpecifier":
              case "ImportSpecifier":
                return false;

              case "JSXAttribute":
                return false;

              case "ObjectPattern":
              case "ArrayPattern":
                return false;

              case "MetaProperty":
                return false;

              case "ObjectTypeProperty":
                return parent.key !== node;
            }

            return true;
          }
        },
        /* 292 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isScope;

          var _generated = __webpack_require__(2);

          function isScope(node, parent) {
            if (
              (0, _generated.isBlockStatement)(node) &&
              (0, _generated.isFunction)(parent, {
                body: node,
              })
            ) {
              return false;
            }

            if (
              (0, _generated.isBlockStatement)(node) &&
              (0, _generated.isCatchClause)(parent, {
                body: node,
              })
            ) {
              return false;
            }

            return (0, _generated.isScopable)(node);
          }
        },
        /* 293 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isSpecifierDefault;

          var _generated = __webpack_require__(2);

          function isSpecifierDefault(specifier) {
            return (
              (0, _generated.isImportDefaultSpecifier)(specifier) ||
              (0, _generated.isIdentifier)(
                specifier.imported || specifier.exported,
                {
                  name: "default",
                }
              )
            );
          }
        },
        /* 294 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isValidES3Identifier;

          var _isValidIdentifier = _interopRequireDefault(
            __webpack_require__(27)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var RESERVED_WORDS_ES3_ONLY = new Set([
            "abstract",
            "boolean",
            "byte",
            "char",
            "double",
            "enum",
            "final",
            "float",
            "goto",
            "implements",
            "int",
            "interface",
            "long",
            "native",
            "package",
            "private",
            "protected",
            "public",
            "short",
            "static",
            "synchronized",
            "throws",
            "transient",
            "volatile",
          ]);

          function isValidES3Identifier(name) {
            return (
              (0, _isValidIdentifier.default)(name) &&
              !RESERVED_WORDS_ES3_ONLY.has(name)
            );
          }
        },
        /* 295 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = isVar;

          var _generated = __webpack_require__(2);

          var _constants = __webpack_require__(14);

          function isVar(node) {
            return (
              (0, _generated.isVariableDeclaration)(node, {
                kind: "var",
              }) && !node[_constants.BLOCK_SCOPED_SYMBOL]
            );
          }
        },
        /* 296 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function _assert() {
            var data = _interopRequireDefault(__webpack_require__(23));

            _assert = function _assert() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var ImportBuilder = (function() {
            function ImportBuilder(importedSource, scope, hub) {
              this._statements = [];
              this._resultName = null;
              this._scope = null;
              this._hub = null;
              this._scope = scope;
              this._hub = hub;
              this._importedSource = importedSource;
            }

            var _proto = ImportBuilder.prototype;

            _proto.done = function done() {
              return {
                statements: this._statements,
                resultName: this._resultName,
              };
            };

            _proto.import = function _import() {
              this._statements.push(
                t().importDeclaration(
                  [],
                  t().stringLiteral(this._importedSource)
                )
              );

              return this;
            };

            _proto.require = function require() {
              this._statements.push(
                t().expressionStatement(
                  t().callExpression(t().identifier("require"), [
                    t().stringLiteral(this._importedSource),
                  ])
                )
              );

              return this;
            };

            _proto.namespace = function namespace(name) {
              if (name === void 0) {
                name = "namespace";
              }

              name = this._scope.generateUidIdentifier(name);
              var statement = this._statements[this._statements.length - 1];
              (0, _assert().default)(statement.type === "ImportDeclaration");
              (0, _assert().default)(statement.specifiers.length === 0);
              statement.specifiers = [t().importNamespaceSpecifier(name)];
              this._resultName = t().cloneNode(name);
              return this;
            };

            _proto.default = function _default(name) {
              name = this._scope.generateUidIdentifier(name);
              var statement = this._statements[this._statements.length - 1];
              (0, _assert().default)(statement.type === "ImportDeclaration");
              (0, _assert().default)(statement.specifiers.length === 0);
              statement.specifiers = [t().importDefaultSpecifier(name)];
              this._resultName = t().cloneNode(name);
              return this;
            };

            _proto.named = function named(name, importName) {
              if (importName === "default") return this.default(name);
              name = this._scope.generateUidIdentifier(name);
              var statement = this._statements[this._statements.length - 1];
              (0, _assert().default)(statement.type === "ImportDeclaration");
              (0, _assert().default)(statement.specifiers.length === 0);
              statement.specifiers = [
                t().importSpecifier(name, t().identifier(importName)),
              ];
              this._resultName = t().cloneNode(name);
              return this;
            };

            _proto.var = function _var(name) {
              name = this._scope.generateUidIdentifier(name);
              var statement = this._statements[this._statements.length - 1];

              if (statement.type !== "ExpressionStatement") {
                (0, _assert().default)(this._resultName);
                statement = t().expressionStatement(this._resultName);

                this._statements.push(statement);
              }

              this._statements[
                this._statements.length - 1
              ] = t().variableDeclaration("var", [
                t().variableDeclarator(name, statement.expression),
              ]);
              this._resultName = t().cloneNode(name);
              return this;
            };

            _proto.defaultInterop = function defaultInterop() {
              return this._interop(
                this._hub.addHelper("interopRequireDefault")
              );
            };

            _proto.wildcardInterop = function wildcardInterop() {
              return this._interop(
                this._hub.addHelper("interopRequireWildcard")
              );
            };

            _proto._interop = function _interop(callee) {
              var statement = this._statements[this._statements.length - 1];

              if (statement.type === "ExpressionStatement") {
                statement.expression = t().callExpression(callee, [
                  statement.expression,
                ]);
              } else if (statement.type === "VariableDeclaration") {
                (0, _assert().default)(statement.declarations.length === 1);
                statement.declarations[0].init = t().callExpression(callee, [
                  statement.declarations[0].init,
                ]);
              } else {
                _assert().default.fail("Unexpected type.");
              }

              return this;
            };

            _proto.prop = function prop(name) {
              var statement = this._statements[this._statements.length - 1];

              if (statement.type === "ExpressionStatement") {
                statement.expression = t().memberExpression(
                  statement.expression,
                  t().identifier(name)
                );
              } else if (statement.type === "VariableDeclaration") {
                (0, _assert().default)(statement.declarations.length === 1);
                statement.declarations[0].init = t().memberExpression(
                  statement.declarations[0].init,
                  t().identifier(name)
                );
              } else {
                _assert().default.fail("Unexpected type:" + statement.type);
              }

              return this;
            };

            _proto.read = function read(name) {
              this._resultName = t().memberExpression(
                this._resultName,
                t().identifier(name)
              );
            };

            return ImportBuilder;
          })();

          exports.default = ImportBuilder;
        },
        /* 297 */
        function(module, exports) {
          module.exports = {
            safari: "tp",
          };
        },
        /* 298 */
        function(module) {
          module.exports = [
            {
              name: "nodejs",
              version: "0.2.0",
              date: "2011-08-26",
              lts: false,
            },
            {
              name: "nodejs",
              version: "0.3.0",
              date: "2011-08-26",
              lts: false,
            },
            {
              name: "nodejs",
              version: "0.4.0",
              date: "2011-08-26",
              lts: false,
            },
            {
              name: "nodejs",
              version: "0.5.0",
              date: "2011-08-26",
              lts: false,
            },
            {
              name: "nodejs",
              version: "0.6.0",
              date: "2011-11-04",
              lts: false,
            },
            {
              name: "nodejs",
              version: "0.7.0",
              date: "2012-01-17",
              lts: false,
            },
            {
              name: "nodejs",
              version: "0.8.0",
              date: "2012-06-22",
              lts: false,
            },
            {
              name: "nodejs",
              version: "0.9.0",
              date: "2012-07-20",
              lts: false,
            },
            {
              name: "nodejs",
              version: "0.10.0",
              date: "2013-03-11",
              lts: false,
            },
            {
              name: "nodejs",
              version: "0.11.0",
              date: "2013-03-28",
              lts: false,
            },
            {
              name: "nodejs",
              version: "0.12.0",
              date: "2015-02-06",
              lts: false,
            },
            { name: "iojs", version: "1.0.0", date: "2015-01-14" },
            { name: "iojs", version: "1.1.0", date: "2015-02-03" },
            { name: "iojs", version: "1.2.0", date: "2015-02-11" },
            { name: "iojs", version: "1.3.0", date: "2015-02-20" },
            { name: "iojs", version: "1.5.0", date: "2015-03-06" },
            { name: "iojs", version: "1.6.0", date: "2015-03-20" },
            { name: "iojs", version: "2.0.0", date: "2015-05-04" },
            { name: "iojs", version: "2.1.0", date: "2015-05-24" },
            { name: "iojs", version: "2.2.0", date: "2015-06-01" },
            { name: "iojs", version: "2.3.0", date: "2015-06-13" },
            { name: "iojs", version: "2.4.0", date: "2015-07-17" },
            { name: "iojs", version: "2.5.0", date: "2015-07-28" },
            { name: "iojs", version: "3.0.0", date: "2015-08-04" },
            { name: "iojs", version: "3.1.0", date: "2015-08-19" },
            { name: "iojs", version: "3.2.0", date: "2015-08-25" },
            { name: "iojs", version: "3.3.0", date: "2015-09-02" },
            {
              name: "nodejs",
              version: "4.0.0",
              date: "2015-09-08",
              lts: false,
            },
            {
              name: "nodejs",
              version: "4.1.0",
              date: "2015-09-17",
              lts: false,
            },
            {
              name: "nodejs",
              version: "4.2.0",
              date: "2015-10-12",
              lts: "Argon",
            },
            {
              name: "nodejs",
              version: "4.3.0",
              date: "2016-02-09",
              lts: "Argon",
            },
            {
              name: "nodejs",
              version: "4.4.0",
              date: "2016-03-08",
              lts: "Argon",
            },
            {
              name: "nodejs",
              version: "4.5.0",
              date: "2016-08-16",
              lts: "Argon",
            },
            {
              name: "nodejs",
              version: "4.6.0",
              date: "2016-09-27",
              lts: "Argon",
            },
            {
              name: "nodejs",
              version: "4.7.0",
              date: "2016-12-06",
              lts: "Argon",
            },
            {
              name: "nodejs",
              version: "4.8.0",
              date: "2017-02-21",
              lts: "Argon",
            },
            {
              name: "nodejs",
              version: "4.9.0",
              date: "2018-03-28",
              lts: "Argon",
            },
            {
              name: "nodejs",
              version: "5.0.0",
              date: "2015-10-29",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.1.0",
              date: "2015-11-17",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.2.0",
              date: "2015-12-09",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.3.0",
              date: "2015-12-15",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.4.0",
              date: "2016-01-06",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.5.0",
              date: "2016-01-21",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.6.0",
              date: "2016-02-09",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.7.0",
              date: "2016-02-23",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.8.0",
              date: "2016-03-09",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.9.0",
              date: "2016-03-16",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.10.0",
              date: "2016-04-01",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.11.0",
              date: "2016-04-21",
              lts: false,
            },
            {
              name: "nodejs",
              version: "5.12.0",
              date: "2016-06-23",
              lts: false,
            },
            {
              name: "nodejs",
              version: "6.0.0",
              date: "2016-04-26",
              lts: false,
            },
            {
              name: "nodejs",
              version: "6.1.0",
              date: "2016-05-05",
              lts: false,
            },
            {
              name: "nodejs",
              version: "6.2.0",
              date: "2016-05-17",
              lts: false,
            },
            {
              name: "nodejs",
              version: "6.3.0",
              date: "2016-07-06",
              lts: false,
            },
            {
              name: "nodejs",
              version: "6.4.0",
              date: "2016-08-12",
              lts: false,
            },
            {
              name: "nodejs",
              version: "6.5.0",
              date: "2016-08-26",
              lts: false,
            },
            {
              name: "nodejs",
              version: "6.6.0",
              date: "2016-09-14",
              lts: false,
            },
            {
              name: "nodejs",
              version: "6.7.0",
              date: "2016-09-27",
              lts: false,
            },
            {
              name: "nodejs",
              version: "6.8.0",
              date: "2016-10-12",
              lts: false,
            },
            {
              name: "nodejs",
              version: "6.9.0",
              date: "2016-10-18",
              lts: "Boron",
            },
            {
              name: "nodejs",
              version: "6.10.0",
              date: "2017-02-21",
              lts: "Boron",
            },
            {
              name: "nodejs",
              version: "6.11.0",
              date: "2017-06-06",
              lts: "Boron",
            },
            {
              name: "nodejs",
              version: "6.12.0",
              date: "2017-11-06",
              lts: "Boron",
            },
            {
              name: "nodejs",
              version: "6.13.0",
              date: "2018-02-10",
              lts: "Boron",
            },
            {
              name: "nodejs",
              version: "6.14.0",
              date: "2018-03-28",
              lts: "Boron",
            },
            {
              name: "nodejs",
              version: "7.0.0",
              date: "2016-10-25",
              lts: false,
            },
            {
              name: "nodejs",
              version: "7.1.0",
              date: "2016-11-08",
              lts: false,
            },
            {
              name: "nodejs",
              version: "7.2.0",
              date: "2016-11-22",
              lts: false,
            },
            {
              name: "nodejs",
              version: "7.3.0",
              date: "2016-12-20",
              lts: false,
            },
            {
              name: "nodejs",
              version: "7.4.0",
              date: "2017-01-04",
              lts: false,
            },
            {
              name: "nodejs",
              version: "7.5.0",
              date: "2017-01-31",
              lts: false,
            },
            {
              name: "nodejs",
              version: "7.6.0",
              date: "2017-02-21",
              lts: false,
            },
            {
              name: "nodejs",
              version: "7.7.0",
              date: "2017-02-28",
              lts: false,
            },
            {
              name: "nodejs",
              version: "7.8.0",
              date: "2017-03-29",
              lts: false,
            },
            {
              name: "nodejs",
              version: "7.9.0",
              date: "2017-04-11",
              lts: false,
            },
            {
              name: "nodejs",
              version: "7.10.0",
              date: "2017-05-02",
              lts: false,
            },
            {
              name: "nodejs",
              version: "8.0.0",
              date: "2017-05-30",
              lts: false,
            },
            {
              name: "nodejs",
              version: "8.1.0",
              date: "2017-06-08",
              lts: false,
            },
            {
              name: "nodejs",
              version: "8.2.0",
              date: "2017-07-19",
              lts: false,
            },
            {
              name: "nodejs",
              version: "8.3.0",
              date: "2017-08-08",
              lts: false,
            },
            {
              name: "nodejs",
              version: "8.4.0",
              date: "2017-08-15",
              lts: false,
            },
            {
              name: "nodejs",
              version: "8.5.0",
              date: "2017-09-12",
              lts: false,
            },
            {
              name: "nodejs",
              version: "8.6.0",
              date: "2017-09-26",
              lts: false,
            },
            {
              name: "nodejs",
              version: "8.7.0",
              date: "2017-10-11",
              lts: false,
            },
            {
              name: "nodejs",
              version: "8.8.0",
              date: "2017-10-24",
              lts: false,
            },
            {
              name: "nodejs",
              version: "8.9.0",
              date: "2017-10-31",
              lts: "Carbon",
            },
            {
              name: "nodejs",
              version: "8.10.0",
              date: "2018-03-06",
              lts: "Carbon",
            },
            {
              name: "nodejs",
              version: "8.11.0",
              date: "2018-03-28",
              lts: "Carbon",
            },
            {
              name: "nodejs",
              version: "9.0.0",
              date: "2017-10-31",
              lts: false,
            },
            {
              name: "nodejs",
              version: "9.1.0",
              date: "2017-11-07",
              lts: false,
            },
            {
              name: "nodejs",
              version: "9.2.0",
              date: "2017-11-14",
              lts: false,
            },
            {
              name: "nodejs",
              version: "9.3.0",
              date: "2017-12-12",
              lts: false,
            },
            {
              name: "nodejs",
              version: "9.4.0",
              date: "2018-01-10",
              lts: false,
            },
            {
              name: "nodejs",
              version: "9.5.0",
              date: "2018-01-31",
              lts: false,
            },
            {
              name: "nodejs",
              version: "9.6.0",
              date: "2018-02-21",
              lts: false,
            },
            {
              name: "nodejs",
              version: "9.7.0",
              date: "2018-03-01",
              lts: false,
            },
            {
              name: "nodejs",
              version: "9.8.0",
              date: "2018-03-07",
              lts: false,
            },
            {
              name: "nodejs",
              version: "9.9.0",
              date: "2018-03-21",
              lts: false,
            },
            {
              name: "nodejs",
              version: "9.10.0",
              date: "2018-03-28",
              lts: false,
            },
            {
              name: "nodejs",
              version: "9.11.0",
              date: "2018-04-04",
              lts: false,
            },
            {
              name: "nodejs",
              version: "10.0.0",
              date: "2018-04-24",
              lts: false,
            },
            {
              name: "nodejs",
              version: "10.1.0",
              date: "2018-05-08",
              lts: false,
            },
            {
              name: "nodejs",
              version: "10.2.0",
              date: "2018-05-23",
              lts: false,
            },
            {
              name: "nodejs",
              version: "10.3.0",
              date: "2018-05-29",
              lts: false,
            },
            {
              name: "nodejs",
              version: "10.4.0",
              date: "2018-06-06",
              lts: false,
            },
            {
              name: "nodejs",
              version: "10.5.0",
              date: "2018-06-20",
              lts: false,
            },
            {
              name: "nodejs",
              version: "10.6.0",
              date: "2018-07-04",
              lts: false,
            },
            {
              name: "nodejs",
              version: "10.7.0",
              date: "2018-07-18",
              lts: false,
            },
            {
              name: "nodejs",
              version: "10.8.0",
              date: "2018-08-01",
              lts: false,
            },
          ];
        },
        /* 299 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.agents = undefined;

          var _browsers = __webpack_require__(300);

          var _browserVersions = __webpack_require__(302);

          var agentsData = __webpack_require__(304);

          function unpackBrowserVersions(versionsData) {
            return Object.keys(versionsData).reduce(function(usage, version) {
              usage[_browserVersions.browserVersions[version]] =
                versionsData[version];
              return usage;
            }, {});
          }

          var agents = (exports.agents = Object.keys(agentsData).reduce(
            function(map, key) {
              var versionsData = agentsData[key];
              map[_browsers.browsers[key]] = Object.keys(versionsData).reduce(
                function(data, entry) {
                  if (entry === "A") {
                    data.usage_global = unpackBrowserVersions(
                      versionsData[entry]
                    );
                  } else if (entry === "C") {
                    data.versions = versionsData[entry].reduce(function(
                      list,
                      version
                    ) {
                      if (version === "") {
                        list.push(null);
                      } else {
                        list.push(_browserVersions.browserVersions[version]);
                      }

                      return list;
                    },
                    []);
                  } else if (entry === "D") {
                    data.prefix_exceptions = unpackBrowserVersions(
                      versionsData[entry]
                    );
                  } else if (entry === "E") {
                    data.browser = versionsData[entry];
                  } else if (entry === "F") {
                    data.release_date = Object.keys(versionsData[entry]).reduce(
                      function(map, key) {
                        map[_browserVersions.browserVersions[key]] =
                          versionsData[entry][key];
                        return map;
                      },
                      {}
                    );
                  } else {
                    data.prefix = versionsData[entry];
                  }

                  return data;
                },
                {}
              );
              return map;
            },
            {}
          ));
        },
        /* 300 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });

          var browsers = (exports.browsers = __webpack_require__(301));
        },
        /* 301 */
        function(module, exports) {
          module.exports = {
            A: "ie",
            B: "edge",
            C: "firefox",
            D: "chrome",
            E: "safari",
            F: "opera",
            G: "ios_saf",
            H: "op_mini",
            I: "android",
            J: "bb",
            K: "op_mob",
            L: "and_chr",
            M: "and_ff",
            N: "ie_mob",
            O: "and_uc",
            P: "samsung",
            Q: "and_qq",
            R: "baidu",
          };
        },
        /* 302 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });

          var browserVersions = (exports.browserVersions = __webpack_require__(
            303
          ));
        },
        /* 303 */
        function(module, exports) {
          module.exports = {
            "0": "60",
            "1": "11.1",
            "2": "32",
            "3": "56",
            "4": "3",
            "5": "58",
            "6": "59",
            "7": "4.2-4.3",
            "8": "61",
            "9": "62",
            A: "10",
            B: "11",
            C: "12",
            D: "7",
            E: "9",
            F: "4",
            G: "8",
            H: "6",
            I: "18",
            J: "15",
            K: "5",
            L: "16",
            M: "46",
            N: "17",
            O: "19",
            P: "20",
            Q: "21",
            R: "22",
            S: "23",
            T: "24",
            U: "25",
            V: "26",
            W: "27",
            X: "28",
            Y: "29",
            Z: "30",
            a: "31",
            b: "67",
            c: "33",
            d: "34",
            e: "35",
            f: "36",
            g: "37",
            h: "38",
            i: "39",
            j: "40",
            k: "41",
            l: "42",
            m: "43",
            n: "44",
            o: "45",
            p: "13",
            q: "47",
            r: "48",
            s: "49",
            t: "50",
            u: "51",
            v: "52",
            w: "53",
            x: "54",
            y: "55",
            z: "14",
            AB: "63",
            BB: "11.5",
            CB: "57",
            DB: "3.2",
            EB: "12.1",
            FB: "5.5",
            GB: "66",
            HB: "68",
            IB: "69",
            JB: "70",
            KB: "71",
            LB: "3.1",
            MB: "64",
            NB: "5.1",
            OB: "6.1",
            PB: "7.1",
            QB: "9.1",
            RB: "10.1",
            SB: "3.6",
            TB: "TP",
            UB: "9.5-9.6",
            VB: "10.0-10.1",
            WB: "10.5",
            XB: "10.6",
            YB: "3.5",
            ZB: "11.6",
            aB: "2",
            bB: "4.0-4.1",
            cB: "65",
            dB: "5.0-5.1",
            eB: "6.0-6.1",
            fB: "7.0-7.1",
            gB: "8.1-8.4",
            hB: "9.0-9.2",
            iB: "9.3",
            jB: "10.0-10.2",
            kB: "10.3",
            lB: "11.0-11.2",
            mB: "11.3-11.4",
            nB: "all",
            oB: "2.1",
            pB: "2.2",
            qB: "2.3",
            rB: "4.1",
            sB: "4.4",
            tB: "4.4.3-4.4.4",
            uB: "11.8",
            vB: "6.2",
            wB: "7.2",
            xB: "1.2",
            yB: "7.12",
          };
        },
        /* 304 */
        function(module, exports) {
          module.exports = {
            A: {
              A: {
                H: 0.00884489,
                D: 0.00884489,
                G: 0.176898,
                E: 0.145941,
                A: 0.0928713,
                B: 2.64462,
                FB: 0.009298,
              },
              B: "ms",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "FB",
                "H",
                "D",
                "G",
                "E",
                "A",
                "B",
                "",
                "",
                "",
              ],
              E: "IE",
              F: {
                FB: 962323200,
                H: 998870400,
                D: 1161129600,
                G: 1237420800,
                E: 1300060800,
                A: 1346716800,
                B: 1381968000,
              },
            },
            B: {
              A: {
                C: 0.025902,
                p: 0.025902,
                z: 0.060438,
                J: 0.069072,
                L: 0.263337,
                N: 1.38144,
                I: 0,
              },
              B: "ms",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "C",
                "p",
                "z",
                "J",
                "L",
                "N",
                "I",
                "",
                "",
              ],
              E: "Edge",
              F: {
                C: 1438128000,
                p: 1447286400,
                z: 1470096000,
                J: 1491868800,
                L: 1508198400,
                N: 1525046400,
                I: null,
              },
            },
            C: {
              A: {
                "0": 0.453285,
                "2": 0.004471,
                "3": 0.090657,
                "4": 0.004317,
                "5": 0.038853,
                "6": 0.082023,
                "8": 2.91398,
                "9": 0.094974,
                aB: 0.004317,
                F: 0.008634,
                K: 0.004879,
                H: 0.020136,
                D: 0.005725,
                G: 0.004317,
                E: 0.00533,
                A: 0.004283,
                B: 0.004317,
                C: 0.004471,
                p: 0.004486,
                z: 0.00453,
                J: 0.004317,
                L: 0.004417,
                N: 0.004349,
                I: 0.004393,
                O: 0.004443,
                P: 0.004283,
                Q: 0.008634,
                R: 0.004393,
                S: 0.004317,
                T: 0.008786,
                U: 0.004317,
                V: 0.004317,
                W: 0.004393,
                X: 0.004418,
                Y: 0.004317,
                Z: 0.008634,
                a: 0.017268,
                c: 0.008634,
                d: 0.012951,
                e: 0.008634,
                f: 0.004317,
                g: 0.008634,
                h: 0.056121,
                i: 0.008634,
                j: 0.008634,
                k: 0.008634,
                l: 0.004317,
                m: 0.025902,
                n: 0.012951,
                o: 0.030219,
                M: 0.008634,
                q: 0.069072,
                r: 0.099291,
                s: 0.017268,
                t: 0.021585,
                u: 0.056121,
                v: 0.410115,
                w: 0.017268,
                x: 0.021585,
                y: 0.038853,
                CB: 0.047487,
                AB: 0,
                YB: 0.008786,
                SB: 0.008634,
              },
              B: "moz",
              C: [
                "",
                "",
                "",
                "aB",
                "4",
                "YB",
                "SB",
                "F",
                "K",
                "H",
                "D",
                "G",
                "E",
                "A",
                "B",
                "C",
                "p",
                "z",
                "J",
                "L",
                "N",
                "I",
                "O",
                "P",
                "Q",
                "R",
                "S",
                "T",
                "U",
                "V",
                "W",
                "X",
                "Y",
                "Z",
                "a",
                "2",
                "c",
                "d",
                "e",
                "f",
                "g",
                "h",
                "i",
                "j",
                "k",
                "l",
                "m",
                "n",
                "o",
                "M",
                "q",
                "r",
                "s",
                "t",
                "u",
                "v",
                "w",
                "x",
                "y",
                "3",
                "CB",
                "5",
                "6",
                "0",
                "8",
                "9",
                "AB",
                "",
              ],
              E: "Firefox",
              F: {
                "0": 1525824000,
                "2": 1409616000,
                "3": 1506556800,
                "4": 1213660800,
                "5": 1516665600,
                "6": 1520985600,
                "8": 1529971200,
                "9": null,
                aB: 1161648000,
                YB: 1246320000,
                SB: 1264032000,
                F: 1300752000,
                K: 1308614400,
                H: 1313452800,
                D: 1317081600,
                G: 1317081600,
                E: 1320710400,
                A: 1324339200,
                B: 1327968000,
                C: 1331596800,
                p: 1335225600,
                z: 1338854400,
                J: 1342483200,
                L: 1346112000,
                N: 1349740800,
                I: 1353628800,
                O: 1357603200,
                P: 1361232000,
                Q: 1364860800,
                R: 1368489600,
                S: 1372118400,
                T: 1375747200,
                U: 1379376000,
                V: 1386633600,
                W: 1391472000,
                X: 1395100800,
                Y: 1398729600,
                Z: 1402358400,
                a: 1405987200,
                c: 1413244800,
                d: 1417392000,
                e: 1421107200,
                f: 1424736000,
                g: 1428278400,
                h: 1431475200,
                i: 1435881600,
                j: 1439251200,
                k: 1442880000,
                l: 1446508800,
                m: 1450137600,
                n: 1453852800,
                o: 1457395200,
                M: 1461628800,
                q: 1465257600,
                r: 1470096000,
                s: 1474329600,
                t: 1479168000,
                u: 1485216000,
                v: 1488844800,
                w: 1492560000,
                x: 1497312000,
                y: 1502150400,
                CB: 1510617600,
                AB: null,
              },
            },
            D: {
              A: {
                "0": 0.08634,
                "2": 0.012951,
                "3": 0.094974,
                "5": 0.107925,
                "6": 0.047487,
                "8": 0.082023,
                "9": 0.120876,
                F: 0.004706,
                K: 0.004879,
                H: 0.004879,
                D: 0.005591,
                G: 0.005591,
                E: 0.005591,
                A: 0.004534,
                B: 0.008634,
                C: 0.004283,
                p: 0.004879,
                z: 0.004706,
                J: 0.017268,
                L: 0.004393,
                N: 0.004393,
                I: 0.012951,
                O: 0.004418,
                P: 0.004393,
                Q: 0.004317,
                R: 0.021585,
                S: 0.008786,
                T: 0.012951,
                U: 0.008634,
                V: 0.008634,
                W: 0.004317,
                X: 0.004317,
                Y: 0.289239,
                Z: 0.012951,
                a: 0.030219,
                c: 0.012951,
                d: 0.021585,
                e: 0.012951,
                f: 0.021585,
                g: 0.017268,
                h: 0.030219,
                i: 0.017268,
                j: 0.017268,
                k: 0.090657,
                l: 0.012951,
                m: 0.051804,
                n: 0.012951,
                o: 0.017268,
                M: 0.017268,
                q: 0.030219,
                r: 0.038853,
                s: 0.69072,
                t: 0.021585,
                u: 0.038853,
                v: 0.021585,
                w: 0.021585,
                x: 0.064755,
                y: 0.271971,
                CB: 0.064755,
                AB: 0.500772,
                MB: 0.17268,
                cB: 0.289239,
                GB: 0.530991,
                b: 23.4715,
                HB: 0.591429,
                IB: 0.04317,
                JB: 0.004317,
                KB: 0,
              },
              B: "webkit",
              C: [
                "F",
                "K",
                "H",
                "D",
                "G",
                "E",
                "A",
                "B",
                "C",
                "p",
                "z",
                "J",
                "L",
                "N",
                "I",
                "O",
                "P",
                "Q",
                "R",
                "S",
                "T",
                "U",
                "V",
                "W",
                "X",
                "Y",
                "Z",
                "a",
                "2",
                "c",
                "d",
                "e",
                "f",
                "g",
                "h",
                "i",
                "j",
                "k",
                "l",
                "m",
                "n",
                "o",
                "M",
                "q",
                "r",
                "s",
                "t",
                "u",
                "v",
                "w",
                "x",
                "y",
                "3",
                "CB",
                "5",
                "6",
                "0",
                "8",
                "9",
                "AB",
                "MB",
                "cB",
                "GB",
                "b",
                "HB",
                "IB",
                "JB",
                "KB",
              ],
              E: "Chrome",
              F: {
                "0": 1500940800,
                "2": 1389657600,
                "3": 1485302400,
                "5": 1492560000,
                "6": 1496707200,
                "8": 1504569600,
                "9": 1508198400,
                F: 1264377600,
                K: 1274745600,
                H: 1283385600,
                D: 1287619200,
                G: 1291248000,
                E: 1296777600,
                A: 1299542400,
                B: 1303862400,
                C: 1307404800,
                p: 1312243200,
                z: 1316131200,
                J: 1316131200,
                L: 1319500800,
                N: 1323734400,
                I: 1328659200,
                O: 1332892800,
                P: 1337040000,
                Q: 1340668800,
                R: 1343692800,
                S: 1348531200,
                T: 1352246400,
                U: 1357862400,
                V: 1361404800,
                W: 1364428800,
                X: 1369094400,
                Y: 1374105600,
                Z: 1376956800,
                a: 1384214400,
                c: 1392940800,
                d: 1397001600,
                e: 1400544000,
                f: 1405468800,
                g: 1409011200,
                h: 1412640000,
                i: 1416268800,
                j: 1421798400,
                k: 1425513600,
                l: 1429401600,
                m: 1432080000,
                n: 1437523200,
                o: 1441152000,
                M: 1444780800,
                q: 1449014400,
                r: 1453248000,
                s: 1456963200,
                t: 1460592000,
                u: 1464134400,
                v: 1469059200,
                w: 1472601600,
                x: 1476230400,
                y: 1480550400,
                CB: 1489017600,
                AB: 1512518400,
                MB: 1516752000,
                cB: 1520294400,
                GB: 1523923200,
                b: 1527552000,
                HB: 1532390400,
                IB: null,
                JB: null,
                KB: null,
              },
            },
            E: {
              A: {
                "1": 1.37281,
                F: 0,
                K: 0.008634,
                H: 0.004349,
                D: 0.004317,
                G: 0.038853,
                E: 0.034536,
                A: 0.064755,
                B: 0.220167,
                C: 0.012951,
                LB: 0,
                DB: 0.008692,
                NB: 0.025902,
                OB: 0.012951,
                PB: 0.004283,
                QB: 0.116559,
                RB: 0.21585,
                TB: 0,
              },
              B: "webkit",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "LB",
                "DB",
                "F",
                "K",
                "NB",
                "H",
                "OB",
                "D",
                "PB",
                "G",
                "E",
                "QB",
                "A",
                "RB",
                "B",
                "1",
                "C",
                "TB",
                "",
              ],
              E: "Safari",
              F: {
                "1": 1522281600,
                LB: 1205798400,
                DB: 1226534400,
                F: 1244419200,
                K: 1275868800,
                NB: 1311120000,
                H: 1343174400,
                OB: 1382400000,
                D: 1382400000,
                PB: 1410998400,
                G: 1413417600,
                E: 1443657600,
                QB: 1458518400,
                A: 1474329600,
                RB: 1490572800,
                B: 1505779200,
                C: null,
                TB: null,
              },
            },
            F: {
              A: {
                "1": 0.006229,
                "2": 0.005152,
                E: 0.0082,
                B: 0.016581,
                C: 0.004317,
                J: 0.00685,
                L: 0.00685,
                N: 0.00685,
                I: 0.005014,
                O: 0.006015,
                P: 0.004879,
                Q: 0.006597,
                R: 0.006597,
                S: 0.013434,
                T: 0.006702,
                U: 0.006015,
                V: 0.005595,
                W: 0.004393,
                X: 0.008634,
                Y: 0.004879,
                Z: 0.004879,
                a: 0.008634,
                c: 0.005014,
                d: 0.009758,
                e: 0.004879,
                f: 0.025902,
                g: 0.004283,
                h: 0.004367,
                i: 0.004534,
                j: 0.004367,
                k: 0.004227,
                l: 0.004418,
                m: 0.004317,
                n: 0.004227,
                o: 0.004471,
                M: 0.004417,
                q: 0.008942,
                r: 0.004369,
                s: 0.004317,
                t: 0.004369,
                u: 0.004317,
                v: 0.008634,
                w: 0.246069,
                x: 0,
                y: 0,
                UB: 0.00685,
                VB: 0,
                WB: 0.008392,
                XB: 0.004706,
                BB: 0.004879,
                ZB: 0.008786,
                EB: 0.038853,
              },
              B: "webkit",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "E",
                "UB",
                "VB",
                "WB",
                "XB",
                "B",
                "1",
                "BB",
                "ZB",
                "C",
                "EB",
                "J",
                "L",
                "N",
                "I",
                "O",
                "P",
                "Q",
                "R",
                "S",
                "T",
                "U",
                "V",
                "W",
                "X",
                "Y",
                "Z",
                "a",
                "2",
                "c",
                "d",
                "e",
                "f",
                "g",
                "h",
                "i",
                "j",
                "k",
                "l",
                "m",
                "n",
                "o",
                "M",
                "q",
                "r",
                "s",
                "t",
                "u",
                "v",
                "w",
                "x",
                "y",
                "",
                "",
                "",
              ],
              E: "Opera",
              F: {
                "1": 1302566400,
                "2": 1442448000,
                E: 1150761600,
                UB: 1223424000,
                VB: 1251763200,
                WB: 1267488000,
                XB: 1277942400,
                B: 1292457600,
                BB: 1309219200,
                ZB: 1323129600,
                C: 1323129600,
                EB: 1352073600,
                J: 1372723200,
                L: 1377561600,
                N: 1381104000,
                I: 1386288000,
                O: 1390867200,
                P: 1393891200,
                Q: 1399334400,
                R: 1401753600,
                S: 1405987200,
                T: 1409616000,
                U: 1413331200,
                V: 1417132800,
                W: 1422316800,
                X: 1425945600,
                Y: 1430179200,
                Z: 1433808000,
                a: 1438646400,
                c: 1445904000,
                d: 1449100800,
                e: 1454371200,
                f: 1457308800,
                g: 1462320000,
                h: 1465344000,
                i: 1470096000,
                j: 1474329600,
                k: 1477267200,
                l: 1481587200,
                m: 1486425600,
                n: 1490054400,
                o: 1494374400,
                M: 1498003200,
                q: 1502236800,
                r: 1506470400,
                s: 1510099200,
                t: 1515024000,
                u: 1517961600,
                v: 1521676800,
                w: 1525910400,
                x: 1530144000,
                y: 1534982400,
              },
              D: {
                "1": "o",
                E: "o",
                B: "o",
                C: "o",
                UB: "o",
                VB: "o",
                WB: "o",
                XB: "o",
                BB: "o",
                ZB: "o",
                EB: "o",
              },
            },
            G: {
              A: {
                "7": 0.00301888,
                G: 0.00805035,
                C: 0.0674217,
                DB: 0.00100629,
                bB: 0,
                dB: 0.0181133,
                eB: 0.00805035,
                fB: 0.0533336,
                gB: 0.0764783,
                hB: 0.0402517,
                iB: 0.302894,
                jB: 0.326039,
                kB: 0.605789,
                lB: 1.29812,
                mB: 7.25034,
              },
              B: "webkit",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "DB",
                "bB",
                "7",
                "dB",
                "eB",
                "fB",
                "G",
                "gB",
                "hB",
                "iB",
                "jB",
                "kB",
                "lB",
                "mB",
                "C",
                "",
                "",
              ],
              E: "iOS Safari",
              F: {
                "7": 1299628800,
                DB: 1270252800,
                bB: 1283904000,
                dB: 1331078400,
                eB: 1359331200,
                fB: 1394409600,
                G: 1410912000,
                gB: 1413763200,
                hB: 1442361600,
                iB: 1458518400,
                jB: 1473724800,
                kB: 1490572800,
                lB: 1505779200,
                mB: 1522281600,
                C: null,
              },
            },
            H: {
              A: {
                nB: 2.29201,
              },
              B: "o",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "nB",
                "",
                "",
                "",
              ],
              E: "Opera Mini",
              F: {
                nB: 1426464000,
              },
            },
            I: {
              A: {
                "4": 0,
                "7": 0.15472,
                F: 0,
                b: 0,
                oB: 0,
                pB: 0,
                qB: 0,
                rB: 0,
                sB: 0.576334,
                tB: 0.377131,
              },
              B: "webkit",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "oB",
                "pB",
                "qB",
                "4",
                "F",
                "rB",
                "7",
                "sB",
                "tB",
                "b",
                "",
                "",
                "",
              ],
              E: "Android Browser",
              F: {
                "4": 1298332800,
                "7": 1374624000,
                oB: 1256515200,
                pB: 1274313600,
                qB: 1291593600,
                F: 1318896000,
                rB: 1341792000,
                sB: 1386547200,
                tB: 1401667200,
                b: 1494115200,
              },
            },
            J: {
              A: {
                D: 0.0079562,
                A: 0.0318248,
              },
              B: "webkit",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "D",
                "A",
                "",
                "",
                "",
              ],
              E: "Blackberry Browser",
              F: {
                D: 1325376000,
                A: 1359504000,
              },
            },
            K: {
              A: {
                "1": 0,
                A: 0,
                B: 0,
                C: 0,
                M: 0.0111391,
                BB: 0,
                EB: 0,
              },
              B: "o",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "A",
                "B",
                "1",
                "BB",
                "C",
                "EB",
                "M",
                "",
                "",
                "",
              ],
              E: "Opera Mobile",
              F: {
                "1": 1314835200,
                A: 1287100800,
                B: 1300752000,
                BB: 1318291200,
                C: 1330300800,
                EB: 1349740800,
                M: 1474588800,
              },
              D: {
                M: "webkit",
              },
            },
            L: {
              A: {
                b: 32.6509,
              },
              B: "webkit",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "b",
                "",
                "",
                "",
              ],
              E: "Chrome for Android",
              F: {
                b: 1527724800,
              },
            },
            M: {
              A: {
                "0": 0.176173,
              },
              B: "moz",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "0",
                "",
                "",
                "",
              ],
              E: "Firefox for Android",
              F: {
                "0": 1525824000,
              },
            },
            N: {
              A: {
                A: 0.0234897,
                B: 0.152683,
              },
              B: "ms",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "A",
                "B",
                "",
                "",
                "",
              ],
              E: "IE Mobile",
              F: {
                A: 1340150400,
                B: 1353456000,
              },
            },
            O: {
              A: {
                uB: 7.09807,
              },
              B: "webkit",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "uB",
                "",
                "",
                "",
              ],
              E: "UC Browser for Android",
              F: {
                uB: 1471392000,
              },
              D: {
                uB: "webkit",
              },
            },
            P: {
              A: {
                F: 0.828383,
                K: 0.155322,
                vB: 0.320998,
                wB: 0,
              },
              B: "webkit",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "F",
                "K",
                "vB",
                "wB",
                "",
                "",
                "",
              ],
              E: "Samsung Internet",
              F: {
                F: 1461024000,
                K: 1481846400,
                vB: 1509408000,
                wB: 1528329600,
              },
            },
            Q: {
              A: {
                xB: 0,
              },
              B: "webkit",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "xB",
                "",
                "",
                "",
              ],
              E: "QQ Browser",
              F: {
                xB: 1483228800,
              },
            },
            R: {
              A: {
                yB: 0,
              },
              B: "webkit",
              C: [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "yB",
                "",
                "",
                "",
              ],
              E: "Baidu Browser",
              F: {
                yB: 1491004800,
              },
            },
          };
        },
        /* 305 */
        function(module) {
          module.exports = {
            "v0.10": { start: "2013-03-11", end: "2016-10-31" },
            "v0.12": { start: "2015-02-06", end: "2016-12-31" },
            v4: {
              start: "2015-09-08",
              lts: "2015-10-12",
              maintenance: "2017-04-01",
              end: "2018-04-30",
              codename: "Argon",
            },
            v5: {
              start: "2015-10-29",
              maintenance: "2016-04-30",
              end: "2016-06-30",
            },
            v6: {
              start: "2016-04-26",
              lts: "2016-10-18",
              maintenance: "2018-04-30",
              end: "2019-04-01",
              codename: "Boron",
            },
            v7: {
              start: "2016-10-25",
              maintenance: "2017-04-30",
              end: "2017-06-30",
            },
            v8: {
              start: "2017-05-30",
              lts: "2017-10-31",
              maintenance: "2019-04-01",
              end: "2019-12-31",
              codename: "Carbon",
            },
            v9: {
              start: "2017-10-01",
              maintenance: "2018-04-01",
              end: "2018-06-30",
            },
            v10: {
              start: "2018-04-24",
              lts: "2018-10-01",
              maintenance: "2020-04-01",
              end: "2021-04-01",
              codename: "",
            },
            v11: {
              start: "2018-10-23",
              maintenance: "2019-04-01",
              end: "2019-06-30",
            },
          };
        },
        /* 306 */
        function(module, exports) {
          /* (ignored) */
        },
        /* 307 */
        function(module, exports) {
          module.exports = {
            "3.0": "66",
            "2.1": "61",
            "2.0": "61",
            "1.8": "59",
            "1.7": "58",
            "1.6": "56",
            "1.5": "54",
            "1.4": "53",
            "1.3": "52",
            "1.2": "51",
            "1.1": "50",
            "1.0": "49",
            "0.37": "49",
            "0.36": "47",
            "0.35": "45",
            "0.34": "45",
            "0.33": "45",
            "0.32": "45",
            "0.31": "44",
            "0.30": "44",
            "0.29": "43",
            "0.28": "43",
            "0.27": "42",
            "0.26": "42",
            "0.25": "42",
            "0.24": "41",
            "0.23": "41",
            "0.22": "41",
            "0.21": "40",
            "0.20": "39",
          };
        },
        /* 308 */
        function(module, exports, __webpack_require__) {
          var BrowserslistError = __webpack_require__(128);

          function noop() {}

          module.exports = {
            loadQueries: function loadQueries() {
              throw new BrowserslistError(
                "Sharable configs are not supported in client-side build of Browserslist"
              );
            },
            getStat: function getStat(opts) {
              return opts.stats;
            },
            loadConfig: function loadConfig(opts) {
              if (opts.config) {
                throw new BrowserslistError(
                  "Browserslist config are not supported in client-side build"
                );
              }
            },
            loadCountry: function loadCountry() {
              throw new BrowserslistError(
                "Country statistics is not supported " +
                  "in client-side build of Browserslist"
              );
            },
            currentNode: function currentNode(resolve, context) {
              return resolve(["maintained node versions"], context)[0];
            },
            parseConfig: noop,
            readConfig: noop,
            findConfig: noop,
            clearCaches: noop,
            oldDataWarning: noop,
          };
        },
        /* 309 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.defaultWebIncludes = void 0;
          var defaultWebIncludes = [
            "web.timers",
            "web.immediate",
            "web.dom.iterable",
          ];
          exports.defaultWebIncludes = defaultWebIncludes;
        },
        /* 310 */
        function(module) {
          module.exports = {
            "es6.module": {
              edge: "16",
              firefox: "60",
              chrome: "61",
              safari: "10.1",
              opera: "48",
              ios_saf: "10.3",
              and_ff: "60",
            },
          };
        },
        /* 311 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.getOptionSpecificExcludesFor = exports.getPlatformSpecificDefaultFor = void 0;
          var defaultWebIncludes = [
            "web.timers",
            "web.immediate",
            "web.dom.iterable",
          ];
          var defaultExcludesForLooseMode = ["transform-typeof-symbol"];

          var getPlatformSpecificDefaultFor = function getPlatformSpecificDefaultFor(
            targets
          ) {
            var targetNames = Object.keys(targets);
            var isAnyTarget = !targetNames.length;
            var isWebTarget = targetNames.some(function(name) {
              return name !== "node";
            });
            return isAnyTarget || isWebTarget ? defaultWebIncludes : null;
          };

          exports.getPlatformSpecificDefaultFor = getPlatformSpecificDefaultFor;

          var getOptionSpecificExcludesFor = function getOptionSpecificExcludesFor(
            _ref
          ) {
            var loose = _ref.loose;

            if (loose) {
              return defaultExcludesForLooseMode;
            }

            return null;
          };

          exports.getOptionSpecificExcludesFor = getOptionSpecificExcludesFor;
        },
        /* 312 */
        function(module, exports) {
          var builtIns = {
            "es7.array.flat-map":
              "Array.prototype.{flat, flatMap} / Array.prototype.flatMap",
          };
          var features = {};
          var pluginSyntaxMap = new Map([
            ["proposal-async-generator-functions", "syntax-async-generators"],
            ["proposal-object-rest-spread", "syntax-object-rest-spread"],
            [
              "proposal-optional-catch-binding",
              "syntax-optional-catch-binding",
            ],
            ["proposal-unicode-property-regex", null],
            ["proposal-json-strings", "syntax-json-strings"],
          ]);
          module.exports = {
            builtIns: builtIns,
            features: features,
            pluginSyntaxMap: pluginSyntaxMap,
          };
        },
        /* 313 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = _default;

          var _debug = __webpack_require__(50);

          var _utils = __webpack_require__(17);

          function _default(_ref) {
            var t = _ref.types;

            function replaceWithPolyfillImports(path, polyfills, regenerator) {
              if (regenerator) {
                (0, _utils.createImport)(path, "regenerator-runtime");
              }

              var items = Array.isArray(polyfills)
                ? new Set(polyfills)
                : polyfills;

              for (
                var _iterator = Array.from(items).reverse(),
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref2;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref2 = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref2 = _i.value;
                }

                var p = _ref2;
                (0, _utils.createImport)(path, p);
              }

              path.remove();
            }

            var isPolyfillImport = {
              ImportDeclaration: function ImportDeclaration(path, state) {
                if (
                  path.node.specifiers.length === 0 &&
                  (0, _utils.isPolyfillSource)(path.node.source.value)
                ) {
                  this.importPolyfillIncluded = true;
                  replaceWithPolyfillImports(
                    path,
                    state.opts.polyfills,
                    state.opts.regenerator
                  );
                }
              },
              Program: function Program(path, state) {
                path.get("body").forEach(function(bodyPath) {
                  if ((0, _utils.isRequire)(t, bodyPath)) {
                    replaceWithPolyfillImports(
                      bodyPath,
                      state.opts.polyfills,
                      state.opts.regenerator
                    );
                  }
                });
              },
            };
            return {
              name: "transform-polyfill-require",
              visitor: isPolyfillImport,
              pre: function pre() {
                this.numPolyfillImports = 0;
                this.importPolyfillIncluded = false;
              },
              post: function post() {
                var _this$opts = this.opts,
                  debug = _this$opts.debug,
                  onDebug = _this$opts.onDebug,
                  polyfills = _this$opts.polyfills;

                if (debug) {
                  (0, _debug.logEntryPolyfills)(
                    this.importPolyfillIncluded,
                    polyfills,
                    this.file.opts.filename,
                    onDebug
                  );
                }
              },
            };
          }
        },
        /* 314 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = _default;

          var _builtInDefinitions = __webpack_require__(315);

          var _debug = __webpack_require__(50);

          var _utils = __webpack_require__(17);

          function has(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key);
          }

          function getType(target) {
            if (Array.isArray(target)) return "array";
            return typeof target;
          }

          function _default(_ref) {
            var t = _ref.types;

            function addImport(path, builtIn, builtIns) {
              if (builtIn && !builtIns.has(builtIn)) {
                builtIns.add(builtIn);
                (0, _utils.createImport)(path, builtIn);
              }
            }

            function addUnsupported(path, polyfills, builtIn, builtIns) {
              if (Array.isArray(builtIn)) {
                for (
                  var _iterator = builtIn,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray
                      ? _iterator
                      : _iterator[Symbol.iterator]();
                  ;

                ) {
                  var _ref2;

                  if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref2 = _iterator[_i++];
                  } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref2 = _i.value;
                  }

                  var i = _ref2;

                  if (polyfills.has(i)) {
                    addImport(path, i, builtIns);
                  }
                }
              } else {
                if (polyfills.has(builtIn)) {
                  addImport(path, builtIn, builtIns);
                }
              }
            }

            var addAndRemovePolyfillImports = {
              ImportDeclaration: function ImportDeclaration(path) {
                if (
                  path.node.specifiers.length === 0 &&
                  (0, _utils.isPolyfillSource)(path.node.source.value)
                ) {
                  console.warn(
                    "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the `import '@gerhobbelt/babel-polyfill'` call or use `useBuiltIns: 'entry'` instead."
                  );
                  path.remove();
                }
              },
              Program: {
                enter: function enter(path) {
                  path.get("body").forEach(function(bodyPath) {
                    if ((0, _utils.isRequire)(t, bodyPath)) {
                      console.warn(
                        "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the `require('@gerhobbelt/babel-polyfill')` call or use `useBuiltIns: 'entry'` instead."
                      );
                      bodyPath.remove();
                    }
                  });
                },
              },
              ReferencedIdentifier: function ReferencedIdentifier(path, state) {
                var node = path.node,
                  parent = path.parent,
                  scope = path.scope;
                if (t.isMemberExpression(parent)) return;
                if (!has(_builtInDefinitions.definitions.builtins, node.name))
                  return;
                if (scope.getBindingIdentifier(node.name)) return;
                var builtIn =
                  _builtInDefinitions.definitions.builtins[node.name];
                addUnsupported(
                  path,
                  state.opts.polyfills,
                  builtIn,
                  this.builtIns
                );
              },
              CallExpression: function CallExpression(path) {
                if (path.node.arguments.length) return;
                var callee = path.node.callee;
                if (!t.isMemberExpression(callee)) return;
                if (!callee.computed) return;

                if (
                  !path.get("callee.property").matchesPattern("Symbol.iterator")
                ) {
                  return;
                }

                addImport(path, "web.dom.iterable", this.builtIns);
              },
              BinaryExpression: function BinaryExpression(path) {
                if (path.node.operator !== "in") return;
                if (!path.get("left").matchesPattern("Symbol.iterator")) return;
                addImport(path, "web.dom.iterable", this.builtIns);
              },
              YieldExpression: function YieldExpression(path) {
                if (!path.node.delegate) return;
                addImport(path, "web.dom.iterable", this.builtIns);
              },
              MemberExpression: {
                enter: function enter(path, state) {
                  if (!path.isReferenced()) return;
                  var node = path.node;
                  var obj = node.object;
                  var prop = node.property;
                  if (!t.isReferenced(obj, node)) return;
                  var instanceType;
                  var evaluatedPropType = obj.name;
                  var propName = prop.name;

                  if (node.computed) {
                    if (t.isStringLiteral(prop)) {
                      propName = prop.value;
                    } else {
                      var res = path.get("property").evaluate();

                      if (res.confident && res.value) {
                        propName = res.value;
                      }
                    }
                  }

                  if (path.scope.getBindingIdentifier(obj.name)) {
                    var result = path.get("object").evaluate();

                    if (result.value) {
                      instanceType = getType(result.value);
                    } else if (result.deopt && result.deopt.isIdentifier()) {
                      evaluatedPropType = result.deopt.node.name;
                    }
                  }

                  if (
                    has(
                      _builtInDefinitions.definitions.staticMethods,
                      evaluatedPropType
                    )
                  ) {
                    var staticMethods =
                      _builtInDefinitions.definitions.staticMethods[
                        evaluatedPropType
                      ];

                    if (has(staticMethods, propName)) {
                      var builtIn = staticMethods[propName];
                      addUnsupported(
                        path,
                        state.opts.polyfills,
                        builtIn,
                        this.builtIns
                      );
                    }
                  }

                  if (
                    has(
                      _builtInDefinitions.definitions.instanceMethods,
                      propName
                    )
                  ) {
                    var _builtIn =
                      _builtInDefinitions.definitions.instanceMethods[propName];

                    if (instanceType) {
                      _builtIn = _builtIn.filter(function(item) {
                        return item.includes(instanceType);
                      });
                    }

                    addUnsupported(
                      path,
                      state.opts.polyfills,
                      _builtIn,
                      this.builtIns
                    );
                  }
                },
                exit: function exit(path, state) {
                  if (!path.isReferenced()) return;
                  var node = path.node;
                  var obj = node.object;
                  if (!has(_builtInDefinitions.definitions.builtins, obj.name))
                    return;
                  if (path.scope.getBindingIdentifier(obj.name)) return;
                  var builtIn =
                    _builtInDefinitions.definitions.builtins[obj.name];
                  addUnsupported(
                    path,
                    state.opts.polyfills,
                    builtIn,
                    this.builtIns
                  );
                },
              },
              VariableDeclarator: function VariableDeclarator(path, state) {
                if (!path.isReferenced()) return;
                var node = path.node;
                var obj = node.init;
                if (!t.isObjectPattern(node.id)) return;
                if (!t.isReferenced(obj, node)) return;
                if (obj && path.scope.getBindingIdentifier(obj.name)) return;

                for (
                  var _iterator2 = node.id.properties,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : _iterator2[Symbol.iterator]();
                  ;

                ) {
                  var _ref3;

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref3 = _iterator2[_i2++];
                  } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref3 = _i2.value;
                  }

                  var prop = _ref3;
                  prop = prop.key;

                  if (
                    !node.computed &&
                    t.isIdentifier(prop) &&
                    has(
                      _builtInDefinitions.definitions.instanceMethods,
                      prop.name
                    )
                  ) {
                    var builtIn =
                      _builtInDefinitions.definitions.instanceMethods[
                        prop.name
                      ];
                    addUnsupported(
                      path,
                      state.opts.polyfills,
                      builtIn,
                      this.builtIns
                    );
                  }
                }
              },
              Function: function Function(path, state) {
                if (
                  !this.usesRegenerator &&
                  (path.node.generator || path.node.async)
                ) {
                  this.usesRegenerator = true;

                  if (state.opts.regenerator) {
                    addImport(path, "regenerator-runtime", this.builtIns);
                  }
                }
              },
            };
            return {
              name: "use-built-ins",
              pre: function pre() {
                this.builtIns = new Set();
                this.usesRegenerator = false;
              },
              post: function post() {
                var _this$opts = this.opts,
                  debug = _this$opts.debug,
                  onDebug = _this$opts.onDebug;

                if (debug) {
                  (0, _debug.logUsagePolyfills)(
                    this.builtIns,
                    this.file.opts.filename,
                    onDebug
                  );
                }
              },
              visitor: addAndRemovePolyfillImports,
            };
          }
        },
        /* 315 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.definitions = void 0;
          var ArrayNatureIterators = [
            "es6.object.to-string",
            "es6.array.iterator",
            "web.dom.iterable",
          ];
          var CommonIterators = ["es6.string.iterator"].concat(
            ArrayNatureIterators
          );
          var definitions = {
            builtins: {
              DataView: "es6.typed.data-view",
              Float32Array: "es6.typed.float32-array",
              Float64Array: "es6.typed.float64-array",
              Int8Array: "es6.typed.int8-array",
              Int16Array: "es6.typed.int16-array",
              Int32Array: "es6.typed.int32-array",
              Map: ["es6.map"].concat(CommonIterators),
              Number: "es6.number.constructor",
              Promise: ["es6.object.to-string", "es6.promise"],
              RegExp: ["es6.regexp.constructor"],
              Set: ["es6.set"].concat(CommonIterators),
              Symbol: ["es6.symbol", "es7.symbol.async-iterator"],
              Uint8Array: "es6.typed.uint8-array",
              Uint8ClampedArray: "es6.typed.uint8-clamped-array",
              Uint16Array: "es6.typed.uint16-array",
              Uint32Array: "es6.typed.uint32-array",
              WeakMap: ["es6.weak-map"].concat(CommonIterators),
              WeakSet: ["es6.weak-set"].concat(CommonIterators),
            },
            instanceMethods: {
              __defineGetter__: ["es7.object.define-getter"],
              __defineSetter__: ["es7.object.define-setter"],
              __lookupGetter__: ["es7.object.lookup-getter"],
              __lookupSetter__: ["es7.object.lookup-setter"],
              anchor: ["es6.string.anchor"],
              big: ["es6.string.big"],
              bind: ["es6.function.bind"],
              blink: ["es6.string.blink"],
              bold: ["es6.string.bold"],
              codePointAt: ["es6.string.code-point-at"],
              copyWithin: ["es6.array.copy-within"],
              endsWith: ["es6.string.ends-with"],
              entries: ArrayNatureIterators,
              every: ["es6.array.is-array"],
              fill: ["es6.array.fill"],
              filter: ["es6.array.filter"],
              finally: ["es7.promise.finally"],
              find: ["es6.array.find"],
              findIndex: ["es6.array.find-index"],
              fixed: ["es6.string.fixed"],
              flags: ["es6.regexp.flags"],
              fontcolor: ["es6.string.fontcolor"],
              fontsize: ["es6.string.fontsize"],
              forEach: ["es6.array.for-each", "web.dom.iterable"],
              includes: ["es6.string.includes", "es7.array.includes"],
              indexOf: ["es6.array.index-of"],
              italics: ["es6.string.italics"],
              keys: ArrayNatureIterators,
              lastIndexOf: ["es6.array.last-index-of"],
              link: ["es6.string.link"],
              map: ["es6.array.map"],
              match: ["es6.regexp.match"],
              name: ["es6.function.name"],
              padStart: ["es7.string.pad-start"],
              padEnd: ["es7.string.pad-end"],
              reduce: ["es6.array.reduce"],
              reduceRight: ["es6.array.reduce-right"],
              repeat: ["es6.string.repeat"],
              replace: ["es6.regexp.replace"],
              search: ["es6.regexp.search"],
              slice: ["es6.array.slice"],
              small: ["es6.string.small"],
              some: ["es6.array.some"],
              sort: ["es6.array.sort"],
              split: ["es6.regexp.split"],
              startsWith: ["es6.string.starts-with"],
              strike: ["es6.string.strike"],
              sub: ["es6.string.sub"],
              sup: ["es6.string.sup"],
              toISOString: ["es6.date.to-iso-string"],
              toJSON: ["es6.date.to-json"],
              toString: [
                "es6.object.to-string",
                "es6.date.to-string",
                "es6.regexp.to-string",
              ],
              trim: ["es6.string.trim"],
              values: ArrayNatureIterators,
            },
            staticMethods: {
              Array: {
                from: ["es6.array.from", "es6.string.iterator"],
                isArray: "es6.array.is-array",
                of: "es6.array.of",
              },
              Date: {
                now: "es6.date.now",
              },
              Object: {
                assign: "es6.object.assign",
                create: "es6.object.create",
                defineProperty: "es6.object.define-property",
                defineProperties: "es6.object.define-properties",
                entries: "es7.object.entries",
                freeze: "es6.object.freeze",
                getOwnPropertyDescriptors:
                  "es7.object.get-own-property-descriptors",
                getOwnPropertySymbols: "es6.object.get-own-property-symbols",
                is: "es6.object.is",
                isExtensible: "es6.object.is-extensible",
                isFrozen: "es6.object.is-frozen",
                isSealed: "es6.object.is-sealed",
                keys: "es6.object.keys",
                preventExtensions: "es6.object.prevent-extensions",
                seal: "es6.object.seal",
                setPrototypeOf: "es6.object.set-prototype-of",
                values: "es7.object.values",
              },
              Math: {
                acosh: "es6.math.acosh",
                asinh: "es6.math.asinh",
                atanh: "es6.math.atanh",
                cbrt: "es6.math.cbrt",
                clz32: "es6.math.clz32",
                cosh: "es6.math.cosh",
                expm1: "es6.math.expm1",
                fround: "es6.math.fround",
                hypot: "es6.math.hypot",
                imul: "es6.math.imul",
                log1p: "es6.math.log1p",
                log10: "es6.math.log10",
                log2: "es6.math.log2",
                sign: "es6.math.sign",
                sinh: "es6.math.sinh",
                tanh: "es6.math.tanh",
                trunc: "es6.math.trunc",
              },
              String: {
                fromCodePoint: "es6.string.from-code-point",
                raw: "es6.string.raw",
              },
              Number: {
                EPSILON: "es6.number.epsilon",
                MIN_SAFE_INTEGER: "es6.number.min-safe-integer",
                MAX_SAFE_INTEGER: "es6.number.max-safe-integer",
                isFinite: "es6.number.is-finite",
                isInteger: "es6.number.is-integer",
                isSafeInteger: "es6.number.is-safe-integer",
                isNaN: "es6.number.is-nan",
                parseFloat: "es6.number.parse-float",
                parseInt: "es6.number.parse-int",
              },
              Promise: {
                all: CommonIterators,
                race: CommonIterators,
              },
              Reflect: {
                apply: "es6.reflect.apply",
                construct: "es6.reflect.construct",
                defineProperty: "es6.reflect.define-property",
                deleteProperty: "es6.reflect.delete-property",
                get: "es6.reflect.get",
                getOwnPropertyDescriptor:
                  "es6.reflect.get-own-property-descriptor",
                getPrototypeOf: "es6.reflect.get-prototype-of",
                has: "es6.reflect.has",
                isExtensible: "es6.reflect.is-extensible",
                ownKeys: "es6.reflect.own-keys",
                preventExtensions: "es6.reflect.prevent-extensions",
                set: "es6.reflect.set",
                setPrototypeOf: "es6.reflect.set-prototype-of",
              },
            },
          };
          exports.definitions = definitions;
        },
        /* 316 */
        function(module, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _gerhobbelt_babel_standalone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            22
          );
          /* harmony import */ var _gerhobbelt_babel_standalone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
            _gerhobbelt_babel_standalone__WEBPACK_IMPORTED_MODULE_0__
          );

          var notIncludedPlugins = {
            "transform-new-target": __webpack_require__(317),
            "proposal-json-strings": __webpack_require__(454),
          };
          Object.keys(notIncludedPlugins).forEach(function(pluginName) {
            if (
              !_gerhobbelt_babel_standalone__WEBPACK_IMPORTED_MODULE_0__[
                "availablePlugins"
              ][pluginName]
            ) {
              Object(
                _gerhobbelt_babel_standalone__WEBPACK_IMPORTED_MODULE_0__[
                  "registerPlugin"
                ]
              )(pluginName, notIncludedPlugins[pluginName]);
            }
          });
          /* harmony default export */ __webpack_exports__["default"] =
            _gerhobbelt_babel_standalone__WEBPACK_IMPORTED_MODULE_0__[
              "availablePlugins"
            ];
        },
        /* 317 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function _babelHelperPluginUtils() {
            var data = __webpack_require__(41);

            _babelHelperPluginUtils = function _babelHelperPluginUtils() {
              return data;
            };

            return data;
          }

          function _babelCore() {
            var data = __webpack_require__(72);

            _babelCore = function _babelCore() {
              return data;
            };

            return data;
          }

          var _default = (0, _babelHelperPluginUtils().declare)(function(api) {
            api.assertVersion(7);
            return {
              name: "transform-new-target",
              visitor: {
                MetaProperty: function MetaProperty(path) {
                  var meta = path.get("meta");
                  var property = path.get("property");
                  var scope = path.scope;

                  if (
                    meta.isIdentifier({
                      name: "new",
                    }) &&
                    property.isIdentifier({
                      name: "target",
                    })
                  ) {
                    var func = path.findParent(function(path) {
                      if (path.isClass()) return true;

                      if (
                        path.isFunction() &&
                        !path.isArrowFunctionExpression()
                      ) {
                        if (
                          path.isClassMethod({
                            kind: "constructor",
                          })
                        ) {
                          return false;
                        }

                        return true;
                      }

                      return false;
                    });

                    if (!func) {
                      throw path.buildCodeFrameError(
                        "new.target must be under a (non-arrow) function or a class."
                      );
                    }

                    var node = func.node;

                    if (!node.id) {
                      if (func.isMethod()) {
                        path.replaceWith(scope.buildUndefinedNode());
                        return;
                      }

                      node.id = scope.generateUidIdentifier("target");
                    }

                    var _constructor = _babelCore().types.memberExpression(
                      _babelCore().types.thisExpression(),
                      _babelCore().types.identifier("constructor")
                    );

                    if (func.isClass()) {
                      path.replaceWith(_constructor);
                      return;
                    }

                    path.replaceWith(
                      _babelCore().types.conditionalExpression(
                        _babelCore().types.binaryExpression(
                          "instanceof",
                          _babelCore().types.thisExpression(),
                          _babelCore().types.cloneNode(node.id)
                        ),
                        _constructor,
                        scope.buildUndefinedNode()
                      )
                    );
                  }
                },
              },
            };
          });

          exports.default = _default;
        },
        /* 318 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          var _path = _interopRequireDefault(__webpack_require__(21));

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var testing = "development" === "test";

          var TraversalContext = (function() {
            function TraversalContext(scope, opts, state, parentPath) {
              this.queue = null;
              this.parentPath = parentPath;
              this.scope = scope;
              this.state = state;
              this.opts = opts;
            }

            var _proto = TraversalContext.prototype;

            _proto.shouldVisit = function shouldVisit(node) {
              var opts = this.opts;
              if (opts.enter || opts.exit) return true;
              if (opts[node.type]) return true;
              var keys = t().VISITOR_KEYS[node.type];
              if (!keys || !keys.length) return false;

              for (
                var _iterator = keys,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var key = _ref;
                if (node[key]) return true;
              }

              return false;
            };

            _proto.create = function create(node, obj, key, listKey) {
              return _path.default.get({
                parentPath: this.parentPath,
                parent: node,
                container: obj,
                key: key,
                listKey: listKey,
              });
            };

            _proto.maybeQueue = function maybeQueue(path, notPriority) {
              if (this.trap) {
                throw new Error("Infinite cycle detected");
              }

              if (this.queue) {
                if (notPriority) {
                  this.queue.push(path);
                } else {
                  this.priorityQueue.push(path);
                }
              }
            };

            _proto.visitMultiple = function visitMultiple(
              container,
              parent,
              listKey
            ) {
              if (container.length === 0) return false;
              var queue = [];

              for (var key = 0; key < container.length; key++) {
                var node = container[key];

                if (node && this.shouldVisit(node)) {
                  queue.push(this.create(parent, container, key, listKey));
                }
              }

              return this.visitQueue(queue);
            };

            _proto.visitSingle = function visitSingle(node, key) {
              if (this.shouldVisit(node[key])) {
                return this.visitQueue([this.create(node, node, key)]);
              } else {
                return false;
              }
            };

            _proto.visitQueue = function visitQueue(queue) {
              this.queue = queue;
              this.priorityQueue = [];
              var visited = [];
              var stop = false;

              for (
                var _iterator2 = queue,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : _iterator2[Symbol.iterator]();
                ;

              ) {
                var _ref2;

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break;
                  _ref2 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done) break;
                  _ref2 = _i2.value;
                }

                var path = _ref2;
                path.resync();

                if (
                  path.contexts.length === 0 ||
                  path.contexts[path.contexts.length - 1] !== this
                ) {
                  path.pushContext(this);
                }

                if (path.key === null) continue;

                if (testing && queue.length >= 10000) {
                  this.trap = true;
                }

                if (visited.indexOf(path.node) >= 0) continue;
                visited.push(path.node);

                if (path.visit()) {
                  stop = true;
                  break;
                }

                if (this.priorityQueue.length) {
                  stop = this.visitQueue(this.priorityQueue);
                  this.priorityQueue = [];
                  this.queue = queue;
                  if (stop) break;
                }
              }

              for (
                var _iterator3 = queue,
                  _isArray3 = Array.isArray(_iterator3),
                  _i3 = 0,
                  _iterator3 = _isArray3
                    ? _iterator3
                    : _iterator3[Symbol.iterator]();
                ;

              ) {
                var _ref3;

                if (_isArray3) {
                  if (_i3 >= _iterator3.length) break;
                  _ref3 = _iterator3[_i3++];
                } else {
                  _i3 = _iterator3.next();
                  if (_i3.done) break;
                  _ref3 = _i3.value;
                }

                var _path2 = _ref3;

                _path2.popContext();
              }

              this.queue = null;
              return stop;
            };

            _proto.visit = function visit(node, key) {
              var nodes = node[key];
              if (!nodes) return false;

              if (Array.isArray(nodes)) {
                return this.visitMultiple(nodes, node, key);
              } else {
                return this.visitSingle(node, key);
              }
            };

            return TraversalContext;
          })();

          exports.default = TraversalContext;
        },
        /* 319 */
        function(module, exports, __webpack_require__) {
          /* WEBPACK VAR INJECTION */ (function(process) {
            exports = module.exports = __webpack_require__(320);
            exports.log = log;
            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.storage =
              "undefined" != typeof chrome &&
              "undefined" != typeof chrome.storage
                ? chrome.storage.local
                : localstorage();
            exports.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33",
            ];

            function useColors() {
              if (
                typeof window !== "undefined" &&
                window.process &&
                window.process.type === "renderer"
              ) {
                return true;
              }

              if (
                typeof navigator !== "undefined" &&
                navigator.userAgent &&
                navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
              ) {
                return false;
              }

              return (
                (typeof document !== "undefined" &&
                  document.documentElement &&
                  document.documentElement.style &&
                  document.documentElement.style.WebkitAppearance) ||
                (typeof window !== "undefined" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
              );
            }

            exports.formatters.j = function(v) {
              try {
                return JSON.stringify(v);
              } catch (err) {
                return "[UnexpectedJSONParseError]: " + err.message;
              }
            };

            function formatArgs(args) {
              var useColors = this.useColors;
              args[0] =
                (useColors ? "%c" : "") +
                this.namespace +
                (useColors ? " %c" : " ") +
                args[0] +
                (useColors ? "%c " : " ") +
                "+" +
                exports.humanize(this.diff);
              if (!useColors) return;
              var c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");
              var index = 0;
              var lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, function(match) {
                if ("%%" === match) return;
                index++;

                if ("%c" === match) {
                  lastC = index;
                }
              });
              args.splice(lastC, 0, c);
            }

            function log() {
              return (
                "object" === typeof console &&
                console.log &&
                Function.prototype.apply.call(console.log, console, arguments)
              );
            }

            function save(namespaces) {
              try {
                if (null == namespaces) {
                  exports.storage.removeItem("debug");
                } else {
                  exports.storage.debug = namespaces;
                }
              } catch (e) {}
            }

            function load() {
              var r;

              try {
                r = exports.storage.debug;
              } catch (e) {}

              if (!r && typeof process !== "undefined" && "env" in process) {
                r = undefined;
              }

              return r;
            }

            exports.enable(load());

            function localstorage() {
              try {
                return window.localStorage;
              } catch (e) {}
            }
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(3)));
        },
        /* 320 */
        function(module, exports, __webpack_require__) {
          exports = module.exports = createDebug.debug = createDebug[
            "default"
          ] = createDebug;
          exports.coerce = coerce;
          exports.disable = disable;
          exports.enable = enable;
          exports.enabled = enabled;
          exports.humanize = __webpack_require__(136);
          exports.instances = [];
          exports.names = [];
          exports.skips = [];
          exports.formatters = {};

          function selectColor(namespace) {
            var hash = 0,
              i;

            for (i in namespace) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }

            return exports.colors[Math.abs(hash) % exports.colors.length];
          }

          function createDebug(namespace) {
            var prevTime;

            function debug() {
              if (!debug.enabled) return;
              var self = debug;
              var curr = +new Date();
              var ms = curr - (prevTime || curr);
              self.diff = ms;
              self.prev = prevTime;
              self.curr = curr;
              prevTime = curr;
              var args = new Array(arguments.length);

              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i];
              }

              args[0] = exports.coerce(args[0]);

              if ("string" !== typeof args[0]) {
                args.unshift("%O");
              }

              var index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, function(
                match,
                format
              ) {
                if (match === "%%") return match;
                index++;
                var formatter = exports.formatters[format];

                if ("function" === typeof formatter) {
                  var val = args[index];
                  match = formatter.call(self, val);
                  args.splice(index, 1);
                  index--;
                }

                return match;
              });
              exports.formatArgs.call(self, args);
              var logFn = debug.log || exports.log || console.log.bind(console);
              logFn.apply(self, args);
            }

            debug.namespace = namespace;
            debug.enabled = exports.enabled(namespace);
            debug.useColors = exports.useColors();
            debug.color = selectColor(namespace);
            debug.destroy = destroy;

            if ("function" === typeof exports.init) {
              exports.init(debug);
            }

            exports.instances.push(debug);
            return debug;
          }

          function destroy() {
            var index = exports.instances.indexOf(this);

            if (index !== -1) {
              exports.instances.splice(index, 1);
              return true;
            } else {
              return false;
            }
          }

          function enable(namespaces) {
            exports.save(namespaces);
            exports.names = [];
            exports.skips = [];
            var i;
            var split = (typeof namespaces === "string"
              ? namespaces
              : ""
            ).split(/[\s,]+/);
            var len = split.length;

            for (i = 0; i < len; i++) {
              if (!split[i]) continue;
              namespaces = split[i].replace(/\*/g, ".*?");

              if (namespaces[0] === "-") {
                exports.skips.push(
                  new RegExp("^" + namespaces.substr(1) + "$")
                );
              } else {
                exports.names.push(new RegExp("^" + namespaces + "$"));
              }
            }

            for (i = 0; i < exports.instances.length; i++) {
              var instance = exports.instances[i];
              instance.enabled = exports.enabled(instance.namespace);
            }
          }

          function disable() {
            exports.enable("");
          }

          function enabled(name) {
            if (name[name.length - 1] === "*") {
              return true;
            }

            var i, len;

            for (i = 0, len = exports.skips.length; i < len; i++) {
              if (exports.skips[i].test(name)) {
                return false;
              }
            }

            for (i = 0, len = exports.names.length; i < len; i++) {
              if (exports.names[i].test(name)) {
                return true;
              }
            }

            return false;
          }

          function coerce(val) {
            if (val instanceof Error) return val.stack || val.message;
            return val;
          }
        },
        /* 321 */
        function(module, exports, __webpack_require__) {
          var baseGetTag = __webpack_require__(10),
            isArray = __webpack_require__(5),
            isObjectLike = __webpack_require__(7);

          var stringTag = "[object String]";

          function isString(value) {
            return (
              typeof value == "string" ||
              (!isArray(value) &&
                isObjectLike(value) &&
                baseGetTag(value) == stringTag)
            );
          }

          module.exports = isString;
        },
        /* 322 */
        function(module, exports, __webpack_require__) {
          var toNumber = __webpack_require__(323);

          var INFINITY = 1 / 0,
            MAX_INTEGER = 1.7976931348623157e308;

          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }

            value = toNumber(value);

            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }

            return value === value ? value : 0;
          }

          module.exports = toFinite;
        },
        /* 323 */
        function(module, exports, __webpack_require__) {
          var isObject = __webpack_require__(11),
            isSymbol = __webpack_require__(29);

          var NAN = 0 / 0;
          var reTrim = /^\s+|\s+$/g;
          var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
          var reIsBinary = /^0b[01]+$/i;
          var reIsOctal = /^0o[0-7]+$/i;
          var freeParseInt = parseInt;

          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }

            if (isSymbol(value)) {
              return NAN;
            }

            if (isObject(value)) {
              var other =
                typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }

            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }

            value = value.replace(reTrim, "");
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value)
              ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
              : reIsBadHex.test(value)
                ? NAN
                : +value;
          }

          module.exports = toNumber;
        },
        /* 324 */
        function(module, exports, __webpack_require__) {
          var baseValues = __webpack_require__(325),
            keys = __webpack_require__(19);

          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }

          module.exports = values;
        },
        /* 325 */
        function(module, exports, __webpack_require__) {
          var arrayMap = __webpack_require__(75);

          function baseValues(object, props) {
            return arrayMap(props, function(key) {
              return object[key];
            });
          }

          module.exports = baseValues;
        },
        /* 326 */
        function(module, exports) {
          var MAX_SAFE_INTEGER = 9007199254740991;
          var nativeFloor = Math.floor;

          function baseRepeat(string, n) {
            var result = "";

            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result;
            }

            do {
              if (n % 2) {
                result += string;
              }

              n = nativeFloor(n / 2);

              if (n) {
                string += string;
              }
            } while (n);

            return result;
          }

          module.exports = baseRepeat;
        },
        /* 327 */
        function(module, exports, __webpack_require__) {
          var Symbol = __webpack_require__(18),
            arrayMap = __webpack_require__(75),
            isArray = __webpack_require__(5),
            isSymbol = __webpack_require__(29);

          var INFINITY = 1 / 0;
          var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolToString = symbolProto ? symbolProto.toString : undefined;

          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }

            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }

            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }

            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }

          module.exports = baseToString;
        },
        /* 328 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          var _binding = _interopRequireDefault(__webpack_require__(139));

          function _babelHelperSplitExportDeclaration() {
            var data = _interopRequireDefault(__webpack_require__(329));

            _babelHelperSplitExportDeclaration = function _babelHelperSplitExportDeclaration() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var renameVisitor = {
            ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
              var node = _ref.node;

              if (node.name === state.oldName) {
                node.name = state.newName;
              }
            },
            Scope: function Scope(path, state) {
              if (
                !path.scope.bindingIdentifierEquals(
                  state.oldName,
                  state.binding.identifier
                )
              ) {
                path.skip();
              }
            },
            "AssignmentExpression|Declaration": function AssignmentExpressionDeclaration(
              path,
              state
            ) {
              var ids = path.getOuterBindingIdentifiers();

              for (var name in ids) {
                if (name === state.oldName) ids[name].name = state.newName;
              }
            },
          };

          var Renamer = (function() {
            function Renamer(binding, oldName, newName) {
              this.newName = newName;
              this.oldName = oldName;
              this.binding = binding;
            }

            var _proto = Renamer.prototype;

            _proto.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(
              parentDeclar
            ) {
              var maybeExportDeclar = parentDeclar.parentPath;

              if (!maybeExportDeclar.isExportDeclaration()) {
                return;
              }

              if (
                maybeExportDeclar.isExportDefaultDeclaration() &&
                !maybeExportDeclar.get("declaration").node.id
              ) {
                return;
              }

              (0, _babelHelperSplitExportDeclaration().default)(
                maybeExportDeclar
              );
            };

            _proto.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(
              path
            ) {
              return;
              if (!path.isFunctionDeclaration() && !path.isClassDeclaration())
                return;
              if (this.binding.kind !== "hoisted") return;
              path.node.id = t().identifier(this.oldName);
              path.node._blockHoist = 3;
              path.replaceWith(
                t().variableDeclaration("let", [
                  t().variableDeclarator(
                    t().identifier(this.newName),
                    t().toExpression(path.node)
                  ),
                ])
              );
            };

            _proto.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(
              path
            ) {
              return;
              if (!path.isFunctionExpression() && !path.isClassExpression())
                return;
              if (this.binding.kind !== "local") return;
              path.node.id = t().identifier(this.oldName);
              this.binding.scope.parent.push({
                id: t().identifier(this.newName),
              });
              path.replaceWith(
                t().assignmentExpression(
                  "=",
                  t().identifier(this.newName),
                  path.node
                )
              );
            };

            _proto.rename = function rename(block) {
              var binding = this.binding,
                oldName = this.oldName,
                newName = this.newName;
              var scope = binding.scope,
                path = binding.path;
              var parentDeclar = path.find(function(path) {
                return (
                  path.isDeclaration() ||
                  path.isFunctionExpression() ||
                  path.isClassExpression()
                );
              });

              if (parentDeclar) {
                var bindingIds = parentDeclar.getOuterBindingIdentifiers();

                if (bindingIds[oldName] === binding.identifier) {
                  this.maybeConvertFromExportDeclaration(parentDeclar);
                }
              }

              scope.traverse(block || scope.block, renameVisitor, this);

              if (!block) {
                scope.removeOwnBinding(oldName);
                scope.bindings[newName] = binding;
                this.binding.identifier.name = newName;
              }

              if (binding.type === "hoisted") {
              }

              if (parentDeclar) {
                this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
                this.maybeConvertFromClassFunctionExpression(parentDeclar);
              }
            };

            return Renamer;
          })();

          exports.default = Renamer;
        },
        /* 329 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = splitExportDeclaration;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function splitExportDeclaration(exportDeclaration) {
            if (!exportDeclaration.isExportDeclaration()) {
              throw new Error("Only export declarations can be splitted.");
            }

            var isDefault = exportDeclaration.isExportDefaultDeclaration();
            var declaration = exportDeclaration.get("declaration");
            var isClassDeclaration = declaration.isClassDeclaration();

            if (isDefault) {
              var standaloneDeclaration =
                declaration.isFunctionDeclaration() || isClassDeclaration;
              var scope = declaration.isScope()
                ? declaration.scope.parent
                : declaration.scope;
              var id = declaration.node.id;
              var needBindingRegistration = false;

              if (!id) {
                needBindingRegistration = true;
                id = scope.generateUidIdentifier("default");

                if (
                  standaloneDeclaration ||
                  declaration.isFunctionExpression() ||
                  declaration.isClassExpression()
                ) {
                  declaration.node.id = t().cloneNode(id);
                }
              }

              var updatedDeclaration = standaloneDeclaration
                ? declaration
                : t().variableDeclaration("var", [
                    t().variableDeclarator(t().cloneNode(id), declaration.node),
                  ]);
              var updatedExportDeclaration = t().exportNamedDeclaration(null, [
                t().exportSpecifier(
                  t().cloneNode(id),
                  t().identifier("default")
                ),
              ]);
              exportDeclaration.insertAfter(updatedExportDeclaration);
              exportDeclaration.replaceWith(updatedDeclaration);

              if (needBindingRegistration) {
                scope.registerBinding(
                  isClassDeclaration ? "let" : "var",
                  exportDeclaration
                );
              }

              return exportDeclaration;
            }

            if (exportDeclaration.get("specifiers").length > 0) {
              throw new Error(
                "It doesn't make sense to split exported specifiers."
              );
            }

            var bindingIdentifiers = declaration.getOuterBindingIdentifiers();
            var specifiers = Object.keys(bindingIdentifiers).map(function(
              name
            ) {
              return t().exportSpecifier(
                t().identifier(name),
                t().identifier(name)
              );
            });
            var aliasDeclar = t().exportNamedDeclaration(null, specifiers);
            exportDeclaration.insertAfter(aliasDeclar);
            exportDeclaration.replaceWith(declaration.node);
            return exportDeclaration;
          }
        },
        /* 330 */
        function(module, exports, __webpack_require__) {
          var baseRest = __webpack_require__(140),
            eq = __webpack_require__(25),
            isIterateeCall = __webpack_require__(76),
            keysIn = __webpack_require__(60);

          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var defaults = baseRest(function(object, sources) {
            object = Object(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined;

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }

            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;

              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];

                if (
                  value === undefined ||
                  (eq(value, objectProto[key]) &&
                    !hasOwnProperty.call(object, key))
                ) {
                  object[key] = source[key];
                }
              }
            }

            return object;
          });
          module.exports = defaults;
        },
        /* 331 */
        function(module, exports, __webpack_require__) {
          var apply = __webpack_require__(332);

          var nativeMax = Math.max;

          function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function() {
              var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);

              while (++index < length) {
                array[index] = args[start + index];
              }

              index = -1;
              var otherArgs = Array(start + 1);

              while (++index < start) {
                otherArgs[index] = args[index];
              }

              otherArgs[start] = transform(array);
              return apply(func, this, otherArgs);
            };
          }

          module.exports = overRest;
        },
        /* 332 */
        function(module, exports) {
          function apply(func, thisArg, args) {
            switch (args.length) {
              case 0:
                return func.call(thisArg);

              case 1:
                return func.call(thisArg, args[0]);

              case 2:
                return func.call(thisArg, args[0], args[1]);

              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
            }

            return func.apply(thisArg, args);
          }

          module.exports = apply;
        },
        /* 333 */
        function(module, exports, __webpack_require__) {
          var baseSetToString = __webpack_require__(334),
            shortOut = __webpack_require__(336);

          var setToString = shortOut(baseSetToString);
          module.exports = setToString;
        },
        /* 334 */
        function(module, exports, __webpack_require__) {
          var constant = __webpack_require__(335),
            defineProperty = __webpack_require__(96),
            identity = __webpack_require__(42);

          var baseSetToString = !defineProperty
            ? identity
            : function(func, string) {
                return defineProperty(func, "toString", {
                  configurable: true,
                  enumerable: false,
                  value: constant(string),
                  writable: true,
                });
              };
          module.exports = baseSetToString;
        },
        /* 335 */
        function(module, exports) {
          function constant(value) {
            return function() {
              return value;
            };
          }

          module.exports = constant;
        },
        /* 336 */
        function(module, exports) {
          var HOT_COUNT = 800,
            HOT_SPAN = 16;
          var nativeNow = Date.now;

          function shortOut(func) {
            var count = 0,
              lastCalled = 0;
            return function() {
              var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;

              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }

              return func.apply(undefined, arguments);
            };
          }

          module.exports = shortOut;
        },
        /* 337 */
        function(module, exports, __webpack_require__) {
          "use strict";

          module.exports = __webpack_require__(338);
        },
        /* 338 */
        function(module) {
          module.exports = {
            builtin: {
              Array: false,
              ArrayBuffer: false,
              Atomics: false,
              BigInt: false,
              BigInt64Array: false,
              BigUint64Array: false,
              Boolean: false,
              constructor: false,
              DataView: false,
              Date: false,
              decodeURI: false,
              decodeURIComponent: false,
              encodeURI: false,
              encodeURIComponent: false,
              Error: false,
              escape: false,
              eval: false,
              EvalError: false,
              Float32Array: false,
              Float64Array: false,
              Function: false,
              hasOwnProperty: false,
              Infinity: false,
              Int16Array: false,
              Int32Array: false,
              Int8Array: false,
              isFinite: false,
              isNaN: false,
              isPrototypeOf: false,
              JSON: false,
              Map: false,
              Math: false,
              NaN: false,
              Number: false,
              Object: false,
              parseFloat: false,
              parseInt: false,
              Promise: false,
              propertyIsEnumerable: false,
              Proxy: false,
              RangeError: false,
              ReferenceError: false,
              Reflect: false,
              RegExp: false,
              Set: false,
              SharedArrayBuffer: false,
              String: false,
              Symbol: false,
              SyntaxError: false,
              toLocaleString: false,
              toString: false,
              TypeError: false,
              Uint16Array: false,
              Uint32Array: false,
              Uint8Array: false,
              Uint8ClampedArray: false,
              undefined: false,
              unescape: false,
              URIError: false,
              valueOf: false,
              WeakMap: false,
              WeakSet: false,
            },
            es5: {
              Array: false,
              Boolean: false,
              constructor: false,
              Date: false,
              decodeURI: false,
              decodeURIComponent: false,
              encodeURI: false,
              encodeURIComponent: false,
              Error: false,
              escape: false,
              eval: false,
              EvalError: false,
              Function: false,
              hasOwnProperty: false,
              Infinity: false,
              isFinite: false,
              isNaN: false,
              isPrototypeOf: false,
              JSON: false,
              Math: false,
              NaN: false,
              Number: false,
              Object: false,
              parseFloat: false,
              parseInt: false,
              propertyIsEnumerable: false,
              RangeError: false,
              ReferenceError: false,
              RegExp: false,
              String: false,
              SyntaxError: false,
              toLocaleString: false,
              toString: false,
              TypeError: false,
              undefined: false,
              unescape: false,
              URIError: false,
              valueOf: false,
            },
            es2015: {
              Array: false,
              ArrayBuffer: false,
              Boolean: false,
              constructor: false,
              DataView: false,
              Date: false,
              decodeURI: false,
              decodeURIComponent: false,
              encodeURI: false,
              encodeURIComponent: false,
              Error: false,
              escape: false,
              eval: false,
              EvalError: false,
              Float32Array: false,
              Float64Array: false,
              Function: false,
              hasOwnProperty: false,
              Infinity: false,
              Int16Array: false,
              Int32Array: false,
              Int8Array: false,
              isFinite: false,
              isNaN: false,
              isPrototypeOf: false,
              JSON: false,
              Map: false,
              Math: false,
              NaN: false,
              Number: false,
              Object: false,
              parseFloat: false,
              parseInt: false,
              Promise: false,
              propertyIsEnumerable: false,
              Proxy: false,
              RangeError: false,
              ReferenceError: false,
              Reflect: false,
              RegExp: false,
              Set: false,
              String: false,
              Symbol: false,
              SyntaxError: false,
              toLocaleString: false,
              toString: false,
              TypeError: false,
              Uint16Array: false,
              Uint32Array: false,
              Uint8Array: false,
              Uint8ClampedArray: false,
              undefined: false,
              unescape: false,
              URIError: false,
              valueOf: false,
              WeakMap: false,
              WeakSet: false,
            },
            es2017: {
              Array: false,
              ArrayBuffer: false,
              Atomics: false,
              Boolean: false,
              constructor: false,
              DataView: false,
              Date: false,
              decodeURI: false,
              decodeURIComponent: false,
              encodeURI: false,
              encodeURIComponent: false,
              Error: false,
              escape: false,
              eval: false,
              EvalError: false,
              Float32Array: false,
              Float64Array: false,
              Function: false,
              hasOwnProperty: false,
              Infinity: false,
              Int16Array: false,
              Int32Array: false,
              Int8Array: false,
              isFinite: false,
              isNaN: false,
              isPrototypeOf: false,
              JSON: false,
              Map: false,
              Math: false,
              NaN: false,
              Number: false,
              Object: false,
              parseFloat: false,
              parseInt: false,
              Promise: false,
              propertyIsEnumerable: false,
              Proxy: false,
              RangeError: false,
              ReferenceError: false,
              Reflect: false,
              RegExp: false,
              Set: false,
              SharedArrayBuffer: false,
              String: false,
              Symbol: false,
              SyntaxError: false,
              toLocaleString: false,
              toString: false,
              TypeError: false,
              Uint16Array: false,
              Uint32Array: false,
              Uint8Array: false,
              Uint8ClampedArray: false,
              undefined: false,
              unescape: false,
              URIError: false,
              valueOf: false,
              WeakMap: false,
              WeakSet: false,
            },
            browser: {
              AbortController: false,
              AbortSignal: false,
              addEventListener: false,
              alert: false,
              AnalyserNode: false,
              Animation: false,
              AnimationEffectReadOnly: false,
              AnimationEffectTiming: false,
              AnimationEffectTimingReadOnly: false,
              AnimationEvent: false,
              AnimationPlaybackEvent: false,
              AnimationTimeline: false,
              applicationCache: false,
              ApplicationCache: false,
              ApplicationCacheErrorEvent: false,
              atob: false,
              Attr: false,
              Audio: false,
              AudioBuffer: false,
              AudioBufferSourceNode: false,
              AudioContext: false,
              AudioDestinationNode: false,
              AudioListener: false,
              AudioNode: false,
              AudioParam: false,
              AudioProcessingEvent: false,
              AudioScheduledSourceNode: false,
              "AudioWorkletGlobalScope ": false,
              AudioWorkletNode: false,
              AudioWorkletProcessor: false,
              BarProp: false,
              BaseAudioContext: false,
              BatteryManager: false,
              BeforeUnloadEvent: false,
              BiquadFilterNode: false,
              Blob: false,
              BlobEvent: false,
              blur: false,
              BroadcastChannel: false,
              btoa: false,
              BudgetService: false,
              ByteLengthQueuingStrategy: false,
              Cache: false,
              caches: false,
              CacheStorage: false,
              cancelAnimationFrame: false,
              cancelIdleCallback: false,
              CanvasCaptureMediaStreamTrack: false,
              CanvasGradient: false,
              CanvasPattern: false,
              CanvasRenderingContext2D: false,
              ChannelMergerNode: false,
              ChannelSplitterNode: false,
              CharacterData: false,
              clearInterval: false,
              clearTimeout: false,
              clientInformation: false,
              ClipboardEvent: false,
              close: false,
              closed: false,
              CloseEvent: false,
              Comment: false,
              CompositionEvent: false,
              confirm: false,
              console: false,
              ConstantSourceNode: false,
              ConvolverNode: false,
              CountQueuingStrategy: false,
              createImageBitmap: false,
              Credential: false,
              CredentialsContainer: false,
              crypto: false,
              Crypto: false,
              CryptoKey: false,
              CSS: false,
              CSSConditionRule: false,
              CSSFontFaceRule: false,
              CSSGroupingRule: false,
              CSSImportRule: false,
              CSSKeyframeRule: false,
              CSSKeyframesRule: false,
              CSSMediaRule: false,
              CSSNamespaceRule: false,
              CSSPageRule: false,
              CSSRule: false,
              CSSRuleList: false,
              CSSStyleDeclaration: false,
              CSSStyleRule: false,
              CSSStyleSheet: false,
              CSSSupportsRule: false,
              CustomElementRegistry: false,
              customElements: false,
              CustomEvent: false,
              DataTransfer: false,
              DataTransferItem: false,
              DataTransferItemList: false,
              defaultstatus: false,
              defaultStatus: false,
              DelayNode: false,
              DeviceMotionEvent: false,
              DeviceOrientationEvent: false,
              devicePixelRatio: false,
              dispatchEvent: false,
              document: false,
              Document: false,
              DocumentFragment: false,
              DocumentType: false,
              DOMError: false,
              DOMException: false,
              DOMImplementation: false,
              DOMMatrix: false,
              DOMMatrixReadOnly: false,
              DOMParser: false,
              DOMPoint: false,
              DOMPointReadOnly: false,
              DOMQuad: false,
              DOMRect: false,
              DOMRectReadOnly: false,
              DOMStringList: false,
              DOMStringMap: false,
              DOMTokenList: false,
              DragEvent: false,
              DynamicsCompressorNode: false,
              Element: false,
              ErrorEvent: false,
              event: false,
              Event: false,
              EventSource: false,
              EventTarget: false,
              external: false,
              fetch: false,
              File: false,
              FileList: false,
              FileReader: false,
              find: false,
              focus: false,
              FocusEvent: false,
              FontFace: false,
              FontFaceSetLoadEvent: false,
              FormData: false,
              frameElement: false,
              frames: false,
              GainNode: false,
              Gamepad: false,
              GamepadButton: false,
              GamepadEvent: false,
              getComputedStyle: false,
              getSelection: false,
              HashChangeEvent: false,
              Headers: false,
              history: false,
              History: false,
              HTMLAllCollection: false,
              HTMLAnchorElement: false,
              HTMLAreaElement: false,
              HTMLAudioElement: false,
              HTMLBaseElement: false,
              HTMLBodyElement: false,
              HTMLBRElement: false,
              HTMLButtonElement: false,
              HTMLCanvasElement: false,
              HTMLCollection: false,
              HTMLContentElement: false,
              HTMLDataElement: false,
              HTMLDataListElement: false,
              HTMLDetailsElement: false,
              HTMLDialogElement: false,
              HTMLDirectoryElement: false,
              HTMLDivElement: false,
              HTMLDListElement: false,
              HTMLDocument: false,
              HTMLElement: false,
              HTMLEmbedElement: false,
              HTMLFieldSetElement: false,
              HTMLFontElement: false,
              HTMLFormControlsCollection: false,
              HTMLFormElement: false,
              HTMLFrameElement: false,
              HTMLFrameSetElement: false,
              HTMLHeadElement: false,
              HTMLHeadingElement: false,
              HTMLHRElement: false,
              HTMLHtmlElement: false,
              HTMLIFrameElement: false,
              HTMLImageElement: false,
              HTMLInputElement: false,
              HTMLLabelElement: false,
              HTMLLegendElement: false,
              HTMLLIElement: false,
              HTMLLinkElement: false,
              HTMLMapElement: false,
              HTMLMarqueeElement: false,
              HTMLMediaElement: false,
              HTMLMenuElement: false,
              HTMLMetaElement: false,
              HTMLMeterElement: false,
              HTMLModElement: false,
              HTMLObjectElement: false,
              HTMLOListElement: false,
              HTMLOptGroupElement: false,
              HTMLOptionElement: false,
              HTMLOptionsCollection: false,
              HTMLOutputElement: false,
              HTMLParagraphElement: false,
              HTMLParamElement: false,
              HTMLPictureElement: false,
              HTMLPreElement: false,
              HTMLProgressElement: false,
              HTMLQuoteElement: false,
              HTMLScriptElement: false,
              HTMLSelectElement: false,
              HTMLShadowElement: false,
              HTMLSlotElement: false,
              HTMLSourceElement: false,
              HTMLSpanElement: false,
              HTMLStyleElement: false,
              HTMLTableCaptionElement: false,
              HTMLTableCellElement: false,
              HTMLTableColElement: false,
              HTMLTableElement: false,
              HTMLTableRowElement: false,
              HTMLTableSectionElement: false,
              HTMLTemplateElement: false,
              HTMLTextAreaElement: false,
              HTMLTimeElement: false,
              HTMLTitleElement: false,
              HTMLTrackElement: false,
              HTMLUListElement: false,
              HTMLUnknownElement: false,
              HTMLVideoElement: false,
              IDBCursor: false,
              IDBCursorWithValue: false,
              IDBDatabase: false,
              IDBFactory: false,
              IDBIndex: false,
              IDBKeyRange: false,
              IDBObjectStore: false,
              IDBOpenDBRequest: false,
              IDBRequest: false,
              IDBTransaction: false,
              IDBVersionChangeEvent: false,
              IdleDeadline: false,
              IIRFilterNode: false,
              Image: false,
              ImageBitmap: false,
              ImageBitmapRenderingContext: false,
              ImageCapture: false,
              ImageData: false,
              indexedDB: false,
              innerHeight: false,
              innerWidth: false,
              InputEvent: false,
              IntersectionObserver: false,
              IntersectionObserverEntry: false,
              Intl: false,
              isSecureContext: false,
              KeyboardEvent: false,
              KeyframeEffect: false,
              KeyframeEffectReadOnly: false,
              length: false,
              localStorage: false,
              location: false,
              Location: false,
              locationbar: false,
              matchMedia: false,
              MediaDeviceInfo: false,
              MediaDevices: false,
              MediaElementAudioSourceNode: false,
              MediaEncryptedEvent: false,
              MediaError: false,
              MediaKeyMessageEvent: false,
              MediaKeySession: false,
              MediaKeyStatusMap: false,
              MediaKeySystemAccess: false,
              MediaList: false,
              MediaQueryList: false,
              MediaQueryListEvent: false,
              MediaRecorder: false,
              MediaSettingsRange: false,
              MediaSource: false,
              MediaStream: false,
              MediaStreamAudioDestinationNode: false,
              MediaStreamAudioSourceNode: false,
              MediaStreamEvent: false,
              MediaStreamTrack: false,
              MediaStreamTrackEvent: false,
              menubar: false,
              MessageChannel: false,
              MessageEvent: false,
              MessagePort: false,
              MIDIAccess: false,
              MIDIConnectionEvent: false,
              MIDIInput: false,
              MIDIInputMap: false,
              MIDIMessageEvent: false,
              MIDIOutput: false,
              MIDIOutputMap: false,
              MIDIPort: false,
              MimeType: false,
              MimeTypeArray: false,
              MouseEvent: false,
              moveBy: false,
              moveTo: false,
              MutationEvent: false,
              MutationObserver: false,
              MutationRecord: false,
              name: false,
              NamedNodeMap: false,
              NavigationPreloadManager: false,
              navigator: false,
              Navigator: false,
              NetworkInformation: false,
              Node: false,
              NodeFilter: false,
              NodeIterator: false,
              NodeList: false,
              Notification: false,
              OfflineAudioCompletionEvent: false,
              OfflineAudioContext: false,
              offscreenBuffering: false,
              OffscreenCanvas: true,
              onabort: true,
              onafterprint: true,
              onanimationend: true,
              onanimationiteration: true,
              onanimationstart: true,
              onappinstalled: true,
              onauxclick: true,
              onbeforeinstallprompt: true,
              onbeforeprint: true,
              onbeforeunload: true,
              onblur: true,
              oncancel: true,
              oncanplay: true,
              oncanplaythrough: true,
              onchange: true,
              onclick: true,
              onclose: true,
              oncontextmenu: true,
              oncuechange: true,
              ondblclick: true,
              ondevicemotion: true,
              ondeviceorientation: true,
              ondeviceorientationabsolute: true,
              ondrag: true,
              ondragend: true,
              ondragenter: true,
              ondragleave: true,
              ondragover: true,
              ondragstart: true,
              ondrop: true,
              ondurationchange: true,
              onemptied: true,
              onended: true,
              onerror: true,
              onfocus: true,
              ongotpointercapture: true,
              onhashchange: true,
              oninput: true,
              oninvalid: true,
              onkeydown: true,
              onkeypress: true,
              onkeyup: true,
              onlanguagechange: true,
              onload: true,
              onloadeddata: true,
              onloadedmetadata: true,
              onloadstart: true,
              onlostpointercapture: true,
              onmessage: true,
              onmessageerror: true,
              onmousedown: true,
              onmouseenter: true,
              onmouseleave: true,
              onmousemove: true,
              onmouseout: true,
              onmouseover: true,
              onmouseup: true,
              onmousewheel: true,
              onoffline: true,
              ononline: true,
              onpagehide: true,
              onpageshow: true,
              onpause: true,
              onplay: true,
              onplaying: true,
              onpointercancel: true,
              onpointerdown: true,
              onpointerenter: true,
              onpointerleave: true,
              onpointermove: true,
              onpointerout: true,
              onpointerover: true,
              onpointerup: true,
              onpopstate: true,
              onprogress: true,
              onratechange: true,
              onrejectionhandled: true,
              onreset: true,
              onresize: true,
              onscroll: true,
              onsearch: true,
              onseeked: true,
              onseeking: true,
              onselect: true,
              onstalled: true,
              onstorage: true,
              onsubmit: true,
              onsuspend: true,
              ontimeupdate: true,
              ontoggle: true,
              ontransitionend: true,
              onunhandledrejection: true,
              onunload: true,
              onvolumechange: true,
              onwaiting: true,
              onwheel: true,
              open: false,
              openDatabase: false,
              opener: false,
              Option: false,
              origin: false,
              OscillatorNode: false,
              outerHeight: false,
              outerWidth: false,
              PageTransitionEvent: false,
              pageXOffset: false,
              pageYOffset: false,
              PannerNode: false,
              parent: false,
              Path2D: false,
              PaymentAddress: false,
              PaymentRequest: false,
              PaymentRequestUpdateEvent: false,
              PaymentResponse: false,
              performance: false,
              Performance: false,
              PerformanceEntry: false,
              PerformanceLongTaskTiming: false,
              PerformanceMark: false,
              PerformanceMeasure: false,
              PerformanceNavigation: false,
              PerformanceNavigationTiming: false,
              PerformanceObserver: false,
              PerformanceObserverEntryList: false,
              PerformancePaintTiming: false,
              PerformanceResourceTiming: false,
              PerformanceTiming: false,
              PeriodicWave: false,
              Permissions: false,
              PermissionStatus: false,
              personalbar: false,
              PhotoCapabilities: false,
              Plugin: false,
              PluginArray: false,
              PointerEvent: false,
              PopStateEvent: false,
              postMessage: false,
              Presentation: false,
              PresentationAvailability: false,
              PresentationConnection: false,
              PresentationConnectionAvailableEvent: false,
              PresentationConnectionCloseEvent: false,
              PresentationConnectionList: false,
              PresentationReceiver: false,
              PresentationRequest: false,
              print: false,
              ProcessingInstruction: false,
              ProgressEvent: false,
              PromiseRejectionEvent: false,
              prompt: false,
              PushManager: false,
              PushSubscription: false,
              PushSubscriptionOptions: false,
              RadioNodeList: false,
              Range: false,
              ReadableStream: false,
              registerProcessor: false,
              RemotePlayback: false,
              removeEventListener: false,
              Request: false,
              requestAnimationFrame: false,
              requestIdleCallback: false,
              resizeBy: false,
              ResizeObserver: false,
              ResizeObserverEntry: false,
              resizeTo: false,
              Response: false,
              RTCCertificate: false,
              RTCDataChannel: false,
              RTCDataChannelEvent: false,
              RTCDtlsTransport: false,
              RTCIceCandidate: false,
              RTCIceGatherer: false,
              RTCIceTransport: false,
              RTCPeerConnection: false,
              RTCPeerConnectionIceEvent: false,
              RTCRtpContributingSource: false,
              RTCRtpReceiver: false,
              RTCRtpSender: false,
              RTCSctpTransport: false,
              RTCSessionDescription: false,
              RTCStatsReport: false,
              RTCTrackEvent: false,
              screen: false,
              Screen: false,
              screenLeft: false,
              ScreenOrientation: false,
              screenTop: false,
              screenX: false,
              screenY: false,
              ScriptProcessorNode: false,
              scroll: false,
              scrollbars: false,
              scrollBy: false,
              scrollTo: false,
              scrollX: false,
              scrollY: false,
              SecurityPolicyViolationEvent: false,
              Selection: false,
              self: false,
              ServiceWorker: false,
              ServiceWorkerContainer: false,
              ServiceWorkerRegistration: false,
              sessionStorage: false,
              setInterval: false,
              setTimeout: false,
              ShadowRoot: false,
              SharedWorker: false,
              SourceBuffer: false,
              SourceBufferList: false,
              speechSynthesis: false,
              SpeechSynthesisEvent: false,
              SpeechSynthesisUtterance: false,
              StaticRange: false,
              status: false,
              statusbar: false,
              StereoPannerNode: false,
              stop: false,
              Storage: false,
              StorageEvent: false,
              StorageManager: false,
              styleMedia: false,
              StyleSheet: false,
              StyleSheetList: false,
              SubtleCrypto: false,
              SVGAElement: false,
              SVGAngle: false,
              SVGAnimatedAngle: false,
              SVGAnimatedBoolean: false,
              SVGAnimatedEnumeration: false,
              SVGAnimatedInteger: false,
              SVGAnimatedLength: false,
              SVGAnimatedLengthList: false,
              SVGAnimatedNumber: false,
              SVGAnimatedNumberList: false,
              SVGAnimatedPreserveAspectRatio: false,
              SVGAnimatedRect: false,
              SVGAnimatedString: false,
              SVGAnimatedTransformList: false,
              SVGAnimateElement: false,
              SVGAnimateMotionElement: false,
              SVGAnimateTransformElement: false,
              SVGAnimationElement: false,
              SVGCircleElement: false,
              SVGClipPathElement: false,
              SVGComponentTransferFunctionElement: false,
              SVGDefsElement: false,
              SVGDescElement: false,
              SVGDiscardElement: false,
              SVGElement: false,
              SVGEllipseElement: false,
              SVGFEBlendElement: false,
              SVGFEColorMatrixElement: false,
              SVGFEComponentTransferElement: false,
              SVGFECompositeElement: false,
              SVGFEConvolveMatrixElement: false,
              SVGFEDiffuseLightingElement: false,
              SVGFEDisplacementMapElement: false,
              SVGFEDistantLightElement: false,
              SVGFEDropShadowElement: false,
              SVGFEFloodElement: false,
              SVGFEFuncAElement: false,
              SVGFEFuncBElement: false,
              SVGFEFuncGElement: false,
              SVGFEFuncRElement: false,
              SVGFEGaussianBlurElement: false,
              SVGFEImageElement: false,
              SVGFEMergeElement: false,
              SVGFEMergeNodeElement: false,
              SVGFEMorphologyElement: false,
              SVGFEOffsetElement: false,
              SVGFEPointLightElement: false,
              SVGFESpecularLightingElement: false,
              SVGFESpotLightElement: false,
              SVGFETileElement: false,
              SVGFETurbulenceElement: false,
              SVGFilterElement: false,
              SVGForeignObjectElement: false,
              SVGGElement: false,
              SVGGeometryElement: false,
              SVGGradientElement: false,
              SVGGraphicsElement: false,
              SVGImageElement: false,
              SVGLength: false,
              SVGLengthList: false,
              SVGLinearGradientElement: false,
              SVGLineElement: false,
              SVGMarkerElement: false,
              SVGMaskElement: false,
              SVGMatrix: false,
              SVGMetadataElement: false,
              SVGMPathElement: false,
              SVGNumber: false,
              SVGNumberList: false,
              SVGPathElement: false,
              SVGPatternElement: false,
              SVGPoint: false,
              SVGPointList: false,
              SVGPolygonElement: false,
              SVGPolylineElement: false,
              SVGPreserveAspectRatio: false,
              SVGRadialGradientElement: false,
              SVGRect: false,
              SVGRectElement: false,
              SVGScriptElement: false,
              SVGSetElement: false,
              SVGStopElement: false,
              SVGStringList: false,
              SVGStyleElement: false,
              SVGSVGElement: false,
              SVGSwitchElement: false,
              SVGSymbolElement: false,
              SVGTextContentElement: false,
              SVGTextElement: false,
              SVGTextPathElement: false,
              SVGTextPositioningElement: false,
              SVGTitleElement: false,
              SVGTransform: false,
              SVGTransformList: false,
              SVGTSpanElement: false,
              SVGUnitTypes: false,
              SVGUseElement: false,
              SVGViewElement: false,
              TaskAttributionTiming: false,
              Text: false,
              TextDecoder: false,
              TextEncoder: false,
              TextEvent: false,
              TextMetrics: false,
              TextTrack: false,
              TextTrackCue: false,
              TextTrackCueList: false,
              TextTrackList: false,
              TimeRanges: false,
              toolbar: false,
              top: false,
              Touch: false,
              TouchEvent: false,
              TouchList: false,
              TrackEvent: false,
              TransitionEvent: false,
              TreeWalker: false,
              UIEvent: false,
              URL: false,
              URLSearchParams: false,
              ValidityState: false,
              visualViewport: false,
              VisualViewport: false,
              VTTCue: false,
              WaveShaperNode: false,
              WebAssembly: false,
              WebGL2RenderingContext: false,
              WebGLActiveInfo: false,
              WebGLBuffer: false,
              WebGLContextEvent: false,
              WebGLFramebuffer: false,
              WebGLProgram: false,
              WebGLQuery: false,
              WebGLRenderbuffer: false,
              WebGLRenderingContext: false,
              WebGLSampler: false,
              WebGLShader: false,
              WebGLShaderPrecisionFormat: false,
              WebGLSync: false,
              WebGLTexture: false,
              WebGLTransformFeedback: false,
              WebGLUniformLocation: false,
              WebGLVertexArrayObject: false,
              WebSocket: false,
              WheelEvent: false,
              window: false,
              Window: false,
              Worker: false,
              WritableStream: false,
              XMLDocument: false,
              XMLHttpRequest: false,
              XMLHttpRequestEventTarget: false,
              XMLHttpRequestUpload: false,
              XMLSerializer: false,
              XPathEvaluator: false,
              XPathExpression: false,
              XPathResult: false,
              XSLTProcessor: false,
            },
            worker: {
              applicationCache: false,
              atob: false,
              Blob: false,
              BroadcastChannel: false,
              btoa: false,
              Cache: false,
              caches: false,
              clearInterval: false,
              clearTimeout: false,
              close: true,
              console: false,
              fetch: false,
              FileReaderSync: false,
              FormData: false,
              Headers: false,
              IDBCursor: false,
              IDBCursorWithValue: false,
              IDBDatabase: false,
              IDBFactory: false,
              IDBIndex: false,
              IDBKeyRange: false,
              IDBObjectStore: false,
              IDBOpenDBRequest: false,
              IDBRequest: false,
              IDBTransaction: false,
              IDBVersionChangeEvent: false,
              ImageData: false,
              importScripts: true,
              indexedDB: false,
              location: false,
              MessageChannel: false,
              MessagePort: false,
              name: false,
              navigator: false,
              Notification: false,
              onclose: true,
              onconnect: true,
              onerror: true,
              onlanguagechange: true,
              onmessage: true,
              onoffline: true,
              ononline: true,
              onrejectionhandled: true,
              onunhandledrejection: true,
              performance: false,
              Performance: false,
              PerformanceEntry: false,
              PerformanceMark: false,
              PerformanceMeasure: false,
              PerformanceNavigation: false,
              PerformanceResourceTiming: false,
              PerformanceTiming: false,
              postMessage: true,
              Promise: false,
              Request: false,
              Response: false,
              self: true,
              ServiceWorkerRegistration: false,
              setInterval: false,
              setTimeout: false,
              TextDecoder: false,
              TextEncoder: false,
              URL: false,
              URLSearchParams: false,
              WebSocket: false,
              Worker: false,
              XMLHttpRequest: false,
            },
            node: {
              __dirname: false,
              __filename: false,
              Buffer: false,
              clearImmediate: false,
              clearInterval: false,
              clearTimeout: false,
              console: false,
              exports: true,
              global: false,
              Intl: false,
              module: false,
              process: false,
              require: false,
              setImmediate: false,
              setInterval: false,
              setTimeout: false,
              URL: false,
              URLSearchParams: false,
            },
            commonjs: {
              exports: true,
              global: false,
              module: false,
              require: false,
            },
            amd: { define: false, require: false },
            mocha: {
              after: false,
              afterEach: false,
              before: false,
              beforeEach: false,
              context: false,
              describe: false,
              it: false,
              mocha: false,
              run: false,
              setup: false,
              specify: false,
              suite: false,
              suiteSetup: false,
              suiteTeardown: false,
              teardown: false,
              test: false,
              xcontext: false,
              xdescribe: false,
              xit: false,
              xspecify: false,
            },
            jasmine: {
              afterAll: false,
              afterEach: false,
              beforeAll: false,
              beforeEach: false,
              describe: false,
              expect: false,
              fail: false,
              fdescribe: false,
              fit: false,
              it: false,
              jasmine: false,
              pending: false,
              runs: false,
              spyOn: false,
              spyOnProperty: false,
              waits: false,
              waitsFor: false,
              xdescribe: false,
              xit: false,
            },
            jest: {
              afterAll: false,
              afterEach: false,
              beforeAll: false,
              beforeEach: false,
              describe: false,
              expect: false,
              fdescribe: false,
              fit: false,
              it: false,
              jest: false,
              pit: false,
              require: false,
              test: false,
              xdescribe: false,
              xit: false,
              xtest: false,
            },
            qunit: {
              asyncTest: false,
              deepEqual: false,
              equal: false,
              expect: false,
              module: false,
              notDeepEqual: false,
              notEqual: false,
              notOk: false,
              notPropEqual: false,
              notStrictEqual: false,
              ok: false,
              propEqual: false,
              QUnit: false,
              raises: false,
              start: false,
              stop: false,
              strictEqual: false,
              test: false,
              throws: false,
            },
            phantomjs: {
              console: true,
              exports: true,
              phantom: true,
              require: true,
              WebPage: true,
            },
            couch: {
              emit: false,
              exports: false,
              getRow: false,
              log: false,
              module: false,
              provides: false,
              require: false,
              respond: false,
              send: false,
              start: false,
              sum: false,
            },
            rhino: {
              defineClass: false,
              deserialize: false,
              gc: false,
              help: false,
              importClass: false,
              importPackage: false,
              java: false,
              load: false,
              loadClass: false,
              Packages: false,
              print: false,
              quit: false,
              readFile: false,
              readUrl: false,
              runCommand: false,
              seal: false,
              serialize: false,
              spawn: false,
              sync: false,
              toint32: false,
              version: false,
            },
            nashorn: {
              __DIR__: false,
              __FILE__: false,
              __LINE__: false,
              com: false,
              edu: false,
              exit: false,
              java: false,
              Java: false,
              javafx: false,
              JavaImporter: false,
              javax: false,
              JSAdapter: false,
              load: false,
              loadWithNewGlobal: false,
              org: false,
              Packages: false,
              print: false,
              quit: false,
            },
            wsh: {
              ActiveXObject: true,
              Enumerator: true,
              GetObject: true,
              ScriptEngine: true,
              ScriptEngineBuildVersion: true,
              ScriptEngineMajorVersion: true,
              ScriptEngineMinorVersion: true,
              VBArray: true,
              WScript: true,
              WSH: true,
              XDomainRequest: true,
            },
            jquery: { $: false, jQuery: false },
            yui: { Y: false, YUI: false, YUI_config: false },
            shelljs: {
              cat: false,
              cd: false,
              chmod: false,
              config: false,
              cp: false,
              dirs: false,
              echo: false,
              env: false,
              error: false,
              exec: false,
              exit: false,
              find: false,
              grep: false,
              ln: false,
              ls: false,
              mkdir: false,
              mv: false,
              popd: false,
              pushd: false,
              pwd: false,
              rm: false,
              sed: false,
              set: false,
              target: false,
              tempdir: false,
              test: false,
              touch: false,
              which: false,
            },
            prototypejs: {
              $: false,
              $$: false,
              $A: false,
              $break: false,
              $continue: false,
              $F: false,
              $H: false,
              $R: false,
              $w: false,
              Abstract: false,
              Ajax: false,
              Autocompleter: false,
              Builder: false,
              Class: false,
              Control: false,
              Draggable: false,
              Draggables: false,
              Droppables: false,
              Effect: false,
              Element: false,
              Enumerable: false,
              Event: false,
              Field: false,
              Form: false,
              Hash: false,
              Insertion: false,
              ObjectRange: false,
              PeriodicalExecuter: false,
              Position: false,
              Prototype: false,
              Scriptaculous: false,
              Selector: false,
              Sortable: false,
              SortableObserver: false,
              Sound: false,
              Template: false,
              Toggle: false,
              Try: false,
            },
            meteor: {
              _: false,
              $: false,
              Accounts: false,
              AccountsClient: false,
              AccountsCommon: false,
              AccountsServer: false,
              App: false,
              Assets: false,
              Blaze: false,
              check: false,
              Cordova: false,
              DDP: false,
              DDPRateLimiter: false,
              DDPServer: false,
              Deps: false,
              EJSON: false,
              Email: false,
              HTTP: false,
              Log: false,
              Match: false,
              Meteor: false,
              Mongo: false,
              MongoInternals: false,
              Npm: false,
              Package: false,
              Plugin: false,
              process: false,
              Random: false,
              ReactiveDict: false,
              ReactiveVar: false,
              Router: false,
              ServiceConfiguration: false,
              Session: false,
              share: false,
              Spacebars: false,
              Template: false,
              Tinytest: false,
              Tracker: false,
              UI: false,
              Utils: false,
              WebApp: false,
              WebAppInternals: false,
            },
            mongo: {
              _isWindows: false,
              _rand: false,
              BulkWriteResult: false,
              cat: false,
              cd: false,
              connect: false,
              db: false,
              getHostName: false,
              getMemInfo: false,
              hostname: false,
              ISODate: false,
              listFiles: false,
              load: false,
              ls: false,
              md5sumFile: false,
              mkdir: false,
              Mongo: false,
              NumberInt: false,
              NumberLong: false,
              ObjectId: false,
              PlanCache: false,
              print: false,
              printjson: false,
              pwd: false,
              quit: false,
              removeFile: false,
              rs: false,
              sh: false,
              UUID: false,
              version: false,
              WriteResult: false,
            },
            applescript: {
              $: false,
              Application: false,
              Automation: false,
              console: false,
              delay: false,
              Library: false,
              ObjC: false,
              ObjectSpecifier: false,
              Path: false,
              Progress: false,
              Ref: false,
            },
            serviceworker: {
              Cache: false,
              caches: false,
              CacheStorage: false,
              Client: false,
              clients: false,
              Clients: false,
              ExtendableEvent: false,
              ExtendableMessageEvent: false,
              FetchEvent: false,
              importScripts: false,
              registration: false,
              self: false,
              ServiceWorker: false,
              ServiceWorkerContainer: false,
              ServiceWorkerGlobalScope: false,
              ServiceWorkerMessageEvent: false,
              ServiceWorkerRegistration: false,
              skipWaiting: false,
              WindowClient: false,
            },
            atomtest: {
              advanceClock: false,
              fakeClearInterval: false,
              fakeClearTimeout: false,
              fakeSetInterval: false,
              fakeSetTimeout: false,
              resetTimeouts: false,
              waitsForPromise: false,
            },
            embertest: {
              andThen: false,
              click: false,
              currentPath: false,
              currentRouteName: false,
              currentURL: false,
              fillIn: false,
              find: false,
              findAll: false,
              findWithAssert: false,
              keyEvent: false,
              pauseTest: false,
              resumeTest: false,
              triggerEvent: false,
              visit: false,
              wait: false,
            },
            protractor: {
              $: false,
              $$: false,
              browser: false,
              by: false,
              By: false,
              DartObject: false,
              element: false,
              protractor: false,
            },
            "shared-node-browser": {
              clearInterval: false,
              clearTimeout: false,
              console: false,
              setInterval: false,
              setTimeout: false,
              URL: false,
              URLSearchParams: false,
            },
            webextensions: { browser: false, chrome: false, opr: false },
            greasemonkey: {
              GM: false,
              GM_addStyle: false,
              GM_deleteValue: false,
              GM_getResourceText: false,
              GM_getResourceURL: false,
              GM_getValue: false,
              GM_info: false,
              GM_listValues: false,
              GM_log: false,
              GM_openInTab: false,
              GM_registerMenuCommand: false,
              GM_setClipboard: false,
              GM_setValue: false,
              GM_xmlhttpRequest: false,
              unsafeWindow: false,
            },
            devtools: {
              $: false,
              $_: false,
              $$: false,
              $0: false,
              $1: false,
              $2: false,
              $3: false,
              $4: false,
              $x: false,
              chrome: false,
              clear: false,
              copy: false,
              debug: false,
              dir: false,
              dirxml: false,
              getEventListeners: false,
              inspect: false,
              keys: false,
              monitor: false,
              monitorEvents: false,
              profile: false,
              profileEnd: false,
              queryObjects: false,
              table: false,
              undebug: false,
              unmonitor: false,
              unmonitorEvents: false,
              values: false,
            },
          };
        },
        /* 339 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function _sourceMap() {
            var data = _interopRequireDefault(__webpack_require__(141));

            _sourceMap = function _sourceMap() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var SourceMap = (function() {
            function SourceMap(opts, code) {
              this._cachedMap = null;
              this._code = code;
              this._opts = opts;
              this._rawMappings = [];
            }

            var _proto = SourceMap.prototype;

            _proto.get = function get() {
              if (!this._cachedMap) {
                var map = (this._cachedMap = new (_sourceMap()).default.SourceMapGenerator(
                  {
                    sourceRoot: this._opts.sourceRoot,
                  }
                ));
                var code = this._code;

                if (typeof code === "string") {
                  map.setSourceContent(this._opts.sourceFileName, code);
                } else if (typeof code === "object") {
                  Object.keys(code).forEach(function(sourceFileName) {
                    map.setSourceContent(sourceFileName, code[sourceFileName]);
                  });
                }

                this._rawMappings.forEach(map.addMapping, map);
              }

              return this._cachedMap.toJSON();
            };

            _proto.getRawMappings = function getRawMappings() {
              return this._rawMappings.slice();
            };

            _proto.mark = function mark(
              generatedLine,
              generatedColumn,
              line,
              column,
              identifierName,
              filename,
              force
            ) {
              if (this._lastGenLine !== generatedLine && line === null) return;

              if (
                !force &&
                this._lastGenLine === generatedLine &&
                this._lastSourceLine === line &&
                this._lastSourceColumn === column
              ) {
                return;
              }

              this._cachedMap = null;
              this._lastGenLine = generatedLine;
              this._lastSourceLine = line;
              this._lastSourceColumn = column;

              this._rawMappings.push({
                name: identifierName || undefined,
                generated: {
                  line: generatedLine,
                  column: generatedColumn,
                },
                source:
                  line == null
                    ? undefined
                    : filename || this._opts.sourceFileName,
                original:
                  line == null
                    ? undefined
                    : {
                        line: line,
                        column: column,
                      },
              });
            };

            return SourceMap;
          })();

          exports.default = SourceMap;
        },
        /* 340 */
        function(module, exports) {
          var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
            ""
          );

          exports.encode = function(number) {
            if (0 <= number && number < intToCharMap.length) {
              return intToCharMap[number];
            }

            throw new TypeError("Must be between 0 and 63: " + number);
          };

          exports.decode = function(charCode) {
            var bigA = 65;
            var bigZ = 90;
            var littleA = 97;
            var littleZ = 122;
            var zero = 48;
            var nine = 57;
            var plus = 43;
            var slash = 47;
            var littleOffset = 26;
            var numberOffset = 52;

            if (bigA <= charCode && charCode <= bigZ) {
              return charCode - bigA;
            }

            if (littleA <= charCode && charCode <= littleZ) {
              return charCode - littleA + littleOffset;
            }

            if (zero <= charCode && charCode <= nine) {
              return charCode - zero + numberOffset;
            }

            if (charCode == plus) {
              return 62;
            }

            if (charCode == slash) {
              return 63;
            }

            return -1;
          };
        },
        /* 341 */
        function(module, exports, __webpack_require__) {
          var util = __webpack_require__(30);

          function generatedPositionAfter(mappingA, mappingB) {
            var lineA = mappingA.generatedLine;
            var lineB = mappingB.generatedLine;
            var columnA = mappingA.generatedColumn;
            var columnB = mappingB.generatedColumn;
            return (
              lineB > lineA ||
              (lineB == lineA && columnB >= columnA) ||
              util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
            );
          }

          function MappingList() {
            this._array = [];
            this._sorted = true;
            this._last = {
              generatedLine: -1,
              generatedColumn: 0,
            };
          }

          MappingList.prototype.unsortedForEach = function MappingList_forEach(
            aCallback,
            aThisArg
          ) {
            this._array.forEach(aCallback, aThisArg);
          };

          MappingList.prototype.add = function MappingList_add(aMapping) {
            if (generatedPositionAfter(this._last, aMapping)) {
              this._last = aMapping;

              this._array.push(aMapping);
            } else {
              this._sorted = false;

              this._array.push(aMapping);
            }
          };

          MappingList.prototype.toArray = function MappingList_toArray() {
            if (!this._sorted) {
              this._array.sort(util.compareByGeneratedPositionsInflated);

              this._sorted = true;
            }

            return this._array;
          };

          exports.MappingList = MappingList;
        },
        /* 342 */
        function(module, exports, __webpack_require__) {
          var util = __webpack_require__(30);

          var binarySearch = __webpack_require__(343);

          var ArraySet = __webpack_require__(144).ArraySet;

          var base64VLQ = __webpack_require__(143);

          var quickSort = __webpack_require__(344).quickSort;

          function SourceMapConsumer(aSourceMap, aSourceMapURL) {
            var sourceMap = aSourceMap;

            if (typeof aSourceMap === "string") {
              sourceMap = util.parseSourceMapInput(aSourceMap);
            }

            return sourceMap.sections != null
              ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
              : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
          }

          SourceMapConsumer.fromSourceMap = function(
            aSourceMap,
            aSourceMapURL
          ) {
            return BasicSourceMapConsumer.fromSourceMap(
              aSourceMap,
              aSourceMapURL
            );
          };

          SourceMapConsumer.prototype._version = 3;
          SourceMapConsumer.prototype.__generatedMappings = null;
          Object.defineProperty(
            SourceMapConsumer.prototype,
            "_generatedMappings",
            {
              configurable: true,
              enumerable: true,
              get: function get() {
                if (!this.__generatedMappings) {
                  this._parseMappings(this._mappings, this.sourceRoot);
                }

                return this.__generatedMappings;
              },
            }
          );
          SourceMapConsumer.prototype.__originalMappings = null;
          Object.defineProperty(
            SourceMapConsumer.prototype,
            "_originalMappings",
            {
              configurable: true,
              enumerable: true,
              get: function get() {
                if (!this.__originalMappings) {
                  this._parseMappings(this._mappings, this.sourceRoot);
                }

                return this.__originalMappings;
              },
            }
          );

          SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(
            aStr,
            index
          ) {
            var c = aStr.charAt(index);
            return c === ";" || c === ",";
          };

          SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
            aStr,
            aSourceRoot
          ) {
            throw new Error("Subclasses must implement _parseMappings");
          };

          SourceMapConsumer.GENERATED_ORDER = 1;
          SourceMapConsumer.ORIGINAL_ORDER = 2;
          SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
          SourceMapConsumer.LEAST_UPPER_BOUND = 2;

          SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(
            aCallback,
            aContext,
            aOrder
          ) {
            var context = aContext || null;
            var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
            var mappings;

            switch (order) {
              case SourceMapConsumer.GENERATED_ORDER:
                mappings = this._generatedMappings;
                break;

              case SourceMapConsumer.ORIGINAL_ORDER:
                mappings = this._originalMappings;
                break;

              default:
                throw new Error("Unknown order of iteration.");
            }

            var sourceRoot = this.sourceRoot;
            mappings
              .map(function(mapping) {
                var source =
                  mapping.source === null
                    ? null
                    : this._sources.at(mapping.source);
                source = util.computeSourceURL(
                  sourceRoot,
                  source,
                  this._sourceMapURL
                );
                return {
                  source: source,
                  generatedLine: mapping.generatedLine,
                  generatedColumn: mapping.generatedColumn,
                  originalLine: mapping.originalLine,
                  originalColumn: mapping.originalColumn,
                  name:
                    mapping.name === null ? null : this._names.at(mapping.name),
                };
              }, this)
              .forEach(aCallback, context);
          };

          SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(
            aArgs
          ) {
            var line = util.getArg(aArgs, "line");
            var needle = {
              source: util.getArg(aArgs, "source"),
              originalLine: line,
              originalColumn: util.getArg(aArgs, "column", 0),
            };
            needle.source = this._findSourceIndex(needle.source);

            if (needle.source < 0) {
              return [];
            }

            var mappings = [];

            var index = this._findMapping(
              needle,
              this._originalMappings,
              "originalLine",
              "originalColumn",
              util.compareByOriginalPositions,
              binarySearch.LEAST_UPPER_BOUND
            );

            if (index >= 0) {
              var mapping = this._originalMappings[index];

              if (aArgs.column === undefined) {
                var originalLine = mapping.originalLine;

                while (mapping && mapping.originalLine === originalLine) {
                  mappings.push({
                    line: util.getArg(mapping, "generatedLine", null),
                    column: util.getArg(mapping, "generatedColumn", null),
                    lastColumn: util.getArg(
                      mapping,
                      "lastGeneratedColumn",
                      null
                    ),
                  });
                  mapping = this._originalMappings[++index];
                }
              } else {
                var originalColumn = mapping.originalColumn;

                while (
                  mapping &&
                  mapping.originalLine === line &&
                  mapping.originalColumn == originalColumn
                ) {
                  mappings.push({
                    line: util.getArg(mapping, "generatedLine", null),
                    column: util.getArg(mapping, "generatedColumn", null),
                    lastColumn: util.getArg(
                      mapping,
                      "lastGeneratedColumn",
                      null
                    ),
                  });
                  mapping = this._originalMappings[++index];
                }
              }
            }

            return mappings;
          };

          exports.SourceMapConsumer = SourceMapConsumer;

          function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
            var sourceMap = aSourceMap;

            if (typeof aSourceMap === "string") {
              sourceMap = util.parseSourceMapInput(aSourceMap);
            }

            var version = util.getArg(sourceMap, "version");
            var sources = util.getArg(sourceMap, "sources");
            var names = util.getArg(sourceMap, "names", []);
            var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
            var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
            var mappings = util.getArg(sourceMap, "mappings");
            var file = util.getArg(sourceMap, "file", null);

            if (version != this._version) {
              throw new Error("Unsupported version: " + version);
            }

            if (sourceRoot) {
              sourceRoot = util.normalize(sourceRoot);
            }

            sources = sources
              .map(String)
              .map(util.normalize)
              .map(function(source) {
                return sourceRoot &&
                  util.isAbsolute(sourceRoot) &&
                  util.isAbsolute(source)
                  ? util.relative(sourceRoot, source)
                  : source;
              });
            this._names = ArraySet.fromArray(names.map(String), true);
            this._sources = ArraySet.fromArray(sources, true);
            this._absoluteSources = this._sources.toArray().map(function(s) {
              return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
            });
            this.sourceRoot = sourceRoot;
            this.sourcesContent = sourcesContent;
            this._mappings = mappings;
            this._sourceMapURL = aSourceMapURL;
            this.file = file;
          }

          BasicSourceMapConsumer.prototype = Object.create(
            SourceMapConsumer.prototype
          );
          BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

          BasicSourceMapConsumer.prototype._findSourceIndex = function(
            aSource
          ) {
            var relativeSource = aSource;

            if (this.sourceRoot != null) {
              relativeSource = util.relative(this.sourceRoot, relativeSource);
            }

            if (this._sources.has(relativeSource)) {
              return this._sources.indexOf(relativeSource);
            }

            var i;

            for (i = 0; i < this._absoluteSources.length; ++i) {
              if (this._absoluteSources[i] == aSource) {
                return i;
              }
            }

            return -1;
          };

          BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(
            aSourceMap,
            aSourceMapURL
          ) {
            var smc = Object.create(BasicSourceMapConsumer.prototype);
            var names = (smc._names = ArraySet.fromArray(
              aSourceMap._names.toArray(),
              true
            ));
            var sources = (smc._sources = ArraySet.fromArray(
              aSourceMap._sources.toArray(),
              true
            ));
            smc.sourceRoot = aSourceMap._sourceRoot;
            smc.sourcesContent = aSourceMap._generateSourcesContent(
              smc._sources.toArray(),
              smc.sourceRoot
            );
            smc.file = aSourceMap._file;
            smc._sourceMapURL = aSourceMapURL;
            smc._absoluteSources = smc._sources.toArray().map(function(s) {
              return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
            });

            var generatedMappings = aSourceMap._mappings.toArray().slice();

            var destGeneratedMappings = (smc.__generatedMappings = []);
            var destOriginalMappings = (smc.__originalMappings = []);

            for (
              var i = 0, length = generatedMappings.length;
              i < length;
              i++
            ) {
              var srcMapping = generatedMappings[i];
              var destMapping = new Mapping();
              destMapping.generatedLine = srcMapping.generatedLine;
              destMapping.generatedColumn = srcMapping.generatedColumn;

              if (srcMapping.source) {
                destMapping.source = sources.indexOf(srcMapping.source);
                destMapping.originalLine = srcMapping.originalLine;
                destMapping.originalColumn = srcMapping.originalColumn;

                if (srcMapping.name) {
                  destMapping.name = names.indexOf(srcMapping.name);
                }

                destOriginalMappings.push(destMapping);
              }

              destGeneratedMappings.push(destMapping);
            }

            quickSort(smc.__originalMappings, util.compareByOriginalPositions);
            return smc;
          };

          BasicSourceMapConsumer.prototype._version = 3;
          Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
            get: function get() {
              return this._absoluteSources.slice();
            },
          });

          function Mapping() {
            this.generatedLine = 0;
            this.generatedColumn = 0;
            this.source = null;
            this.originalLine = null;
            this.originalColumn = null;
            this.name = null;
          }

          BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
            aStr,
            aSourceRoot
          ) {
            var generatedLine = 1;
            var previousGeneratedColumn = 0;
            var previousOriginalLine = 0;
            var previousOriginalColumn = 0;
            var previousSource = 0;
            var previousName = 0;
            var length = aStr.length;
            var index = 0;
            var cachedSegments = {};
            var temp = {};
            var originalMappings = [];
            var generatedMappings = [];
            var mapping, str, segment, end, value;

            while (index < length) {
              if (aStr.charAt(index) === ";") {
                generatedLine++;
                index++;
                previousGeneratedColumn = 0;
              } else if (aStr.charAt(index) === ",") {
                index++;
              } else {
                mapping = new Mapping();
                mapping.generatedLine = generatedLine;

                for (end = index; end < length; end++) {
                  if (this._charIsMappingSeparator(aStr, end)) {
                    break;
                  }
                }

                str = aStr.slice(index, end);
                segment = cachedSegments[str];

                if (segment) {
                  index += str.length;
                } else {
                  segment = [];

                  while (index < end) {
                    base64VLQ.decode(aStr, index, temp);
                    value = temp.value;
                    index = temp.rest;
                    segment.push(value);
                  }

                  if (segment.length === 2) {
                    throw new Error("Found a source, but no line and column");
                  }

                  if (segment.length === 3) {
                    throw new Error("Found a source and line, but no column");
                  }

                  cachedSegments[str] = segment;
                }

                mapping.generatedColumn = previousGeneratedColumn + segment[0];
                previousGeneratedColumn = mapping.generatedColumn;

                if (segment.length > 1) {
                  mapping.source = previousSource + segment[1];
                  previousSource += segment[1];
                  mapping.originalLine = previousOriginalLine + segment[2];
                  previousOriginalLine = mapping.originalLine;
                  mapping.originalLine += 1;
                  mapping.originalColumn = previousOriginalColumn + segment[3];
                  previousOriginalColumn = mapping.originalColumn;

                  if (segment.length > 4) {
                    mapping.name = previousName + segment[4];
                    previousName += segment[4];
                  }
                }

                generatedMappings.push(mapping);

                if (typeof mapping.originalLine === "number") {
                  originalMappings.push(mapping);
                }
              }
            }

            quickSort(
              generatedMappings,
              util.compareByGeneratedPositionsDeflated
            );
            this.__generatedMappings = generatedMappings;
            quickSort(originalMappings, util.compareByOriginalPositions);
            this.__originalMappings = originalMappings;
          };

          BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(
            aNeedle,
            aMappings,
            aLineName,
            aColumnName,
            aComparator,
            aBias
          ) {
            if (aNeedle[aLineName] <= 0) {
              throw new TypeError(
                "Line must be greater than or equal to 1, got " +
                  aNeedle[aLineName]
              );
            }

            if (aNeedle[aColumnName] < 0) {
              throw new TypeError(
                "Column must be greater than or equal to 0, got " +
                  aNeedle[aColumnName]
              );
            }

            return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
          };

          BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
            for (
              var index = 0;
              index < this._generatedMappings.length;
              ++index
            ) {
              var mapping = this._generatedMappings[index];

              if (index + 1 < this._generatedMappings.length) {
                var nextMapping = this._generatedMappings[index + 1];

                if (mapping.generatedLine === nextMapping.generatedLine) {
                  mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                  continue;
                }
              }

              mapping.lastGeneratedColumn = Infinity;
            }
          };

          BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(
            aArgs
          ) {
            var needle = {
              generatedLine: util.getArg(aArgs, "line"),
              generatedColumn: util.getArg(aArgs, "column"),
            };

            var index = this._findMapping(
              needle,
              this._generatedMappings,
              "generatedLine",
              "generatedColumn",
              util.compareByGeneratedPositionsDeflated,
              util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
            );

            if (index >= 0) {
              var mapping = this._generatedMappings[index];

              if (mapping.generatedLine === needle.generatedLine) {
                var source = util.getArg(mapping, "source", null);

                if (source !== null) {
                  source = this._sources.at(source);
                  source = util.computeSourceURL(
                    this.sourceRoot,
                    source,
                    this._sourceMapURL
                  );
                }

                var name = util.getArg(mapping, "name", null);

                if (name !== null) {
                  name = this._names.at(name);
                }

                return {
                  source: source,
                  line: util.getArg(mapping, "originalLine", null),
                  column: util.getArg(mapping, "originalColumn", null),
                  name: name,
                };
              }
            }

            return {
              source: null,
              line: null,
              column: null,
              name: null,
            };
          };

          BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
            if (!this.sourcesContent) {
              return false;
            }

            return (
              this.sourcesContent.length >= this._sources.size() &&
              !this.sourcesContent.some(function(sc) {
                return sc == null;
              })
            );
          };

          BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(
            aSource,
            nullOnMissing
          ) {
            if (!this.sourcesContent) {
              return null;
            }

            var index = this._findSourceIndex(aSource);

            if (index >= 0) {
              return this.sourcesContent[index];
            }

            var relativeSource = aSource;

            if (this.sourceRoot != null) {
              relativeSource = util.relative(this.sourceRoot, relativeSource);
            }

            var url;

            if (
              this.sourceRoot != null &&
              (url = util.urlParse(this.sourceRoot))
            ) {
              var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");

              if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
                return this.sourcesContent[
                  this._sources.indexOf(fileUriAbsPath)
                ];
              }

              if (
                (!url.path || url.path == "/") &&
                this._sources.has("/" + relativeSource)
              ) {
                return this.sourcesContent[
                  this._sources.indexOf("/" + relativeSource)
                ];
              }
            }

            if (nullOnMissing) {
              return null;
            } else {
              throw new Error(
                '"' + relativeSource + '" is not in the SourceMap.'
              );
            }
          };

          BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(
            aArgs
          ) {
            var source = util.getArg(aArgs, "source");
            source = this._findSourceIndex(source);

            if (source < 0) {
              return {
                line: null,
                column: null,
                lastColumn: null,
              };
            }

            var needle = {
              source: source,
              originalLine: util.getArg(aArgs, "line"),
              originalColumn: util.getArg(aArgs, "column"),
            };

            var index = this._findMapping(
              needle,
              this._originalMappings,
              "originalLine",
              "originalColumn",
              util.compareByOriginalPositions,
              util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
            );

            if (index >= 0) {
              var mapping = this._originalMappings[index];

              if (mapping.source === needle.source) {
                return {
                  line: util.getArg(mapping, "generatedLine", null),
                  column: util.getArg(mapping, "generatedColumn", null),
                  lastColumn: util.getArg(mapping, "lastGeneratedColumn", null),
                };
              }
            }

            return {
              line: null,
              column: null,
              lastColumn: null,
            };
          };

          exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

          function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
            var sourceMap = aSourceMap;

            if (typeof aSourceMap === "string") {
              sourceMap = util.parseSourceMapInput(aSourceMap);
            }

            var version = util.getArg(sourceMap, "version");
            var sections = util.getArg(sourceMap, "sections");

            if (version != this._version) {
              throw new Error("Unsupported version: " + version);
            }

            this._sources = new ArraySet();
            this._names = new ArraySet();
            var lastOffset = {
              line: -1,
              column: 0,
            };
            this._sections = sections.map(function(s) {
              if (s.url) {
                throw new Error(
                  "Support for url field in sections not implemented."
                );
              }

              var offset = util.getArg(s, "offset");
              var offsetLine = util.getArg(offset, "line");
              var offsetColumn = util.getArg(offset, "column");

              if (
                offsetLine < lastOffset.line ||
                (offsetLine === lastOffset.line &&
                  offsetColumn < lastOffset.column)
              ) {
                throw new Error(
                  "Section offsets must be ordered and non-overlapping."
                );
              }

              lastOffset = offset;
              return {
                generatedOffset: {
                  generatedLine: offsetLine + 1,
                  generatedColumn: offsetColumn + 1,
                },
                consumer: new SourceMapConsumer(
                  util.getArg(s, "map"),
                  aSourceMapURL
                ),
              };
            });
          }

          IndexedSourceMapConsumer.prototype = Object.create(
            SourceMapConsumer.prototype
          );
          IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
          IndexedSourceMapConsumer.prototype._version = 3;
          Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
            get: function get() {
              var sources = [];

              for (var i = 0; i < this._sections.length; i++) {
                for (
                  var j = 0;
                  j < this._sections[i].consumer.sources.length;
                  j++
                ) {
                  sources.push(this._sections[i].consumer.sources[j]);
                }
              }

              return sources;
            },
          });

          IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(
            aArgs
          ) {
            var needle = {
              generatedLine: util.getArg(aArgs, "line"),
              generatedColumn: util.getArg(aArgs, "column"),
            };
            var sectionIndex = binarySearch.search(
              needle,
              this._sections,
              function(needle, section) {
                var cmp =
                  needle.generatedLine - section.generatedOffset.generatedLine;

                if (cmp) {
                  return cmp;
                }

                return (
                  needle.generatedColumn -
                  section.generatedOffset.generatedColumn
                );
              }
            );
            var section = this._sections[sectionIndex];

            if (!section) {
              return {
                source: null,
                line: null,
                column: null,
                name: null,
              };
            }

            return section.consumer.originalPositionFor({
              line:
                needle.generatedLine -
                (section.generatedOffset.generatedLine - 1),
              column:
                needle.generatedColumn -
                (section.generatedOffset.generatedLine === needle.generatedLine
                  ? section.generatedOffset.generatedColumn - 1
                  : 0),
              bias: aArgs.bias,
            });
          };

          IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
            return this._sections.every(function(s) {
              return s.consumer.hasContentsOfAllSources();
            });
          };

          IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(
            aSource,
            nullOnMissing
          ) {
            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i];
              var content = section.consumer.sourceContentFor(aSource, true);

              if (content) {
                return content;
              }
            }

            if (nullOnMissing) {
              return null;
            } else {
              throw new Error('"' + aSource + '" is not in the SourceMap.');
            }
          };

          IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(
            aArgs
          ) {
            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i];

              if (
                section.consumer._findSourceIndex(
                  util.getArg(aArgs, "source")
                ) === -1
              ) {
                continue;
              }

              var generatedPosition = section.consumer.generatedPositionFor(
                aArgs
              );

              if (generatedPosition) {
                var ret = {
                  line:
                    generatedPosition.line +
                    (section.generatedOffset.generatedLine - 1),
                  column:
                    generatedPosition.column +
                    (section.generatedOffset.generatedLine ===
                    generatedPosition.line
                      ? section.generatedOffset.generatedColumn - 1
                      : 0),
                };
                return ret;
              }
            }

            return {
              line: null,
              column: null,
            };
          };

          IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(
            aStr,
            aSourceRoot
          ) {
            this.__generatedMappings = [];
            this.__originalMappings = [];

            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i];
              var sectionMappings = section.consumer._generatedMappings;

              for (var j = 0; j < sectionMappings.length; j++) {
                var mapping = sectionMappings[j];

                var source = section.consumer._sources.at(mapping.source);

                source = util.computeSourceURL(
                  section.consumer.sourceRoot,
                  source,
                  this._sourceMapURL
                );

                this._sources.add(source);

                source = this._sources.indexOf(source);
                var name = null;

                if (mapping.name) {
                  name = section.consumer._names.at(mapping.name);

                  this._names.add(name);

                  name = this._names.indexOf(name);
                }

                var adjustedMapping = {
                  source: source,
                  generatedLine:
                    mapping.generatedLine +
                    (section.generatedOffset.generatedLine - 1),
                  generatedColumn:
                    mapping.generatedColumn +
                    (section.generatedOffset.generatedLine ===
                    mapping.generatedLine
                      ? section.generatedOffset.generatedColumn - 1
                      : 0),
                  originalLine: mapping.originalLine,
                  originalColumn: mapping.originalColumn,
                  name: name,
                };

                this.__generatedMappings.push(adjustedMapping);

                if (typeof adjustedMapping.originalLine === "number") {
                  this.__originalMappings.push(adjustedMapping);
                }
              }
            }

            quickSort(
              this.__generatedMappings,
              util.compareByGeneratedPositionsDeflated
            );
            quickSort(this.__originalMappings, util.compareByOriginalPositions);
          };

          exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
        },
        /* 343 */
        function(module, exports) {
          exports.GREATEST_LOWER_BOUND = 1;
          exports.LEAST_UPPER_BOUND = 2;

          function recursiveSearch(
            aLow,
            aHigh,
            aNeedle,
            aHaystack,
            aCompare,
            aBias
          ) {
            var mid = Math.floor((aHigh - aLow) / 2) + aLow;
            var cmp = aCompare(aNeedle, aHaystack[mid], true);

            if (cmp === 0) {
              return mid;
            } else if (cmp > 0) {
              if (aHigh - mid > 1) {
                return recursiveSearch(
                  mid,
                  aHigh,
                  aNeedle,
                  aHaystack,
                  aCompare,
                  aBias
                );
              }

              if (aBias == exports.LEAST_UPPER_BOUND) {
                return aHigh < aHaystack.length ? aHigh : -1;
              } else {
                return mid;
              }
            } else {
              if (mid - aLow > 1) {
                return recursiveSearch(
                  aLow,
                  mid,
                  aNeedle,
                  aHaystack,
                  aCompare,
                  aBias
                );
              }

              if (aBias == exports.LEAST_UPPER_BOUND) {
                return mid;
              } else {
                return aLow < 0 ? -1 : aLow;
              }
            }
          }

          exports.search = function search(
            aNeedle,
            aHaystack,
            aCompare,
            aBias
          ) {
            if (aHaystack.length === 0) {
              return -1;
            }

            var index = recursiveSearch(
              -1,
              aHaystack.length,
              aNeedle,
              aHaystack,
              aCompare,
              aBias || exports.GREATEST_LOWER_BOUND
            );

            if (index < 0) {
              return -1;
            }

            while (index - 1 >= 0) {
              if (
                aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0
              ) {
                break;
              }

              --index;
            }

            return index;
          };
        },
        /* 344 */
        function(module, exports) {
          function swap(ary, x, y) {
            var temp = ary[x];
            ary[x] = ary[y];
            ary[y] = temp;
          }

          function randomIntInRange(low, high) {
            return Math.round(low + Math.random() * (high - low));
          }

          function doQuickSort(ary, comparator, p, r) {
            if (p < r) {
              var pivotIndex = randomIntInRange(p, r);
              var i = p - 1;
              swap(ary, pivotIndex, r);
              var pivot = ary[r];

              for (var j = p; j < r; j++) {
                if (comparator(ary[j], pivot) <= 0) {
                  i += 1;
                  swap(ary, i, j);
                }
              }

              swap(ary, i + 1, j);
              var q = i + 1;
              doQuickSort(ary, comparator, p, q - 1);
              doQuickSort(ary, comparator, q + 1, r);
            }
          }

          exports.quickSort = function(ary, comparator) {
            doQuickSort(ary, comparator, 0, ary.length - 1);
          };
        },
        /* 345 */
        function(module, exports, __webpack_require__) {
          var SourceMapGenerator = __webpack_require__(142).SourceMapGenerator;

          var util = __webpack_require__(30);

          var REGEX_NEWLINE = /(\r?\n)/;
          var NEWLINE_CODE = 10;
          var isSourceNode = "$$$isSourceNode$$$";

          function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
            this.children = [];
            this.sourceContents = {};
            this.line = aLine == null ? null : aLine;
            this.column = aColumn == null ? null : aColumn;
            this.source = aSource == null ? null : aSource;
            this.name = aName == null ? null : aName;
            this[isSourceNode] = true;
            if (aChunks != null) this.add(aChunks);
          }

          SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(
            aGeneratedCode,
            aSourceMapConsumer,
            aRelativePath
          ) {
            var node = new SourceNode();
            var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
            var remainingLinesIndex = 0;

            var shiftNextLine = function shiftNextLine() {
              var lineContents = getNextLine();
              var newLine = getNextLine() || "";
              return lineContents + newLine;

              function getNextLine() {
                return remainingLinesIndex < remainingLines.length
                  ? remainingLines[remainingLinesIndex++]
                  : undefined;
              }
            };

            var lastGeneratedLine = 1,
              lastGeneratedColumn = 0;
            var lastMapping = null;
            aSourceMapConsumer.eachMapping(function(mapping) {
              if (lastMapping !== null) {
                if (lastGeneratedLine < mapping.generatedLine) {
                  addMappingWithCode(lastMapping, shiftNextLine());
                  lastGeneratedLine++;
                  lastGeneratedColumn = 0;
                } else {
                  var nextLine = remainingLines[remainingLinesIndex] || "";
                  var code = nextLine.substr(
                    0,
                    mapping.generatedColumn - lastGeneratedColumn
                  );
                  remainingLines[remainingLinesIndex] = nextLine.substr(
                    mapping.generatedColumn - lastGeneratedColumn
                  );
                  lastGeneratedColumn = mapping.generatedColumn;
                  addMappingWithCode(lastMapping, code);
                  lastMapping = mapping;
                  return;
                }
              }

              while (lastGeneratedLine < mapping.generatedLine) {
                node.add(shiftNextLine());
                lastGeneratedLine++;
              }

              if (lastGeneratedColumn < mapping.generatedColumn) {
                var nextLine = remainingLines[remainingLinesIndex] || "";
                node.add(nextLine.substr(0, mapping.generatedColumn));
                remainingLines[remainingLinesIndex] = nextLine.substr(
                  mapping.generatedColumn
                );
                lastGeneratedColumn = mapping.generatedColumn;
              }

              lastMapping = mapping;
            }, this);

            if (remainingLinesIndex < remainingLines.length) {
              if (lastMapping) {
                addMappingWithCode(lastMapping, shiftNextLine());
              }

              node.add(remainingLines.splice(remainingLinesIndex).join(""));
            }

            aSourceMapConsumer.sources.forEach(function(sourceFile) {
              var content = aSourceMapConsumer.sourceContentFor(sourceFile);

              if (content != null) {
                if (aRelativePath != null) {
                  sourceFile = util.join(aRelativePath, sourceFile);
                }

                node.setSourceContent(sourceFile, content);
              }
            });
            return node;

            function addMappingWithCode(mapping, code) {
              if (mapping === null || mapping.source === undefined) {
                node.add(code);
              } else {
                var source = aRelativePath
                  ? util.join(aRelativePath, mapping.source)
                  : mapping.source;
                node.add(
                  new SourceNode(
                    mapping.originalLine,
                    mapping.originalColumn,
                    source,
                    code,
                    mapping.name
                  )
                );
              }
            }
          };

          SourceNode.prototype.add = function SourceNode_add(aChunk) {
            if (Array.isArray(aChunk)) {
              aChunk.forEach(function(chunk) {
                this.add(chunk);
              }, this);
            } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
              if (aChunk) {
                this.children.push(aChunk);
              }
            } else {
              throw new TypeError(
                "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
                  aChunk
              );
            }

            return this;
          };

          SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
            if (Array.isArray(aChunk)) {
              for (var i = aChunk.length - 1; i >= 0; i--) {
                this.prepend(aChunk[i]);
              }
            } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
              this.children.unshift(aChunk);
            } else {
              throw new TypeError(
                "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
                  aChunk
              );
            }

            return this;
          };

          SourceNode.prototype.walk = function SourceNode_walk(aFn) {
            var chunk;

            for (var i = 0, len = this.children.length; i < len; i++) {
              chunk = this.children[i];

              if (chunk[isSourceNode]) {
                chunk.walk(aFn);
              } else {
                if (chunk !== "") {
                  aFn(chunk, {
                    source: this.source,
                    line: this.line,
                    column: this.column,
                    name: this.name,
                  });
                }
              }
            }
          };

          SourceNode.prototype.join = function SourceNode_join(aSep) {
            var newChildren;
            var i;
            var len = this.children.length;

            if (len > 0) {
              newChildren = [];

              for (i = 0; i < len - 1; i++) {
                newChildren.push(this.children[i]);
                newChildren.push(aSep);
              }

              newChildren.push(this.children[i]);
              this.children = newChildren;
            }

            return this;
          };

          SourceNode.prototype.replaceRight = function SourceNode_replaceRight(
            aPattern,
            aReplacement
          ) {
            var lastChild = this.children[this.children.length - 1];

            if (lastChild[isSourceNode]) {
              lastChild.replaceRight(aPattern, aReplacement);
            } else if (typeof lastChild === "string") {
              this.children[this.children.length - 1] = lastChild.replace(
                aPattern,
                aReplacement
              );
            } else {
              this.children.push("".replace(aPattern, aReplacement));
            }

            return this;
          };

          SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(
            aSourceFile,
            aSourceContent
          ) {
            this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
          };

          SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(
            aFn
          ) {
            for (var i = 0, len = this.children.length; i < len; i++) {
              if (this.children[i][isSourceNode]) {
                this.children[i].walkSourceContents(aFn);
              }
            }

            var sources = Object.keys(this.sourceContents);

            for (var i = 0, len = sources.length; i < len; i++) {
              aFn(
                util.fromSetString(sources[i]),
                this.sourceContents[sources[i]]
              );
            }
          };

          SourceNode.prototype.toString = function SourceNode_toString() {
            var str = "";
            this.walk(function(chunk) {
              str += chunk;
            });
            return str;
          };

          SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(
            aArgs
          ) {
            var generated = {
              code: "",
              line: 1,
              column: 0,
            };
            var map = new SourceMapGenerator(aArgs);
            var sourceMappingActive = false;
            var lastOriginalSource = null;
            var lastOriginalLine = null;
            var lastOriginalColumn = null;
            var lastOriginalName = null;
            this.walk(function(chunk, original) {
              generated.code += chunk;

              if (
                original.source !== null &&
                original.line !== null &&
                original.column !== null
              ) {
                if (
                  lastOriginalSource !== original.source ||
                  lastOriginalLine !== original.line ||
                  lastOriginalColumn !== original.column ||
                  lastOriginalName !== original.name
                ) {
                  map.addMapping({
                    source: original.source,
                    original: {
                      line: original.line,
                      column: original.column,
                    },
                    generated: {
                      line: generated.line,
                      column: generated.column,
                    },
                    name: original.name,
                  });
                }

                lastOriginalSource = original.source;
                lastOriginalLine = original.line;
                lastOriginalColumn = original.column;
                lastOriginalName = original.name;
                sourceMappingActive = true;
              } else if (sourceMappingActive) {
                map.addMapping({
                  generated: {
                    line: generated.line,
                    column: generated.column,
                  },
                });
                lastOriginalSource = null;
                sourceMappingActive = false;
              }

              for (var idx = 0, length = chunk.length; idx < length; idx++) {
                if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                  generated.line++;
                  generated.column = 0;

                  if (idx + 1 === length) {
                    lastOriginalSource = null;
                    sourceMappingActive = false;
                  } else if (sourceMappingActive) {
                    map.addMapping({
                      source: original.source,
                      original: {
                        line: original.line,
                        column: original.column,
                      },
                      generated: {
                        line: generated.line,
                        column: generated.column,
                      },
                      name: original.name,
                    });
                  }
                } else {
                  generated.column++;
                }
              }
            });
            this.walkSourceContents(function(sourceFile, sourceContent) {
              map.setSourceContent(sourceFile, sourceContent);
            });
            return {
              code: generated.code,
              map: map,
            };
          };

          exports.SourceNode = SourceNode;
        },
        /* 346 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function _isInteger() {
            var data = _interopRequireDefault(__webpack_require__(347));

            _isInteger = function _isInteger() {
              return data;
            };

            return data;
          }

          function _repeat() {
            var data = _interopRequireDefault(__webpack_require__(138));

            _repeat = function _repeat() {
              return data;
            };

            return data;
          }

          var _buffer = _interopRequireDefault(__webpack_require__(348));

          var n = _interopRequireWildcard(__webpack_require__(145));

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          var generatorFunctions = _interopRequireWildcard(
            __webpack_require__(352)
          );

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var SCIENTIFIC_NOTATION = /e/i;
          var ZERO_DECIMAL_INTEGER = /\.0+$/;
          var NON_DECIMAL_LITERAL = /^0[box]/;

          var Printer = (function() {
            function Printer(format, map) {
              this.inForStatementInitCounter = 0;
              this._printStack = [];
              this._indent = 0;
              this._insideAux = false;
              this._printedCommentStarts = {};
              this._parenPushNewlineState = null;
              this._noLineTerminator = false;
              this._printAuxAfterOnNextUserNode = false;
              this._printedComments = new WeakSet();
              this._endsWithInteger = false;
              this._endsWithWord = false;
              this.format = format || {};
              this._buf = new _buffer.default(map);
            }

            var _proto = Printer.prototype;

            _proto.generate = function generate(ast) {
              this.print(ast);

              this._maybeAddAuxComment();

              return this._buf.get();
            };

            _proto.indent = function indent() {
              if (this.format.compact || this.format.concise) return;
              this._indent++;
            };

            _proto.dedent = function dedent() {
              if (this.format.compact || this.format.concise) return;
              this._indent--;
            };

            _proto.semicolon = function semicolon(force) {
              if (force === void 0) {
                force = false;
              }

              this._maybeAddAuxComment();

              this._append(";", !force);
            };

            _proto.rightBrace = function rightBrace() {
              if (this.format.minified) {
                this._buf.removeLastSemicolon();
              }

              this.token("}");
            };

            _proto.space = function space(force) {
              if (force === void 0) {
                force = false;
              }

              if (this.format.compact) return;

              if (
                (this._buf.hasContent() &&
                  !this.endsWith(" ") &&
                  !this.endsWith("\n")) ||
                force
              ) {
                this._space();
              }
            };

            _proto.word = function word(str) {
              if (
                this._endsWithWord ||
                (this.endsWith("/") && str.indexOf("/") === 0)
              ) {
                this._space();
              }

              this._maybeAddAuxComment();

              this._append(str);

              this._endsWithWord = true;
            };

            _proto.number = function number(str) {
              this.word(str);
              this._endsWithInteger =
                (0, _isInteger().default)(+str) &&
                !NON_DECIMAL_LITERAL.test(str) &&
                !SCIENTIFIC_NOTATION.test(str) &&
                !ZERO_DECIMAL_INTEGER.test(str) &&
                str[str.length - 1] !== ".";
            };

            _proto.token = function token(str) {
              if (
                (str === "--" && this.endsWith("!")) ||
                (str[0] === "+" && this.endsWith("+")) ||
                (str[0] === "-" && this.endsWith("-")) ||
                (str[0] === "." && this._endsWithInteger)
              ) {
                this._space();
              }

              this._maybeAddAuxComment();

              this._append(str);
            };

            _proto.newline = function newline(i) {
              if (this.format.retainLines || this.format.compact) return;

              if (this.format.concise) {
                this.space();
                return;
              }

              if (this.endsWith("\n\n")) return;
              if (typeof i !== "number") i = 1;
              i = Math.min(2, i);
              if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
              if (i <= 0) return;

              for (var j = 0; j < i; j++) {
                this._newline();
              }
            };

            _proto.endsWith = function endsWith(str) {
              return this._buf.endsWith(str);
            };

            _proto.removeTrailingNewline = function removeTrailingNewline() {
              this._buf.removeTrailingNewline();
            };

            _proto.exactSource = function exactSource(loc, cb) {
              this._catchUp("start", loc);

              this._buf.exactSource(loc, cb);
            };

            _proto.source = function source(prop, loc) {
              this._catchUp(prop, loc);

              this._buf.source(prop, loc);
            };

            _proto.withSource = function withSource(prop, loc, cb) {
              this._catchUp(prop, loc);

              this._buf.withSource(prop, loc, cb);
            };

            _proto._space = function _space() {
              this._append(" ", true);
            };

            _proto._newline = function _newline() {
              this._append("\n", true);
            };

            _proto._append = function _append(str, queue) {
              if (queue === void 0) {
                queue = false;
              }

              this._maybeAddParen(str);

              this._maybeIndent(str);

              if (queue) this._buf.queue(str);
              else this._buf.append(str);
              this._endsWithWord = false;
              this._endsWithInteger = false;
            };

            _proto._maybeIndent = function _maybeIndent(str) {
              if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
                this._buf.queue(this._getIndent());
              }
            };

            _proto._maybeAddParen = function _maybeAddParen(str) {
              var parenPushNewlineState = this._parenPushNewlineState;
              if (!parenPushNewlineState) return;
              this._parenPushNewlineState = null;
              var i;

              for (i = 0; i < str.length && str[i] === " "; i++) {
                continue;
              }

              if (i === str.length) return;
              var cha = str[i];

              if (cha !== "\n") {
                if (cha !== "/") return;
                if (i + 1 === str.length) return;
                var chaPost = str[i + 1];
                if (chaPost !== "/" && chaPost !== "*") return;
              }

              this.token("(");
              this.indent();
              parenPushNewlineState.printed = true;
            };

            _proto._catchUp = function _catchUp(prop, loc) {
              if (!this.format.retainLines) return;
              var pos = loc ? loc[prop] : null;

              if (pos && pos.line !== null) {
                var count = pos.line - this._buf.getCurrentLine();

                for (var i = 0; i < count; i++) {
                  this._newline();
                }
              }
            };

            _proto._getIndent = function _getIndent() {
              return (0, _repeat().default)(
                this.format.indent.style,
                this._indent
              );
            };

            _proto.startTerminatorless = function startTerminatorless(isLabel) {
              if (isLabel === void 0) {
                isLabel = false;
              }

              if (isLabel) {
                this._noLineTerminator = true;
                return null;
              } else {
                return (this._parenPushNewlineState = {
                  printed: false,
                });
              }
            };

            _proto.endTerminatorless = function endTerminatorless(state) {
              this._noLineTerminator = false;

              if (state && state.printed) {
                this.dedent();
                this.newline();
                this.token(")");
              }
            };

            _proto.print = function print(node, parent) {
              var _this = this;

              if (!node) return;
              var oldConcise = this.format.concise;

              if (node._compact) {
                this.format.concise = true;
              }

              var printMethod = this[node.type];

              if (!printMethod) {
                throw new ReferenceError(
                  "unknown node of type " +
                    JSON.stringify(node.type) +
                    " with constructor " +
                    JSON.stringify(node && node.constructor.name)
                );
              }

              this._printStack.push(node);

              var oldInAux = this._insideAux;
              this._insideAux = !node.loc;

              this._maybeAddAuxComment(this._insideAux && !oldInAux);

              var needsParens = n.needsParens(node, parent, this._printStack);

              if (
                this.format.retainFunctionParens &&
                node.type === "FunctionExpression" &&
                node.extra &&
                node.extra.parenthesized
              ) {
                needsParens = true;
              }

              if (needsParens) this.token("(");

              this._printLeadingComments(node, parent);

              var loc =
                t().isProgram(node) || t().isFile(node) ? null : node.loc;
              this.withSource("start", loc, function() {
                _this[node.type](node, parent);
              });

              this._printTrailingComments(node, parent);

              if (needsParens) this.token(")");

              this._printStack.pop();

              this.format.concise = oldConcise;
              this._insideAux = oldInAux;
            };

            _proto._maybeAddAuxComment = function _maybeAddAuxComment(
              enteredPositionlessNode
            ) {
              if (enteredPositionlessNode) this._printAuxBeforeComment();
              if (!this._insideAux) this._printAuxAfterComment();
            };

            _proto._printAuxBeforeComment = function _printAuxBeforeComment() {
              if (this._printAuxAfterOnNextUserNode) return;
              this._printAuxAfterOnNextUserNode = true;
              var comment = this.format.auxiliaryCommentBefore;

              if (comment) {
                this._printComment({
                  type: "CommentBlock",
                  value: comment,
                });
              }
            };

            _proto._printAuxAfterComment = function _printAuxAfterComment() {
              if (!this._printAuxAfterOnNextUserNode) return;
              this._printAuxAfterOnNextUserNode = false;
              var comment = this.format.auxiliaryCommentAfter;

              if (comment) {
                this._printComment({
                  type: "CommentBlock",
                  value: comment,
                });
              }
            };

            _proto.getPossibleRaw = function getPossibleRaw(node) {
              var extra = node.extra;

              if (
                extra &&
                extra.raw != null &&
                extra.rawValue != null &&
                node.value === extra.rawValue
              ) {
                return extra.raw;
              }
            };

            _proto.printJoin = function printJoin(nodes, parent, opts) {
              if (opts === void 0) {
                opts = {};
              }

              if (!nodes || !nodes.length) return;
              if (opts.indent) this.indent();
              var newlineOpts = {
                addNewlines: opts.addNewlines,
              };

              for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if (!node) continue;
                if (opts.statement)
                  this._printNewline(true, node, parent, newlineOpts);
                this.print(node, parent);

                if (opts.iterator) {
                  opts.iterator(node, i);
                }

                if (opts.separator && i < nodes.length - 1) {
                  opts.separator.call(this);
                }

                if (opts.statement)
                  this._printNewline(false, node, parent, newlineOpts);
              }

              if (opts.indent) this.dedent();
            };

            _proto.printAndIndentOnComments = function printAndIndentOnComments(
              node,
              parent
            ) {
              var indent =
                node.leadingComments && node.leadingComments.length > 0;
              if (indent) this.indent();
              this.print(node, parent);
              if (indent) this.dedent();
            };

            _proto.printBlock = function printBlock(parent) {
              var node = parent.body;

              if (!t().isEmptyStatement(node)) {
                this.space();
              }

              this.print(node, parent);
            };

            _proto._printTrailingComments = function _printTrailingComments(
              node,
              parent
            ) {
              this._printComments(this._getComments(false, node, parent));
            };

            _proto._printLeadingComments = function _printLeadingComments(
              node,
              parent
            ) {
              this._printComments(this._getComments(true, node, parent));
            };

            _proto.printInnerComments = function printInnerComments(
              node,
              indent
            ) {
              if (indent === void 0) {
                indent = true;
              }

              if (!node.innerComments || !node.innerComments.length) return;
              if (indent) this.indent();

              this._printComments(node.innerComments);

              if (indent) this.dedent();
            };

            _proto.printSequence = function printSequence(nodes, parent, opts) {
              if (opts === void 0) {
                opts = {};
              }

              opts.statement = true;
              return this.printJoin(nodes, parent, opts);
            };

            _proto.printList = function printList(items, parent, opts) {
              if (opts === void 0) {
                opts = {};
              }

              if (opts.separator == null) {
                opts.separator = commaSeparator;
              }

              return this.printJoin(items, parent, opts);
            };

            _proto._printNewline = function _printNewline(
              leading,
              node,
              parent,
              opts
            ) {
              if (this.format.retainLines || this.format.compact) return;

              if (this.format.concise) {
                this.space();
                return;
              }

              var lines = 0;

              if (this._buf.hasContent()) {
                if (!leading) lines++;
                if (opts.addNewlines)
                  lines += opts.addNewlines(leading, node) || 0;
                var needs = leading
                  ? n.needsWhitespaceBefore
                  : n.needsWhitespaceAfter;
                if (needs(node, parent)) lines++;
              }

              this.newline(lines);
            };

            _proto._getComments = function _getComments(leading, node) {
              return (
                (node &&
                  (leading ? node.leadingComments : node.trailingComments)) ||
                []
              );
            };

            _proto._printComment = function _printComment(comment) {
              var _this2 = this;

              if (!this.format.shouldPrintComment(comment.value)) return;
              if (comment.ignore) return;
              if (this._printedComments.has(comment)) return;

              this._printedComments.add(comment);

              if (comment.start != null) {
                if (this._printedCommentStarts[comment.start]) return;
                this._printedCommentStarts[comment.start] = true;
              }

              var isBlockComment = comment.type === "CommentBlock";
              this.newline(
                this._buf.hasContent() &&
                !this._noLineTerminator &&
                isBlockComment
                  ? 1
                  : 0
              );
              if (!this.endsWith("[") && !this.endsWith("{")) this.space();
              var val =
                !isBlockComment && !this._noLineTerminator
                  ? "//" + comment.value + "\n"
                  : "/*" + comment.value + "*/";

              if (isBlockComment && this.format.indent.adjustMultilineComment) {
                var offset = comment.loc && comment.loc.start.column;

                if (offset) {
                  var newlineRegex = new RegExp(
                    "\\n\\s{1," + offset + "}",
                    "g"
                  );
                  val = val.replace(newlineRegex, "\n");
                }

                var indentSize = Math.max(
                  this._getIndent().length,
                  this._buf.getCurrentColumn()
                );
                val = val.replace(
                  /\n(?!$)/g,
                  "\n" + (0, _repeat().default)(" ", indentSize)
                );
              }

              if (this.endsWith("/")) this._space();
              this.withSource("start", comment.loc, function() {
                _this2._append(val);
              });
              this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);
            };

            _proto._printComments = function _printComments(comments) {
              if (!comments || !comments.length) return;

              for (
                var _iterator = comments,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var comment = _ref;

                this._printComment(comment);
              }
            };

            return Printer;
          })();

          exports.default = Printer;
          Object.assign(Printer.prototype, generatorFunctions);

          function commaSeparator() {
            this.token(",");
            this.space();
          }
        },
        /* 347 */
        function(module, exports, __webpack_require__) {
          var toInteger = __webpack_require__(74);

          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }

          module.exports = isInteger;
        },
        /* 348 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function _trimRight() {
            var data = _interopRequireDefault(__webpack_require__(349));

            _trimRight = function _trimRight() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var SPACES_RE = /^[ \t]+$/;

          var Buffer = (function() {
            function Buffer(map) {
              this._map = null;
              this._buf = [];
              this._last = "";
              this._queue = [];
              this._position = {
                line: 1,
                column: 0,
              };
              this._sourcePosition = {
                identifierName: null,
                line: null,
                column: null,
                filename: null,
              };
              this._disallowedPop = null;
              this._map = map;
            }

            var _proto = Buffer.prototype;

            _proto.get = function get() {
              this._flush();

              var map = this._map;
              var result = {
                code: (0, _trimRight().default)(this._buf.join("")),
                map: null,
                rawMappings: map && map.getRawMappings(),
              };

              if (map) {
                Object.defineProperty(result, "map", {
                  configurable: true,
                  enumerable: true,
                  get: function get() {
                    return (this.map = map.get());
                  },
                  set: function set(value) {
                    Object.defineProperty(this, "map", {
                      value: value,
                      writable: true,
                    });
                  },
                });
              }

              return result;
            };

            _proto.append = function append(str) {
              this._flush();

              var _this$_sourcePosition = this._sourcePosition,
                line = _this$_sourcePosition.line,
                column = _this$_sourcePosition.column,
                filename = _this$_sourcePosition.filename,
                identifierName = _this$_sourcePosition.identifierName,
                force = _this$_sourcePosition.force;

              this._append(str, line, column, identifierName, filename, force);
            };

            _proto.queue = function queue(str) {
              if (str === "\n") {
                while (
                  this._queue.length > 0 &&
                  SPACES_RE.test(this._queue[0][0])
                ) {
                  this._queue.shift();
                }
              }

              var _this$_sourcePosition2 = this._sourcePosition,
                line = _this$_sourcePosition2.line,
                column = _this$_sourcePosition2.column,
                filename = _this$_sourcePosition2.filename,
                identifierName = _this$_sourcePosition2.identifierName,
                force = _this$_sourcePosition2.force;

              this._queue.unshift([
                str,
                line,
                column,
                identifierName,
                filename,
                force,
              ]);
            };

            _proto._flush = function _flush() {
              var item;

              while ((item = this._queue.pop())) {
                this._append.apply(this, item);
              }
            };

            _proto._append = function _append(
              str,
              line,
              column,
              identifierName,
              filename,
              force
            ) {
              if (this._map && str[0] !== "\n") {
                this._map.mark(
                  this._position.line,
                  this._position.column,
                  line,
                  column,
                  identifierName,
                  filename,
                  force
                );
              }

              this._buf.push(str);

              this._last = str[str.length - 1];

              for (var i = 0; i < str.length; i++) {
                if (str[i] === "\n") {
                  this._position.line++;
                  this._position.column = 0;
                } else {
                  this._position.column++;
                }
              }
            };

            _proto.removeTrailingNewline = function removeTrailingNewline() {
              if (this._queue.length > 0 && this._queue[0][0] === "\n") {
                this._queue.shift();
              }
            };

            _proto.removeLastSemicolon = function removeLastSemicolon() {
              if (this._queue.length > 0 && this._queue[0][0] === ";") {
                this._queue.shift();
              }
            };

            _proto.endsWith = function endsWith(suffix) {
              if (suffix.length === 1) {
                var last;

                if (this._queue.length > 0) {
                  var str = this._queue[0][0];
                  last = str[str.length - 1];
                } else {
                  last = this._last;
                }

                return last === suffix;
              }

              var end =
                this._last +
                this._queue.reduce(function(acc, item) {
                  return item[0] + acc;
                }, "");

              if (suffix.length <= end.length) {
                return end.slice(-suffix.length) === suffix;
              }

              return false;
            };

            _proto.hasContent = function hasContent() {
              return this._queue.length > 0 || !!this._last;
            };

            _proto.exactSource = function exactSource(loc, cb) {
              this.source("start", loc, true);
              cb();
              this.source("end", loc);

              this._disallowPop("start", loc);
            };

            _proto.source = function source(prop, loc, force) {
              if (prop && !loc) return;

              this._normalizePosition(prop, loc, this._sourcePosition, force);
            };

            _proto.withSource = function withSource(prop, loc, cb) {
              if (!this._map) return cb();
              var originalLine = this._sourcePosition.line;
              var originalColumn = this._sourcePosition.column;
              var originalFilename = this._sourcePosition.filename;
              var originalIdentifierName = this._sourcePosition.identifierName;
              this.source(prop, loc);
              cb();

              if (
                (!this._sourcePosition.force ||
                  this._sourcePosition.line !== originalLine ||
                  this._sourcePosition.column !== originalColumn ||
                  this._sourcePosition.filename !== originalFilename) &&
                (!this._disallowedPop ||
                  this._disallowedPop.line !== originalLine ||
                  this._disallowedPop.column !== originalColumn ||
                  this._disallowedPop.filename !== originalFilename)
              ) {
                this._sourcePosition.line = originalLine;
                this._sourcePosition.column = originalColumn;
                this._sourcePosition.filename = originalFilename;
                this._sourcePosition.identifierName = originalIdentifierName;
                this._sourcePosition.force = false;
                this._disallowedPop = null;
              }
            };

            _proto._disallowPop = function _disallowPop(prop, loc) {
              if (prop && !loc) return;
              this._disallowedPop = this._normalizePosition(prop, loc);
            };

            _proto._normalizePosition = function _normalizePosition(
              prop,
              loc,
              targetObj,
              force
            ) {
              var pos = loc ? loc[prop] : null;

              if (targetObj === undefined) {
                targetObj = {
                  identifierName: null,
                  line: null,
                  column: null,
                  filename: null,
                  force: false,
                };
              }

              var origLine = targetObj.line;
              var origColumn = targetObj.column;
              var origFilename = targetObj.filename;
              targetObj.identifierName =
                (prop === "start" && loc && loc.identifierName) || null;
              targetObj.line = pos ? pos.line : null;
              targetObj.column = pos ? pos.column : null;
              targetObj.filename = (loc && loc.filename) || null;

              if (
                force ||
                targetObj.line !== origLine ||
                targetObj.column !== origColumn ||
                targetObj.filename !== origFilename
              ) {
                targetObj.force = force;
              }

              return targetObj;
            };

            _proto.getCurrentColumn = function getCurrentColumn() {
              var extra = this._queue.reduce(function(acc, item) {
                return item[0] + acc;
              }, "");

              var lastIndex = extra.lastIndexOf("\n");
              return lastIndex === -1
                ? this._position.column + extra.length
                : extra.length - 1 - lastIndex;
            };

            _proto.getCurrentLine = function getCurrentLine() {
              var extra = this._queue.reduce(function(acc, item) {
                return item[0] + acc;
              }, "");

              var count = 0;

              for (var i = 0; i < extra.length; i++) {
                if (extra[i] === "\n") count++;
              }

              return this._position.line + count;
            };

            return Buffer;
          })();

          exports.default = Buffer;
        },
        /* 349 */
        function(module, exports, __webpack_require__) {
          "use strict";

          module.exports = function(str) {
            var tail = str.length;

            while (/[\s\uFEFF\u00A0]/.test(str[tail - 1])) {
              tail--;
            }

            return str.slice(0, tail);
          };
        },
        /* 350 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.list = exports.nodes = void 0;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function crawl(node, state) {
            if (state === void 0) {
              state = {};
            }

            if (t().isMemberExpression(node)) {
              crawl(node.object, state);
              if (node.computed) crawl(node.property, state);
            } else if (t().isBinary(node) || t().isAssignmentExpression(node)) {
              crawl(node.left, state);
              crawl(node.right, state);
            } else if (t().isCallExpression(node)) {
              state.hasCall = true;
              crawl(node.callee, state);
            } else if (t().isFunction(node)) {
              state.hasFunction = true;
            } else if (t().isIdentifier(node)) {
              state.hasHelper = state.hasHelper || isHelper(node.callee);
            }

            return state;
          }

          function isHelper(node) {
            if (t().isMemberExpression(node)) {
              return isHelper(node.object) || isHelper(node.property);
            } else if (t().isIdentifier(node)) {
              return node.name === "require" || node.name[0] === "_";
            } else if (t().isCallExpression(node)) {
              return isHelper(node.callee);
            } else if (t().isBinary(node) || t().isAssignmentExpression(node)) {
              return (
                (t().isIdentifier(node.left) && isHelper(node.left)) ||
                isHelper(node.right)
              );
            } else {
              return false;
            }
          }

          function isType(node) {
            return (
              t().isLiteral(node) ||
              t().isObjectExpression(node) ||
              t().isArrayExpression(node) ||
              t().isIdentifier(node) ||
              t().isMemberExpression(node)
            );
          }

          var nodes = {
            AssignmentExpression: function AssignmentExpression(node) {
              var state = crawl(node.right);

              if ((state.hasCall && state.hasHelper) || state.hasFunction) {
                return {
                  before: state.hasFunction,
                  after: true,
                };
              }
            },
            SwitchCase: function SwitchCase(node, parent) {
              return {
                before: node.consequent.length || parent.cases[0] === node,
                after:
                  !node.consequent.length &&
                  parent.cases[parent.cases.length - 1] === node,
              };
            },
            LogicalExpression: function LogicalExpression(node) {
              if (t().isFunction(node.left) || t().isFunction(node.right)) {
                return {
                  after: true,
                };
              }
            },
            Literal: function Literal(node) {
              if (node.value === "use strict") {
                return {
                  after: true,
                };
              }
            },
            CallExpression: function CallExpression(node) {
              if (t().isFunction(node.callee) || isHelper(node)) {
                return {
                  before: true,
                  after: true,
                };
              }
            },
            VariableDeclaration: function VariableDeclaration(node) {
              for (var i = 0; i < node.declarations.length; i++) {
                var declar = node.declarations[i];
                var enabled = isHelper(declar.id) && !isType(declar.init);

                if (!enabled) {
                  var state = crawl(declar.init);
                  enabled =
                    (isHelper(declar.init) && state.hasCall) ||
                    state.hasFunction;
                }

                if (enabled) {
                  return {
                    before: true,
                    after: true,
                  };
                }
              }
            },
            IfStatement: function IfStatement(node) {
              if (t().isBlockStatement(node.consequent)) {
                return {
                  before: true,
                  after: true,
                };
              }
            },
          };
          exports.nodes = nodes;

          nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(
            node,
            parent
          ) {
            if (parent.properties[0] === node) {
              return {
                before: true,
              };
            }
          };

          nodes.ObjectTypeCallProperty = function(node, parent) {
            if (
              parent.callProperties[0] === node &&
              (!parent.properties || !parent.properties.length)
            ) {
              return {
                before: true,
              };
            }
          };

          nodes.ObjectTypeIndexer = function(node, parent) {
            if (
              parent.indexers[0] === node &&
              (!parent.properties || !parent.properties.length) &&
              (!parent.callProperties || !parent.callProperties.length)
            ) {
              return {
                before: true,
              };
            }
          };

          nodes.ObjectTypeInternalSlot = function(node, parent) {
            if (
              parent.internalSlots[0] === node &&
              (!parent.properties || !parent.properties.length) &&
              (!parent.callProperties || !parent.callProperties.length) &&
              (!parent.indexers || !parent.indexers.length)
            ) {
              return {
                before: true,
              };
            }
          };

          var list = {
            VariableDeclaration: function VariableDeclaration(node) {
              return node.declarations.map(function(decl) {
                return decl.init;
              });
            },
            ArrayExpression: function ArrayExpression(node) {
              return node.elements;
            },
            ObjectExpression: function ObjectExpression(node) {
              return node.properties;
            },
          };
          exports.list = list;
          [
            ["Function", true],
            ["Class", true],
            ["Loop", true],
            ["LabeledStatement", true],
            ["SwitchStatement", true],
            ["TryStatement", true],
          ].forEach(function(_ref) {
            var type = _ref[0],
              amounts = _ref[1];

            if (typeof amounts === "boolean") {
              amounts = {
                after: amounts,
                before: amounts,
              };
            }

            [type]
              .concat(t().FLIPPED_ALIAS_KEYS[type] || [])
              .forEach(function(type) {
                nodes[type] = function() {
                  return amounts;
                };
              });
          });
        },
        /* 351 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.FunctionTypeAnnotation = exports.NullableTypeAnnotation = NullableTypeAnnotation;
          exports.UpdateExpression = UpdateExpression;
          exports.ObjectExpression = ObjectExpression;
          exports.DoExpression = DoExpression;
          exports.Binary = Binary;
          exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
          exports.TSAsExpression = TSAsExpression;
          exports.TSTypeAssertion = TSTypeAssertion;
          exports.BinaryExpression = BinaryExpression;
          exports.SequenceExpression = SequenceExpression;
          exports.AwaitExpression = exports.YieldExpression = YieldExpression;
          exports.ClassExpression = ClassExpression;
          exports.UnaryLike = UnaryLike;
          exports.FunctionExpression = FunctionExpression;
          exports.ArrowFunctionExpression = ArrowFunctionExpression;
          exports.ConditionalExpression = ConditionalExpression;
          exports.AssignmentExpression = AssignmentExpression;
          exports.NewExpression = NewExpression;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          var PRECEDENCE = {
            "||": 0,
            "&&": 1,
            "|": 2,
            "^": 3,
            "&": 4,
            "==": 5,
            "===": 5,
            "!=": 5,
            "!==": 5,
            "<": 6,
            ">": 6,
            "<=": 6,
            ">=": 6,
            in: 6,
            instanceof: 6,
            ">>": 7,
            "<<": 7,
            ">>>": 7,
            "+": 8,
            "-": 8,
            "*": 9,
            "/": 9,
            "%": 9,
            "**": 10,
          };

          var isClassExtendsClause = function isClassExtendsClause(
            node,
            parent
          ) {
            return (
              (t().isClassDeclaration(parent) ||
                t().isClassExpression(parent)) &&
              parent.superClass === node
            );
          };

          function NullableTypeAnnotation(node, parent) {
            return t().isArrayTypeAnnotation(parent);
          }

          function UpdateExpression(node, parent) {
            return (
              t().isMemberExpression(parent, {
                object: node,
              }) ||
              t().isCallExpression(parent, {
                callee: node,
              }) ||
              t().isNewExpression(parent, {
                callee: node,
              }) ||
              isClassExtendsClause(node, parent)
            );
          }

          function ObjectExpression(node, parent, printStack) {
            return isFirstInStatement(printStack, {
              considerArrow: true,
            });
          }

          function DoExpression(node, parent, printStack) {
            return isFirstInStatement(printStack);
          }

          function Binary(node, parent) {
            if (
              node.operator === "**" &&
              t().isBinaryExpression(parent, {
                operator: "**",
              })
            ) {
              return parent.left === node;
            }

            if (isClassExtendsClause(node, parent)) {
              return true;
            }

            if (
              ((t().isCallExpression(parent) || t().isNewExpression(parent)) &&
                parent.callee === node) ||
              t().isUnaryLike(parent) ||
              (t().isMemberExpression(parent) && parent.object === node) ||
              t().isAwaitExpression(parent)
            ) {
              return true;
            }

            if (t().isBinary(parent)) {
              var parentOp = parent.operator;
              var parentPos = PRECEDENCE[parentOp];
              var nodeOp = node.operator;
              var nodePos = PRECEDENCE[nodeOp];

              if (
                (parentPos === nodePos &&
                  parent.right === node &&
                  !t().isLogicalExpression(parent)) ||
                parentPos > nodePos
              ) {
                return true;
              }
            }

            return false;
          }

          function UnionTypeAnnotation(node, parent) {
            return (
              t().isArrayTypeAnnotation(parent) ||
              t().isNullableTypeAnnotation(parent) ||
              t().isIntersectionTypeAnnotation(parent) ||
              t().isUnionTypeAnnotation(parent)
            );
          }

          function TSAsExpression() {
            return true;
          }

          function TSTypeAssertion() {
            return true;
          }

          function BinaryExpression(node, parent) {
            return (
              node.operator === "in" &&
              (t().isVariableDeclarator(parent) || t().isFor(parent))
            );
          }

          function SequenceExpression(node, parent) {
            if (
              t().isForStatement(parent) ||
              t().isThrowStatement(parent) ||
              t().isReturnStatement(parent) ||
              (t().isIfStatement(parent) && parent.test === node) ||
              (t().isWhileStatement(parent) && parent.test === node) ||
              (t().isForInStatement(parent) && parent.right === node) ||
              (t().isSwitchStatement(parent) && parent.discriminant === node) ||
              (t().isExpressionStatement(parent) && parent.expression === node)
            ) {
              return false;
            }

            return true;
          }

          function YieldExpression(node, parent) {
            return (
              t().isBinary(parent) ||
              t().isUnaryLike(parent) ||
              t().isCallExpression(parent) ||
              t().isMemberExpression(parent) ||
              t().isNewExpression(parent) ||
              (t().isConditionalExpression(parent) && node === parent.test) ||
              isClassExtendsClause(node, parent)
            );
          }

          function ClassExpression(node, parent, printStack) {
            return isFirstInStatement(printStack, {
              considerDefaultExports: true,
            });
          }

          function UnaryLike(node, parent) {
            return (
              t().isMemberExpression(parent, {
                object: node,
              }) ||
              t().isCallExpression(parent, {
                callee: node,
              }) ||
              t().isNewExpression(parent, {
                callee: node,
              }) ||
              t().isBinaryExpression(parent, {
                operator: "**",
                left: node,
              }) ||
              isClassExtendsClause(node, parent)
            );
          }

          function FunctionExpression(node, parent, printStack) {
            return isFirstInStatement(printStack, {
              considerDefaultExports: true,
            });
          }

          function ArrowFunctionExpression(node, parent) {
            return (
              t().isExportDeclaration(parent) ||
              ConditionalExpression(node, parent)
            );
          }

          function ConditionalExpression(node, parent) {
            if (
              t().isUnaryLike(parent) ||
              t().isBinary(parent) ||
              t().isConditionalExpression(parent, {
                test: node,
              }) ||
              t().isAwaitExpression(parent) ||
              t().isTaggedTemplateExpression(parent) ||
              t().isTSTypeAssertion(parent) ||
              t().isTSAsExpression(parent)
            ) {
              return true;
            }

            return UnaryLike(node, parent);
          }

          function AssignmentExpression(node) {
            if (t().isObjectPattern(node.left)) {
              return true;
            } else {
              return ConditionalExpression.apply(void 0, arguments);
            }
          }

          function NewExpression(node, parent) {
            return isClassExtendsClause(node, parent);
          }

          function isFirstInStatement(printStack, _temp) {
            var _ref = _temp === void 0 ? {} : _temp,
              _ref$considerArrow = _ref.considerArrow,
              considerArrow =
                _ref$considerArrow === void 0 ? false : _ref$considerArrow,
              _ref$considerDefaultE = _ref.considerDefaultExports,
              considerDefaultExports =
                _ref$considerDefaultE === void 0
                  ? false
                  : _ref$considerDefaultE;

            var i = printStack.length - 1;
            var node = printStack[i];
            i--;
            var parent = printStack[i];

            while (i > 0) {
              if (
                t().isExpressionStatement(parent, {
                  expression: node,
                }) ||
                t().isTaggedTemplateExpression(parent) ||
                (considerDefaultExports &&
                  t().isExportDefaultDeclaration(parent, {
                    declaration: node,
                  })) ||
                (considerArrow &&
                  t().isArrowFunctionExpression(parent, {
                    body: node,
                  }))
              ) {
                return true;
              }

              if (
                t().isCallExpression(parent, {
                  callee: node,
                }) ||
                (t().isSequenceExpression(parent) &&
                  parent.expressions[0] === node) ||
                t().isMemberExpression(parent, {
                  object: node,
                }) ||
                t().isConditional(parent, {
                  test: node,
                }) ||
                t().isBinary(parent, {
                  left: node,
                }) ||
                t().isAssignmentExpression(parent, {
                  left: node,
                })
              ) {
                node = parent;
                i--;
                parent = printStack[i];
              } else {
                return false;
              }
            }

            return false;
          }
        },
        /* 352 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });

          var _templateLiterals = __webpack_require__(353);

          Object.keys(_templateLiterals).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _templateLiterals[key];
              },
            });
          });

          var _expressions = __webpack_require__(354);

          Object.keys(_expressions).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _expressions[key];
              },
            });
          });

          var _statements = __webpack_require__(355);

          Object.keys(_statements).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _statements[key];
              },
            });
          });

          var _classes = __webpack_require__(356);

          Object.keys(_classes).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _classes[key];
              },
            });
          });

          var _methods = __webpack_require__(357);

          Object.keys(_methods).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _methods[key];
              },
            });
          });

          var _modules = __webpack_require__(146);

          Object.keys(_modules).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _modules[key];
              },
            });
          });

          var _types = __webpack_require__(79);

          Object.keys(_types).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _types[key];
              },
            });
          });

          var _flow = __webpack_require__(362);

          Object.keys(_flow).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _flow[key];
              },
            });
          });

          var _base = __webpack_require__(363);

          Object.keys(_base).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _base[key];
              },
            });
          });

          var _jsx = __webpack_require__(364);

          Object.keys(_jsx).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _jsx[key];
              },
            });
          });

          var _typescript = __webpack_require__(365);

          Object.keys(_typescript).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _typescript[key];
              },
            });
          });
        },
        /* 353 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.TaggedTemplateExpression = TaggedTemplateExpression;
          exports.TemplateElement = TemplateElement;
          exports.TemplateLiteral = TemplateLiteral;

          function TaggedTemplateExpression(node) {
            this.print(node.tag, node);
            this.print(node.typeParameters, node);
            this.print(node.quasi, node);
          }

          function TemplateElement(node, parent) {
            var isFirst = parent.quasis[0] === node;
            var isLast = parent.quasis[parent.quasis.length - 1] === node;
            var value =
              (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
            this.token(value);
          }

          function TemplateLiteral(node) {
            var quasis = node.quasis;

            for (var i = 0; i < quasis.length; i++) {
              this.print(quasis[i], node);

              if (i + 1 < quasis.length) {
                this.print(node.expressions[i], node);
              }
            }
          }
        },
        /* 354 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.UnaryExpression = UnaryExpression;
          exports.DoExpression = DoExpression;
          exports.ParenthesizedExpression = ParenthesizedExpression;
          exports.UpdateExpression = UpdateExpression;
          exports.ConditionalExpression = ConditionalExpression;
          exports.NewExpression = NewExpression;
          exports.SequenceExpression = SequenceExpression;
          exports.ThisExpression = ThisExpression;
          exports.Super = Super;
          exports.Decorator = Decorator;
          exports.OptionalMemberExpression = OptionalMemberExpression;
          exports.OptionalCallExpression = OptionalCallExpression;
          exports.CallExpression = CallExpression;
          exports.Import = Import;
          exports.EmptyStatement = EmptyStatement;
          exports.ExpressionStatement = ExpressionStatement;
          exports.AssignmentPattern = AssignmentPattern;
          exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
          exports.BindExpression = BindExpression;
          exports.MemberExpression = MemberExpression;
          exports.MetaProperty = MetaProperty;
          exports.PrivateName = PrivateName;
          exports.AwaitExpression = exports.YieldExpression = void 0;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          var n = _interopRequireWildcard(__webpack_require__(145));

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function UnaryExpression(node) {
            if (
              node.operator === "void" ||
              node.operator === "delete" ||
              node.operator === "typeof"
            ) {
              this.word(node.operator);
              this.space();
            } else {
              this.token(node.operator);
            }

            this.print(node.argument, node);
          }

          function DoExpression(node) {
            this.word("do");
            this.space();
            this.print(node.body, node);
          }

          function ParenthesizedExpression(node) {
            this.token("(");
            this.print(node.expression, node);
            this.token(")");
          }

          function UpdateExpression(node) {
            if (node.prefix) {
              this.token(node.operator);
              this.print(node.argument, node);
            } else {
              this.startTerminatorless(true);
              this.print(node.argument, node);
              this.endTerminatorless();
              this.token(node.operator);
            }
          }

          function ConditionalExpression(node) {
            this.print(node.test, node);
            this.space();
            this.token("?");
            this.space();
            this.print(node.consequent, node);
            this.space();
            this.token(":");
            this.space();
            this.print(node.alternate, node);
          }

          function NewExpression(node, parent) {
            this.word("new");
            this.space();
            this.print(node.callee, node);

            if (
              this.format.minified &&
              node.arguments.length === 0 &&
              !node.optional &&
              !t().isCallExpression(parent, {
                callee: node,
              }) &&
              !t().isMemberExpression(parent) &&
              !t().isNewExpression(parent)
            ) {
              return;
            }

            this.print(node.typeArguments, node);
            this.print(node.typeParameters, node);

            if (node.optional) {
              this.token("?.");
            }

            this.token("(");
            this.printList(node.arguments, node);
            this.token(")");
          }

          function SequenceExpression(node) {
            this.printList(node.expressions, node);
          }

          function ThisExpression() {
            this.word("this");
          }

          function Super() {
            this.word("super");
          }

          function Decorator(node) {
            this.token("@");
            this.print(node.expression, node);
            this.newline();
          }

          function OptionalMemberExpression(node) {
            this.print(node.object, node);

            if (!node.computed && t().isMemberExpression(node.property)) {
              throw new TypeError(
                "Got a MemberExpression for MemberExpression property"
              );
            }

            var computed = node.computed;

            if (
              t().isLiteral(node.property) &&
              typeof node.property.value === "number"
            ) {
              computed = true;
            }

            if (node.optional) {
              this.token("?.");
            }

            if (computed) {
              this.token("[");
              this.print(node.property, node);
              this.token("]");
            } else {
              if (!node.optional) {
                this.token(".");
              }

              this.print(node.property, node);
            }
          }

          function OptionalCallExpression(node) {
            this.print(node.callee, node);
            this.print(node.typeArguments, node);
            this.print(node.typeParameters, node);

            if (node.optional) {
              this.token("?.");
            }

            this.token("(");
            this.printList(node.arguments, node);
            this.token(")");
          }

          function CallExpression(node) {
            this.print(node.callee, node);
            this.print(node.typeArguments, node);
            this.print(node.typeParameters, node);
            this.token("(");
            this.printList(node.arguments, node);
            this.token(")");
          }

          function Import() {
            this.word("import");
          }

          function buildYieldAwait(keyword) {
            return function(node) {
              this.word(keyword);

              if (node.delegate) {
                this.token("*");
              }

              if (node.argument) {
                this.space();
                var terminatorState = this.startTerminatorless();
                this.print(node.argument, node);
                this.endTerminatorless(terminatorState);
              }
            };
          }

          var YieldExpression = buildYieldAwait("yield");
          exports.YieldExpression = YieldExpression;
          var AwaitExpression = buildYieldAwait("await");
          exports.AwaitExpression = AwaitExpression;

          function EmptyStatement() {
            this.semicolon(true);
          }

          function ExpressionStatement(node) {
            this.print(node.expression, node);
            this.semicolon();
          }

          function AssignmentPattern(node) {
            this.print(node.left, node);
            if (node.left.optional) this.token("?");
            this.print(node.left.typeAnnotation, node);
            this.space();
            this.token("=");
            this.space();
            this.print(node.right, node);
          }

          function AssignmentExpression(node, parent) {
            var parens =
              this.inForStatementInitCounter &&
              node.operator === "in" &&
              !n.needsParens(node, parent);

            if (parens) {
              this.token("(");
            }

            this.print(node.left, node);
            this.space();

            if (node.operator === "in" || node.operator === "instanceof") {
              this.word(node.operator);
            } else {
              this.token(node.operator);
            }

            this.space();
            this.print(node.right, node);

            if (parens) {
              this.token(")");
            }
          }

          function BindExpression(node) {
            this.print(node.object, node);
            this.token("::");
            this.print(node.callee, node);
          }

          function MemberExpression(node) {
            this.print(node.object, node);

            if (!node.computed && t().isMemberExpression(node.property)) {
              throw new TypeError(
                "Got a MemberExpression for MemberExpression property"
              );
            }

            var computed = node.computed;

            if (
              t().isLiteral(node.property) &&
              typeof node.property.value === "number"
            ) {
              computed = true;
            }

            if (computed) {
              this.token("[");
              this.print(node.property, node);
              this.token("]");
            } else {
              this.token(".");
              this.print(node.property, node);
            }
          }

          function MetaProperty(node) {
            this.print(node.meta, node);
            this.token(".");
            this.print(node.property, node);
          }

          function PrivateName(node) {
            this.token("#");
            this.print(node.id, node);
          }
        },
        /* 355 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.WithStatement = WithStatement;
          exports.IfStatement = IfStatement;
          exports.ForStatement = ForStatement;
          exports.WhileStatement = WhileStatement;
          exports.DoWhileStatement = DoWhileStatement;
          exports.LabeledStatement = LabeledStatement;
          exports.TryStatement = TryStatement;
          exports.CatchClause = CatchClause;
          exports.SwitchStatement = SwitchStatement;
          exports.SwitchCase = SwitchCase;
          exports.DebuggerStatement = DebuggerStatement;
          exports.VariableDeclaration = VariableDeclaration;
          exports.VariableDeclarator = VariableDeclarator;
          exports.ThrowStatement = exports.BreakStatement = exports.ReturnStatement = exports.ContinueStatement = exports.ForOfStatement = exports.ForInStatement = void 0;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function WithStatement(node) {
            this.word("with");
            this.space();
            this.token("(");
            this.print(node.object, node);
            this.token(")");
            this.printBlock(node);
          }

          function IfStatement(node) {
            this.word("if");
            this.space();
            this.token("(");
            this.print(node.test, node);
            this.token(")");
            this.space();
            var needsBlock =
              node.alternate &&
              t().isIfStatement(getLastStatement(node.consequent));

            if (needsBlock) {
              this.token("{");
              this.newline();
              this.indent();
            }

            this.printAndIndentOnComments(node.consequent, node);

            if (needsBlock) {
              this.dedent();
              this.newline();
              this.token("}");
            }

            if (node.alternate) {
              if (this.endsWith("}")) this.space();
              this.word("else");
              this.space();
              this.printAndIndentOnComments(node.alternate, node);
            }
          }

          function getLastStatement(statement) {
            if (!t().isStatement(statement.body)) return statement;
            return getLastStatement(statement.body);
          }

          function ForStatement(node) {
            this.word("for");
            this.space();
            this.token("(");
            this.inForStatementInitCounter++;
            this.print(node.init, node);
            this.inForStatementInitCounter--;
            this.token(";");

            if (node.test) {
              this.space();
              this.print(node.test, node);
            }

            this.token(";");

            if (node.update) {
              this.space();
              this.print(node.update, node);
            }

            this.token(")");
            this.printBlock(node);
          }

          function WhileStatement(node) {
            this.word("while");
            this.space();
            this.token("(");
            this.print(node.test, node);
            this.token(")");
            this.printBlock(node);
          }

          var buildForXStatement = function buildForXStatement(op) {
            return function(node) {
              this.word("for");
              this.space();

              if (op === "of" && node.await) {
                this.word("await");
                this.space();
              }

              this.token("(");
              this.print(node.left, node);
              this.space();
              this.word(op);
              this.space();
              this.print(node.right, node);
              this.token(")");
              this.printBlock(node);
            };
          };

          var ForInStatement = buildForXStatement("in");
          exports.ForInStatement = ForInStatement;
          var ForOfStatement = buildForXStatement("of");
          exports.ForOfStatement = ForOfStatement;

          function DoWhileStatement(node) {
            this.word("do");
            this.space();
            this.print(node.body, node);
            this.space();
            this.word("while");
            this.space();
            this.token("(");
            this.print(node.test, node);
            this.token(")");
            this.semicolon();
          }

          function buildLabelStatement(prefix, key) {
            if (key === void 0) {
              key = "label";
            }

            return function(node) {
              this.word(prefix);
              var label = node[key];

              if (label) {
                this.space();
                var isLabel = key == "label";
                var terminatorState = this.startTerminatorless(isLabel);
                this.print(label, node);
                this.endTerminatorless(terminatorState);
              }

              this.semicolon();
            };
          }

          var ContinueStatement = buildLabelStatement("continue");
          exports.ContinueStatement = ContinueStatement;
          var ReturnStatement = buildLabelStatement("return", "argument");
          exports.ReturnStatement = ReturnStatement;
          var BreakStatement = buildLabelStatement("break");
          exports.BreakStatement = BreakStatement;
          var ThrowStatement = buildLabelStatement("throw", "argument");
          exports.ThrowStatement = ThrowStatement;

          function LabeledStatement(node) {
            this.print(node.label, node);
            this.token(":");
            this.space();
            this.print(node.body, node);
          }

          function TryStatement(node) {
            this.word("try");
            this.space();
            this.print(node.block, node);
            this.space();

            if (node.handlers) {
              this.print(node.handlers[0], node);
            } else {
              this.print(node.handler, node);
            }

            if (node.finalizer) {
              this.space();
              this.word("finally");
              this.space();
              this.print(node.finalizer, node);
            }
          }

          function CatchClause(node) {
            this.word("catch");
            this.space();

            if (node.param) {
              this.token("(");
              this.print(node.param, node);
              this.token(")");
              this.space();
            }

            this.print(node.body, node);
          }

          function SwitchStatement(node) {
            this.word("switch");
            this.space();
            this.token("(");
            this.print(node.discriminant, node);
            this.token(")");
            this.space();
            this.token("{");
            this.printSequence(node.cases, node, {
              indent: true,
              addNewlines: function addNewlines(leading, cas) {
                if (!leading && node.cases[node.cases.length - 1] === cas)
                  return -1;
              },
            });
            this.token("}");
          }

          function SwitchCase(node) {
            if (node.test) {
              this.word("case");
              this.space();
              this.print(node.test, node);
              this.token(":");
            } else {
              this.word("default");
              this.token(":");
            }

            if (node.consequent.length) {
              this.newline();
              this.printSequence(node.consequent, node, {
                indent: true,
              });
            }
          }

          function DebuggerStatement() {
            this.word("debugger");
            this.semicolon();
          }

          function variableDeclarationIndent() {
            this.token(",");
            this.newline();
            if (this.endsWith("\n"))
              for (var i = 0; i < 4; i++) {
                this.space(true);
              }
          }

          function constDeclarationIndent() {
            this.token(",");
            this.newline();
            if (this.endsWith("\n"))
              for (var i = 0; i < 6; i++) {
                this.space(true);
              }
          }

          function VariableDeclaration(node, parent) {
            if (node.declare) {
              this.word("declare");
              this.space();
            }

            this.word(node.kind);
            this.space();
            var hasInits = false;

            if (!t().isFor(parent)) {
              for (
                var _iterator = node.declarations,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var declar = _ref;

                if (declar.init) {
                  hasInits = true;
                }
              }
            }

            var separator;

            if (hasInits) {
              separator =
                node.kind === "const"
                  ? constDeclarationIndent
                  : variableDeclarationIndent;
            }

            this.printList(node.declarations, node, {
              separator: separator,
            });

            if (t().isFor(parent)) {
              if (parent.left === node || parent.init === node) return;
            }

            this.semicolon();
          }

          function VariableDeclarator(node) {
            this.print(node.id, node);
            if (node.definite) this.token("!");
            this.print(node.id.typeAnnotation, node);

            if (node.init) {
              this.space();
              this.token("=");
              this.space();
              this.print(node.init, node);
            }
          }
        },
        /* 356 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
          exports.ClassBody = ClassBody;
          exports.ClassProperty = ClassProperty;
          exports.ClassPrivateProperty = ClassPrivateProperty;
          exports.ClassMethod = ClassMethod;
          exports._classMethodHead = _classMethodHead;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function ClassDeclaration(node, parent) {
            if (
              !this.format.decoratorsBeforeExport ||
              (!t().isExportDefaultDeclaration(parent) &&
                !t().isExportNamedDeclaration(parent))
            ) {
              this.printJoin(node.decorators, node);
            }

            if (node.declare) {
              this.word("declare");
              this.space();
            }

            if (node.abstract) {
              this.word("abstract");
              this.space();
            }

            this.word("class");

            if (node.id) {
              this.space();
              this.print(node.id, node);
            }

            this.print(node.typeParameters, node);

            if (node.superClass) {
              this.space();
              this.word("extends");
              this.space();
              this.print(node.superClass, node);
              this.print(node.superTypeParameters, node);
            }

            if (node.implements) {
              this.space();
              this.word("implements");
              this.space();
              this.printList(node.implements, node);
            }

            this.space();
            this.print(node.body, node);
          }

          function ClassBody(node) {
            this.token("{");
            this.printInnerComments(node);

            if (node.body.length === 0) {
              this.token("}");
            } else {
              this.newline();
              this.indent();
              this.printSequence(node.body, node);
              this.dedent();
              if (!this.endsWith("\n")) this.newline();
              this.rightBrace();
            }
          }

          function ClassProperty(node) {
            this.printJoin(node.decorators, node);

            if (node.accessibility) {
              this.word(node.accessibility);
              this.space();
            }

            if (node.static) {
              this.word("static");
              this.space();
            }

            if (node.abstract) {
              this.word("abstract");
              this.space();
            }

            if (node.readonly) {
              this.word("readonly");
              this.space();
            }

            if (node.computed) {
              this.token("[");
              this.print(node.key, node);
              this.token("]");
            } else {
              this._variance(node);

              this.print(node.key, node);
            }

            if (node.optional) {
              this.token("?");
            }

            if (node.definite) {
              this.token("!");
            }

            this.print(node.typeAnnotation, node);

            if (node.value) {
              this.space();
              this.token("=");
              this.space();
              this.print(node.value, node);
            }

            this.semicolon();
          }

          function ClassPrivateProperty(node) {
            if (node.static) {
              this.word("static");
              this.space();
            }

            this.print(node.key, node);
            this.print(node.typeAnnotation, node);

            if (node.value) {
              this.space();
              this.token("=");
              this.space();
              this.print(node.value, node);
            }

            this.semicolon();
          }

          function ClassMethod(node) {
            this._classMethodHead(node);

            this.space();
            this.print(node.body, node);
          }

          function _classMethodHead(node) {
            this.printJoin(node.decorators, node);

            if (node.accessibility) {
              this.word(node.accessibility);
              this.space();
            }

            if (node.abstract) {
              this.word("abstract");
              this.space();
            }

            if (node.static) {
              this.word("static");
              this.space();
            }

            this._methodHead(node);
          }
        },
        /* 357 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports._params = _params;
          exports._parameters = _parameters;
          exports._param = _param;
          exports._methodHead = _methodHead;
          exports._predicate = _predicate;
          exports._functionHead = _functionHead;
          exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
          exports.ArrowFunctionExpression = ArrowFunctionExpression;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _params(node) {
            this.print(node.typeParameters, node);
            this.token("(");

            this._parameters(node.params, node);

            this.token(")");
            this.print(node.returnType, node);
          }

          function _parameters(parameters, parent) {
            for (var i = 0; i < parameters.length; i++) {
              this._param(parameters[i], parent);

              if (i < parameters.length - 1) {
                this.token(",");
                this.space();
              }
            }
          }

          function _param(parameter, parent) {
            this.printJoin(parameter.decorators, parameter);
            this.print(parameter, parent);
            if (parameter.optional) this.token("?");
            this.print(parameter.typeAnnotation, parameter);
          }

          function _methodHead(node) {
            var kind = node.kind;
            var key = node.key;

            if (kind === "get" || kind === "set") {
              this.word(kind);
              this.space();
            }

            if (node.async) {
              this.word("async");
              this.space();
            }

            if (kind === "method" || kind === "init") {
              if (node.generator) {
                this.token("*");
              }
            }

            if (node.computed) {
              this.token("[");
              this.print(key, node);
              this.token("]");
            } else {
              this.print(key, node);
            }

            if (node.optional) {
              this.token("?");
            }

            this._params(node);
          }

          function _predicate(node) {
            if (node.predicate) {
              if (!node.returnType) {
                this.token(":");
              }

              this.space();
              this.print(node.predicate, node);
            }
          }

          function _functionHead(node) {
            if (node.async) {
              this.word("async");
              this.space();
            }

            this.word("function");
            if (node.generator) this.token("*");
            this.space();

            if (node.id) {
              this.print(node.id, node);
            }

            this._params(node);

            this._predicate(node);
          }

          function FunctionExpression(node) {
            this._functionHead(node);

            this.space();
            this.print(node.body, node);
          }

          function ArrowFunctionExpression(node) {
            if (node.async) {
              this.word("async");
              this.space();
            }

            var firstParam = node.params[0];

            if (
              node.params.length === 1 &&
              t().isIdentifier(firstParam) &&
              !hasTypes(node, firstParam)
            ) {
              this.print(firstParam, node);
            } else {
              this._params(node);
            }

            this._predicate(node);

            this.space();
            this.token("=>");
            this.space();
            this.print(node.body, node);
          }

          function hasTypes(node, param) {
            return (
              node.typeParameters ||
              node.returnType ||
              param.typeAnnotation ||
              param.optional ||
              param.trailingComments
            );
          }
        },
        /* 358 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(Buffer) {
            var object = {};
            var hasOwnProperty = object.hasOwnProperty;

            var forOwn = function forOwn(object, callback) {
              for (var key in object) {
                if (hasOwnProperty.call(object, key)) {
                  callback(key, object[key]);
                }
              }
            };

            var extend = function extend(destination, source) {
              if (!source) {
                return destination;
              }

              forOwn(source, function(key, value) {
                destination[key] = value;
              });
              return destination;
            };

            var forEach = function forEach(array, callback) {
              var length = array.length;
              var index = -1;

              while (++index < length) {
                callback(array[index]);
              }
            };

            var toString = object.toString;
            var isArray = Array.isArray;
            var isBuffer = Buffer.isBuffer;

            var isObject = function isObject(value) {
              return toString.call(value) == "[object Object]";
            };

            var isString = function isString(value) {
              return (
                typeof value == "string" ||
                toString.call(value) == "[object String]"
              );
            };

            var isNumber = function isNumber(value) {
              return (
                typeof value == "number" ||
                toString.call(value) == "[object Number]"
              );
            };

            var isFunction = function isFunction(value) {
              return typeof value == "function";
            };

            var isMap = function isMap(value) {
              return toString.call(value) == "[object Map]";
            };

            var isSet = function isSet(value) {
              return toString.call(value) == "[object Set]";
            };

            var singleEscapes = {
              '"': '\\"',
              "'": "\\'",
              "\\": "\\\\",
              "\b": "\\b",
              "\f": "\\f",
              "\n": "\\n",
              "\r": "\\r",
              "\t": "\\t",
            };
            var regexSingleEscape = /["'\\\b\f\n\r\t]/;
            var regexDigit = /[0-9]/;
            var regexWhitelist = /[ !#-&\(-\[\]-~]/;

            var jsesc = function jsesc(argument, options) {
              var increaseIndentation = function increaseIndentation() {
                oldIndent = indent;
                ++options.indentLevel;
                indent = options.indent.repeat(options.indentLevel);
              };

              var defaults = {
                escapeEverything: false,
                minimal: false,
                isScriptContext: false,
                quotes: "single",
                wrap: false,
                es6: false,
                json: false,
                compact: true,
                lowercaseHex: false,
                numbers: "decimal",
                indent: "\t",
                indentLevel: 0,
                __inline1__: false,
                __inline2__: false,
              };
              var json = options && options.json;

              if (json) {
                defaults.quotes = "double";
                defaults.wrap = true;
              }

              options = extend(defaults, options);

              if (
                options.quotes != "single" &&
                options.quotes != "double" &&
                options.quotes != "backtick"
              ) {
                options.quotes = "single";
              }

              var quote =
                options.quotes == "double"
                  ? '"'
                  : options.quotes == "backtick"
                    ? "`"
                    : "'";
              var compact = options.compact;
              var lowercaseHex = options.lowercaseHex;
              var indent = options.indent.repeat(options.indentLevel);
              var oldIndent = "";
              var inline1 = options.__inline1__;
              var inline2 = options.__inline2__;
              var newLine = compact ? "" : "\n";
              var result;
              var isEmpty = true;
              var useBinNumbers = options.numbers == "binary";
              var useOctNumbers = options.numbers == "octal";
              var useDecNumbers = options.numbers == "decimal";
              var useHexNumbers = options.numbers == "hexadecimal";

              if (json && argument && isFunction(argument.toJSON)) {
                argument = argument.toJSON();
              }

              if (!isString(argument)) {
                if (isMap(argument)) {
                  if (argument.size == 0) {
                    return "new Map()";
                  }

                  if (!compact) {
                    options.__inline1__ = true;
                    options.__inline2__ = false;
                  }

                  return (
                    "new Map(" + jsesc(Array.from(argument), options) + ")"
                  );
                }

                if (isSet(argument)) {
                  if (argument.size == 0) {
                    return "new Set()";
                  }

                  return (
                    "new Set(" + jsesc(Array.from(argument), options) + ")"
                  );
                }

                if (isBuffer(argument)) {
                  if (argument.length == 0) {
                    return "Buffer.from([])";
                  }

                  return (
                    "Buffer.from(" + jsesc(Array.from(argument), options) + ")"
                  );
                }

                if (isArray(argument)) {
                  result = [];
                  options.wrap = true;

                  if (inline1) {
                    options.__inline1__ = false;
                    options.__inline2__ = true;
                  }

                  if (!inline2) {
                    increaseIndentation();
                  }

                  forEach(argument, function(value) {
                    isEmpty = false;

                    if (inline2) {
                      options.__inline2__ = false;
                    }

                    result.push(
                      (compact || inline2 ? "" : indent) + jsesc(value, options)
                    );
                  });

                  if (isEmpty) {
                    return "[]";
                  }

                  if (inline2) {
                    return "[" + result.join(", ") + "]";
                  }

                  return (
                    "[" +
                    newLine +
                    result.join("," + newLine) +
                    newLine +
                    (compact ? "" : oldIndent) +
                    "]"
                  );
                } else if (isNumber(argument)) {
                  if (json) {
                    return JSON.stringify(argument);
                  }

                  if (useDecNumbers) {
                    return String(argument);
                  }

                  if (useHexNumbers) {
                    var hexadecimal = argument.toString(16);

                    if (!lowercaseHex) {
                      hexadecimal = hexadecimal.toUpperCase();
                    }

                    return "0x" + hexadecimal;
                  }

                  if (useBinNumbers) {
                    return "0b" + argument.toString(2);
                  }

                  if (useOctNumbers) {
                    return "0o" + argument.toString(8);
                  }
                } else if (!isObject(argument)) {
                  if (json) {
                    return JSON.stringify(argument) || "null";
                  }

                  return String(argument);
                } else {
                  result = [];
                  options.wrap = true;
                  increaseIndentation();
                  forOwn(argument, function(key, value) {
                    isEmpty = false;
                    result.push(
                      (compact ? "" : indent) +
                        jsesc(key, options) +
                        ":" +
                        (compact ? "" : " ") +
                        jsesc(value, options)
                    );
                  });

                  if (isEmpty) {
                    return "{}";
                  }

                  return (
                    "{" +
                    newLine +
                    result.join("," + newLine) +
                    newLine +
                    (compact ? "" : oldIndent) +
                    "}"
                  );
                }
              }

              var string = argument;
              var index = -1;
              var length = string.length;
              result = "";

              while (++index < length) {
                var character = string.charAt(index);

                if (options.es6) {
                  var first = string.charCodeAt(index);

                  if (
                    first >= 0xd800 &&
                    first <= 0xdbff &&
                    length > index + 1
                  ) {
                    var second = string.charCodeAt(index + 1);

                    if (second >= 0xdc00 && second <= 0xdfff) {
                      var codePoint =
                        (first - 0xd800) * 0x400 + second - 0xdc00 + 0x10000;

                      var _hexadecimal2 = codePoint.toString(16);

                      if (!lowercaseHex) {
                        _hexadecimal2 = _hexadecimal2.toUpperCase();
                      }

                      result += "\\u{" + _hexadecimal2 + "}";
                      ++index;
                      continue;
                    }
                  }
                }

                if (!options.escapeEverything) {
                  if (regexWhitelist.test(character)) {
                    result += character;
                    continue;
                  }

                  if (character == '"') {
                    result += quote == character ? '\\"' : character;
                    continue;
                  }

                  if (character == "`") {
                    result += quote == character ? "\\`" : character;
                    continue;
                  }

                  if (character == "'") {
                    result += quote == character ? "\\'" : character;
                    continue;
                  }
                }

                if (
                  character == "\0" &&
                  !json &&
                  !regexDigit.test(string.charAt(index + 1))
                ) {
                  result += "\\0";
                  continue;
                }

                if (regexSingleEscape.test(character)) {
                  result += singleEscapes[character];
                  continue;
                }

                var charCode = character.charCodeAt(0);

                if (
                  options.minimal &&
                  charCode != 0x2028 &&
                  charCode != 0x2029
                ) {
                  result += character;
                  continue;
                }

                var _hexadecimal = charCode.toString(16);

                if (!lowercaseHex) {
                  _hexadecimal = _hexadecimal.toUpperCase();
                }

                var longhand = _hexadecimal.length > 2 || json;

                var escaped =
                  "\\" +
                  (longhand ? "u" : "x") +
                  ("0000" + _hexadecimal).slice(longhand ? -4 : -2);

                result += escaped;
                continue;
              }

              if (options.wrap) {
                result = quote + result + quote;
              }

              if (quote == "`") {
                result = result.replace(/\$\{/g, "\\${");
              }

              if (options.isScriptContext) {
                return result
                  .replace(/<\/(script|style)/gi, "<\\/$1")
                  .replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
              }

              return result;
            };

            jsesc.version = "2.5.1";
            module.exports = jsesc;
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(147).Buffer));
        },
        /* 359 */
        function(module, exports, __webpack_require__) {
          "use strict";

          exports.byteLength = byteLength;
          exports.toByteArray = toByteArray;
          exports.fromByteArray = fromByteArray;
          var lookup = [];
          var revLookup = [];
          var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
          var code =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

          for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
          }

          revLookup["-".charCodeAt(0)] = 62;
          revLookup["_".charCodeAt(0)] = 63;

          function getLens(b64) {
            var len = b64.length;

            if (len % 4 > 0) {
              throw new Error("Invalid string. Length must be a multiple of 4");
            }

            var validLen = b64.indexOf("=");
            if (validLen === -1) validLen = len;
            var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);
            return [validLen, placeHoldersLen];
          }

          function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
          }

          function _byteLength(b64, validLen, placeHoldersLen) {
            return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
          }

          function toByteArray(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

            for (var i = 0; i < len; i += 4) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 18) |
                (revLookup[b64.charCodeAt(i + 1)] << 12) |
                (revLookup[b64.charCodeAt(i + 2)] << 6) |
                revLookup[b64.charCodeAt(i + 3)];
              arr[curByte++] = (tmp >> 16) & 0xff;
              arr[curByte++] = (tmp >> 8) & 0xff;
              arr[curByte++] = tmp & 0xff;
            }

            if (placeHoldersLen === 2) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 2) |
                (revLookup[b64.charCodeAt(i + 1)] >> 4);
              arr[curByte++] = tmp & 0xff;
            }

            if (placeHoldersLen === 1) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 10) |
                (revLookup[b64.charCodeAt(i + 1)] << 4) |
                (revLookup[b64.charCodeAt(i + 2)] >> 2);
              arr[curByte++] = (tmp >> 8) & 0xff;
              arr[curByte++] = tmp & 0xff;
            }

            return arr;
          }

          function tripletToBase64(num) {
            return (
              lookup[(num >> 18) & 0x3f] +
              lookup[(num >> 12) & 0x3f] +
              lookup[(num >> 6) & 0x3f] +
              lookup[num & 0x3f]
            );
          }

          function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];

            for (var i = start; i < end; i += 3) {
              tmp =
                ((uint8[i] << 16) & 0xff0000) +
                ((uint8[i + 1] << 8) & 0xff00) +
                (uint8[i + 2] & 0xff);
              output.push(tripletToBase64(tmp));
            }

            return output.join("");
          }

          function fromByteArray(uint8) {
            var tmp;
            var len = uint8.length;
            var extraBytes = len % 3;
            var parts = [];
            var maxChunkLength = 16383;

            for (
              var i = 0, len2 = len - extraBytes;
              i < len2;
              i += maxChunkLength
            ) {
              parts.push(
                encodeChunk(
                  uint8,
                  i,
                  i + maxChunkLength > len2 ? len2 : i + maxChunkLength
                )
              );
            }

            if (extraBytes === 1) {
              tmp = uint8[len - 1];
              parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==");
            } else if (extraBytes === 2) {
              tmp = (uint8[len - 2] << 8) + uint8[len - 1];
              parts.push(
                lookup[tmp >> 10] +
                  lookup[(tmp >> 4) & 0x3f] +
                  lookup[(tmp << 2) & 0x3f] +
                  "="
              );
            }

            return parts.join("");
          }
        },
        /* 360 */
        function(module, exports) {
          exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & ((1 << -nBits) - 1);
            s >>= -nBits;
            nBits += eLen;

            for (
              ;
              nBits > 0;
              e = e * 256 + buffer[offset + i], i += d, nBits -= 8
            ) {}

            m = e & ((1 << -nBits) - 1);
            e >>= -nBits;
            nBits += mLen;

            for (
              ;
              nBits > 0;
              m = m * 256 + buffer[offset + i], i += d, nBits -= 8
            ) {}

            if (e === 0) {
              e = 1 - eBias;
            } else if (e === eMax) {
              return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
              m = m + Math.pow(2, mLen);
              e = e - eBias;
            }

            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          };

          exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
            value = Math.abs(value);

            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0;
              e = eMax;
            } else {
              e = Math.floor(Math.log(value) / Math.LN2);

              if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
              }

              if (e + eBias >= 1) {
                value += rt / c;
              } else {
                value += rt * Math.pow(2, 1 - eBias);
              }

              if (value * c >= 2) {
                e++;
                c /= 2;
              }

              if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
              } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
              }
            }

            for (
              ;
              mLen >= 8;
              buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
            ) {}

            e = (e << mLen) | m;
            eLen += mLen;

            for (
              ;
              eLen > 0;
              buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
            ) {}

            buffer[offset + i - d] |= s * 128;
          };
        },
        /* 361 */
        function(module, exports) {
          var toString = {}.toString;

          module.exports =
            Array.isArray ||
            function(arr) {
              return toString.call(arr) == "[object Array]";
            };
        },
        /* 362 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.AnyTypeAnnotation = AnyTypeAnnotation;
          exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
          exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
          exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
          exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
          exports.DeclareClass = DeclareClass;
          exports.DeclareFunction = DeclareFunction;
          exports.InferredPredicate = InferredPredicate;
          exports.DeclaredPredicate = DeclaredPredicate;
          exports.DeclareInterface = DeclareInterface;
          exports.DeclareModule = DeclareModule;
          exports.DeclareModuleExports = DeclareModuleExports;
          exports.DeclareTypeAlias = DeclareTypeAlias;
          exports.DeclareOpaqueType = DeclareOpaqueType;
          exports.DeclareVariable = DeclareVariable;
          exports.DeclareExportDeclaration = DeclareExportDeclaration;
          exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
          exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
          exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
          exports.FunctionTypeParam = FunctionTypeParam;
          exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
          exports._interfaceish = _interfaceish;
          exports._variance = _variance;
          exports.InterfaceDeclaration = InterfaceDeclaration;
          exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
          exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
          exports.MixedTypeAnnotation = MixedTypeAnnotation;
          exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
          exports.NullableTypeAnnotation = NullableTypeAnnotation;
          exports.NumberTypeAnnotation = NumberTypeAnnotation;
          exports.StringTypeAnnotation = StringTypeAnnotation;
          exports.ThisTypeAnnotation = ThisTypeAnnotation;
          exports.TupleTypeAnnotation = TupleTypeAnnotation;
          exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
          exports.TypeAlias = TypeAlias;
          exports.TypeAnnotation = TypeAnnotation;
          exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
          exports.TypeParameter = TypeParameter;
          exports.OpaqueType = OpaqueType;
          exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
          exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
          exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
          exports.ObjectTypeIndexer = ObjectTypeIndexer;
          exports.ObjectTypeProperty = ObjectTypeProperty;
          exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
          exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
          exports.UnionTypeAnnotation = UnionTypeAnnotation;
          exports.TypeCastExpression = TypeCastExpression;
          exports.Variance = Variance;
          exports.VoidTypeAnnotation = VoidTypeAnnotation;
          Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
            enumerable: true,
            get: function get() {
              return _types.NumericLiteral;
            },
          });
          Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
            enumerable: true,
            get: function get() {
              return _types.StringLiteral;
            },
          });

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          var _modules = __webpack_require__(146);

          var _types = __webpack_require__(79);

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function AnyTypeAnnotation() {
            this.word("any");
          }

          function ArrayTypeAnnotation(node) {
            this.print(node.elementType, node);
            this.token("[");
            this.token("]");
          }

          function BooleanTypeAnnotation() {
            this.word("boolean");
          }

          function BooleanLiteralTypeAnnotation(node) {
            this.word(node.value ? "true" : "false");
          }

          function NullLiteralTypeAnnotation() {
            this.word("null");
          }

          function DeclareClass(node, parent) {
            if (!t().isDeclareExportDeclaration(parent)) {
              this.word("declare");
              this.space();
            }

            this.word("class");
            this.space();

            this._interfaceish(node);
          }

          function DeclareFunction(node, parent) {
            if (!t().isDeclareExportDeclaration(parent)) {
              this.word("declare");
              this.space();
            }

            this.word("function");
            this.space();
            this.print(node.id, node);
            this.print(node.id.typeAnnotation.typeAnnotation, node);

            if (node.predicate) {
              this.space();
              this.print(node.predicate, node);
            }

            this.semicolon();
          }

          function InferredPredicate() {
            this.token("%");
            this.word("checks");
          }

          function DeclaredPredicate(node) {
            this.token("%");
            this.word("checks");
            this.token("(");
            this.print(node.value, node);
            this.token(")");
          }

          function DeclareInterface(node) {
            this.word("declare");
            this.space();
            this.InterfaceDeclaration(node);
          }

          function DeclareModule(node) {
            this.word("declare");
            this.space();
            this.word("module");
            this.space();
            this.print(node.id, node);
            this.space();
            this.print(node.body, node);
          }

          function DeclareModuleExports(node) {
            this.word("declare");
            this.space();
            this.word("module");
            this.token(".");
            this.word("exports");
            this.print(node.typeAnnotation, node);
          }

          function DeclareTypeAlias(node) {
            this.word("declare");
            this.space();
            this.TypeAlias(node);
          }

          function DeclareOpaqueType(node, parent) {
            if (!t().isDeclareExportDeclaration(parent)) {
              this.word("declare");
              this.space();
            }

            this.OpaqueType(node);
          }

          function DeclareVariable(node, parent) {
            if (!t().isDeclareExportDeclaration(parent)) {
              this.word("declare");
              this.space();
            }

            this.word("var");
            this.space();
            this.print(node.id, node);
            this.print(node.id.typeAnnotation, node);
            this.semicolon();
          }

          function DeclareExportDeclaration(node) {
            this.word("declare");
            this.space();
            this.word("export");
            this.space();

            if (node.default) {
              this.word("default");
              this.space();
            }

            FlowExportDeclaration.apply(this, arguments);
          }

          function DeclareExportAllDeclaration() {
            this.word("declare");
            this.space();

            _modules.ExportAllDeclaration.apply(this, arguments);
          }

          function FlowExportDeclaration(node) {
            if (node.declaration) {
              var declar = node.declaration;
              this.print(declar, node);
              if (!t().isStatement(declar)) this.semicolon();
            } else {
              this.token("{");

              if (node.specifiers.length) {
                this.space();
                this.printList(node.specifiers, node);
                this.space();
              }

              this.token("}");

              if (node.source) {
                this.space();
                this.word("from");
                this.space();
                this.print(node.source, node);
              }

              this.semicolon();
            }
          }

          function ExistsTypeAnnotation() {
            this.token("*");
          }

          function FunctionTypeAnnotation(node, parent) {
            this.print(node.typeParameters, node);
            this.token("(");
            this.printList(node.params, node);

            if (node.rest) {
              if (node.params.length) {
                this.token(",");
                this.space();
              }

              this.token("...");
              this.print(node.rest, node);
            }

            this.token(")");

            if (
              parent.type === "ObjectTypeCallProperty" ||
              parent.type === "DeclareFunction" ||
              (parent.type === "ObjectTypeProperty" && parent.method)
            ) {
              this.token(":");
            } else {
              this.space();
              this.token("=>");
            }

            this.space();
            this.print(node.returnType, node);
          }

          function FunctionTypeParam(node) {
            this.print(node.name, node);
            if (node.optional) this.token("?");

            if (node.name) {
              this.token(":");
              this.space();
            }

            this.print(node.typeAnnotation, node);
          }

          function InterfaceExtends(node) {
            this.print(node.id, node);
            this.print(node.typeParameters, node);
          }

          function _interfaceish(node) {
            this.print(node.id, node);
            this.print(node.typeParameters, node);

            if (node.extends.length) {
              this.space();
              this.word("extends");
              this.space();
              this.printList(node.extends, node);
            }

            if (node.mixins && node.mixins.length) {
              this.space();
              this.word("mixins");
              this.space();
              this.printList(node.mixins, node);
            }

            if (node.implements && node.implements.length) {
              this.space();
              this.word("implements");
              this.space();
              this.printList(node.implements, node);
            }

            this.space();
            this.print(node.body, node);
          }

          function _variance(node) {
            if (node.variance) {
              if (node.variance.kind === "plus") {
                this.token("+");
              } else if (node.variance.kind === "minus") {
                this.token("-");
              }
            }
          }

          function InterfaceDeclaration(node) {
            this.word("interface");
            this.space();

            this._interfaceish(node);
          }

          function andSeparator() {
            this.space();
            this.token("&");
            this.space();
          }

          function InterfaceTypeAnnotation(node) {
            this.word("interface");

            if (node.extends && node.extends.length) {
              this.space();
              this.word("extends");
              this.space();
              this.printList(node.extends, node);
            }

            this.space();
            this.print(node.body, node);
          }

          function IntersectionTypeAnnotation(node) {
            this.printJoin(node.types, node, {
              separator: andSeparator,
            });
          }

          function MixedTypeAnnotation() {
            this.word("mixed");
          }

          function EmptyTypeAnnotation() {
            this.word("empty");
          }

          function NullableTypeAnnotation(node) {
            this.token("?");
            this.print(node.typeAnnotation, node);
          }

          function NumberTypeAnnotation() {
            this.word("number");
          }

          function StringTypeAnnotation() {
            this.word("string");
          }

          function ThisTypeAnnotation() {
            this.word("this");
          }

          function TupleTypeAnnotation(node) {
            this.token("[");
            this.printList(node.types, node);
            this.token("]");
          }

          function TypeofTypeAnnotation(node) {
            this.word("typeof");
            this.space();
            this.print(node.argument, node);
          }

          function TypeAlias(node) {
            this.word("type");
            this.space();
            this.print(node.id, node);
            this.print(node.typeParameters, node);
            this.space();
            this.token("=");
            this.space();
            this.print(node.right, node);
            this.semicolon();
          }

          function TypeAnnotation(node) {
            this.token(":");
            this.space();
            if (node.optional) this.token("?");
            this.print(node.typeAnnotation, node);
          }

          function TypeParameterInstantiation(node) {
            this.token("<");
            this.printList(node.params, node, {});
            this.token(">");
          }

          function TypeParameter(node) {
            this._variance(node);

            this.word(node.name);

            if (node.bound) {
              this.print(node.bound, node);
            }

            if (node.default) {
              this.space();
              this.token("=");
              this.space();
              this.print(node.default, node);
            }
          }

          function OpaqueType(node) {
            this.word("opaque");
            this.space();
            this.word("type");
            this.space();
            this.print(node.id, node);
            this.print(node.typeParameters, node);

            if (node.supertype) {
              this.token(":");
              this.space();
              this.print(node.supertype, node);
            }

            if (node.impltype) {
              this.space();
              this.token("=");
              this.space();
              this.print(node.impltype, node);
            }

            this.semicolon();
          }

          function ObjectTypeAnnotation(node) {
            var _this = this;

            if (node.exact) {
              this.token("{|");
            } else {
              this.token("{");
            }

            var props = node.properties.concat(
              node.callProperties || [],
              node.indexers || [],
              node.internalSlots || []
            );

            if (props.length) {
              this.space();
              this.printJoin(props, node, {
                addNewlines: function addNewlines(leading) {
                  if (leading && !props[0]) return 1;
                },
                indent: true,
                statement: true,
                iterator: function iterator() {
                  if (props.length !== 1) {
                    _this.token(",");

                    _this.space();
                  }
                },
              });
              this.space();
            }

            if (node.exact) {
              this.token("|}");
            } else {
              this.token("}");
            }
          }

          function ObjectTypeInternalSlot(node) {
            if (node.static) {
              this.word("static");
              this.space();
            }

            this.token("[");
            this.token("[");
            this.print(node.id, node);
            this.token("]");
            this.token("]");
            if (node.optional) this.token("?");

            if (!node.method) {
              this.token(":");
              this.space();
            }

            this.print(node.value, node);
          }

          function ObjectTypeCallProperty(node) {
            if (node.static) {
              this.word("static");
              this.space();
            }

            this.print(node.value, node);
          }

          function ObjectTypeIndexer(node) {
            if (node.static) {
              this.word("static");
              this.space();
            }

            this._variance(node);

            this.token("[");

            if (node.id) {
              this.print(node.id, node);
              this.token(":");
              this.space();
            }

            this.print(node.key, node);
            this.token("]");
            this.token(":");
            this.space();
            this.print(node.value, node);
          }

          function ObjectTypeProperty(node) {
            if (node.proto) {
              this.word("proto");
              this.space();
            }

            if (node.static) {
              this.word("static");
              this.space();
            }

            this._variance(node);

            this.print(node.key, node);
            if (node.optional) this.token("?");

            if (!node.method) {
              this.token(":");
              this.space();
            }

            this.print(node.value, node);
          }

          function ObjectTypeSpreadProperty(node) {
            this.token("...");
            this.print(node.argument, node);
          }

          function QualifiedTypeIdentifier(node) {
            this.print(node.qualification, node);
            this.token(".");
            this.print(node.id, node);
          }

          function orSeparator() {
            this.space();
            this.token("|");
            this.space();
          }

          function UnionTypeAnnotation(node) {
            this.printJoin(node.types, node, {
              separator: orSeparator,
            });
          }

          function TypeCastExpression(node) {
            this.token("(");
            this.print(node.expression, node);
            this.print(node.typeAnnotation, node);
            this.token(")");
          }

          function Variance(node) {
            if (node.kind === "plus") {
              this.token("+");
            } else {
              this.token("-");
            }
          }

          function VoidTypeAnnotation() {
            this.word("void");
          }
        },
        /* 363 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.File = File;
          exports.Program = Program;
          exports.BlockStatement = BlockStatement;
          exports.Noop = Noop;
          exports.Directive = Directive;
          exports.InterpreterDirective = InterpreterDirective;
          Object.defineProperty(exports, "DirectiveLiteral", {
            enumerable: true,
            get: function get() {
              return _types.StringLiteral;
            },
          });

          var _types = __webpack_require__(79);

          function File(node) {
            if (node.program) {
              this.print(node.program.interpreter, node);
            }

            this.print(node.program, node);
          }

          function Program(node) {
            this.printInnerComments(node, false);
            this.printSequence(node.directives, node);
            if (node.directives && node.directives.length) this.newline();
            this.printSequence(node.body, node);
          }

          function BlockStatement(node) {
            this.token("{");
            this.printInnerComments(node);
            var hasDirectives = node.directives && node.directives.length;

            if (node.body.length || hasDirectives) {
              this.newline();
              this.printSequence(node.directives, node, {
                indent: true,
              });
              if (hasDirectives) this.newline();
              this.printSequence(node.body, node, {
                indent: true,
              });
              this.removeTrailingNewline();
              this.source("end", node.loc);
              if (!this.endsWith("\n")) this.newline();
              this.rightBrace();
            } else {
              this.source("end", node.loc);
              this.token("}");
            }
          }

          function Noop() {}

          function Directive(node) {
            this.print(node.value, node);
            this.semicolon();
          }

          function InterpreterDirective(node) {
            this.token("#!" + node.value + "\n");
          }
        },
        /* 364 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.JSXAttribute = JSXAttribute;
          exports.JSXIdentifier = JSXIdentifier;
          exports.JSXNamespacedName = JSXNamespacedName;
          exports.JSXMemberExpression = JSXMemberExpression;
          exports.JSXSpreadAttribute = JSXSpreadAttribute;
          exports.JSXExpressionContainer = JSXExpressionContainer;
          exports.JSXSpreadChild = JSXSpreadChild;
          exports.JSXText = JSXText;
          exports.JSXElement = JSXElement;
          exports.JSXOpeningElement = JSXOpeningElement;
          exports.JSXClosingElement = JSXClosingElement;
          exports.JSXEmptyExpression = JSXEmptyExpression;
          exports.JSXFragment = JSXFragment;
          exports.JSXOpeningFragment = JSXOpeningFragment;
          exports.JSXClosingFragment = JSXClosingFragment;

          function JSXAttribute(node) {
            this.print(node.name, node);

            if (node.value) {
              this.token("=");
              this.print(node.value, node);
            }
          }

          function JSXIdentifier(node) {
            this.word(node.name);
          }

          function JSXNamespacedName(node) {
            this.print(node.namespace, node);
            this.token(":");
            this.print(node.name, node);
          }

          function JSXMemberExpression(node) {
            this.print(node.object, node);
            this.token(".");
            this.print(node.property, node);
          }

          function JSXSpreadAttribute(node) {
            this.token("{");
            this.token("...");
            this.print(node.argument, node);
            this.token("}");
          }

          function JSXExpressionContainer(node) {
            this.token("{");
            this.print(node.expression, node);
            this.token("}");
          }

          function JSXSpreadChild(node) {
            this.token("{");
            this.token("...");
            this.print(node.expression, node);
            this.token("}");
          }

          function JSXText(node) {
            var raw = this.getPossibleRaw(node);

            if (raw != null) {
              this.token(raw);
            } else {
              this.token(node.value);
            }
          }

          function JSXElement(node) {
            var open = node.openingElement;
            this.print(open, node);
            if (open.selfClosing) return;
            this.indent();

            for (
              var _iterator = node.children,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var child = _ref;
              this.print(child, node);
            }

            this.dedent();
            this.print(node.closingElement, node);
          }

          function spaceSeparator() {
            this.space();
          }

          function JSXOpeningElement(node) {
            this.token("<");
            this.print(node.name, node);
            this.print(node.typeParameters, node);

            if (node.attributes.length > 0) {
              this.space();
              this.printJoin(node.attributes, node, {
                separator: spaceSeparator,
              });
            }

            if (node.selfClosing) {
              this.space();
              this.token("/>");
            } else {
              this.token(">");
            }
          }

          function JSXClosingElement(node) {
            this.token("</");
            this.print(node.name, node);
            this.token(">");
          }

          function JSXEmptyExpression(node) {
            this.printInnerComments(node);
          }

          function JSXFragment(node) {
            this.print(node.openingFragment, node);
            this.indent();

            for (
              var _iterator2 = node.children,
                _isArray2 = Array.isArray(_iterator2),
                _i2 = 0,
                _iterator2 = _isArray2
                  ? _iterator2
                  : _iterator2[Symbol.iterator]();
              ;

            ) {
              var _ref2;

              if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
              } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
              }

              var child = _ref2;
              this.print(child, node);
            }

            this.dedent();
            this.print(node.closingFragment, node);
          }

          function JSXOpeningFragment() {
            this.token("<");
            this.token(">");
          }

          function JSXClosingFragment() {
            this.token("</");
            this.token(">");
          }
        },
        /* 365 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.TSTypeAnnotation = TSTypeAnnotation;
          exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
          exports.TSTypeParameter = TSTypeParameter;
          exports.TSParameterProperty = TSParameterProperty;
          exports.TSDeclareFunction = TSDeclareFunction;
          exports.TSDeclareMethod = TSDeclareMethod;
          exports.TSQualifiedName = TSQualifiedName;
          exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
          exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
          exports.TSPropertySignature = TSPropertySignature;
          exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
          exports.TSMethodSignature = TSMethodSignature;
          exports.TSIndexSignature = TSIndexSignature;
          exports.TSAnyKeyword = TSAnyKeyword;
          exports.TSNumberKeyword = TSNumberKeyword;
          exports.TSObjectKeyword = TSObjectKeyword;
          exports.TSBooleanKeyword = TSBooleanKeyword;
          exports.TSStringKeyword = TSStringKeyword;
          exports.TSSymbolKeyword = TSSymbolKeyword;
          exports.TSVoidKeyword = TSVoidKeyword;
          exports.TSUndefinedKeyword = TSUndefinedKeyword;
          exports.TSNullKeyword = TSNullKeyword;
          exports.TSNeverKeyword = TSNeverKeyword;
          exports.TSThisType = TSThisType;
          exports.TSFunctionType = TSFunctionType;
          exports.TSConstructorType = TSConstructorType;
          exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
          exports.TSTypeReference = TSTypeReference;
          exports.TSTypePredicate = TSTypePredicate;
          exports.TSTypeQuery = TSTypeQuery;
          exports.TSTypeLiteral = TSTypeLiteral;
          exports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
          exports.tsPrintBraced = tsPrintBraced;
          exports.TSArrayType = TSArrayType;
          exports.TSTupleType = TSTupleType;
          exports.TSUnionType = TSUnionType;
          exports.TSIntersectionType = TSIntersectionType;
          exports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;
          exports.TSConditionalType = TSConditionalType;
          exports.TSInferType = TSInferType;
          exports.TSParenthesizedType = TSParenthesizedType;
          exports.TSTypeOperator = TSTypeOperator;
          exports.TSIndexedAccessType = TSIndexedAccessType;
          exports.TSMappedType = TSMappedType;
          exports.TSLiteralType = TSLiteralType;
          exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
          exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
          exports.TSInterfaceBody = TSInterfaceBody;
          exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
          exports.TSAsExpression = TSAsExpression;
          exports.TSTypeAssertion = TSTypeAssertion;
          exports.TSEnumDeclaration = TSEnumDeclaration;
          exports.TSEnumMember = TSEnumMember;
          exports.TSModuleDeclaration = TSModuleDeclaration;
          exports.TSModuleBlock = TSModuleBlock;
          exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
          exports.TSExternalModuleReference = TSExternalModuleReference;
          exports.TSNonNullExpression = TSNonNullExpression;
          exports.TSExportAssignment = TSExportAssignment;
          exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
          exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;

          function TSTypeAnnotation(node) {
            this.token(":");
            this.space();
            if (node.optional) this.token("?");
            this.print(node.typeAnnotation, node);
          }

          function TSTypeParameterInstantiation(node) {
            this.token("<");
            this.printList(node.params, node, {});
            this.token(">");
          }

          function TSTypeParameter(node) {
            this.word(node.name);

            if (node.constraint) {
              this.space();
              this.word("extends");
              this.space();
              this.print(node.constraint, node);
            }

            if (node.default) {
              this.space();
              this.token("=");
              this.space();
              this.print(node.default, node);
            }
          }

          function TSParameterProperty(node) {
            if (node.accessibility) {
              this.word(node.accessibility);
              this.space();
            }

            if (node.readonly) {
              this.word("readonly");
              this.space();
            }

            this._param(node.parameter);
          }

          function TSDeclareFunction(node) {
            if (node.declare) {
              this.word("declare");
              this.space();
            }

            this._functionHead(node);

            this.token(";");
          }

          function TSDeclareMethod(node) {
            this._classMethodHead(node);

            this.token(";");
          }

          function TSQualifiedName(node) {
            this.print(node.left, node);
            this.token(".");
            this.print(node.right, node);
          }

          function TSCallSignatureDeclaration(node) {
            this.tsPrintSignatureDeclarationBase(node);
          }

          function TSConstructSignatureDeclaration(node) {
            this.word("new");
            this.space();
            this.tsPrintSignatureDeclarationBase(node);
          }

          function TSPropertySignature(node) {
            var readonly = node.readonly,
              initializer = node.initializer;

            if (readonly) {
              this.word("readonly");
              this.space();
            }

            this.tsPrintPropertyOrMethodName(node);
            this.print(node.typeAnnotation, node);

            if (initializer) {
              this.space();
              this.token("=");
              this.space();
              this.print(initializer, node);
            }

            this.token(";");
          }

          function tsPrintPropertyOrMethodName(node) {
            if (node.computed) {
              this.token("[");
            }

            this.print(node.key, node);

            if (node.computed) {
              this.token("]");
            }

            if (node.optional) {
              this.token("?");
            }
          }

          function TSMethodSignature(node) {
            this.tsPrintPropertyOrMethodName(node);
            this.tsPrintSignatureDeclarationBase(node);
            this.token(";");
          }

          function TSIndexSignature(node) {
            var readonly = node.readonly;

            if (readonly) {
              this.word("readonly");
              this.space();
            }

            this.token("[");

            this._parameters(node.parameters, node);

            this.token("]");
            this.print(node.typeAnnotation, node);
            this.token(";");
          }

          function TSAnyKeyword() {
            this.word("any");
          }

          function TSNumberKeyword() {
            this.word("number");
          }

          function TSObjectKeyword() {
            this.word("object");
          }

          function TSBooleanKeyword() {
            this.word("boolean");
          }

          function TSStringKeyword() {
            this.word("string");
          }

          function TSSymbolKeyword() {
            this.word("symbol");
          }

          function TSVoidKeyword() {
            this.word("void");
          }

          function TSUndefinedKeyword() {
            this.word("undefined");
          }

          function TSNullKeyword() {
            this.word("null");
          }

          function TSNeverKeyword() {
            this.word("never");
          }

          function TSThisType() {
            this.word("this");
          }

          function TSFunctionType(node) {
            this.tsPrintFunctionOrConstructorType(node);
          }

          function TSConstructorType(node) {
            this.word("new");
            this.space();
            this.tsPrintFunctionOrConstructorType(node);
          }

          function tsPrintFunctionOrConstructorType(node) {
            var typeParameters = node.typeParameters,
              parameters = node.parameters;
            this.print(typeParameters, node);
            this.token("(");

            this._parameters(parameters, node);

            this.token(")");
            this.space();
            this.token("=>");
            this.space();
            this.print(node.typeAnnotation.typeAnnotation, node);
          }

          function TSTypeReference(node) {
            this.print(node.typeName, node);
            this.print(node.typeParameters, node);
          }

          function TSTypePredicate(node) {
            this.print(node.parameterName);
            this.space();
            this.word("is");
            this.space();
            this.print(node.typeAnnotation.typeAnnotation);
          }

          function TSTypeQuery(node) {
            this.word("typeof");
            this.space();
            this.print(node.exprName);
          }

          function TSTypeLiteral(node) {
            this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
          }

          function tsPrintTypeLiteralOrInterfaceBody(members, node) {
            this.tsPrintBraced(members, node);
          }

          function tsPrintBraced(members, node) {
            this.token("{");

            if (members.length) {
              this.indent();
              this.newline();

              for (
                var _iterator = members,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var member = _ref;
                this.print(member, node);
                this.newline();
              }

              this.dedent();
              this.rightBrace();
            } else {
              this.token("}");
            }
          }

          function TSArrayType(node) {
            this.print(node.elementType);
            this.token("[]");
          }

          function TSTupleType(node) {
            this.token("[");
            this.printList(node.elementTypes, node);
            this.token("]");
          }

          function TSUnionType(node) {
            this.tsPrintUnionOrIntersectionType(node, "|");
          }

          function TSIntersectionType(node) {
            this.tsPrintUnionOrIntersectionType(node, "&");
          }

          function tsPrintUnionOrIntersectionType(node, sep) {
            this.printJoin(node.types, node, {
              separator: function separator() {
                this.space();
                this.token(sep);
                this.space();
              },
            });
          }

          function TSConditionalType(node) {
            this.print(node.checkType);
            this.space();
            this.word("extends");
            this.space();
            this.print(node.extendsType);
            this.space();
            this.token("?");
            this.space();
            this.print(node.trueType);
            this.space();
            this.token(":");
            this.space();
            this.print(node.falseType);
          }

          function TSInferType(node) {
            this.token("infer");
            this.space();
            this.print(node.typeParameter);
          }

          function TSParenthesizedType(node) {
            this.token("(");
            this.print(node.typeAnnotation, node);
            this.token(")");
          }

          function TSTypeOperator(node) {
            this.token(node.operator);
            this.space();
            this.print(node.typeAnnotation, node);
          }

          function TSIndexedAccessType(node) {
            this.print(node.objectType, node);
            this.token("[");
            this.print(node.indexType, node);
            this.token("]");
          }

          function TSMappedType(node) {
            var readonly = node.readonly,
              typeParameter = node.typeParameter,
              optional = node.optional;
            this.token("{");
            this.space();

            if (readonly) {
              tokenIfPlusMinus(this, readonly);
              this.word("readonly");
              this.space();
            }

            this.token("[");
            this.word(typeParameter.name);
            this.space();
            this.word("in");
            this.space();
            this.print(typeParameter.constraint, typeParameter);
            this.token("]");

            if (optional) {
              tokenIfPlusMinus(this, optional);
              this.token("?");
            }

            this.token(":");
            this.space();
            this.print(node.typeAnnotation, node);
            this.space();
            this.token("}");
          }

          function tokenIfPlusMinus(self, tok) {
            if (tok !== true) {
              self.token(tok);
            }
          }

          function TSLiteralType(node) {
            this.print(node.literal, node);
          }

          function TSExpressionWithTypeArguments(node) {
            this.print(node.expression, node);
            this.print(node.typeParameters, node);
          }

          function TSInterfaceDeclaration(node) {
            var declare = node.declare,
              id = node.id,
              typeParameters = node.typeParameters,
              extendz = node.extends,
              body = node.body;

            if (declare) {
              this.word("declare");
              this.space();
            }

            this.word("interface");
            this.space();
            this.print(id, node);
            this.print(typeParameters, node);

            if (extendz) {
              this.space();
              this.word("extends");
              this.space();
              this.printList(extendz, node);
            }

            this.space();
            this.print(body, node);
          }

          function TSInterfaceBody(node) {
            this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
          }

          function TSTypeAliasDeclaration(node) {
            var declare = node.declare,
              id = node.id,
              typeParameters = node.typeParameters,
              typeAnnotation = node.typeAnnotation;

            if (declare) {
              this.word("declare");
              this.space();
            }

            this.word("type");
            this.space();
            this.print(id, node);
            this.print(typeParameters, node);
            this.space();
            this.token("=");
            this.space();
            this.print(typeAnnotation, node);
            this.token(";");
          }

          function TSAsExpression(node) {
            var expression = node.expression,
              typeAnnotation = node.typeAnnotation;
            this.print(expression, node);
            this.space();
            this.word("as");
            this.space();
            this.print(typeAnnotation, node);
          }

          function TSTypeAssertion(node) {
            var typeAnnotation = node.typeAnnotation,
              expression = node.expression;
            this.token("<");
            this.print(typeAnnotation, node);
            this.token(">");
            this.space();
            this.print(expression, node);
          }

          function TSEnumDeclaration(node) {
            var declare = node.declare,
              isConst = node.const,
              id = node.id,
              members = node.members;

            if (declare) {
              this.word("declare");
              this.space();
            }

            if (isConst) {
              this.word("const");
              this.space();
            }

            this.word("enum");
            this.space();
            this.print(id, node);
            this.space();
            this.tsPrintBraced(members, node);
          }

          function TSEnumMember(node) {
            var id = node.id,
              initializer = node.initializer;
            this.print(id, node);

            if (initializer) {
              this.space();
              this.token("=");
              this.space();
              this.print(initializer, node);
            }

            this.token(",");
          }

          function TSModuleDeclaration(node) {
            var declare = node.declare,
              id = node.id;

            if (declare) {
              this.word("declare");
              this.space();
            }

            if (!node.global) {
              this.word(id.type === "Identifier" ? "namespace" : "module");
              this.space();
            }

            this.print(id, node);

            if (!node.body) {
              this.token(";");
              return;
            }

            var body = node.body;

            while (body.type === "TSModuleDeclaration") {
              this.token(".");
              this.print(body.id, body);
              body = body.body;
            }

            this.space();
            this.print(body, node);
          }

          function TSModuleBlock(node) {
            this.tsPrintBraced(node.body, node);
          }

          function TSImportEqualsDeclaration(node) {
            var isExport = node.isExport,
              id = node.id,
              moduleReference = node.moduleReference;

            if (isExport) {
              this.word("export");
              this.space();
            }

            this.word("import");
            this.space();
            this.print(id, node);
            this.space();
            this.token("=");
            this.space();
            this.print(moduleReference, node);
            this.token(";");
          }

          function TSExternalModuleReference(node) {
            this.token("require(");
            this.print(node.expression, node);
            this.token(")");
          }

          function TSNonNullExpression(node) {
            this.print(node.expression, node);
            this.token("!");
          }

          function TSExportAssignment(node) {
            this.word("export");
            this.space();
            this.token("=");
            this.space();
            this.print(node.expression, node);
            this.token(";");
          }

          function TSNamespaceExportDeclaration(node) {
            this.word("export");
            this.space();
            this.word("as");
            this.space();
            this.word("namespace");
            this.space();
            this.print(node.id, node);
          }

          function tsPrintSignatureDeclarationBase(node) {
            var typeParameters = node.typeParameters,
              parameters = node.parameters;
            this.print(typeParameters, node);
            this.token("(");

            this._parameters(parameters, node);

            this.token(")");
            this.print(node.typeAnnotation, node);
          }
        },
        /* 366 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.findParent = findParent;
          exports.find = find;
          exports.getFunctionParent = getFunctionParent;
          exports.getStatementParent = getStatementParent;
          exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
          exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
          exports.getAncestry = getAncestry;
          exports.isAncestor = isAncestor;
          exports.isDescendant = isDescendant;
          exports.inType = inType;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          var _index = _interopRequireDefault(__webpack_require__(21));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function findParent(callback) {
            var path = this;

            while ((path = path.parentPath)) {
              if (callback(path)) return path;
            }

            return null;
          }

          function find(callback) {
            var path = this;

            do {
              if (callback(path)) return path;
            } while ((path = path.parentPath));

            return null;
          }

          function getFunctionParent() {
            return this.findParent(function(p) {
              return p.isFunction();
            });
          }

          function getStatementParent() {
            var path = this;

            do {
              if (
                !path.parentPath ||
                (Array.isArray(path.container) && path.isStatement())
              ) {
                break;
              } else {
                path = path.parentPath;
              }
            } while (path);

            if (path && (path.isProgram() || path.isFile())) {
              throw new Error(
                "File/Program node, we can't possibly find a statement parent to this"
              );
            }

            return path;
          }

          function getEarliestCommonAncestorFrom(paths) {
            return this.getDeepestCommonAncestorFrom(paths, function(
              deepest,
              i,
              ancestries
            ) {
              var earliest;
              var keys = t().VISITOR_KEYS[deepest.type];

              for (
                var _iterator = ancestries,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var ancestry = _ref;
                var path = ancestry[i + 1];

                if (!earliest) {
                  earliest = path;
                  continue;
                }

                if (path.listKey && earliest.listKey === path.listKey) {
                  if (path.key < earliest.key) {
                    earliest = path;
                    continue;
                  }
                }

                var earliestKeyIndex = keys.indexOf(earliest.parentKey);
                var currentKeyIndex = keys.indexOf(path.parentKey);

                if (earliestKeyIndex > currentKeyIndex) {
                  earliest = path;
                }
              }

              return earliest;
            });
          }

          function getDeepestCommonAncestorFrom(paths, filter) {
            var _this = this;

            if (!paths.length) {
              return this;
            }

            if (paths.length === 1) {
              return paths[0];
            }

            var minDepth = Infinity;
            var lastCommonIndex, lastCommon;
            var ancestries = paths.map(function(path) {
              var ancestry = [];

              do {
                ancestry.unshift(path);
              } while ((path = path.parentPath) && path !== _this);

              if (ancestry.length < minDepth) {
                minDepth = ancestry.length;
              }

              return ancestry;
            });
            var first = ancestries[0];

            depthLoop: for (var i = 0; i < minDepth; i++) {
              var shouldMatch = first[i];

              for (
                var _iterator2 = ancestries,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : _iterator2[Symbol.iterator]();
                ;

              ) {
                var _ref2;

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break;
                  _ref2 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done) break;
                  _ref2 = _i2.value;
                }

                var ancestry = _ref2;

                if (ancestry[i] !== shouldMatch) {
                  break depthLoop;
                }
              }

              lastCommonIndex = i;
              lastCommon = shouldMatch;
            }

            if (lastCommon) {
              if (filter) {
                return filter(lastCommon, lastCommonIndex, ancestries);
              } else {
                return lastCommon;
              }
            } else {
              throw new Error("Couldn't find intersection");
            }
          }

          function getAncestry() {
            var path = this;
            var paths = [];

            do {
              paths.push(path);
            } while ((path = path.parentPath));

            return paths;
          }

          function isAncestor(maybeDescendant) {
            return maybeDescendant.isDescendant(this);
          }

          function isDescendant(maybeAncestor) {
            return !!this.findParent(function(parent) {
              return parent === maybeAncestor;
            });
          }

          function inType() {
            var path = this;

            while (path) {
              for (
                var _iterator3 = arguments,
                  _isArray3 = Array.isArray(_iterator3),
                  _i3 = 0,
                  _iterator3 = _isArray3
                    ? _iterator3
                    : _iterator3[Symbol.iterator]();
                ;

              ) {
                var _ref3;

                if (_isArray3) {
                  if (_i3 >= _iterator3.length) break;
                  _ref3 = _iterator3[_i3++];
                } else {
                  _i3 = _iterator3.next();
                  if (_i3.done) break;
                  _ref3 = _i3.value;
                }

                var type = _ref3;
                if (path.node.type === type) return true;
              }

              path = path.parentPath;
            }

            return false;
          }
        },
        /* 367 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.getTypeAnnotation = getTypeAnnotation;
          exports._getTypeAnnotation = _getTypeAnnotation;
          exports.isBaseType = isBaseType;
          exports.couldBeBaseType = couldBeBaseType;
          exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
          exports.isGenericType = isGenericType;

          var inferers = _interopRequireWildcard(__webpack_require__(368));

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function getTypeAnnotation() {
            if (this.typeAnnotation) return this.typeAnnotation;
            var type = this._getTypeAnnotation() || t().anyTypeAnnotation();
            if (t().isTypeAnnotation(type)) type = type.typeAnnotation;
            return (this.typeAnnotation = type);
          }

          function _getTypeAnnotation() {
            var node = this.node;

            if (!node) {
              if (
                this.key === "init" &&
                this.parentPath.isVariableDeclarator()
              ) {
                var declar = this.parentPath.parentPath;
                var declarParent = declar.parentPath;

                if (declar.key === "left" && declarParent.isForInStatement()) {
                  return t().stringTypeAnnotation();
                }

                if (declar.key === "left" && declarParent.isForOfStatement()) {
                  return t().anyTypeAnnotation();
                }

                return t().voidTypeAnnotation();
              } else {
                return;
              }
            }

            if (node.typeAnnotation) {
              return node.typeAnnotation;
            }

            var inferer = inferers[node.type];

            if (inferer) {
              return inferer.call(this, node);
            }

            inferer = inferers[this.parentPath.type];

            if (inferer && inferer.validParent) {
              return this.parentPath.getTypeAnnotation();
            }
          }

          function isBaseType(baseName, soft) {
            return _isBaseType(baseName, this.getTypeAnnotation(), soft);
          }

          function _isBaseType(baseName, type, soft) {
            if (baseName === "string") {
              return t().isStringTypeAnnotation(type);
            } else if (baseName === "number") {
              return t().isNumberTypeAnnotation(type);
            } else if (baseName === "boolean") {
              return t().isBooleanTypeAnnotation(type);
            } else if (baseName === "any") {
              return t().isAnyTypeAnnotation(type);
            } else if (baseName === "mixed") {
              return t().isMixedTypeAnnotation(type);
            } else if (baseName === "empty") {
              return t().isEmptyTypeAnnotation(type);
            } else if (baseName === "void") {
              return t().isVoidTypeAnnotation(type);
            } else {
              if (soft) {
                return false;
              } else {
                throw new Error("Unknown base type " + baseName);
              }
            }
          }

          function couldBeBaseType(name) {
            var type = this.getTypeAnnotation();
            if (t().isAnyTypeAnnotation(type)) return true;

            if (t().isUnionTypeAnnotation(type)) {
              for (
                var _iterator = type.types,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var type2 = _ref;

                if (
                  t().isAnyTypeAnnotation(type2) ||
                  _isBaseType(name, type2, true)
                ) {
                  return true;
                }
              }

              return false;
            } else {
              return _isBaseType(name, type, true);
            }
          }

          function baseTypeStrictlyMatches(right) {
            var left = this.getTypeAnnotation();
            right = right.getTypeAnnotation();

            if (
              !t().isAnyTypeAnnotation(left) &&
              t().isFlowBaseAnnotation(left)
            ) {
              return right.type === left.type;
            }
          }

          function isGenericType(genericName) {
            var type = this.getTypeAnnotation();
            return (
              t().isGenericTypeAnnotation(type) &&
              t().isIdentifier(type.id, {
                name: genericName,
              })
            );
          }
        },
        /* 368 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.VariableDeclarator = VariableDeclarator;
          exports.TypeCastExpression = TypeCastExpression;
          exports.NewExpression = NewExpression;
          exports.TemplateLiteral = TemplateLiteral;
          exports.UnaryExpression = UnaryExpression;
          exports.BinaryExpression = BinaryExpression;
          exports.LogicalExpression = LogicalExpression;
          exports.ConditionalExpression = ConditionalExpression;
          exports.SequenceExpression = SequenceExpression;
          exports.AssignmentExpression = AssignmentExpression;
          exports.UpdateExpression = UpdateExpression;
          exports.StringLiteral = StringLiteral;
          exports.NumericLiteral = NumericLiteral;
          exports.BooleanLiteral = BooleanLiteral;
          exports.NullLiteral = NullLiteral;
          exports.RegExpLiteral = RegExpLiteral;
          exports.ObjectExpression = ObjectExpression;
          exports.ArrayExpression = ArrayExpression;
          exports.RestElement = RestElement;
          exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
          exports.CallExpression = CallExpression;
          exports.TaggedTemplateExpression = TaggedTemplateExpression;
          Object.defineProperty(exports, "Identifier", {
            enumerable: true,
            get: function get() {
              return _infererReference.default;
            },
          });

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          var _infererReference = _interopRequireDefault(
            __webpack_require__(369)
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function VariableDeclarator() {
            var id = this.get("id");
            if (!id.isIdentifier()) return;
            var init = this.get("init");
            var type = init.getTypeAnnotation();

            if (type && type.type === "AnyTypeAnnotation") {
              if (
                init.isCallExpression() &&
                init.get("callee").isIdentifier({
                  name: "Array",
                }) &&
                !init.scope.hasBinding("Array", true)
              ) {
                type = ArrayExpression();
              }
            }

            return type;
          }

          function TypeCastExpression(node) {
            return node.typeAnnotation;
          }

          TypeCastExpression.validParent = true;

          function NewExpression(node) {
            if (this.get("callee").isIdentifier()) {
              return t().genericTypeAnnotation(node.callee);
            }
          }

          function TemplateLiteral() {
            return t().stringTypeAnnotation();
          }

          function UnaryExpression(node) {
            var operator = node.operator;

            if (operator === "void") {
              return t().voidTypeAnnotation();
            } else if (t().NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
              return t().numberTypeAnnotation();
            } else if (t().STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
              return t().stringTypeAnnotation();
            } else if (t().BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
              return t().booleanTypeAnnotation();
            }
          }

          function BinaryExpression(node) {
            var operator = node.operator;

            if (t().NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
              return t().numberTypeAnnotation();
            } else if (t().BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
              return t().booleanTypeAnnotation();
            } else if (operator === "+") {
              var right = this.get("right");
              var left = this.get("left");

              if (left.isBaseType("number") && right.isBaseType("number")) {
                return t().numberTypeAnnotation();
              } else if (
                left.isBaseType("string") ||
                right.isBaseType("string")
              ) {
                return t().stringTypeAnnotation();
              }

              return t().unionTypeAnnotation([
                t().stringTypeAnnotation(),
                t().numberTypeAnnotation(),
              ]);
            }
          }

          function LogicalExpression() {
            return t().createUnionTypeAnnotation([
              this.get("left").getTypeAnnotation(),
              this.get("right").getTypeAnnotation(),
            ]);
          }

          function ConditionalExpression() {
            return t().createUnionTypeAnnotation([
              this.get("consequent").getTypeAnnotation(),
              this.get("alternate").getTypeAnnotation(),
            ]);
          }

          function SequenceExpression() {
            return this.get("expressions")
              .pop()
              .getTypeAnnotation();
          }

          function AssignmentExpression() {
            return this.get("right").getTypeAnnotation();
          }

          function UpdateExpression(node) {
            var operator = node.operator;

            if (operator === "++" || operator === "--") {
              return t().numberTypeAnnotation();
            }
          }

          function StringLiteral() {
            return t().stringTypeAnnotation();
          }

          function NumericLiteral() {
            return t().numberTypeAnnotation();
          }

          function BooleanLiteral() {
            return t().booleanTypeAnnotation();
          }

          function NullLiteral() {
            return t().nullLiteralTypeAnnotation();
          }

          function RegExpLiteral() {
            return t().genericTypeAnnotation(t().identifier("RegExp"));
          }

          function ObjectExpression() {
            return t().genericTypeAnnotation(t().identifier("Object"));
          }

          function ArrayExpression() {
            return t().genericTypeAnnotation(t().identifier("Array"));
          }

          function RestElement() {
            return ArrayExpression();
          }

          RestElement.validParent = true;

          function Func() {
            return t().genericTypeAnnotation(t().identifier("Function"));
          }

          var isArrayFrom = t().buildMatchMemberExpression("Array.from");
          var isObjectKeys = t().buildMatchMemberExpression("Object.keys");
          var isObjectValues = t().buildMatchMemberExpression("Object.values");
          var isObjectEntries = t().buildMatchMemberExpression(
            "Object.entries"
          );

          function CallExpression() {
            var callee = this.node.callee;

            if (isObjectKeys(callee)) {
              return t().arrayTypeAnnotation(t().stringTypeAnnotation());
            } else if (isArrayFrom(callee) || isObjectValues(callee)) {
              return t().arrayTypeAnnotation(t().anyTypeAnnotation());
            } else if (isObjectEntries(callee)) {
              return t().arrayTypeAnnotation(
                t().tupleTypeAnnotation([
                  t().stringTypeAnnotation(),
                  t().anyTypeAnnotation(),
                ])
              );
            }

            return resolveCall(this.get("callee"));
          }

          function TaggedTemplateExpression() {
            return resolveCall(this.get("tag"));
          }

          function resolveCall(callee) {
            callee = callee.resolve();

            if (callee.isFunction()) {
              if (callee.is("async")) {
                if (callee.is("generator")) {
                  return t().genericTypeAnnotation(
                    t().identifier("AsyncIterator")
                  );
                } else {
                  return t().genericTypeAnnotation(t().identifier("Promise"));
                }
              } else {
                if (callee.node.returnType) {
                  return callee.node.returnType;
                } else {
                }
              }
            }
          }
        },
        /* 369 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = _default;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _default(node) {
            if (!this.isReferenced()) return;
            var binding = this.scope.getBinding(node.name);

            if (binding) {
              if (binding.identifier.typeAnnotation) {
                return binding.identifier.typeAnnotation;
              } else {
                return getTypeAnnotationBindingConstantViolations(
                  binding,
                  this,
                  node.name
                );
              }
            }

            if (node.name === "undefined") {
              return t().voidTypeAnnotation();
            } else if (node.name === "NaN" || node.name === "Infinity") {
              return t().numberTypeAnnotation();
            } else if (node.name === "arguments") {
            }
          }

          function getTypeAnnotationBindingConstantViolations(
            binding,
            path,
            name
          ) {
            var types = [];
            var functionConstantViolations = [];
            var constantViolations = getConstantViolationsBefore(
              binding,
              path,
              functionConstantViolations
            );
            var testType = getConditionalAnnotation(binding, path, name);

            if (testType) {
              var testConstantViolations = getConstantViolationsBefore(
                binding,
                testType.ifStatement
              );
              constantViolations = constantViolations.filter(function(path) {
                return testConstantViolations.indexOf(path) < 0;
              });
              types.push(testType.typeAnnotation);
            }

            if (constantViolations.length) {
              constantViolations = constantViolations.concat(
                functionConstantViolations
              );

              for (
                var _iterator = constantViolations,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var violation = _ref;
                types.push(violation.getTypeAnnotation());
              }
            }

            if (types.length) {
              return t().createUnionTypeAnnotation(types);
            }
          }

          function getConstantViolationsBefore(binding, path, functions) {
            var violations = binding.constantViolations.slice();
            violations.unshift(binding.path);
            return violations.filter(function(violation) {
              violation = violation.resolve();

              var status = violation._guessExecutionStatusRelativeTo(path);

              if (functions && status === "function") functions.push(violation);
              return status === "before";
            });
          }

          function inferAnnotationFromBinaryExpression(name, path) {
            var operator = path.node.operator;
            var right = path.get("right").resolve();
            var left = path.get("left").resolve();
            var target;

            if (
              left.isIdentifier({
                name: name,
              })
            ) {
              target = right;
            } else if (
              right.isIdentifier({
                name: name,
              })
            ) {
              target = left;
            }

            if (target) {
              if (operator === "===") {
                return target.getTypeAnnotation();
              }

              if (t().BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
                return t().numberTypeAnnotation();
              }

              return;
            }

            if (operator !== "===" && operator !== "==") return;
            var typeofPath;
            var typePath;

            if (
              left.isUnaryExpression({
                operator: "typeof",
              })
            ) {
              typeofPath = left;
              typePath = right;
            } else if (
              right.isUnaryExpression({
                operator: "typeof",
              })
            ) {
              typeofPath = right;
              typePath = left;
            }

            if (!typeofPath) return;
            if (
              !typeofPath.get("argument").isIdentifier({
                name: name,
              })
            )
              return;
            typePath = typePath.resolve();
            if (!typePath.isLiteral()) return;
            var typeValue = typePath.node.value;
            if (typeof typeValue !== "string") return;
            return t().createTypeAnnotationBasedOnTypeof(typeValue);
          }

          function getParentConditionalPath(binding, path, name) {
            var parentPath;

            while ((parentPath = path.parentPath)) {
              if (
                parentPath.isIfStatement() ||
                parentPath.isConditionalExpression()
              ) {
                if (path.key === "test") {
                  return;
                }

                return parentPath;
              }

              if (parentPath.isFunction()) {
                if (parentPath.parentPath.scope.getBinding(name) !== binding)
                  return;
              }

              path = parentPath;
            }
          }

          function getConditionalAnnotation(binding, path, name) {
            var ifStatement = getParentConditionalPath(binding, path, name);
            if (!ifStatement) return;
            var test = ifStatement.get("test");
            var paths = [test];
            var types = [];

            for (var i = 0; i < paths.length; i++) {
              var _path = paths[i];

              if (_path.isLogicalExpression()) {
                if (_path.node.operator === "&&") {
                  paths.push(_path.get("left"));
                  paths.push(_path.get("right"));
                }
              } else if (_path.isBinaryExpression()) {
                var type = inferAnnotationFromBinaryExpression(name, _path);
                if (type) types.push(type);
              }
            }

            if (types.length) {
              return {
                typeAnnotation: t().createUnionTypeAnnotation(types),
                ifStatement: ifStatement,
              };
            }

            return getConditionalAnnotation(ifStatement, name);
          }
        },
        /* 370 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.replaceWithMultiple = replaceWithMultiple;
          exports.replaceWithSourceString = replaceWithSourceString;
          exports.replaceWith = replaceWith;
          exports._replaceWith = _replaceWith;
          exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
          exports.replaceInline = replaceInline;

          function _babelCodeFrame() {
            var data = __webpack_require__(44);

            _babelCodeFrame = function _babelCodeFrame() {
              return data;
            };

            return data;
          }

          var _index = _interopRequireDefault(__webpack_require__(9));

          var _index2 = _interopRequireDefault(__webpack_require__(21));

          function _babelParser() {
            var data = __webpack_require__(80);

            _babelParser = function _babelParser() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var hoistVariablesVisitor = {
            Function: function Function(path) {
              path.skip();
            },
            VariableDeclaration: function VariableDeclaration(path) {
              if (path.node.kind !== "var") return;
              var bindings = path.getBindingIdentifiers();

              for (var key in bindings) {
                path.scope.push({
                  id: bindings[key],
                });
              }

              var exprs = [];

              for (
                var _iterator = path.node.declarations,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var declar = _ref;

                if (declar.init) {
                  exprs.push(
                    t().expressionStatement(
                      t().assignmentExpression("=", declar.id, declar.init)
                    )
                  );
                }
              }

              path.replaceWithMultiple(exprs);
            },
          };

          function replaceWithMultiple(nodes) {
            this.resync();
            nodes = this._verifyNodeList(nodes);
            t().inheritLeadingComments(nodes[0], this.node);
            t().inheritTrailingComments(nodes[nodes.length - 1], this.node);
            this.node = this.container[this.key] = null;
            var paths = this.insertAfter(nodes);

            if (this.node) {
              this.requeue();
            } else {
              this.remove();
            }

            return paths;
          }

          function replaceWithSourceString(replacement) {
            this.resync();

            try {
              replacement = "(" + replacement + ")";
              replacement = (0, _babelParser().parse)(replacement);
            } catch (err) {
              var loc = err.loc;

              if (loc) {
                err.message +=
                  " - make sure this is an expression.\n" +
                  (0, _babelCodeFrame().codeFrameColumns)(replacement, {
                    start: {
                      line: loc.line,
                      column: loc.column + 1,
                    },
                  });
                err.code = "BABEL_REPLACE_SOURCE_ERROR";
              }

              throw err;
            }

            replacement = replacement.program.body[0].expression;

            _index.default.removeProperties(replacement);

            return this.replaceWith(replacement);
          }

          function replaceWith(replacement) {
            this.resync();

            if (this.removed) {
              throw new Error(
                "You can't replace this node, we've already removed it"
              );
            }

            if (replacement instanceof _index2.default) {
              replacement = replacement.node;
            }

            if (!replacement) {
              throw new Error(
                "You passed `path.replaceWith()` a falsy node, use `path.remove()` instead"
              );
            }

            if (this.node === replacement) {
              return [this];
            }

            if (this.isProgram() && !t().isProgram(replacement)) {
              throw new Error(
                "You can only replace a Program root node with another Program node"
              );
            }

            if (Array.isArray(replacement)) {
              throw new Error(
                "Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`"
              );
            }

            if (typeof replacement === "string") {
              throw new Error(
                "Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`"
              );
            }

            var nodePath = "";

            if (this.isNodeType("Statement") && t().isExpression(replacement)) {
              if (
                !this.canHaveVariableDeclarationOrExpression() &&
                !this.canSwapBetweenExpressionAndStatement(replacement) &&
                !this.parentPath.isExportDefaultDeclaration()
              ) {
                replacement = t().expressionStatement(replacement);
                nodePath = "expression";
              }
            }

            if (this.isNodeType("Expression") && t().isStatement(replacement)) {
              if (
                !this.canHaveVariableDeclarationOrExpression() &&
                !this.canSwapBetweenExpressionAndStatement(replacement)
              ) {
                return this.replaceExpressionWithStatements([replacement]);
              }
            }

            var oldNode = this.node;

            if (oldNode) {
              t().inheritsComments(replacement, oldNode);
              t().removeComments(oldNode);
            }

            this._replaceWith(replacement);

            this.type = replacement.type;
            this.setScope();
            this.requeue();
            return [nodePath ? this.get(nodePath) : this];
          }

          function _replaceWith(node) {
            if (!this.container) {
              throw new ReferenceError("Container is falsy");
            }

            if (this.inList) {
              t().validate(this.parent, this.key, [node]);
            } else {
              t().validate(this.parent, this.key, node);
            }

            this.debug("Replace with " + (node && node.type));
            this.node = this.container[this.key] = node;
          }

          function replaceExpressionWithStatements(nodes) {
            this.resync();
            var toSequenceExpression = t().toSequenceExpression(
              nodes,
              this.scope
            );

            if (toSequenceExpression) {
              return this.replaceWith(toSequenceExpression)[0].get(
                "expressions"
              );
            }

            var container = t().arrowFunctionExpression(
              [],
              t().blockStatement(nodes)
            );
            this.replaceWith(t().callExpression(container, []));
            this.traverse(hoistVariablesVisitor);
            var completionRecords = this.get("callee").getCompletionRecords();

            for (
              var _iterator2 = completionRecords,
                _isArray2 = Array.isArray(_iterator2),
                _i2 = 0,
                _iterator2 = _isArray2
                  ? _iterator2
                  : _iterator2[Symbol.iterator]();
              ;

            ) {
              var _ref2;

              if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
              } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
              }

              var path = _ref2;
              if (!path.isExpressionStatement()) continue;
              var loop = path.findParent(function(path) {
                return path.isLoop();
              });

              if (loop) {
                var uid = loop.getData("expressionReplacementReturnUid");

                if (!uid) {
                  var _callee = this.get("callee");

                  uid = _callee.scope.generateDeclaredUidIdentifier("ret");

                  _callee
                    .get("body")
                    .pushContainer(
                      "body",
                      t().returnStatement(t().cloneNode(uid))
                    );

                  loop.setData("expressionReplacementReturnUid", uid);
                } else {
                  uid = t().identifier(uid.name);
                }

                path
                  .get("expression")
                  .replaceWith(
                    t().assignmentExpression(
                      "=",
                      t().cloneNode(uid),
                      path.node.expression
                    )
                  );
              } else {
                path.replaceWith(t().returnStatement(path.node.expression));
              }
            }

            var callee = this.get("callee");
            callee.arrowFunctionToExpression();
            return callee.get("body.body");
          }

          function replaceInline(nodes) {
            this.resync();

            if (Array.isArray(nodes)) {
              if (Array.isArray(this.container)) {
                nodes = this._verifyNodeList(nodes);

                var paths = this._containerInsertAfter(nodes);

                this.remove();
                return paths;
              } else {
                return this.replaceWithMultiple(nodes);
              }
            } else {
              return this.replaceWith(nodes);
            }
          }
        },
        /* 371 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.shouldHighlight = shouldHighlight;
          exports.getChalk = getChalk;
          exports.default = highlight;

          function _jsTokens() {
            var data = _interopRequireWildcard(__webpack_require__(372));

            _jsTokens = function _jsTokens() {
              return data;
            };

            return data;
          }

          function _esutils() {
            var data = _interopRequireDefault(__webpack_require__(106));

            _esutils = function _esutils() {
              return data;
            };

            return data;
          }

          function _chalk() {
            var data = _interopRequireDefault(__webpack_require__(373));

            _chalk = function _chalk() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function getDefs(chalk) {
            return {
              keyword: chalk.cyan,
              capitalized: chalk.yellow,
              jsx_tag: chalk.yellow,
              punctuator: chalk.yellow,
              number: chalk.magenta,
              string: chalk.green,
              regex: chalk.magenta,
              comment: chalk.grey,
              invalid: chalk.white.bgRed.bold,
            };
          }

          var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
          var JSX_TAG = /^[a-z][\w-]*$/i;
          var BRACKET = /^[()[\]{}]$/;

          function getTokenType(match) {
            var _match$slice = match.slice(-2),
              offset = _match$slice[0],
              text = _match$slice[1];

            var token = (0, _jsTokens().matchToToken)(match);

            if (token.type === "name") {
              if (_esutils().default.keyword.isReservedWordES6(token.value)) {
                return "keyword";
              }

              if (
                JSX_TAG.test(token.value) &&
                (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")
              ) {
                return "jsx_tag";
              }

              if (token.value[0] !== token.value[0].toLowerCase()) {
                return "capitalized";
              }
            }

            if (token.type === "punctuator" && BRACKET.test(token.value)) {
              return "bracket";
            }

            if (
              token.type === "invalid" &&
              (token.value === "@" || token.value === "#")
            ) {
              return "punctuator";
            }

            return token.type;
          }

          function highlightTokens(defs, text) {
            return text.replace(_jsTokens().default, function() {
              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key];
              }

              var type = getTokenType(args);
              var colorize = defs[type];

              if (colorize) {
                return args[0]
                  .split(NEWLINE)
                  .map(function(str) {
                    return colorize(str);
                  })
                  .join("\n");
              } else {
                return args[0];
              }
            });
          }

          function shouldHighlight(options) {
            return _chalk().default.supportsColor || options.forceColor;
          }

          function getChalk(options) {
            var chalk = _chalk().default;

            if (options.forceColor) {
              chalk = new (_chalk()).default.constructor({
                enabled: true,
                level: 1,
              });
            }

            return chalk;
          }

          function highlight(code, options) {
            if (options === void 0) {
              options = {};
            }

            if (shouldHighlight(options)) {
              var chalk = getChalk(options);
              var defs = getDefs(chalk);
              return highlightTokens(defs, code);
            } else {
              return code;
            }
          }
        },
        /* 372 */
        function(module, exports) {
          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

          exports.matchToToken = function(match) {
            var token = {
              type: "invalid",
              value: match[0],
              closed: undefined,
            };
            if (match[1])
              (token.type = "string"),
                (token.closed = !!(match[3] || match[4]));
            else if (match[5]) token.type = "comment";
            else if (match[6])
              (token.type = "comment"), (token.closed = !!match[7]);
            else if (match[8]) token.type = "regex";
            else if (match[9]) token.type = "number";
            else if (match[10]) token.type = "name";
            else if (match[11]) token.type = "punctuator";
            else if (match[12]) token.type = "whitespace";
            return token;
          };
        },
        /* 373 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(process) {
            var escapeStringRegexp = __webpack_require__(374);

            var ansiStyles = __webpack_require__(375);

            var stdoutColor = __webpack_require__(379).stdout;

            var template = __webpack_require__(380);

            var isSimpleWindowsTerm =
              process.platform === "win32" &&
              !(process.env.TERM || "").toLowerCase().startsWith("xterm");
            var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
            var skipModels = new Set(["gray"]);
            var styles = Object.create(null);

            function applyOptions(obj, options) {
              options = options || {};
              var scLevel = stdoutColor ? stdoutColor.level : 0;
              obj.level = options.level === undefined ? scLevel : options.level;
              obj.enabled =
                "enabled" in options ? options.enabled : obj.level > 0;
            }

            function Chalk(options) {
              if (!this || !(this instanceof Chalk) || this.template) {
                var chalk = {};
                applyOptions(chalk, options);

                chalk.template = function() {
                  var args = [].slice.call(arguments);
                  return chalkTag.apply(null, [chalk.template].concat(args));
                };

                Object.setPrototypeOf(chalk, Chalk.prototype);
                Object.setPrototypeOf(chalk.template, chalk);
                chalk.template.constructor = Chalk;
                return chalk.template;
              }

              applyOptions(this, options);
            }

            if (isSimpleWindowsTerm) {
              ansiStyles.blue.open = "\x1B[94m";
            }

            var _arr = Object.keys(ansiStyles);

            var _loop = function _loop() {
              var key = _arr[_i];
              ansiStyles[key].closeRe = new RegExp(
                escapeStringRegexp(ansiStyles[key].close),
                "g"
              );
              styles[key] = {
                get: function get() {
                  var codes = ansiStyles[key];
                  return build.call(
                    this,
                    this._styles ? this._styles.concat(codes) : [codes],
                    this._empty,
                    key
                  );
                },
              };
            };

            for (var _i = 0; _i < _arr.length; _i++) {
              _loop();
            }

            styles.visible = {
              get: function get() {
                return build.call(this, this._styles || [], true, "visible");
              },
            };
            ansiStyles.color.closeRe = new RegExp(
              escapeStringRegexp(ansiStyles.color.close),
              "g"
            );

            var _arr2 = Object.keys(ansiStyles.color.ansi);

            var _loop2 = function _loop2() {
              var model = _arr2[_i2];

              if (skipModels.has(model)) {
                return "continue";
              }

              styles[model] = {
                get: function get() {
                  var level = this.level;
                  return function() {
                    var open = ansiStyles.color[levelMapping[level]][
                      model
                    ].apply(null, arguments);
                    var codes = {
                      open: open,
                      close: ansiStyles.color.close,
                      closeRe: ansiStyles.color.closeRe,
                    };
                    return build.call(
                      this,
                      this._styles ? this._styles.concat(codes) : [codes],
                      this._empty,
                      model
                    );
                  };
                },
              };
            };

            for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
              var _ret = _loop2();

              if (_ret === "continue") continue;
            }

            ansiStyles.bgColor.closeRe = new RegExp(
              escapeStringRegexp(ansiStyles.bgColor.close),
              "g"
            );

            var _arr3 = Object.keys(ansiStyles.bgColor.ansi);

            var _loop3 = function _loop3() {
              var model = _arr3[_i3];

              if (skipModels.has(model)) {
                return "continue";
              }

              var bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
              styles[bgModel] = {
                get: function get() {
                  var level = this.level;
                  return function() {
                    var open = ansiStyles.bgColor[levelMapping[level]][
                      model
                    ].apply(null, arguments);
                    var codes = {
                      open: open,
                      close: ansiStyles.bgColor.close,
                      closeRe: ansiStyles.bgColor.closeRe,
                    };
                    return build.call(
                      this,
                      this._styles ? this._styles.concat(codes) : [codes],
                      this._empty,
                      model
                    );
                  };
                },
              };
            };

            for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
              var _ret2 = _loop3();

              if (_ret2 === "continue") continue;
            }

            var proto = Object.defineProperties(function() {}, styles);

            function build(_styles, _empty, key) {
              var builder = function builder() {
                return applyStyle.apply(builder, arguments);
              };

              builder._styles = _styles;
              builder._empty = _empty;
              var self = this;
              Object.defineProperty(builder, "level", {
                enumerable: true,
                get: function get() {
                  return self.level;
                },
                set: function set(level) {
                  self.level = level;
                },
              });
              Object.defineProperty(builder, "enabled", {
                enumerable: true,
                get: function get() {
                  return self.enabled;
                },
                set: function set(enabled) {
                  self.enabled = enabled;
                },
              });
              builder.hasGrey =
                this.hasGrey || key === "gray" || key === "grey";
              builder.__proto__ = proto;
              return builder;
            }

            function applyStyle() {
              var args = arguments;
              var argsLen = args.length;
              var str = String(arguments[0]);

              if (argsLen === 0) {
                return "";
              }

              if (argsLen > 1) {
                for (var a = 1; a < argsLen; a++) {
                  str += " " + args[a];
                }
              }

              if (!this.enabled || this.level <= 0 || !str) {
                return this._empty ? "" : str;
              }

              var originalDim = ansiStyles.dim.open;

              if (isSimpleWindowsTerm && this.hasGrey) {
                ansiStyles.dim.open = "";
              }

              for (
                var _iterator = this._styles.slice().reverse(),
                  _isArray = Array.isArray(_iterator),
                  _i4 = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i4 >= _iterator.length) break;
                  _ref = _iterator[_i4++];
                } else {
                  _i4 = _iterator.next();
                  if (_i4.done) break;
                  _ref = _i4.value;
                }

                var code = _ref;
                str =
                  code.open + str.replace(code.closeRe, code.open) + code.close;
                str = str.replace(/\r?\n/g, code.close + "$&" + code.open);
              }

              ansiStyles.dim.open = originalDim;
              return str;
            }

            function chalkTag(chalk, strings) {
              if (!Array.isArray(strings)) {
                return [].slice.call(arguments, 1).join(" ");
              }

              var args = [].slice.call(arguments, 2);
              var parts = [strings.raw[0]];

              for (var i = 1; i < strings.length; i++) {
                parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
                parts.push(String(strings.raw[i]));
              }

              return template(chalk, parts.join(""));
            }

            Object.defineProperties(Chalk.prototype, styles);
            module.exports = Chalk();
            module.exports.supportsColor = stdoutColor;
            module.exports.default = module.exports;
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(3)));
        },
        /* 374 */
        function(module, exports, __webpack_require__) {
          "use strict";

          var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

          module.exports = function(str) {
            if (typeof str !== "string") {
              throw new TypeError("Expected a string");
            }

            return str.replace(matchOperatorsRe, "\\$&");
          };
        },
        /* 375 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(module) {
            var colorConvert = __webpack_require__(376);

            var wrapAnsi16 = function wrapAnsi16(fn, offset) {
              return function() {
                var code = fn.apply(colorConvert, arguments);
                return "\x1B[" + (code + offset) + "m";
              };
            };

            var wrapAnsi256 = function wrapAnsi256(fn, offset) {
              return function() {
                var code = fn.apply(colorConvert, arguments);
                return "\x1B[" + (38 + offset) + ";5;" + code + "m";
              };
            };

            var wrapAnsi16m = function wrapAnsi16m(fn, offset) {
              return function() {
                var rgb = fn.apply(colorConvert, arguments);
                return (
                  "\x1B[" +
                  (38 + offset) +
                  ";2;" +
                  rgb[0] +
                  ";" +
                  rgb[1] +
                  ";" +
                  rgb[2] +
                  "m"
                );
              };
            };

            function assembleStyles() {
              var codes = new Map();
              var styles = {
                modifier: {
                  reset: [0, 0],
                  bold: [1, 22],
                  dim: [2, 22],
                  italic: [3, 23],
                  underline: [4, 24],
                  inverse: [7, 27],
                  hidden: [8, 28],
                  strikethrough: [9, 29],
                },
                color: {
                  black: [30, 39],
                  red: [31, 39],
                  green: [32, 39],
                  yellow: [33, 39],
                  blue: [34, 39],
                  magenta: [35, 39],
                  cyan: [36, 39],
                  white: [37, 39],
                  gray: [90, 39],
                  redBright: [91, 39],
                  greenBright: [92, 39],
                  yellowBright: [93, 39],
                  blueBright: [94, 39],
                  magentaBright: [95, 39],
                  cyanBright: [96, 39],
                  whiteBright: [97, 39],
                },
                bgColor: {
                  bgBlack: [40, 49],
                  bgRed: [41, 49],
                  bgGreen: [42, 49],
                  bgYellow: [43, 49],
                  bgBlue: [44, 49],
                  bgMagenta: [45, 49],
                  bgCyan: [46, 49],
                  bgWhite: [47, 49],
                  bgBlackBright: [100, 49],
                  bgRedBright: [101, 49],
                  bgGreenBright: [102, 49],
                  bgYellowBright: [103, 49],
                  bgBlueBright: [104, 49],
                  bgMagentaBright: [105, 49],
                  bgCyanBright: [106, 49],
                  bgWhiteBright: [107, 49],
                },
              };
              styles.color.grey = styles.color.gray;

              var _arr = Object.keys(styles);

              for (var _i = 0; _i < _arr.length; _i++) {
                var groupName = _arr[_i];
                var group = styles[groupName];

                var _arr3 = Object.keys(group);

                for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                  var styleName = _arr3[_i3];
                  var style = group[styleName];
                  styles[styleName] = {
                    open: "\x1B[" + style[0] + "m",
                    close: "\x1B[" + style[1] + "m",
                  };
                  group[styleName] = styles[styleName];
                  codes.set(style[0], style[1]);
                }

                Object.defineProperty(styles, groupName, {
                  value: group,
                  enumerable: false,
                });
                Object.defineProperty(styles, "codes", {
                  value: codes,
                  enumerable: false,
                });
              }

              var ansi2ansi = function ansi2ansi(n) {
                return n;
              };

              var rgb2rgb = function rgb2rgb(r, g, b) {
                return [r, g, b];
              };

              styles.color.close = "\x1B[39m";
              styles.bgColor.close = "\x1B[49m";
              styles.color.ansi = {
                ansi: wrapAnsi16(ansi2ansi, 0),
              };
              styles.color.ansi256 = {
                ansi256: wrapAnsi256(ansi2ansi, 0),
              };
              styles.color.ansi16m = {
                rgb: wrapAnsi16m(rgb2rgb, 0),
              };
              styles.bgColor.ansi = {
                ansi: wrapAnsi16(ansi2ansi, 10),
              };
              styles.bgColor.ansi256 = {
                ansi256: wrapAnsi256(ansi2ansi, 10),
              };
              styles.bgColor.ansi16m = {
                rgb: wrapAnsi16m(rgb2rgb, 10),
              };

              var _arr2 = Object.keys(colorConvert);

              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var key = _arr2[_i2];

                if (typeof colorConvert[key] !== "object") {
                  continue;
                }

                var suite = colorConvert[key];

                if (key === "ansi16") {
                  key = "ansi";
                }

                if ("ansi16" in suite) {
                  styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
                  styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
                }

                if ("ansi256" in suite) {
                  styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
                  styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
                }

                if ("rgb" in suite) {
                  styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
                  styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
                }
              }

              return styles;
            }

            Object.defineProperty(module, "exports", {
              enumerable: true,
              get: assembleStyles,
            });
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(37)(module)));
        },
        /* 376 */
        function(module, exports, __webpack_require__) {
          var conversions = __webpack_require__(148);

          var route = __webpack_require__(378);

          var convert = {};
          var models = Object.keys(conversions);

          function wrapRaw(fn) {
            var wrappedFn = function wrappedFn(args) {
              if (args === undefined || args === null) {
                return args;
              }

              if (arguments.length > 1) {
                args = Array.prototype.slice.call(arguments);
              }

              return fn(args);
            };

            if ("conversion" in fn) {
              wrappedFn.conversion = fn.conversion;
            }

            return wrappedFn;
          }

          function wrapRounded(fn) {
            var wrappedFn = function wrappedFn(args) {
              if (args === undefined || args === null) {
                return args;
              }

              if (arguments.length > 1) {
                args = Array.prototype.slice.call(arguments);
              }

              var result = fn(args);

              if (typeof result === "object") {
                for (var len = result.length, i = 0; i < len; i++) {
                  result[i] = Math.round(result[i]);
                }
              }

              return result;
            };

            if ("conversion" in fn) {
              wrappedFn.conversion = fn.conversion;
            }

            return wrappedFn;
          }

          models.forEach(function(fromModel) {
            convert[fromModel] = {};
            Object.defineProperty(convert[fromModel], "channels", {
              value: conversions[fromModel].channels,
            });
            Object.defineProperty(convert[fromModel], "labels", {
              value: conversions[fromModel].labels,
            });
            var routes = route(fromModel);
            var routeModels = Object.keys(routes);
            routeModels.forEach(function(toModel) {
              var fn = routes[toModel];
              convert[fromModel][toModel] = wrapRounded(fn);
              convert[fromModel][toModel].raw = wrapRaw(fn);
            });
          });
          module.exports = convert;
        },
        /* 377 */
        function(module, exports, __webpack_require__) {
          "use strict";

          module.exports = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50],
          };
        },
        /* 378 */
        function(module, exports, __webpack_require__) {
          var conversions = __webpack_require__(148);

          function buildGraph() {
            var graph = {};
            var models = Object.keys(conversions);

            for (var len = models.length, i = 0; i < len; i++) {
              graph[models[i]] = {
                distance: -1,
                parent: null,
              };
            }

            return graph;
          }

          function deriveBFS(fromModel) {
            var graph = buildGraph();
            var queue = [fromModel];
            graph[fromModel].distance = 0;

            while (queue.length) {
              var current = queue.pop();
              var adjacents = Object.keys(conversions[current]);

              for (var len = adjacents.length, i = 0; i < len; i++) {
                var adjacent = adjacents[i];
                var node = graph[adjacent];

                if (node.distance === -1) {
                  node.distance = graph[current].distance + 1;
                  node.parent = current;
                  queue.unshift(adjacent);
                }
              }
            }

            return graph;
          }

          function link(from, to) {
            return function(args) {
              return to(from(args));
            };
          }

          function wrapConversion(toModel, graph) {
            var path = [graph[toModel].parent, toModel];
            var fn = conversions[graph[toModel].parent][toModel];
            var cur = graph[toModel].parent;

            while (graph[cur].parent) {
              path.unshift(graph[cur].parent);
              fn = link(conversions[graph[cur].parent][cur], fn);
              cur = graph[cur].parent;
            }

            fn.conversion = path;
            return fn;
          }

          module.exports = function(fromModel) {
            var graph = deriveBFS(fromModel);
            var conversion = {};
            var models = Object.keys(graph);

            for (var len = models.length, i = 0; i < len; i++) {
              var toModel = models[i];
              var node = graph[toModel];

              if (node.parent === null) {
                continue;
              }

              conversion[toModel] = wrapConversion(toModel, graph);
            }

            return conversion;
          };
        },
        /* 379 */
        function(module, exports, __webpack_require__) {
          "use strict";

          module.exports = {
            stdout: false,
            stderr: false,
          };
        },
        /* 380 */
        function(module, exports, __webpack_require__) {
          "use strict";

          var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
          var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
          var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
          var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
          var ESCAPES = new Map([
            ["n", "\n"],
            ["r", "\r"],
            ["t", "\t"],
            ["b", "\b"],
            ["f", "\f"],
            ["v", "\v"],
            ["0", "\0"],
            ["\\", "\\"],
            ["e", "\x1B"],
            ["a", "\x07"],
          ]);

          function unescape(c) {
            if (
              (c[0] === "u" && c.length === 5) ||
              (c[0] === "x" && c.length === 3)
            ) {
              return String.fromCharCode(parseInt(c.slice(1), 16));
            }

            return ESCAPES.get(c) || c;
          }

          function parseArguments(name, args) {
            var results = [];
            var chunks = args.trim().split(/\s*,\s*/g);
            var matches;

            for (
              var _iterator = chunks,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var chunk = _ref;

              if (!isNaN(chunk)) {
                results.push(Number(chunk));
              } else if ((matches = chunk.match(STRING_REGEX))) {
                results.push(
                  matches[2].replace(ESCAPE_REGEX, function(m, escape, chr) {
                    return escape ? unescape(escape) : chr;
                  })
                );
              } else {
                throw new Error(
                  "Invalid Chalk template style argument: " +
                    chunk +
                    " (in style '" +
                    name +
                    "')"
                );
              }
            }

            return results;
          }

          function parseStyle(style) {
            STYLE_REGEX.lastIndex = 0;
            var results = [];
            var matches;

            while ((matches = STYLE_REGEX.exec(style)) !== null) {
              var name = matches[1];

              if (matches[2]) {
                var args = parseArguments(name, matches[2]);
                results.push([name].concat(args));
              } else {
                results.push([name]);
              }
            }

            return results;
          }

          function buildStyle(chalk, styles) {
            var enabled = {};

            for (
              var _iterator2 = styles,
                _isArray2 = Array.isArray(_iterator2),
                _i2 = 0,
                _iterator2 = _isArray2
                  ? _iterator2
                  : _iterator2[Symbol.iterator]();
              ;

            ) {
              var _ref2;

              if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
              } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
              }

              var layer = _ref2;

              for (
                var _iterator3 = layer.styles,
                  _isArray3 = Array.isArray(_iterator3),
                  _i4 = 0,
                  _iterator3 = _isArray3
                    ? _iterator3
                    : _iterator3[Symbol.iterator]();
                ;

              ) {
                var _ref3;

                if (_isArray3) {
                  if (_i4 >= _iterator3.length) break;
                  _ref3 = _iterator3[_i4++];
                } else {
                  _i4 = _iterator3.next();
                  if (_i4.done) break;
                  _ref3 = _i4.value;
                }

                var style = _ref3;
                enabled[style[0]] = layer.inverse ? null : style.slice(1);
              }
            }

            var current = chalk;

            var _arr = Object.keys(enabled);

            for (var _i3 = 0; _i3 < _arr.length; _i3++) {
              var styleName = _arr[_i3];

              if (Array.isArray(enabled[styleName])) {
                if (!(styleName in current)) {
                  throw new Error("Unknown Chalk style: " + styleName);
                }

                if (enabled[styleName].length > 0) {
                  current = current[styleName].apply(
                    current,
                    enabled[styleName]
                  );
                } else {
                  current = current[styleName];
                }
              }
            }

            return current;
          }

          module.exports = function(chalk, tmp) {
            var styles = [];
            var chunks = [];
            var chunk = [];
            tmp.replace(TEMPLATE_REGEX, function(
              m,
              escapeChar,
              inverse,
              style,
              close,
              chr
            ) {
              if (escapeChar) {
                chunk.push(unescape(escapeChar));
              } else if (style) {
                var str = chunk.join("");
                chunk = [];
                chunks.push(
                  styles.length === 0 ? str : buildStyle(chalk, styles)(str)
                );
                styles.push({
                  inverse: inverse,
                  styles: parseStyle(style),
                });
              } else if (close) {
                if (styles.length === 0) {
                  throw new Error(
                    "Found extraneous } in Chalk template literal"
                  );
                }

                chunks.push(buildStyle(chalk, styles)(chunk.join("")));
                chunk = [];
                styles.pop();
              } else {
                chunk.push(chr);
              }
            });
            chunks.push(chunk.join(""));

            if (styles.length > 0) {
              var errMsg =
                "Chalk template literal is missing " +
                styles.length +
                " closing bracket" +
                (styles.length === 1 ? "" : "s") +
                " (`}`)";
              throw new Error(errMsg);
            }

            return chunks.join("");
          };
        },
        /* 381 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(global) {
            Object.defineProperty(exports, "__esModule", {
              value: true,
            });
            exports.evaluateTruthy = evaluateTruthy;
            exports.evaluate = evaluate;
            var VALID_CALLEES = ["String", "Number", "Math"];
            var INVALID_METHODS = ["random"];

            function evaluateTruthy() {
              var res = this.evaluate();
              if (res.confident) return !!res.value;
            }

            function deopt(path, state) {
              if (!state.confident) return;
              state.deoptPath = path;
              state.confident = false;
            }

            function evaluateCached(path, state) {
              var node = path.node;
              var seen = state.seen;

              if (seen.has(node)) {
                var existing = seen.get(node);

                if (existing.resolved) {
                  return existing.value;
                } else {
                  deopt(path, state);
                  return;
                }
              } else {
                var item = {
                  resolved: false,
                };
                seen.set(node, item);

                var val = _evaluate(path, state);

                if (state.confident) {
                  item.resolved = true;
                  item.value = val;
                }

                return val;
              }
            }

            function _evaluate(path, state) {
              if (!state.confident) return;
              var node = path.node;

              if (path.isSequenceExpression()) {
                var exprs = path.get("expressions");
                return evaluateCached(exprs[exprs.length - 1], state);
              }

              if (
                path.isStringLiteral() ||
                path.isNumericLiteral() ||
                path.isBooleanLiteral()
              ) {
                return node.value;
              }

              if (path.isNullLiteral()) {
                return null;
              }

              if (path.isTemplateLiteral()) {
                return evaluateQuasis(path, node.quasis, state);
              }

              if (
                path.isTaggedTemplateExpression() &&
                path.get("tag").isMemberExpression()
              ) {
                var object = path.get("tag.object");
                var name = object.node.name;
                var property = path.get("tag.property");

                if (
                  object.isIdentifier() &&
                  name === "String" &&
                  !path.scope.getBinding(name, true) &&
                  property.isIdentifier &&
                  property.node.name === "raw"
                ) {
                  return evaluateQuasis(path, node.quasi.quasis, state, true);
                }
              }

              if (path.isConditionalExpression()) {
                var testResult = evaluateCached(path.get("test"), state);
                if (!state.confident) return;

                if (testResult) {
                  return evaluateCached(path.get("consequent"), state);
                } else {
                  return evaluateCached(path.get("alternate"), state);
                }
              }

              if (path.isExpressionWrapper()) {
                return evaluateCached(path.get("expression"), state);
              }

              if (
                path.isMemberExpression() &&
                !path.parentPath.isCallExpression({
                  callee: node,
                })
              ) {
                var _property = path.get("property");

                var _object = path.get("object");

                if (_object.isLiteral() && _property.isIdentifier()) {
                  var value = _object.node.value;
                  var type = typeof value;

                  if (type === "number" || type === "string") {
                    return value[_property.node.name];
                  }
                }
              }

              if (path.isReferencedIdentifier()) {
                var binding = path.scope.getBinding(node.name);

                if (binding && binding.constantViolations.length > 0) {
                  return deopt(binding.path, state);
                }

                if (binding && path.node.start < binding.path.node.end) {
                  return deopt(binding.path, state);
                }

                if (binding && binding.hasValue) {
                  return binding.value;
                } else {
                  if (node.name === "undefined") {
                    return binding ? deopt(binding.path, state) : undefined;
                  } else if (node.name === "Infinity") {
                    return binding ? deopt(binding.path, state) : Infinity;
                  } else if (node.name === "NaN") {
                    return binding ? deopt(binding.path, state) : NaN;
                  }

                  var resolved = path.resolve();

                  if (resolved === path) {
                    return deopt(path, state);
                  } else {
                    return evaluateCached(resolved, state);
                  }
                }
              }

              if (
                path.isUnaryExpression({
                  prefix: true,
                })
              ) {
                if (node.operator === "void") {
                  return undefined;
                }

                var argument = path.get("argument");

                if (
                  node.operator === "typeof" &&
                  (argument.isFunction() || argument.isClass())
                ) {
                  return "function";
                }

                var arg = evaluateCached(argument, state);
                if (!state.confident) return;

                switch (node.operator) {
                  case "!":
                    return !arg;

                  case "+":
                    return +arg;

                  case "-":
                    return -arg;

                  case "~":
                    return ~arg;

                  case "typeof":
                    return typeof arg;
                }
              }

              if (path.isArrayExpression()) {
                var arr = [];
                var elems = path.get("elements");

                for (
                  var _iterator = elems,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray
                      ? _iterator
                      : _iterator[Symbol.iterator]();
                  ;

                ) {
                  var _ref;

                  if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                  } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                  }

                  var elem = _ref;
                  var elemValue = elem.evaluate();

                  if (elemValue.confident) {
                    arr.push(elemValue.value);
                  } else {
                    return deopt(elem, state);
                  }
                }

                return arr;
              }

              if (path.isObjectExpression()) {
                var obj = {};
                var props = path.get("properties");

                for (
                  var _iterator2 = props,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : _iterator2[Symbol.iterator]();
                  ;

                ) {
                  var _ref2;

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                  } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                  }

                  var prop = _ref2;

                  if (prop.isObjectMethod() || prop.isSpreadElement()) {
                    return deopt(prop, state);
                  }

                  var keyPath = prop.get("key");
                  var key = keyPath;

                  if (prop.node.computed) {
                    key = key.evaluate();

                    if (!key.confident) {
                      return deopt(keyPath, state);
                    }

                    key = key.value;
                  } else if (key.isIdentifier()) {
                    key = key.node.name;
                  } else {
                    key = key.node.value;
                  }

                  var valuePath = prop.get("value");

                  var _value = valuePath.evaluate();

                  if (!_value.confident) {
                    return deopt(valuePath, state);
                  }

                  _value = _value.value;
                  obj[key] = _value;
                }

                return obj;
              }

              if (path.isLogicalExpression()) {
                var wasConfident = state.confident;
                var left = evaluateCached(path.get("left"), state);
                var leftConfident = state.confident;
                state.confident = wasConfident;
                var right = evaluateCached(path.get("right"), state);
                var rightConfident = state.confident;
                state.confident = leftConfident && rightConfident;

                switch (node.operator) {
                  case "||":
                    if (left && leftConfident) {
                      state.confident = true;
                      return left;
                    }

                    if (!state.confident) return;
                    return left || right;

                  case "&&":
                    if (
                      (!left && leftConfident) ||
                      (!right && rightConfident)
                    ) {
                      state.confident = true;
                    }

                    if (!state.confident) return;
                    return left && right;
                }
              }

              if (path.isBinaryExpression()) {
                var _left = evaluateCached(path.get("left"), state);

                if (!state.confident) return;

                var _right = evaluateCached(path.get("right"), state);

                if (!state.confident) return;

                switch (node.operator) {
                  case "-":
                    return _left - _right;

                  case "+":
                    return _left + _right;

                  case "/":
                    return _left / _right;

                  case "*":
                    return _left * _right;

                  case "%":
                    return _left % _right;

                  case "**":
                    return Math.pow(_left, _right);

                  case "<":
                    return _left < _right;

                  case ">":
                    return _left > _right;

                  case "<=":
                    return _left <= _right;

                  case ">=":
                    return _left >= _right;

                  case "==":
                    return _left == _right;

                  case "!=":
                    return _left != _right;

                  case "===":
                    return _left === _right;

                  case "!==":
                    return _left !== _right;

                  case "|":
                    return _left | _right;

                  case "&":
                    return _left & _right;

                  case "^":
                    return _left ^ _right;

                  case "<<":
                    return _left << _right;

                  case ">>":
                    return _left >> _right;

                  case ">>>":
                    return _left >>> _right;
                }
              }

              if (path.isCallExpression()) {
                var callee = path.get("callee");
                var context;
                var func;

                if (
                  callee.isIdentifier() &&
                  !path.scope.getBinding(callee.node.name, true) &&
                  VALID_CALLEES.indexOf(callee.node.name) >= 0
                ) {
                  func = global[node.callee.name];
                }

                if (callee.isMemberExpression()) {
                  var _object2 = callee.get("object");

                  var _property2 = callee.get("property");

                  if (
                    _object2.isIdentifier() &&
                    _property2.isIdentifier() &&
                    VALID_CALLEES.indexOf(_object2.node.name) >= 0 &&
                    INVALID_METHODS.indexOf(_property2.node.name) < 0
                  ) {
                    context = global[_object2.node.name];
                    func = context[_property2.node.name];
                  }

                  if (_object2.isLiteral() && _property2.isIdentifier()) {
                    var _type = typeof _object2.node.value;

                    if (_type === "string" || _type === "number") {
                      context = _object2.node.value;
                      func = context[_property2.node.name];
                    }
                  }
                }

                if (func) {
                  var args = path.get("arguments").map(function(arg) {
                    return evaluateCached(arg, state);
                  });
                  if (!state.confident) return;
                  return func.apply(context, args);
                }
              }

              deopt(path, state);
            }

            function evaluateQuasis(path, quasis, state, raw) {
              if (raw === void 0) {
                raw = false;
              }

              var str = "";
              var i = 0;
              var exprs = path.get("expressions");

              for (
                var _iterator3 = quasis,
                  _isArray3 = Array.isArray(_iterator3),
                  _i3 = 0,
                  _iterator3 = _isArray3
                    ? _iterator3
                    : _iterator3[Symbol.iterator]();
                ;

              ) {
                var _ref3;

                if (_isArray3) {
                  if (_i3 >= _iterator3.length) break;
                  _ref3 = _iterator3[_i3++];
                } else {
                  _i3 = _iterator3.next();
                  if (_i3.done) break;
                  _ref3 = _i3.value;
                }

                var elem = _ref3;
                if (!state.confident) break;
                str += raw ? elem.value.raw : elem.value.cooked;
                var expr = exprs[i++];
                if (expr) str += String(evaluateCached(expr, state));
              }

              if (!state.confident) return;
              return str;
            }

            function evaluate() {
              var state = {
                confident: true,
                deoptPath: null,
                seen: new Map(),
              };
              var value = evaluateCached(this, state);
              if (!state.confident) value = undefined;
              return {
                confident: state.confident,
                deopt: state.deoptPath,
                value: value,
              };
            }
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(24)));
        },
        /* 382 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.toComputedKey = toComputedKey;
          exports.ensureBlock = ensureBlock;
          exports.arrowFunctionToShadowed = arrowFunctionToShadowed;
          exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
          exports.arrowFunctionToExpression = arrowFunctionToExpression;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _babelHelperFunctionName() {
            var data = _interopRequireDefault(__webpack_require__(383));

            _babelHelperFunctionName = function _babelHelperFunctionName() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function toComputedKey() {
            var node = this.node;
            var key;

            if (this.isMemberExpression()) {
              key = node.property;
            } else if (this.isProperty() || this.isMethod()) {
              key = node.key;
            } else {
              throw new ReferenceError("todo");
            }

            if (!node.computed) {
              if (t().isIdentifier(key)) key = t().stringLiteral(key.name);
            }

            return key;
          }

          function ensureBlock() {
            var body = this.get("body");
            var bodyNode = body.node;

            if (Array.isArray(body)) {
              throw new Error("Can't convert array path to a block statement");
            }

            if (!bodyNode) {
              throw new Error("Can't convert node without a body");
            }

            if (body.isBlockStatement()) {
              return bodyNode;
            }

            var statements = [];
            var stringPath = "body";
            var key;
            var listKey;

            if (body.isStatement()) {
              listKey = "body";
              key = 0;
              statements.push(body.node);
            } else {
              stringPath += ".body.0";

              if (this.isFunction()) {
                key = "argument";
                statements.push(t().returnStatement(body.node));
              } else {
                key = "expression";
                statements.push(t().expressionStatement(body.node));
              }
            }

            this.node.body = t().blockStatement(statements);
            var parentPath = this.get(stringPath);
            body.setup(
              parentPath,
              listKey ? parentPath.node[listKey] : parentPath.node,
              listKey,
              key
            );
            return this.node;
          }

          function arrowFunctionToShadowed() {
            if (!this.isArrowFunctionExpression()) return;
            this.arrowFunctionToExpression();
          }

          function unwrapFunctionEnvironment() {
            if (
              !this.isArrowFunctionExpression() &&
              !this.isFunctionExpression() &&
              !this.isFunctionDeclaration()
            ) {
              throw this.buildCodeFrameError(
                "Can only unwrap the environment of a function."
              );
            }

            hoistFunctionEnvironment(this);
          }

          function arrowFunctionToExpression(_temp) {
            var _ref = _temp === void 0 ? {} : _temp,
              _ref$allowInsertArrow = _ref.allowInsertArrow,
              allowInsertArrow =
                _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,
              _ref$specCompliant = _ref.specCompliant,
              specCompliant =
                _ref$specCompliant === void 0 ? false : _ref$specCompliant;

            if (!this.isArrowFunctionExpression()) {
              throw this.buildCodeFrameError(
                "Cannot convert non-arrow function to a function expression."
              );
            }

            var thisBinding = hoistFunctionEnvironment(
              this,
              specCompliant,
              allowInsertArrow
            );
            this.ensureBlock();
            this.node.type = "FunctionExpression";

            if (specCompliant) {
              var checkBinding = thisBinding
                ? null
                : this.parentPath.scope.generateUidIdentifier("arrowCheckId");

              if (checkBinding) {
                this.parentPath.scope.push({
                  id: checkBinding,
                  init: t().objectExpression([]),
                });
              }

              this.get("body").unshiftContainer(
                "body",
                t().expressionStatement(
                  t().callExpression(this.hub.addHelper("newArrowCheck"), [
                    t().thisExpression(),
                    checkBinding
                      ? t().identifier(checkBinding.name)
                      : t().identifier(thisBinding),
                  ])
                )
              );
              this.replaceWith(
                t().callExpression(
                  t().memberExpression(
                    (0, _babelHelperFunctionName().default)(this, true) ||
                      this.node,
                    t().identifier("bind")
                  ),
                  [
                    checkBinding
                      ? t().identifier(checkBinding.name)
                      : t().thisExpression(),
                  ]
                )
              );
            }
          }

          function hoistFunctionEnvironment(
            fnPath,
            specCompliant,
            allowInsertArrow
          ) {
            if (specCompliant === void 0) {
              specCompliant = false;
            }

            if (allowInsertArrow === void 0) {
              allowInsertArrow = true;
            }

            var thisEnvFn = fnPath.findParent(function(p) {
              return (
                (p.isFunction() && !p.isArrowFunctionExpression()) ||
                p.isProgram() ||
                p.isClassProperty({
                  static: false,
                })
              );
            });
            var inConstructor =
              thisEnvFn && thisEnvFn.node.kind === "constructor";

            if (thisEnvFn.isClassProperty()) {
              throw fnPath.buildCodeFrameError(
                "Unable to transform arrow inside class property"
              );
            }

            var _getScopeInformation = getScopeInformation(fnPath),
              thisPaths = _getScopeInformation.thisPaths,
              argumentsPaths = _getScopeInformation.argumentsPaths,
              newTargetPaths = _getScopeInformation.newTargetPaths,
              superProps = _getScopeInformation.superProps,
              superCalls = _getScopeInformation.superCalls;

            if (inConstructor && superCalls.length > 0) {
              if (!allowInsertArrow) {
                throw superCalls[0].buildCodeFrameError(
                  "Unable to handle nested super() usage in arrow"
                );
              }

              var allSuperCalls = [];
              thisEnvFn.traverse({
                Function: function Function(child) {
                  if (child.isArrowFunctionExpression()) return;
                  child.skip();
                },
                ClassProperty: function ClassProperty(child) {
                  if (child.node.static) return;
                  child.skip();
                },
                CallExpression: function CallExpression(child) {
                  if (!child.get("callee").isSuper()) return;
                  allSuperCalls.push(child);
                },
              });
              var superBinding = getSuperBinding(thisEnvFn);
              allSuperCalls.forEach(function(superCall) {
                var callee = t().identifier(superBinding);
                callee.loc = superCall.node.callee.loc;
                superCall.get("callee").replaceWith(callee);
              });
            }

            var thisBinding;

            if (thisPaths.length > 0 || specCompliant) {
              thisBinding = getThisBinding(thisEnvFn, inConstructor);

              if (
                !specCompliant ||
                (inConstructor && hasSuperClass(thisEnvFn))
              ) {
                thisPaths.forEach(function(thisChild) {
                  var thisRef = thisChild.isJSX()
                    ? t().jsxIdentifier(thisBinding)
                    : t().identifier(thisBinding);
                  thisRef.loc = thisChild.node.loc;
                  thisChild.replaceWith(thisRef);
                });
                if (specCompliant) thisBinding = null;
              }
            }

            if (argumentsPaths.length > 0) {
              var argumentsBinding = getBinding(
                thisEnvFn,
                "arguments",
                function() {
                  return t().identifier("arguments");
                }
              );
              argumentsPaths.forEach(function(argumentsChild) {
                var argsRef = t().identifier(argumentsBinding);
                argsRef.loc = argumentsChild.node.loc;
                argumentsChild.replaceWith(argsRef);
              });
            }

            if (newTargetPaths.length > 0) {
              var newTargetBinding = getBinding(
                thisEnvFn,
                "newtarget",
                function() {
                  return t().metaProperty(
                    t().identifier("new"),
                    t().identifier("target")
                  );
                }
              );
              newTargetPaths.forEach(function(targetChild) {
                var targetRef = t().identifier(newTargetBinding);
                targetRef.loc = targetChild.node.loc;
                targetChild.replaceWith(targetRef);
              });
            }

            if (superProps.length > 0) {
              if (!allowInsertArrow) {
                throw superProps[0].buildCodeFrameError(
                  "Unable to handle nested super.prop usage"
                );
              }

              var flatSuperProps = superProps.reduce(function(acc, superProp) {
                return acc.concat(standardizeSuperProperty(superProp));
              }, []);
              flatSuperProps.forEach(function(superProp) {
                var key = superProp.node.computed
                  ? ""
                  : superProp.get("property").node.name;

                if (
                  superProp.parentPath.isCallExpression({
                    callee: superProp.node,
                  })
                ) {
                  var _superBinding = getSuperPropCallBinding(thisEnvFn, key);

                  if (superProp.node.computed) {
                    var prop = superProp.get("property").node;
                    superProp.replaceWith(t().identifier(_superBinding));
                    superProp.parentPath.node.arguments.unshift(prop);
                  } else {
                    superProp.replaceWith(t().identifier(_superBinding));
                  }
                } else {
                  var isAssignment = superProp.parentPath.isAssignmentExpression(
                    {
                      left: superProp.node,
                    }
                  );

                  var _superBinding2 = getSuperPropBinding(
                    thisEnvFn,
                    isAssignment,
                    key
                  );

                  var args = [];

                  if (superProp.node.computed) {
                    args.push(superProp.get("property").node);
                  }

                  if (isAssignment) {
                    var value = superProp.parentPath.node.right;
                    args.push(value);
                    superProp.parentPath.replaceWith(
                      t().callExpression(t().identifier(_superBinding2), args)
                    );
                  } else {
                    superProp.replaceWith(
                      t().callExpression(t().identifier(_superBinding2), args)
                    );
                  }
                }
              });
            }

            return thisBinding;
          }

          function standardizeSuperProperty(superProp) {
            if (
              superProp.parentPath.isAssignmentExpression() &&
              superProp.parentPath.node.operator !== "="
            ) {
              var assignmentPath = superProp.parentPath;
              var op = assignmentPath.node.operator.slice(0, -1);
              var value = assignmentPath.node.right;
              assignmentPath.node.operator = "=";

              if (superProp.node.computed) {
                var tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
                assignmentPath
                  .get("left")
                  .replaceWith(
                    t().memberExpression(
                      superProp.node.object,
                      t().assignmentExpression(
                        "=",
                        tmp,
                        superProp.node.property
                      ),
                      true
                    )
                  );
                assignmentPath
                  .get("right")
                  .replaceWith(
                    t().binaryExpression(
                      op,
                      t().memberExpression(
                        superProp.node.object,
                        t().identifier(tmp.name),
                        true
                      ),
                      value
                    )
                  );
              } else {
                assignmentPath
                  .get("left")
                  .replaceWith(
                    t().memberExpression(
                      superProp.node.object,
                      superProp.node.property
                    )
                  );
                assignmentPath
                  .get("right")
                  .replaceWith(
                    t().binaryExpression(
                      op,
                      t().memberExpression(
                        superProp.node.object,
                        t().identifier(superProp.node.property.name)
                      ),
                      value
                    )
                  );
              }

              return [
                assignmentPath.get("left"),
                assignmentPath.get("right").get("left"),
              ];
            } else if (superProp.parentPath.isUpdateExpression()) {
              var updateExpr = superProp.parentPath;

              var _tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");

              var computedKey = superProp.node.computed
                ? superProp.scope.generateDeclaredUidIdentifier("prop")
                : null;
              var parts = [
                t().assignmentExpression(
                  "=",
                  _tmp,
                  t().memberExpression(
                    superProp.node.object,
                    computedKey
                      ? t().assignmentExpression(
                          "=",
                          computedKey,
                          superProp.node.property
                        )
                      : superProp.node.property,
                    superProp.node.computed
                  )
                ),
                t().assignmentExpression(
                  "=",
                  t().memberExpression(
                    superProp.node.object,
                    computedKey
                      ? t().identifier(computedKey.name)
                      : superProp.node.property,
                    superProp.node.computed
                  ),
                  t().binaryExpression(
                    "+",
                    t().identifier(_tmp.name),
                    t().numericLiteral(1)
                  )
                ),
              ];

              if (!superProp.parentPath.node.prefix) {
                parts.push(t().identifier(_tmp.name));
              }

              updateExpr.replaceWith(t().sequenceExpression(parts));
              var left = updateExpr.get("expressions.0.right");
              var right = updateExpr.get("expressions.1.left");
              return [left, right];
            }

            return [superProp];
          }

          function hasSuperClass(thisEnvFn) {
            return (
              thisEnvFn.isClassMethod() &&
              !!thisEnvFn.parentPath.parentPath.node.superClass
            );
          }

          function getThisBinding(thisEnvFn, inConstructor) {
            return getBinding(thisEnvFn, "this", function(thisBinding) {
              if (!inConstructor || !hasSuperClass(thisEnvFn))
                return t().thisExpression();
              var supers = new WeakSet();
              thisEnvFn.traverse({
                Function: function Function(child) {
                  if (child.isArrowFunctionExpression()) return;
                  child.skip();
                },
                ClassProperty: function ClassProperty(child) {
                  if (child.node.static) return;
                  child.skip();
                },
                CallExpression: function CallExpression(child) {
                  if (!child.get("callee").isSuper()) return;
                  if (supers.has(child.node)) return;
                  supers.add(child.node);
                  child.replaceWith(
                    t().assignmentExpression(
                      "=",
                      t().identifier(thisBinding),
                      child.node
                    )
                  );
                },
              });
            });
          }

          function getSuperBinding(thisEnvFn) {
            return getBinding(thisEnvFn, "supercall", function() {
              var argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
              return t().arrowFunctionExpression(
                [t().restElement(argsBinding)],
                t().callExpression(t().super(), [
                  t().spreadElement(t().identifier(argsBinding.name)),
                ])
              );
            });
          }

          function getSuperPropCallBinding(thisEnvFn, propName) {
            return getBinding(
              thisEnvFn,
              "superprop_call:" + (propName || ""),
              function() {
                var argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
                var argsList = [t().restElement(argsBinding)];
                var fnBody;

                if (propName) {
                  fnBody = t().callExpression(
                    t().memberExpression(t().super(), t().identifier(propName)),
                    [t().spreadElement(t().identifier(argsBinding.name))]
                  );
                } else {
                  var method = thisEnvFn.scope.generateUidIdentifier("prop");
                  argsList.unshift(method);
                  fnBody = t().callExpression(
                    t().memberExpression(
                      t().super(),
                      t().identifier(method.name),
                      true
                    ),
                    [t().spreadElement(t().identifier(argsBinding.name))]
                  );
                }

                return t().arrowFunctionExpression(argsList, fnBody);
              }
            );
          }

          function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
            var op = isAssignment ? "set" : "get";
            return getBinding(
              thisEnvFn,
              "superprop_" + op + ":" + (propName || ""),
              function() {
                var argsList = [];
                var fnBody;

                if (propName) {
                  fnBody = t().memberExpression(
                    t().super(),
                    t().identifier(propName)
                  );
                } else {
                  var method = thisEnvFn.scope.generateUidIdentifier("prop");
                  argsList.unshift(method);
                  fnBody = t().memberExpression(
                    t().super(),
                    t().identifier(method.name),
                    true
                  );
                }

                if (isAssignment) {
                  var valueIdent = thisEnvFn.scope.generateUidIdentifier(
                    "value"
                  );
                  argsList.push(valueIdent);
                  fnBody = t().assignmentExpression(
                    "=",
                    fnBody,
                    t().identifier(valueIdent.name)
                  );
                }

                return t().arrowFunctionExpression(argsList, fnBody);
              }
            );
          }

          function getBinding(thisEnvFn, key, init) {
            var cacheKey = "binding:" + key;
            var data = thisEnvFn.getData(cacheKey);

            if (!data) {
              var id = thisEnvFn.scope.generateUidIdentifier(key);
              data = id.name;
              thisEnvFn.setData(cacheKey, data);
              thisEnvFn.scope.push({
                id: id,
                init: init(data),
              });
            }

            return data;
          }

          function getScopeInformation(fnPath) {
            var thisPaths = [];
            var argumentsPaths = [];
            var newTargetPaths = [];
            var superProps = [];
            var superCalls = [];
            fnPath.traverse({
              ClassProperty: function ClassProperty(child) {
                if (child.node.static) return;
                child.skip();
              },
              Function: function Function(child) {
                if (child.isArrowFunctionExpression()) return;
                child.skip();
              },
              ThisExpression: function ThisExpression(child) {
                thisPaths.push(child);
              },
              JSXIdentifier: function JSXIdentifier(child) {
                if (child.node.name !== "this") return;

                if (
                  !child.parentPath.isJSXMemberExpression({
                    object: child.node,
                  }) &&
                  !child.parentPath.isJSXOpeningElement({
                    name: child.node,
                  })
                ) {
                  return;
                }

                thisPaths.push(child);
              },
              CallExpression: function CallExpression(child) {
                if (child.get("callee").isSuper()) superCalls.push(child);
              },
              MemberExpression: function MemberExpression(child) {
                if (child.get("object").isSuper()) superProps.push(child);
              },
              ReferencedIdentifier: function ReferencedIdentifier(child) {
                if (child.node.name !== "arguments") return;
                argumentsPaths.push(child);
              },
              MetaProperty: function MetaProperty(child) {
                if (
                  !child.get("meta").isIdentifier({
                    name: "new",
                  })
                )
                  return;
                if (
                  !child.get("property").isIdentifier({
                    name: "target",
                  })
                )
                  return;
                newTargetPaths.push(child);
              },
            });
            return {
              thisPaths: thisPaths,
              argumentsPaths: argumentsPaths,
              newTargetPaths: newTargetPaths,
              superProps: superProps,
              superCalls: superCalls,
            };
          }
        },
        /* 383 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = _default;

          function _babelHelperGetFunctionArity() {
            var data = _interopRequireDefault(__webpack_require__(384));

            _babelHelperGetFunctionArity = function _babelHelperGetFunctionArity() {
              return data;
            };

            return data;
          }

          function _babelTemplate() {
            var data = _interopRequireDefault(__webpack_require__(45));

            _babelTemplate = function _babelTemplate() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var buildPropertyMethodAssignmentWrapper = (0,
          _babelTemplate().default)(
            "\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"
          );
          var buildGeneratorPropertyMethodAssignmentWrapper = (0,
          _babelTemplate().default)(
            "\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"
          );
          var visitor = {
            "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(
              path,
              state
            ) {
              if (path.node.name !== state.name) return;
              var localDeclar = path.scope.getBindingIdentifier(state.name);
              if (localDeclar !== state.outerDeclar) return;
              state.selfReference = true;
              path.stop();
            },
          };

          function getNameFromLiteralId(id) {
            if (t().isNullLiteral(id)) {
              return "null";
            }

            if (t().isRegExpLiteral(id)) {
              return "_" + id.pattern + "_" + id.flags;
            }

            if (t().isTemplateLiteral(id)) {
              return id.quasis
                .map(function(quasi) {
                  return quasi.value.raw;
                })
                .join("");
            }

            if (id.value !== undefined) {
              return id.value + "";
            }

            return "";
          }

          function wrap(state, method, id, scope) {
            if (state.selfReference) {
              if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
                scope.rename(id.name);
              } else {
                if (!t().isFunction(method)) return;
                var build = buildPropertyMethodAssignmentWrapper;

                if (method.generator) {
                  build = buildGeneratorPropertyMethodAssignmentWrapper;
                }

                var template = build({
                  FUNCTION: method,
                  FUNCTION_ID: id,
                  FUNCTION_KEY: scope.generateUidIdentifier(id.name),
                }).expression;
                var params = template.callee.body.body[0].params;

                for (
                  var i = 0,
                    len = (0, _babelHelperGetFunctionArity().default)(method);
                  i < len;
                  i++
                ) {
                  params.push(scope.generateUidIdentifier("x"));
                }

                return template;
              }
            }

            method.id = id;
            scope.getProgramParent().references[id.name] = true;
          }

          function visit(node, name, scope) {
            var state = {
              selfAssignment: false,
              selfReference: false,
              outerDeclar: scope.getBindingIdentifier(name),
              references: [],
              name: name,
            };
            var binding = scope.getOwnBinding(name);

            if (binding) {
              if (binding.kind === "param") {
                state.selfReference = true;
              } else {
              }
            } else if (state.outerDeclar || scope.hasGlobal(name)) {
              scope.traverse(node, visitor, state);
            }

            return state;
          }

          function _default(_ref, localBinding) {
            var node = _ref.node,
              parent = _ref.parent,
              scope = _ref.scope,
              id = _ref.id;

            if (localBinding === void 0) {
              localBinding = false;
            }

            if (node.id) return;

            if (
              (t().isObjectProperty(parent) ||
                t().isObjectMethod(parent, {
                  kind: "method",
                })) &&
              (!parent.computed || t().isLiteral(parent.key))
            ) {
              id = parent.key;
            } else if (t().isVariableDeclarator(parent)) {
              id = parent.id;

              if (t().isIdentifier(id) && !localBinding) {
                var binding = scope.parent.getBinding(id.name);

                if (
                  binding &&
                  binding.constant &&
                  scope.getBinding(id.name) === binding
                ) {
                  node.id = t().cloneNode(id);
                  node.id[t().NOT_LOCAL_BINDING] = true;
                  return;
                }
              }
            } else if (t().isAssignmentExpression(parent)) {
              id = parent.left;
            } else if (!id) {
              return;
            }

            var name;

            if (id && t().isLiteral(id)) {
              name = getNameFromLiteralId(id);
            } else if (id && t().isIdentifier(id)) {
              name = id.name;
            }

            if (name === undefined) {
              return;
            }

            name = t().toBindingIdentifierName(name);
            id = t().identifier(name);
            id[t().NOT_LOCAL_BINDING] = true;
            var state = visit(node, name, scope);
            return wrap(state, node, id, scope) || node;
          }
        },
        /* 384 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = _default;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _default(node) {
            var params = node.params;

            for (var i = 0; i < params.length; i++) {
              var param = params[i];

              if (t().isAssignmentPattern(param) || t().isRestElement(param)) {
                return i;
              }
            }

            return params.length;
          }
        },
        /* 385 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.program = exports.expression = exports.statement = exports.statements = exports.smart = void 0;

          function makeStatementFormatter(fn) {
            return {
              code: function code(str) {
                return "/* @gerhobbelt/babel-template */;\n" + str;
              },
              validate: function validate() {},
              unwrap: function unwrap(ast) {
                return fn(ast.program.body.slice(1));
              },
            };
          }

          var smart = makeStatementFormatter(function(body) {
            if (body.length > 1) {
              return body;
            } else {
              return body[0];
            }
          });
          exports.smart = smart;
          var statements = makeStatementFormatter(function(body) {
            return body;
          });
          exports.statements = statements;
          var statement = makeStatementFormatter(function(body) {
            if (body.length === 0) {
              throw new Error("Found nothing to return.");
            }

            if (body.length > 1) {
              throw new Error("Found multiple statements but wanted one");
            }

            return body[0];
          });
          exports.statement = statement;
          var expression = {
            code: function code(str) {
              return "(\n" + str + "\n)";
            },
            validate: function validate(_ref) {
              var program = _ref.program;

              if (program.body.length > 1) {
                throw new Error("Found multiple statements but wanted one");
              }

              var expression = program.body[0].expression;

              if (expression.start === 0) {
                throw new Error("Parse result included parens.");
              }
            },
            unwrap: function unwrap(ast) {
              return ast.program.body[0].expression;
            },
          };
          exports.expression = expression;
          var program = {
            code: function code(str) {
              return str;
            },
            validate: function validate() {},
            unwrap: function unwrap(ast) {
              return ast.program;
            },
          };
          exports.program = program;
        },
        /* 386 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = createTemplateBuilder;

          var _options = __webpack_require__(81);

          var _string = _interopRequireDefault(__webpack_require__(387));

          var _literal = _interopRequireDefault(__webpack_require__(388));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var NO_PLACEHOLDER = (0, _options.validate)({
            placeholderPattern: false,
          });

          function createTemplateBuilder(formatter, defaultOpts) {
            var templateFnCache = new WeakMap();
            var templateAstCache = new WeakMap();
            var cachedOpts = defaultOpts || (0, _options.validate)(null);
            return Object.assign(
              function(tpl) {
                for (
                  var _len = arguments.length,
                    args = new Array(_len > 1 ? _len - 1 : 0),
                    _key = 1;
                  _key < _len;
                  _key++
                ) {
                  args[_key - 1] = arguments[_key];
                }

                if (typeof tpl === "string") {
                  if (args.length > 1)
                    throw new Error("Unexpected extra params.");
                  return extendedTrace(
                    (0, _string.default)(
                      formatter,
                      tpl,
                      (0, _options.merge)(
                        cachedOpts,
                        (0, _options.validate)(args[0])
                      )
                    )
                  );
                } else if (Array.isArray(tpl)) {
                  var builder = templateFnCache.get(tpl);

                  if (!builder) {
                    builder = (0, _literal.default)(formatter, tpl, cachedOpts);
                    templateFnCache.set(tpl, builder);
                  }

                  return extendedTrace(builder(args));
                } else if (typeof tpl === "object" && tpl) {
                  if (args.length > 0)
                    throw new Error("Unexpected extra params.");
                  return createTemplateBuilder(
                    formatter,
                    (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl))
                  );
                }

                throw new Error("Unexpected template param " + typeof tpl);
              },
              {
                ast: function ast(tpl) {
                  for (
                    var _len2 = arguments.length,
                      args = new Array(_len2 > 1 ? _len2 - 1 : 0),
                      _key2 = 1;
                    _key2 < _len2;
                    _key2++
                  ) {
                    args[_key2 - 1] = arguments[_key2];
                  }

                  if (typeof tpl === "string") {
                    if (args.length > 1)
                      throw new Error("Unexpected extra params.");
                    return (0, _string.default)(
                      formatter,
                      tpl,
                      (0, _options.merge)(
                        (0, _options.merge)(
                          cachedOpts,
                          (0, _options.validate)(args[0])
                        ),
                        NO_PLACEHOLDER
                      )
                    )();
                  } else if (Array.isArray(tpl)) {
                    var builder = templateAstCache.get(tpl);

                    if (!builder) {
                      builder = (0, _literal.default)(
                        formatter,
                        tpl,
                        (0, _options.merge)(cachedOpts, NO_PLACEHOLDER)
                      );
                      templateAstCache.set(tpl, builder);
                    }

                    return builder(args)();
                  }

                  throw new Error("Unexpected template param " + typeof tpl);
                },
              }
            );
          }

          function extendedTrace(fn) {
            var rootStack = "";

            try {
              throw new Error();
            } catch (error) {
              if (error.stack) {
                rootStack = error.stack
                  .split("\n")
                  .slice(3)
                  .join("\n");
              }
            }

            return function(arg) {
              try {
                return fn(arg);
              } catch (err) {
                err.stack += "\n    =============\n" + rootStack;
                throw err;
              }
            };
          }
        },
        /* 387 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = stringTemplate;

          var _options = __webpack_require__(81);

          var _parse = _interopRequireDefault(__webpack_require__(149));

          var _populate = _interopRequireDefault(__webpack_require__(150));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function stringTemplate(formatter, code, opts) {
            code = formatter.code(code);
            var metadata;
            return function(arg) {
              var replacements = (0, _options.normalizeReplacements)(arg);
              if (!metadata)
                metadata = (0, _parse.default)(formatter, code, opts);
              return formatter.unwrap(
                (0, _populate.default)(metadata, replacements)
              );
            };
          }
        },
        /* 388 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = literalTemplate;

          var _options = __webpack_require__(81);

          var _parse = _interopRequireDefault(__webpack_require__(149));

          var _populate = _interopRequireDefault(__webpack_require__(150));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function literalTemplate(formatter, tpl, opts) {
            var _buildLiteralData = buildLiteralData(formatter, tpl, opts),
              metadata = _buildLiteralData.metadata,
              names = _buildLiteralData.names;

            return function(arg) {
              var defaultReplacements = arg.reduce(function(
                acc,
                replacement,
                i
              ) {
                acc[names[i]] = replacement;
                return acc;
              },
              {});
              return function(arg) {
                var replacements = (0, _options.normalizeReplacements)(arg);

                if (replacements) {
                  Object.keys(replacements).forEach(function(key) {
                    if (
                      Object.prototype.hasOwnProperty.call(
                        defaultReplacements,
                        key
                      )
                    ) {
                      throw new Error("Unexpected replacement overlap.");
                    }
                  });
                }

                return formatter.unwrap(
                  (0, _populate.default)(
                    metadata,
                    replacements
                      ? Object.assign(replacements, defaultReplacements)
                      : defaultReplacements
                  )
                );
              };
            };
          }

          function buildLiteralData(formatter, tpl, opts) {
            var names;
            var nameSet;
            var metadata;
            var prefix = "";

            do {
              prefix += "$";
              var result = buildTemplateCode(tpl, prefix);
              names = result.names;
              nameSet = new Set(names);
              metadata = (0, _parse.default)(
                formatter,
                formatter.code(result.code),
                {
                  parser: opts.parser,
                  placeholderWhitelist: new Set(
                    result.names.concat(
                      opts.placeholderWhitelist
                        ? Array.from(opts.placeholderWhitelist)
                        : []
                    )
                  ),
                  placeholderPattern: opts.placeholderPattern,
                  preserveComments: opts.preserveComments,
                }
              );
            } while (
              metadata.placeholders.some(function(placeholder) {
                return placeholder.isDuplicate && nameSet.has(placeholder.name);
              })
            );

            return {
              metadata: metadata,
              names: names,
            };
          }

          function buildTemplateCode(tpl, prefix) {
            var names = [];
            var code = tpl[0];

            for (var i = 1; i < tpl.length; i++) {
              var value = "" + prefix + (i - 1);
              names.push(value);
              code += value + tpl[i];
            }

            return {
              names: names,
              code: code,
            };
          }
        },
        /* 389 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.matchesPattern = matchesPattern;
          exports.has = has;
          exports.isStatic = isStatic;
          exports.isnt = isnt;
          exports.equals = equals;
          exports.isNodeType = isNodeType;
          exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
          exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
          exports.isCompletionRecord = isCompletionRecord;
          exports.isStatementOrBlock = isStatementOrBlock;
          exports.referencesImport = referencesImport;
          exports.getSource = getSource;
          exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
          exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
          exports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;
          exports.resolve = resolve;
          exports._resolve = _resolve;
          exports.isConstantExpression = isConstantExpression;
          exports.isInStrictMode = isInStrictMode;
          exports.is = void 0;

          function _includes() {
            var data = _interopRequireDefault(__webpack_require__(73));

            _includes = function _includes() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function matchesPattern(pattern, allowPartial) {
            return t().matchesPattern(this.node, pattern, allowPartial);
          }

          function has(key) {
            var val = this.node && this.node[key];

            if (val && Array.isArray(val)) {
              return !!val.length;
            } else {
              return !!val;
            }
          }

          function isStatic() {
            return this.scope.isStatic(this.node);
          }

          var is = has;
          exports.is = is;

          function isnt(key) {
            return !this.has(key);
          }

          function equals(key, value) {
            return this.node[key] === value;
          }

          function isNodeType(type) {
            return t().isType(this.type, type);
          }

          function canHaveVariableDeclarationOrExpression() {
            return (
              (this.key === "init" || this.key === "left") &&
              this.parentPath.isFor()
            );
          }

          function canSwapBetweenExpressionAndStatement(replacement) {
            if (
              this.key !== "body" ||
              !this.parentPath.isArrowFunctionExpression()
            ) {
              return false;
            }

            if (this.isExpression()) {
              return t().isBlockStatement(replacement);
            } else if (this.isBlockStatement()) {
              return t().isExpression(replacement);
            }

            return false;
          }

          function isCompletionRecord(allowInsideFunction) {
            var path = this;
            var first = true;

            do {
              var container = path.container;

              if (path.isFunction() && !first) {
                return !!allowInsideFunction;
              }

              first = false;

              if (
                Array.isArray(container) &&
                path.key !== container.length - 1
              ) {
                return false;
              }
            } while ((path = path.parentPath) && !path.isProgram());

            return true;
          }

          function isStatementOrBlock() {
            if (
              this.parentPath.isLabeledStatement() ||
              t().isBlockStatement(this.container)
            ) {
              return false;
            } else {
              return (0, _includes().default)(
                t().STATEMENT_OR_BLOCK_KEYS,
                this.key
              );
            }
          }

          function referencesImport(moduleSource, importName) {
            if (!this.isReferencedIdentifier()) return false;
            var binding = this.scope.getBinding(this.node.name);
            if (!binding || binding.kind !== "module") return false;
            var path = binding.path;
            var parent = path.parentPath;
            if (!parent.isImportDeclaration()) return false;

            if (parent.node.source.value === moduleSource) {
              if (!importName) return true;
            } else {
              return false;
            }

            if (path.isImportDefaultSpecifier() && importName === "default") {
              return true;
            }

            if (path.isImportNamespaceSpecifier() && importName === "*") {
              return true;
            }

            if (
              path.isImportSpecifier() &&
              path.node.imported.name === importName
            ) {
              return true;
            }

            return false;
          }

          function getSource() {
            var node = this.node;

            if (node.end) {
              var code = this.hub.getCode();
              if (code) return code.slice(node.start, node.end);
            }

            return "";
          }

          function willIMaybeExecuteBefore(target) {
            return this._guessExecutionStatusRelativeTo(target) !== "after";
          }

          function _guessExecutionStatusRelativeTo(target) {
            var targetFuncParent =
              target.scope.getFunctionParent() ||
              target.scope.getProgramParent();
            var selfFuncParent =
              this.scope.getFunctionParent() || target.scope.getProgramParent();

            if (targetFuncParent.node !== selfFuncParent.node) {
              var status = this._guessExecutionStatusRelativeToDifferentFunctions(
                targetFuncParent
              );

              if (status) {
                return status;
              } else {
                target = targetFuncParent.path;
              }
            }

            var targetPaths = target.getAncestry();
            if (targetPaths.indexOf(this) >= 0) return "after";
            var selfPaths = this.getAncestry();
            var commonPath;
            var targetIndex;
            var selfIndex;

            for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {
              var selfPath = selfPaths[selfIndex];
              targetIndex = targetPaths.indexOf(selfPath);

              if (targetIndex >= 0) {
                commonPath = selfPath;
                break;
              }
            }

            if (!commonPath) {
              return "before";
            }

            var targetRelationship = targetPaths[targetIndex - 1];
            var selfRelationship = selfPaths[selfIndex - 1];

            if (!targetRelationship || !selfRelationship) {
              return "before";
            }

            if (
              targetRelationship.listKey &&
              targetRelationship.container === selfRelationship.container
            ) {
              return targetRelationship.key > selfRelationship.key
                ? "before"
                : "after";
            }

            var keys = t().VISITOR_KEYS[commonPath.type];
            var targetKeyPosition = keys.indexOf(targetRelationship.key);
            var selfKeyPosition = keys.indexOf(selfRelationship.key);
            return targetKeyPosition > selfKeyPosition ? "before" : "after";
          }

          function _guessExecutionStatusRelativeToDifferentFunctions(
            targetFuncParent
          ) {
            var targetFuncPath = targetFuncParent.path;
            if (!targetFuncPath.isFunctionDeclaration()) return;
            var binding = targetFuncPath.scope.getBinding(
              targetFuncPath.node.id.name
            );
            if (!binding.references) return "before";
            var referencePaths = binding.referencePaths;

            for (
              var _iterator = referencePaths,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var path = _ref;

              if (
                path.key !== "callee" ||
                !path.parentPath.isCallExpression()
              ) {
                return;
              }
            }

            var allStatus;

            for (
              var _iterator2 = referencePaths,
                _isArray2 = Array.isArray(_iterator2),
                _i2 = 0,
                _iterator2 = _isArray2
                  ? _iterator2
                  : _iterator2[Symbol.iterator]();
              ;

            ) {
              var _ref2;

              if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
              } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
              }

              var _path = _ref2;
              var childOfFunction = !!_path.find(function(path) {
                return path.node === targetFuncPath.node;
              });
              if (childOfFunction) continue;

              var status = this._guessExecutionStatusRelativeTo(_path);

              if (allStatus) {
                if (allStatus !== status) return;
              } else {
                allStatus = status;
              }
            }

            return allStatus;
          }

          function resolve(dangerous, resolved) {
            return this._resolve(dangerous, resolved) || this;
          }

          function _resolve(dangerous, resolved) {
            if (resolved && resolved.indexOf(this) >= 0) return;
            resolved = resolved || [];
            resolved.push(this);

            if (this.isVariableDeclarator()) {
              if (this.get("id").isIdentifier()) {
                return this.get("init").resolve(dangerous, resolved);
              } else {
              }
            } else if (this.isReferencedIdentifier()) {
              var binding = this.scope.getBinding(this.node.name);
              if (!binding) return;
              if (!binding.constant) return;
              if (binding.kind === "module") return;

              if (binding.path !== this) {
                var ret = binding.path.resolve(dangerous, resolved);
                if (
                  this.find(function(parent) {
                    return parent.node === ret.node;
                  })
                )
                  return;
                return ret;
              }
            } else if (this.isTypeCastExpression()) {
              return this.get("expression").resolve(dangerous, resolved);
            } else if (dangerous && this.isMemberExpression()) {
              var targetKey = this.toComputedKey();
              if (!t().isLiteral(targetKey)) return;
              var targetName = targetKey.value;
              var target = this.get("object").resolve(dangerous, resolved);

              if (target.isObjectExpression()) {
                var props = target.get("properties");

                for (
                  var _iterator3 = props,
                    _isArray3 = Array.isArray(_iterator3),
                    _i3 = 0,
                    _iterator3 = _isArray3
                      ? _iterator3
                      : _iterator3[Symbol.iterator]();
                  ;

                ) {
                  var _ref3;

                  if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                  } else {
                    _i3 = _iterator3.next();
                    if (_i3.done) break;
                    _ref3 = _i3.value;
                  }

                  var prop = _ref3;
                  if (!prop.isProperty()) continue;
                  var key = prop.get("key");
                  var match =
                    prop.isnt("computed") &&
                    key.isIdentifier({
                      name: targetName,
                    });
                  match =
                    match ||
                    key.isLiteral({
                      value: targetName,
                    });
                  if (match)
                    return prop.get("value").resolve(dangerous, resolved);
                }
              } else if (target.isArrayExpression() && !isNaN(+targetName)) {
                var elems = target.get("elements");
                var elem = elems[targetName];
                if (elem) return elem.resolve(dangerous, resolved);
              }
            }
          }

          function isConstantExpression() {
            if (this.isIdentifier()) {
              var binding = this.scope.getBinding(this.node.name);
              if (!binding) return false;
              return binding.constant;
            }

            if (this.isLiteral()) {
              if (this.isRegExpLiteral()) {
                return false;
              }

              if (this.isTemplateLiteral()) {
                return this.get("expressions").every(function(expression) {
                  return expression.isConstantExpression();
                });
              }

              return true;
            }

            if (this.isUnaryExpression()) {
              if (this.get("operator").node !== "void") {
                return false;
              }

              return this.get("argument").isConstantExpression();
            }

            if (this.isBinaryExpression()) {
              return (
                this.get("left").isConstantExpression() &&
                this.get("right").isConstantExpression()
              );
            }

            return false;
          }

          function isInStrictMode() {
            var start = this.isProgram() ? this : this.parentPath;
            var strictParent = start.find(function(path) {
              if (
                path.isProgram({
                  sourceType: "module",
                })
              )
                return true;
              if (path.isClass()) return true;
              if (!path.isProgram() && !path.isFunction()) return false;

              if (
                path.isArrowFunctionExpression() &&
                !path.get("body").isBlockStatement()
              ) {
                return false;
              }

              var node = path.node;
              if (path.isFunction()) node = node.body;

              for (
                var _iterator4 = node.directives,
                  _isArray4 = Array.isArray(_iterator4),
                  _i4 = 0,
                  _iterator4 = _isArray4
                    ? _iterator4
                    : _iterator4[Symbol.iterator]();
                ;

              ) {
                var _ref4;

                if (_isArray4) {
                  if (_i4 >= _iterator4.length) break;
                  _ref4 = _iterator4[_i4++];
                } else {
                  _i4 = _iterator4.next();
                  if (_i4.done) break;
                  _ref4 = _i4.value;
                }

                var directive = _ref4;

                if (directive.value.value === "use strict") {
                  return true;
                }
              }
            });
            return !!strictParent;
          }
        },
        /* 390 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.call = call;
          exports._call = _call;
          exports.isBlacklisted = isBlacklisted;
          exports.visit = visit;
          exports.skip = skip;
          exports.skipKey = skipKey;
          exports.stop = stop;
          exports.setScope = setScope;
          exports.setContext = setContext;
          exports.resync = resync;
          exports._resyncParent = _resyncParent;
          exports._resyncKey = _resyncKey;
          exports._resyncList = _resyncList;
          exports._resyncRemoved = _resyncRemoved;
          exports.popContext = popContext;
          exports.pushContext = pushContext;
          exports.setup = setup;
          exports.setKey = setKey;
          exports.requeue = requeue;
          exports._getQueueContexts = _getQueueContexts;

          var _index = _interopRequireDefault(__webpack_require__(9));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function call(key) {
            var opts = this.opts;
            this.debug(key);

            if (this.node) {
              if (this._call(opts[key])) return true;
            }

            if (this.node) {
              return this._call(
                opts[this.node.type] && opts[this.node.type][key]
              );
            }

            return false;
          }

          function _call(fns) {
            if (!fns) return false;

            for (
              var _iterator = fns,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var fn = _ref;
              if (!fn) continue;
              var node = this.node;
              if (!node) return true;
              var ret = fn.call(this.state, this, this.state);

              if (
                ret &&
                typeof ret === "object" &&
                typeof ret.then === "function"
              ) {
                throw new Error(
                  "You appear to be using a plugin with an async traversal visitor, " +
                    "which your current version of Babel does not support." +
                    "If you're using a published plugin, you may need to upgrade " +
                    "your @gerhobbelt/babel-core version."
                );
              }

              if (ret) {
                throw new Error(
                  "Unexpected return value from visitor method " + fn
                );
              }

              if (this.node !== node) return true;
              if (this.shouldStop || this.shouldSkip || this.removed)
                return true;
            }

            return false;
          }

          function isBlacklisted() {
            var blacklist = this.opts.blacklist;
            return blacklist && blacklist.indexOf(this.node.type) > -1;
          }

          function visit() {
            if (!this.node) {
              return false;
            }

            if (this.isBlacklisted()) {
              return false;
            }

            if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
              return false;
            }

            if (this.call("enter") || this.shouldSkip) {
              this.debug("Skip...");
              return this.shouldStop;
            }

            this.debug("Recursing into...");

            _index.default.node(
              this.node,
              this.opts,
              this.scope,
              this.state,
              this,
              this.skipKeys
            );

            this.call("exit");
            return this.shouldStop;
          }

          function skip() {
            this.shouldSkip = true;
          }

          function skipKey(key) {
            this.skipKeys[key] = true;
          }

          function stop() {
            this.shouldStop = true;
            this.shouldSkip = true;
          }

          function setScope() {
            if (this.opts && this.opts.noScope) return;
            var path = this.parentPath;
            var target;

            while (path && !target) {
              if (path.opts && path.opts.noScope) return;
              target = path.scope;
              path = path.parentPath;
            }

            this.scope = this.getScope(target);
            if (this.scope) this.scope.init();
          }

          function setContext(context) {
            this.shouldSkip = false;
            this.shouldStop = false;
            this.removed = false;
            this.skipKeys = {};

            if (context) {
              this.context = context;
              this.state = context.state;
              this.opts = context.opts;
            }

            this.setScope();
            return this;
          }

          function resync() {
            if (this.removed) return;

            this._resyncParent();

            this._resyncList();

            this._resyncKey();
          }

          function _resyncParent() {
            if (this.parentPath) {
              this.parent = this.parentPath.node;
            }
          }

          function _resyncKey() {
            if (!this.container) return;
            if (this.node === this.container[this.key]) return;

            if (Array.isArray(this.container)) {
              for (var i = 0; i < this.container.length; i++) {
                if (this.container[i] === this.node) {
                  return this.setKey(i);
                }
              }
            } else {
              for (var key in this.container) {
                if (this.container[key] === this.node) {
                  return this.setKey(key);
                }
              }
            }

            this.key = null;
          }

          function _resyncList() {
            if (!this.parent || !this.inList) return;
            var newContainer = this.parent[this.listKey];
            if (this.container === newContainer) return;
            this.container = newContainer || null;
          }

          function _resyncRemoved() {
            if (
              this.key == null ||
              !this.container ||
              this.container[this.key] !== this.node
            ) {
              this._markRemoved();
            }
          }

          function popContext() {
            this.contexts.pop();

            if (this.contexts.length > 0) {
              this.setContext(this.contexts[this.contexts.length - 1]);
            } else {
              this.setContext(undefined);
            }
          }

          function pushContext(context) {
            this.contexts.push(context);
            this.setContext(context);
          }

          function setup(parentPath, container, listKey, key) {
            this.inList = !!listKey;
            this.listKey = listKey;
            this.parentKey = listKey || key;
            this.container = container;
            this.parentPath = parentPath || this.parentPath;
            this.setKey(key);
          }

          function setKey(key) {
            this.key = key;
            this.node = this.container[this.key];
            this.type = this.node && this.node.type;
          }

          function requeue(pathToQueue) {
            if (pathToQueue === void 0) {
              pathToQueue = this;
            }

            if (pathToQueue.removed) return;
            var contexts = this.contexts;

            for (
              var _iterator2 = contexts,
                _isArray2 = Array.isArray(_iterator2),
                _i2 = 0,
                _iterator2 = _isArray2
                  ? _iterator2
                  : _iterator2[Symbol.iterator]();
              ;

            ) {
              var _ref2;

              if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
              } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
              }

              var context = _ref2;
              context.maybeQueue(pathToQueue);
            }
          }

          function _getQueueContexts() {
            var path = this;
            var contexts = this.contexts;

            while (!contexts.length) {
              path = path.parentPath;
              if (!path) break;
              contexts = path.contexts;
            }

            return contexts;
          }
        },
        /* 391 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.remove = remove;
          exports._removeFromScope = _removeFromScope;
          exports._callRemovalHooks = _callRemovalHooks;
          exports._remove = _remove;
          exports._markRemoved = _markRemoved;
          exports._assertUnremoved = _assertUnremoved;

          var _removalHooks = __webpack_require__(392);

          function remove() {
            this._assertUnremoved();

            this.resync();

            this._removeFromScope();

            if (this._callRemovalHooks()) {
              this._markRemoved();

              return;
            }

            this.shareCommentsWithSiblings();

            this._remove();

            this._markRemoved();
          }

          function _removeFromScope() {
            var _this = this;

            var bindings = this.getBindingIdentifiers();
            Object.keys(bindings).forEach(function(name) {
              return _this.scope.removeBinding(name);
            });
          }

          function _callRemovalHooks() {
            for (
              var _iterator = _removalHooks.hooks,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var fn = _ref;
              if (fn(this, this.parentPath)) return true;
            }
          }

          function _remove() {
            if (Array.isArray(this.container)) {
              this.container.splice(this.key, 1);
              this.updateSiblingKeys(this.key, -1);
            } else {
              this._replaceWith(null);
            }
          }

          function _markRemoved() {
            this.shouldSkip = true;
            this.removed = true;
            this.node = null;
          }

          function _assertUnremoved() {
            if (this.removed) {
              throw this.buildCodeFrameError(
                "NodePath has been removed so is read-only."
              );
            }
          }
        },
        /* 392 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.hooks = void 0;
          var hooks = [
            function(self, parent) {
              var removeParent =
                (self.key === "test" &&
                  (parent.isWhile() || parent.isSwitchCase())) ||
                (self.key === "declaration" && parent.isExportDeclaration()) ||
                (self.key === "body" && parent.isLabeledStatement()) ||
                (self.listKey === "declarations" &&
                  parent.isVariableDeclaration() &&
                  parent.node.declarations.length === 1) ||
                (self.key === "expression" && parent.isExpressionStatement());

              if (removeParent) {
                parent.remove();
                return true;
              }
            },
            function(self, parent) {
              if (
                parent.isSequenceExpression() &&
                parent.node.expressions.length === 1
              ) {
                parent.replaceWith(parent.node.expressions[0]);
                return true;
              }
            },
            function(self, parent) {
              if (parent.isBinary()) {
                if (self.key === "left") {
                  parent.replaceWith(parent.node.right);
                } else {
                  parent.replaceWith(parent.node.left);
                }

                return true;
              }
            },
            function(self, parent) {
              if (
                (parent.isIfStatement() &&
                  (self.key === "consequent" || self.key === "alternate")) ||
                (self.key === "body" &&
                  (parent.isLoop() || parent.isArrowFunctionExpression()))
              ) {
                self.replaceWith({
                  type: "BlockStatement",
                  body: [],
                });
                return true;
              }
            },
          ];
          exports.hooks = hooks;
        },
        /* 393 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.insertBefore = insertBefore;
          exports._containerInsert = _containerInsert;
          exports._containerInsertBefore = _containerInsertBefore;
          exports._containerInsertAfter = _containerInsertAfter;
          exports.insertAfter = insertAfter;
          exports.updateSiblingKeys = updateSiblingKeys;
          exports._verifyNodeList = _verifyNodeList;
          exports.unshiftContainer = unshiftContainer;
          exports.pushContainer = pushContainer;
          exports.hoist = hoist;

          var _cache = __webpack_require__(43);

          var _hoister = _interopRequireDefault(__webpack_require__(394));

          var _index = _interopRequireDefault(__webpack_require__(21));

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function insertBefore(nodes) {
            this._assertUnremoved();

            nodes = this._verifyNodeList(nodes);
            var parentPath = this.parentPath;

            if (
              parentPath.isExpressionStatement() ||
              parentPath.isLabeledStatement() ||
              parentPath.isExportNamedDeclaration() ||
              (parentPath.isExportDefaultDeclaration() && this.isDeclaration())
            ) {
              return parentPath.insertBefore(nodes);
            } else if (
              (this.isNodeType("Expression") &&
                this.listKey !== "params" &&
                this.listKey !== "arguments") ||
              (parentPath.isForStatement() && this.key === "init")
            ) {
              if (this.node) nodes.push(this.node);
              return this.replaceExpressionWithStatements(nodes);
            } else if (Array.isArray(this.container)) {
              return this._containerInsertBefore(nodes);
            } else if (this.isStatementOrBlock()) {
              var shouldInsertCurrentNode =
                this.node &&
                (!this.isExpressionStatement() || this.node.expression != null);
              this.replaceWith(
                t().blockStatement(shouldInsertCurrentNode ? [this.node] : [])
              );
              return this.unshiftContainer("body", nodes);
            } else {
              throw new Error(
                "We don't know what to do with this node type. " +
                  "We were previously a Statement but we can't fit in here?"
              );
            }
          }

          function _containerInsert(from, nodes) {
            var _this$container;

            this.updateSiblingKeys(from, nodes.length);
            var paths = [];

            (_this$container = this.container).splice.apply(
              _this$container,
              [from, 0].concat(nodes)
            );

            for (var i = 0; i < nodes.length; i++) {
              var to = from + i;
              var path = this.getSibling(to);
              paths.push(path);

              if (this.context && this.context.queue) {
                path.pushContext(this.context);
              }
            }

            var contexts = this._getQueueContexts();

            for (var _i = 0; _i < paths.length; _i++) {
              var _path = paths[_i];

              _path.setScope();

              _path.debug("Inserted.");

              for (
                var _iterator = contexts,
                  _isArray = Array.isArray(_iterator),
                  _i2 = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i2 >= _iterator.length) break;
                  _ref = _iterator[_i2++];
                } else {
                  _i2 = _iterator.next();
                  if (_i2.done) break;
                  _ref = _i2.value;
                }

                var context = _ref;
                context.maybeQueue(_path, true);
              }
            }

            return paths;
          }

          function _containerInsertBefore(nodes) {
            return this._containerInsert(this.key, nodes);
          }

          function _containerInsertAfter(nodes) {
            return this._containerInsert(this.key + 1, nodes);
          }

          function insertAfter(nodes) {
            this._assertUnremoved();

            nodes = this._verifyNodeList(nodes);
            var parentPath = this.parentPath;

            if (
              parentPath.isExpressionStatement() ||
              parentPath.isLabeledStatement() ||
              parentPath.isExportNamedDeclaration() ||
              (parentPath.isExportDefaultDeclaration() && this.isDeclaration())
            ) {
              return parentPath.insertAfter(nodes);
            } else if (
              this.isNodeType("Expression") ||
              (parentPath.isForStatement() && this.key === "init")
            ) {
              if (this.node) {
                var scope = this.scope;

                if (
                  parentPath.isMethod({
                    computed: true,
                    key: this.node,
                  })
                ) {
                  scope = scope.parent;
                }

                var temp = scope.generateDeclaredUidIdentifier();
                nodes.unshift(
                  t().expressionStatement(
                    t().assignmentExpression(
                      "=",
                      t().cloneNode(temp),
                      this.node
                    )
                  )
                );
                nodes.push(t().expressionStatement(t().cloneNode(temp)));
              }

              return this.replaceExpressionWithStatements(nodes);
            } else if (Array.isArray(this.container)) {
              return this._containerInsertAfter(nodes);
            } else if (this.isStatementOrBlock()) {
              var shouldInsertCurrentNode =
                this.node &&
                (!this.isExpressionStatement() || this.node.expression != null);
              this.replaceWith(
                t().blockStatement(shouldInsertCurrentNode ? [this.node] : [])
              );
              return this.pushContainer("body", nodes);
            } else {
              throw new Error(
                "We don't know what to do with this node type. " +
                  "We were previously a Statement but we can't fit in here?"
              );
            }
          }

          function updateSiblingKeys(fromIndex, incrementBy) {
            if (!this.parent) return;

            var paths = _cache.path.get(this.parent);

            for (var i = 0; i < paths.length; i++) {
              var path = paths[i];

              if (path.key >= fromIndex) {
                path.key += incrementBy;
              }
            }
          }

          function _verifyNodeList(nodes) {
            if (!nodes) {
              return [];
            }

            if (nodes.constructor !== Array) {
              nodes = [nodes];
            }

            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var msg = void 0;

              if (!node) {
                msg = "has falsy node";
              } else if (typeof node !== "object") {
                msg = "contains a non-object node";
              } else if (!node.type) {
                msg = "without a type";
              } else if (node instanceof _index.default) {
                msg = "has a NodePath when it expected a raw object";
              }

              if (msg) {
                var type = Array.isArray(node) ? "array" : typeof node;
                throw new Error(
                  "Node list " +
                    msg +
                    " with the index of " +
                    i +
                    " and type of " +
                    type
                );
              }
            }

            return nodes;
          }

          function unshiftContainer(listKey, nodes) {
            this._assertUnremoved();

            nodes = this._verifyNodeList(nodes);

            var path = _index.default.get({
              parentPath: this,
              parent: this.node,
              container: this.node[listKey],
              listKey: listKey,
              key: 0,
            });

            return path.insertBefore(nodes);
          }

          function pushContainer(listKey, nodes) {
            this._assertUnremoved();

            nodes = this._verifyNodeList(nodes);
            var container = this.node[listKey];

            var path = _index.default.get({
              parentPath: this,
              parent: this.node,
              container: container,
              listKey: listKey,
              key: container.length,
            });

            return path.replaceWithMultiple(nodes);
          }

          function hoist(scope) {
            if (scope === void 0) {
              scope = this.scope;
            }

            var hoister = new _hoister.default(this, scope);
            return hoister.run();
          }
        },
        /* 394 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          var referenceVisitor = {
            ReferencedIdentifier: function ReferencedIdentifier(path, state) {
              if (
                path.isJSXIdentifier() &&
                t().react.isCompatTag(path.node.name) &&
                !path.parentPath.isJSXMemberExpression()
              ) {
                return;
              }

              if (path.node.name === "this") {
                var scope = path.scope;

                do {
                  if (
                    scope.path.isFunction() &&
                    !scope.path.isArrowFunctionExpression()
                  ) {
                    break;
                  }
                } while ((scope = scope.parent));

                if (scope) state.breakOnScopePaths.push(scope.path);
              }

              var binding = path.scope.getBinding(path.node.name);
              if (!binding) return;
              if (binding !== state.scope.getBinding(path.node.name)) return;
              state.bindings[path.node.name] = binding;
            },
          };

          var PathHoister = (function() {
            function PathHoister(path, scope) {
              this.breakOnScopePaths = [];
              this.bindings = {};
              this.scopes = [];
              this.scope = scope;
              this.path = path;
              this.attachAfter = false;
            }

            var _proto = PathHoister.prototype;

            _proto.isCompatibleScope = function isCompatibleScope(scope) {
              for (var key in this.bindings) {
                var binding = this.bindings[key];

                if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
                  return false;
                }
              }

              return true;
            };

            _proto.getCompatibleScopes = function getCompatibleScopes() {
              var scope = this.path.scope;

              do {
                if (this.isCompatibleScope(scope)) {
                  this.scopes.push(scope);
                } else {
                  break;
                }

                if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
                  break;
                }
              } while ((scope = scope.parent));
            };

            _proto.getAttachmentPath = function getAttachmentPath() {
              var path = this._getAttachmentPath();

              if (!path) return;
              var targetScope = path.scope;

              if (targetScope.path === path) {
                targetScope = path.scope.parent;
              }

              if (
                targetScope.path.isProgram() ||
                targetScope.path.isFunction()
              ) {
                for (var name in this.bindings) {
                  if (!targetScope.hasOwnBinding(name)) continue;
                  var binding = this.bindings[name];

                  if (
                    binding.kind === "param" ||
                    binding.path.parentKey === "params"
                  ) {
                    continue;
                  }

                  var bindingParentPath = this.getAttachmentParentForPath(
                    binding.path
                  );

                  if (bindingParentPath.key >= path.key) {
                    this.attachAfter = true;
                    path = binding.path;

                    for (
                      var _iterator = binding.constantViolations,
                        _isArray = Array.isArray(_iterator),
                        _i = 0,
                        _iterator = _isArray
                          ? _iterator
                          : _iterator[Symbol.iterator]();
                      ;

                    ) {
                      var _ref;

                      if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                      } else {
                        _i = _iterator.next();
                        if (_i.done) break;
                        _ref = _i.value;
                      }

                      var violationPath = _ref;

                      if (
                        this.getAttachmentParentForPath(violationPath).key >
                        path.key
                      ) {
                        path = violationPath;
                      }
                    }
                  }
                }
              }

              return path;
            };

            _proto._getAttachmentPath = function _getAttachmentPath() {
              var scopes = this.scopes;
              var scope = scopes.pop();
              if (!scope) return;

              if (scope.path.isFunction()) {
                if (this.hasOwnParamBindings(scope)) {
                  if (this.scope === scope) return;
                  var bodies = scope.path.get("body").get("body");

                  for (var i = 0; i < bodies.length; i++) {
                    if (bodies[i].node._blockHoist) continue;
                    return bodies[i];
                  }
                } else {
                  return this.getNextScopeAttachmentParent();
                }
              } else if (scope.path.isProgram()) {
                return this.getNextScopeAttachmentParent();
              }
            };

            _proto.getNextScopeAttachmentParent = function getNextScopeAttachmentParent() {
              var scope = this.scopes.pop();
              if (scope) return this.getAttachmentParentForPath(scope.path);
            };

            _proto.getAttachmentParentForPath = function getAttachmentParentForPath(
              path
            ) {
              do {
                if (
                  !path.parentPath ||
                  (Array.isArray(path.container) && path.isStatement())
                ) {
                  return path;
                }
              } while ((path = path.parentPath));
            };

            _proto.hasOwnParamBindings = function hasOwnParamBindings(scope) {
              for (var name in this.bindings) {
                if (!scope.hasOwnBinding(name)) continue;
                var binding = this.bindings[name];
                if (binding.kind === "param" && binding.constant) return true;
              }

              return false;
            };

            _proto.run = function run() {
              this.path.traverse(referenceVisitor, this);
              this.getCompatibleScopes();
              var attachTo = this.getAttachmentPath();
              if (!attachTo) return;
              if (
                attachTo.getFunctionParent() === this.path.getFunctionParent()
              )
                return;
              var uid = attachTo.scope.generateUidIdentifier("ref");
              var declarator = t().variableDeclarator(uid, this.path.node);
              var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";

              var _attachTo$insertFn = attachTo[insertFn]([
                  attachTo.isVariableDeclarator()
                    ? declarator
                    : t().variableDeclaration("var", [declarator]),
                ]),
                attached = _attachTo$insertFn[0];

              var parent = this.path.parentPath;

              if (
                parent.isJSXElement() &&
                this.path.container === parent.node.children
              ) {
                uid = t().JSXExpressionContainer(uid);
              }

              this.path.replaceWith(t().cloneNode(uid));
              return attachTo.isVariableDeclarator()
                ? attached.get("init")
                : attached.get("declarations.0.init");
            };

            return PathHoister;
          })();

          exports.default = PathHoister;
        },
        /* 395 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.getOpposite = getOpposite;
          exports.getCompletionRecords = getCompletionRecords;
          exports.getSibling = getSibling;
          exports.getPrevSibling = getPrevSibling;
          exports.getNextSibling = getNextSibling;
          exports.getAllNextSiblings = getAllNextSiblings;
          exports.getAllPrevSiblings = getAllPrevSiblings;
          exports.get = get;
          exports._getKey = _getKey;
          exports._getPattern = _getPattern;
          exports.getBindingIdentifiers = getBindingIdentifiers;
          exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
          exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
          exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;

          var _index = _interopRequireDefault(__webpack_require__(21));

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function getOpposite() {
            if (this.key === "left") {
              return this.getSibling("right");
            } else if (this.key === "right") {
              return this.getSibling("left");
            }
          }

          function addCompletionRecords(path, paths) {
            if (path) return paths.concat(path.getCompletionRecords());
            return paths;
          }

          function getCompletionRecords() {
            var paths = [];

            if (this.isIfStatement()) {
              paths = addCompletionRecords(this.get("consequent"), paths);
              paths = addCompletionRecords(this.get("alternate"), paths);
            } else if (
              this.isDoExpression() ||
              this.isFor() ||
              this.isWhile()
            ) {
              paths = addCompletionRecords(this.get("body"), paths);
            } else if (this.isProgram() || this.isBlockStatement()) {
              paths = addCompletionRecords(this.get("body").pop(), paths);
            } else if (this.isFunction()) {
              return this.get("body").getCompletionRecords();
            } else if (this.isTryStatement()) {
              paths = addCompletionRecords(this.get("block"), paths);
              paths = addCompletionRecords(this.get("handler"), paths);
              paths = addCompletionRecords(this.get("finalizer"), paths);
            } else if (this.isCatchClause()) {
              paths = addCompletionRecords(this.get("body"), paths);
            } else {
              paths.push(this);
            }

            return paths;
          }

          function getSibling(key) {
            return _index.default.get({
              parentPath: this.parentPath,
              parent: this.parent,
              container: this.container,
              listKey: this.listKey,
              key: key,
            });
          }

          function getPrevSibling() {
            return this.getSibling(this.key - 1);
          }

          function getNextSibling() {
            return this.getSibling(this.key + 1);
          }

          function getAllNextSiblings() {
            var _key = this.key;
            var sibling = this.getSibling(++_key);
            var siblings = [];

            while (sibling.node) {
              siblings.push(sibling);
              sibling = this.getSibling(++_key);
            }

            return siblings;
          }

          function getAllPrevSiblings() {
            var _key = this.key;
            var sibling = this.getSibling(--_key);
            var siblings = [];

            while (sibling.node) {
              siblings.push(sibling);
              sibling = this.getSibling(--_key);
            }

            return siblings;
          }

          function get(key, context) {
            if (context === true) context = this.context;
            var parts = key.split(".");

            if (parts.length === 1) {
              return this._getKey(key, context);
            } else {
              return this._getPattern(parts, context);
            }
          }

          function _getKey(key, context) {
            var _this = this;

            var node = this.node;
            var container = node[key];

            if (Array.isArray(container)) {
              return container.map(function(_, i) {
                return _index.default
                  .get({
                    listKey: key,
                    parentPath: _this,
                    parent: node,
                    container: container,
                    key: i,
                  })
                  .setContext(context);
              });
            } else {
              return _index.default
                .get({
                  parentPath: this,
                  parent: node,
                  container: node,
                  key: key,
                })
                .setContext(context);
            }
          }

          function _getPattern(parts, context) {
            var path = this;

            for (
              var _iterator = parts,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var part = _ref;

              if (part === ".") {
                path = path.parentPath;
              } else {
                if (Array.isArray(path)) {
                  path = path[part];
                } else {
                  path = path.get(part, context);
                }
              }
            }

            return path;
          }

          function getBindingIdentifiers(duplicates) {
            return t().getBindingIdentifiers(this.node, duplicates);
          }

          function getOuterBindingIdentifiers(duplicates) {
            return t().getOuterBindingIdentifiers(this.node, duplicates);
          }

          function getBindingIdentifierPaths(duplicates, outerOnly) {
            if (duplicates === void 0) {
              duplicates = false;
            }

            if (outerOnly === void 0) {
              outerOnly = false;
            }

            var path = this;
            var search = [].concat(path);
            var ids = Object.create(null);

            while (search.length) {
              var id = search.shift();
              if (!id) continue;
              if (!id.node) continue;
              var keys = t().getBindingIdentifiers.keys[id.node.type];

              if (id.isIdentifier()) {
                if (duplicates) {
                  var _ids = (ids[id.node.name] = ids[id.node.name] || []);

                  _ids.push(id);
                } else {
                  ids[id.node.name] = id;
                }

                continue;
              }

              if (id.isExportDeclaration()) {
                var declaration = id.get("declaration");

                if (declaration.isDeclaration()) {
                  search.push(declaration);
                }

                continue;
              }

              if (outerOnly) {
                if (id.isFunctionDeclaration()) {
                  search.push(id.get("id"));
                  continue;
                }

                if (id.isFunctionExpression()) {
                  continue;
                }
              }

              if (keys) {
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  var child = id.get(key);

                  if (Array.isArray(child) || child.node) {
                    search = search.concat(child);
                  }
                }
              }
            }

            return ids;
          }

          function getOuterBindingIdentifierPaths(duplicates) {
            return this.getBindingIdentifierPaths(duplicates, true);
          }
        },
        /* 396 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
          exports.addComment = addComment;
          exports.addComments = addComments;

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function shareCommentsWithSiblings() {
            if (typeof this.key === "string") return;
            var node = this.node;
            if (!node) return;
            var trailing = node.trailingComments;
            var leading = node.leadingComments;
            if (!trailing && !leading) return;
            var prev = this.getSibling(this.key - 1);
            var next = this.getSibling(this.key + 1);
            var hasPrev = Boolean(prev.node);
            var hasNext = Boolean(next.node);

            if (hasPrev && hasNext) {
            } else if (hasPrev) {
              prev.addComments("trailing", trailing);
            } else if (hasNext) {
              next.addComments("leading", leading);
            }
          }

          function addComment(type, content, line) {
            t().addComment(this.node, type, content, line);
          }

          function addComments(type, comments) {
            t().addComments(this.node, type, comments);
          }
        },
        /* 397 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.explode = explode;
          exports.verify = verify;
          exports.merge = merge;

          var virtualTypes = _interopRequireWildcard(__webpack_require__(135));

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _clone() {
            var data = _interopRequireDefault(__webpack_require__(89));

            _clone = function _clone() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function explode(visitor) {
            if (visitor._exploded) return visitor;
            visitor._exploded = true;

            for (var nodeType in visitor) {
              if (shouldIgnoreKey(nodeType)) continue;
              var parts = nodeType.split("|");
              if (parts.length === 1) continue;
              var fns = visitor[nodeType];
              delete visitor[nodeType];

              for (
                var _iterator = parts,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var part = _ref;
                visitor[part] = fns;
              }
            }

            verify(visitor);
            delete visitor.__esModule;
            ensureEntranceObjects(visitor);
            ensureCallbackArrays(visitor);

            var _arr = Object.keys(visitor);

            for (var _i2 = 0; _i2 < _arr.length; _i2++) {
              var _nodeType3 = _arr[_i2];
              if (shouldIgnoreKey(_nodeType3)) continue;
              var wrapper = virtualTypes[_nodeType3];
              if (!wrapper) continue;
              var _fns2 = visitor[_nodeType3];

              for (var type in _fns2) {
                _fns2[type] = wrapCheck(wrapper, _fns2[type]);
              }

              delete visitor[_nodeType3];

              if (wrapper.types) {
                for (
                  var _iterator3 = wrapper.types,
                    _isArray3 = Array.isArray(_iterator3),
                    _i4 = 0,
                    _iterator3 = _isArray3
                      ? _iterator3
                      : _iterator3[Symbol.iterator]();
                  ;

                ) {
                  var _ref3;

                  if (_isArray3) {
                    if (_i4 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i4++];
                  } else {
                    _i4 = _iterator3.next();
                    if (_i4.done) break;
                    _ref3 = _i4.value;
                  }

                  var _type = _ref3;

                  if (visitor[_type]) {
                    mergePair(visitor[_type], _fns2);
                  } else {
                    visitor[_type] = _fns2;
                  }
                }
              } else {
                mergePair(visitor, _fns2);
              }
            }

            for (var _nodeType in visitor) {
              if (shouldIgnoreKey(_nodeType)) continue;
              var _fns = visitor[_nodeType];

              var aliases = t().FLIPPED_ALIAS_KEYS[_nodeType];

              var deprecratedKey = t().DEPRECATED_KEYS[_nodeType];

              if (deprecratedKey) {
                console.trace(
                  "Visitor defined for " +
                    _nodeType +
                    " but it has been renamed to " +
                    deprecratedKey
                );
                aliases = [deprecratedKey];
              }

              if (!aliases) continue;
              delete visitor[_nodeType];

              for (
                var _iterator2 = aliases,
                  _isArray2 = Array.isArray(_iterator2),
                  _i3 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : _iterator2[Symbol.iterator]();
                ;

              ) {
                var _ref2;

                if (_isArray2) {
                  if (_i3 >= _iterator2.length) break;
                  _ref2 = _iterator2[_i3++];
                } else {
                  _i3 = _iterator2.next();
                  if (_i3.done) break;
                  _ref2 = _i3.value;
                }

                var alias = _ref2;
                var existing = visitor[alias];

                if (existing) {
                  mergePair(existing, _fns);
                } else {
                  visitor[alias] = (0, _clone().default)(_fns);
                }
              }
            }

            for (var _nodeType2 in visitor) {
              if (shouldIgnoreKey(_nodeType2)) continue;
              ensureCallbackArrays(visitor[_nodeType2]);
            }

            return visitor;
          }

          function verify(visitor) {
            if (visitor._verified) return;

            if (typeof visitor === "function") {
              throw new Error(
                "You passed `traverse()` a function when it expected a visitor object, " +
                  "are you sure you didn't mean `{ enter: Function }`?"
              );
            }

            for (var nodeType in visitor) {
              if (nodeType === "enter" || nodeType === "exit") {
                validateVisitorMethods(nodeType, visitor[nodeType]);
              }

              if (shouldIgnoreKey(nodeType)) continue;

              if (t().TYPES.indexOf(nodeType) < 0) {
                throw new Error(
                  "You gave us a visitor for the node type " +
                    nodeType +
                    " but it's not a valid type"
                );
              }

              var visitors = visitor[nodeType];

              if (typeof visitors === "object") {
                for (var visitorKey in visitors) {
                  if (visitorKey === "enter" || visitorKey === "exit") {
                    validateVisitorMethods(
                      nodeType + "." + visitorKey,
                      visitors[visitorKey]
                    );
                  } else {
                    throw new Error(
                      "You passed `traverse()` a visitor object with the property " +
                        (nodeType +
                          " that has the invalid property " +
                          visitorKey)
                    );
                  }
                }
              }
            }

            visitor._verified = true;
          }

          function validateVisitorMethods(path, val) {
            var fns = [].concat(val);

            for (
              var _iterator4 = fns,
                _isArray4 = Array.isArray(_iterator4),
                _i5 = 0,
                _iterator4 = _isArray4
                  ? _iterator4
                  : _iterator4[Symbol.iterator]();
              ;

            ) {
              var _ref4;

              if (_isArray4) {
                if (_i5 >= _iterator4.length) break;
                _ref4 = _iterator4[_i5++];
              } else {
                _i5 = _iterator4.next();
                if (_i5.done) break;
                _ref4 = _i5.value;
              }

              var fn = _ref4;

              if (typeof fn !== "function") {
                throw new TypeError(
                  "Non-function found defined in " +
                    path +
                    " with type " +
                    typeof fn
                );
              }
            }
          }

          function merge(visitors, states, wrapper) {
            if (states === void 0) {
              states = [];
            }

            var rootVisitor = {};

            for (var i = 0; i < visitors.length; i++) {
              var visitor = visitors[i];
              var state = states[i];
              explode(visitor);

              for (var type in visitor) {
                var visitorType = visitor[type];

                if (state || wrapper) {
                  visitorType = wrapWithStateOrWrapper(
                    visitorType,
                    state,
                    wrapper
                  );
                }

                var nodeVisitor = (rootVisitor[type] = rootVisitor[type] || {});
                mergePair(nodeVisitor, visitorType);
              }
            }

            return rootVisitor;
          }

          function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
            var newVisitor = {};

            var _loop = function _loop(key) {
              var fns = oldVisitor[key];
              if (!Array.isArray(fns)) return "continue";
              fns = fns.map(function(fn) {
                var newFn = fn;

                if (state) {
                  newFn = function newFn(path) {
                    return fn.call(state, path, state);
                  };
                }

                if (wrapper) {
                  newFn = wrapper(state.key, key, newFn);
                }

                return newFn;
              });
              newVisitor[key] = fns;
            };

            for (var key in oldVisitor) {
              var _ret = _loop(key);

              if (_ret === "continue") continue;
            }

            return newVisitor;
          }

          function ensureEntranceObjects(obj) {
            for (var key in obj) {
              if (shouldIgnoreKey(key)) continue;
              var fns = obj[key];

              if (typeof fns === "function") {
                obj[key] = {
                  enter: fns,
                };
              }
            }
          }

          function ensureCallbackArrays(obj) {
            if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
            if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
          }

          function wrapCheck(wrapper, fn) {
            var newFn = function newFn(path) {
              if (wrapper.checkPath(path)) {
                return fn.apply(this, arguments);
              }
            };

            newFn.toString = function() {
              return fn.toString();
            };

            return newFn;
          }

          function shouldIgnoreKey(key) {
            if (key[0] === "_") return true;
            if (key === "enter" || key === "exit" || key === "shouldSkip")
              return true;

            if (
              key === "blacklist" ||
              key === "noScope" ||
              key === "skipKeys"
            ) {
              return true;
            }

            return false;
          }

          function mergePair(dest, src) {
            for (var key in src) {
              dest[key] = [].concat(dest[key] || [], src[key]);
            }
          }
        },
        /* 398 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          var Hub = (function() {
            function Hub() {}

            var _proto = Hub.prototype;

            _proto.getCode = function getCode() {};

            _proto.getScope = function getScope() {};

            _proto.addHelper = function addHelper() {
              throw new Error("Helpers are not supported by the default hub.");
            };

            _proto.buildError = function buildError(node, msg, Error) {
              if (Error === void 0) {
                Error = TypeError;
              }

              return new Error(msg);
            };

            return Hub;
          })();

          exports.default = Hub;
        },
        /* 399 */
        function(module, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            0
          );
          /* harmony import */ var _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
            _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0__
          );

          function _templateObject63() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _classStaticPrivateFieldSpecSet(\n    receiver, classConstructor, privateClass, privateId, value\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError("Private static access of wrong provenance");\n    }\n    privateClass[privateId] = value;\n    return value;\n  }\n',
              ]
            );

            _templateObject63 = function _templateObject63() {
              return data;
            };

            return data;
          }

          function _templateObject62() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _classStaticPrivateFieldSpecGet(\n    receiver, classConstructor, privateClass, privateId\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError("Private static access of wrong provenance");\n    }\n    return privateClass[privateId];\n  }\n',
              ]
            );

            _templateObject62 = function _templateObject62() {
              return data;
            };

            return data;
          }

          function _templateObject61() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _classPrivateFieldSet(receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError("attempted to set private field on non-instance");\n    }\n    var descriptor = privateMap.get(receiver);\n    if (!descriptor.writable) {\n      // This should only throw in strict mode, but class bodies are\n      // always strict and private fields can only be used inside\n      // class bodies.\n      throw new TypeError("attempted to set read only private field");\n    }\n    descriptor.value = value;\n    return value;\n  }\n',
              ]
            );

            _templateObject61 = function _templateObject61() {
              return data;
            };

            return data;
          }

          function _templateObject60() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _classPrivateFieldGet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError("attempted to get private field on non-instance");\n    }\n    return privateMap.get(receiver).value;\n  }\n',
              ]
            );

            _templateObject60 = function _templateObject60() {
              return data;
            };

            return data;
          }

          function _templateObject59() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _classPrivateFieldBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError("attempted to use private field on non-instance");\n    }\n    return receiver;\n  }\n',
              ]
            );

            _templateObject59 = function _templateObject59() {
              return data;
            };

            return data;
          }

          function _templateObject58() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  var id = 0;\n  export default function _classPrivateFieldKey(name) {\n    return "__private_" + (id++) + "_" + name;\n  }\n',
              ]
            );

            _templateObject58 = function _templateObject58() {
              return data;
            };

            return data;
          }

          function _templateObject57() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){\n        var desc = {};\n        Object['ke' + 'ys'](descriptor).forEach(function(key){\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n        if ('value' in desc || desc.initializer){\n            desc.writable = true;\n        }\n\n        desc = decorators.slice().reverse().reduce(function(desc, decorator){\n            return decorator(target, property, desc) || desc;\n        }, desc);\n\n        if (context && desc.initializer !== void 0){\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0){\n            // This is a hack to avoid this being processed by 'transform-runtime'.\n            // See issue #9.\n            Object['define' + 'Property'](target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n",
              ]
            );

            _templateObject57 = function _templateObject57() {
              return data;
            };

            return data;
          }

          function _templateObject56() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n    export default function _initializerDefineProperty(target, property, descriptor, context){\n        if (!descriptor) return;\n\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n",
              ]
            );

            _templateObject56 = function _templateObject56() {
              return data;
            };

            return data;
          }

          function _templateObject55() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n    export default function _initializerWarningHelper(descriptor, context){\n        throw new Error(\n          'Decorating class property failed. Please ensure that ' +\n          'proposal-class-properties is enabled and set to use loose mode. ' +\n          'To use proposal-class-properties in spec mode with decorators, wait for ' +\n          'the next major version of decorators in stage 2.'\n        );\n    }\n",
              ]
            );

            _templateObject55 = function _templateObject55() {
              return data;
            };

            return data;
          }

          function _templateObject54() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _toPropertyKey(key) {\n    if (typeof key === "symbol") {\n      return key;\n    } else {\n      return String(key);\n    }\n  }\n',
              ]
            );

            _templateObject54 = function _templateObject54() {
              return data;
            };

            return data;
          }

          function _templateObject53() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _skipFirstGeneratorNext(fn) {\n    return function () {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    }\n  }\n",
              ]
            );

            _templateObject53 = function _templateObject53() {
              return data;
            };

            return data;
          }

          function _templateObject52() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _nonIterableRest() {\n    throw new TypeError("Invalid attempt to destructure non-iterable instance");\n  }\n',
              ]
            );

            _templateObject52 = function _templateObject52() {
              return data;
            };

            return data;
          }

          function _templateObject51() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _nonIterableSpread() {\n    throw new TypeError("Invalid attempt to spread non-iterable instance");\n  }\n',
              ]
            );

            _templateObject51 = function _templateObject51() {
              return data;
            };

            return data;
          }

          function _templateObject50() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _iterableToArrayLimitLoose(arr, i) {\n    var _arr = [];\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n      if (i && _arr.length === i) break;\n    }\n    return _arr;\n  }\n",
              ]
            );

            _templateObject50 = function _templateObject50() {
              return data;
            };

            return data;
          }

          function _templateObject49() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of `for...of` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliancy is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i["return"] != null) _i["return"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n',
              ],
              [
                '\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of \\`for...of\\` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliancy is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i["return"] != null) _i["return"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n',
              ]
            );

            _templateObject49 = function _templateObject49() {
              return data;
            };

            return data;
          }

          function _templateObject48() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _iterableToArray(iter) {\n    if (\n      Symbol.iterator in Object(iter) ||\n      Object.prototype.toString.call(iter) === "[object Arguments]"\n    ) return Array.from(iter);\n  }\n',
              ]
            );

            _templateObject48 = function _templateObject48() {
              return data;
            };

            return data;
          }

          function _templateObject47() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n",
              ]
            );

            _templateObject47 = function _templateObject47() {
              return data;
            };

            return data;
          }

          function _templateObject46() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n      return arr2;\n    }\n  }\n",
              ]
            );

            _templateObject46 = function _templateObject46() {
              return data;
            };

            return data;
          }

          function _templateObject45() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import arrayWithoutHoles from "arrayWithoutHoles";\n  import iterableToArray from "iterableToArray";\n  import nonIterableSpread from "nonIterableSpread";\n\n  export default function _toConsumableArray(arr) {\n    return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n  }\n',
              ]
            );

            _templateObject45 = function _templateObject45() {
              return data;
            };

            return data;
          }

          function _templateObject44() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import arrayWithHoles from "arrayWithHoles";\n  import iterableToArray from "iterableToArray";\n  import nonIterableRest from "nonIterableRest";\n\n  export default function _toArray(arr) {\n    return arrayWithHoles(arr) || iterableToArray(arr) || nonIterableRest();\n  }\n',
              ]
            );

            _templateObject44 = function _templateObject44() {
              return data;
            };

            return data;
          }

          function _templateObject43() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import arrayWithHoles from "arrayWithHoles";\n  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";\n  import nonIterableRest from "nonIterableRest";\n\n  export default function _slicedToArrayLoose(arr, i) {\n    return arrayWithHoles(arr) || iterableToArrayLimitLoose(arr, i) || nonIterableRest();\n  }\n',
              ]
            );

            _templateObject43 = function _templateObject43() {
              return data;
            };

            return data;
          }

          function _templateObject42() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import arrayWithHoles from "arrayWithHoles";\n  import iterableToArrayLimit from "iterableToArrayLimit";\n  import nonIterableRest from "nonIterableRest";\n\n  export default function _slicedToArray(arr, i) {\n    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n  }\n',
              ]
            );

            _templateObject42 = function _templateObject42() {
              return data;
            };

            return data;
          }

          function _templateObject41() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              ["\n  export default {};\n"]
            );

            _templateObject41 = function _templateObject41() {
              return data;
            };

            return data;
          }

          function _templateObject40() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _classNameTDZError(name) {\n    throw new Error("Class \\"" + name + "\\" cannot be referenced in computed property keys.");\n  }\n',
              ],
              [
                '\n  export default function _classNameTDZError(name) {\n    throw new Error("Class \\\\"" + name + "\\\\" cannot be referenced in computed property keys.");\n  }\n',
              ]
            );

            _templateObject40 = function _templateObject40() {
              return data;
            };

            return data;
          }

          function _templateObject39() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _readOnlyError(name) {\n    throw new Error("\\"" + name + "\\" is read-only");\n  }\n',
              ],
              [
                '\n  export default function _readOnlyError(name) {\n    throw new Error("\\\\"" + name + "\\\\" is read-only");\n  }\n',
              ]
            );

            _templateObject39 = function _templateObject39() {
              return data;
            };

            return data;
          }

          function _templateObject38() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import undef from "temporalUndefined";\n\n  export default function _temporalRef(val, name) {\n    if (val === undef) {\n      throw new ReferenceError(name + " is not defined - temporal dead zone");\n    } else {\n      return val;\n    }\n  }\n',
              ]
            );

            _templateObject38 = function _templateObject38() {
              return data;
            };

            return data;
          }

          function _templateObject37() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    strings.raw = raw;\n    return strings;\n  }\n",
              ]
            );

            _templateObject37 = function _templateObject37() {
              return data;
            };

            return data;
          }

          function _templateObject36() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: { value: Object.freeze(raw) }\n    }));\n  }\n",
              ]
            );

            _templateObject36 = function _templateObject36() {
              return data;
            };

            return data;
          }

          function _templateObject35() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import getPrototypeOf from "getPrototypeOf";\n  import superPropBase from "superPropBase";\n  import defineProperty from "defineProperty";\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== "undefined" && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = superPropBase(target, property);\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            // Both getter and non-writable fall into this.\n            return false;\n          }\n        }\n\n        // Without a super that defines the property, spec boils down to\n        // "define on receiver" for some reason.\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n        if (desc) {\n          if (!desc.writable) {\n            // Setter, getter, and non-writable fall into this.\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          // Avoid setters that may be defined on Sub\'s prototype, but not on\n          // the instance.\n          defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  export default function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n    if (!s && isStrict) {\n      throw new Error(\'failed to set property\');\n    }\n\n    return value;\n  }\n',
              ]
            );

            _templateObject35 = function _templateObject35() {
              return data;
            };

            return data;
          }

          function _templateObject34() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import getPrototypeOf from "getPrototypeOf";\n  import superPropBase from "superPropBase";\n\n  export default function _get(target, property, receiver) {\n    if (typeof Reflect !== "undefined" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = superPropBase(target, property);\n\n        if (!base) return;\n\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n    return _get(target, property, receiver || target);\n  }\n',
              ]
            );

            _templateObject34 = function _templateObject34() {
              return data;
            };

            return data;
          }

          function _templateObject33() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import getPrototypeOf from "getPrototypeOf";\n\n  export default function _superPropBase(object, property) {\n    // Yes, this throws if object is null to being with, that\'s on purpose.\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = getPrototypeOf(object);\n      if (object === null) break;\n    }\n    return object;\n  }\n',
              ]
            );

            _templateObject33 = function _templateObject33() {
              return data;
            };

            return data;
          }

          function _templateObject32() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import assertThisInitialized from "assertThisInitialized";\n\n  export default function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === "object" || typeof call === "function")) {\n      return call;\n    }\n    return assertThisInitialized(self);\n  }\n',
              ]
            );

            _templateObject32 = function _templateObject32() {
              return data;
            };

            return data;
          }

          function _templateObject31() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n",
              ]
            );

            _templateObject31 = function _templateObject31() {
              return data;
            };

            return data;
          }

          function _templateObject30() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";\n\n  export default function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n',
              ]
            );

            _templateObject30 = function _templateObject30() {
              return data;
            };

            return data;
          }

          function _templateObject29() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n",
              ]
            );

            _templateObject29 = function _templateObject29() {
              return data;
            };

            return data;
          }

          function _templateObject28() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError("Cannot destructure undefined");\n  }\n',
              ]
            );

            _templateObject28 = function _templateObject28() {
              return data;
            };

            return data;
          }

          function _templateObject27() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError("Cannot instantiate an arrow function");\n    }\n  }\n',
              ]
            );

            _templateObject27 = function _templateObject27() {
              return data;
            };

            return data;
          }

          function _templateObject26() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = Object.defineProperty && Object.getOwnPropertyDescriptor\n              ? Object.getOwnPropertyDescriptor(obj, key)\n              : {};\n            if (desc.get || desc.set) {\n              Object.defineProperty(newObj, key, desc);\n            } else {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n      }\n      newObj.default = obj;\n      return newObj;\n    }\n  }\n",
              ]
            );

            _templateObject26 = function _templateObject26() {
              return data;
            };

            return data;
          }

          function _templateObject25() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  }\n",
              ]
            );

            _templateObject25 = function _templateObject25() {
              return data;
            };

            return data;
          }

          function _templateObject24() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _instanceof(left, right) {\n    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {\n      return right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n',
              ]
            );

            _templateObject24 = function _templateObject24() {
              return data;
            };

            return data;
          }

          function _templateObject23() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import getPrototypeOf from "getPrototypeOf";\n  import setPrototypeOf from "setPrototypeOf";\n  import isNativeFunction from "isNativeFunction";\n  import construct from "construct";\n\n  export default function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === "function" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !isNativeFunction(Class)) return Class;\n      if (typeof Class !== "function") {\n        throw new TypeError("Super expression must either be null or a function");\n      }\n      if (typeof _cache !== "undefined") {\n        if (_cache.has(Class)) return _cache.get(Class);\n        _cache.set(Class, Wrapper);\n      }\n      function Wrapper() {\n        return construct(Class, arguments, getPrototypeOf(this).constructor)\n      }\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true,\n        }\n      });\n\n      return setPrototypeOf(Wrapper, Class);\n    }\n\n    return _wrapNativeSuper(Class)\n  }\n',
              ]
            );

            _templateObject23 = function _templateObject23() {
              return data;
            };

            return data;
          }

          function _templateObject22() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _isNativeFunction(fn) {\n    // Note: This function returns "true" for core-js functions.\n    return Function.toString.call(fn).indexOf("[native code]") !== -1;\n  }\n',
              ]
            );

            _templateObject22 = function _templateObject22() {
              return data;
            };

            return data;
          }

          function _templateObject21() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  import setPrototypeOf from \"setPrototypeOf\";\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n    // core-js@3\n    if (Reflect.construct.sham) return false;\n\n    // Proxy can't be polyfilled. Every browser implemented\n    // proxies before or at the same time as Reflect.construct,\n    // so if they support Proxy they also support Reflect.construct.\n    if (typeof Proxy === \"function\") return true;\n\n    // Since Reflect.construct can't be properly polyfilled, some\n    // implementations (e.g. core-js@2) don't set the correct internal slots.\n    // Those polyfills don't allow us to subclass built-ins, so we need to\n    // use our fallback implementation.\n    try {\n      // If the internal slots aren't set, this throws an error similar to\n      //   TypeError: this is not a Date object.\n      // Date#toString is generic in ES2015 [1] and it doesn't throw, so we also\n      // check Map#get (which on the other hand doesn't exist in ES5 browsers).\n      //\n      // [1]: https://github.com/tc39/ecma262/issues/1268#issuecomment-410104832\n\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      if (typeof Map === \"function\") {\n        Map.prototype.get.call(Reflect.construct(Map, [], function() {}));\n      }\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  export default function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      // NOTE: If Parent !== Class, the correct __proto__ is set *after*\n      //       calling the constructor.\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n    // Avoid issues with Class being present but undefined when it wasn't\n    // present in the original call.\n    return _construct.apply(null, arguments);\n  }\n",
              ]
            );

            _templateObject21 = function _templateObject21() {
              return data;
            };

            return data;
          }

          function _templateObject20() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n",
              ]
            );

            _templateObject20 = function _templateObject20() {
              return data;
            };

            return data;
          }

          function _templateObject19() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n",
              ]
            );

            _templateObject19 = function _templateObject19() {
              return data;
            };

            return data;
          }

          function _templateObject18() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n",
              ]
            );

            _templateObject18 = function _templateObject18() {
              return data;
            };

            return data;
          }

          function _templateObject17() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import setPrototypeOf from "setPrototypeOf";\n\n  export default function _inherits(subClass, superClass) {\n    if (typeof superClass !== "function" && superClass !== null) {\n      throw new TypeError("Super expression must either be null or a function");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) setPrototypeOf(subClass, superClass);\n  }\n',
              ]
            );

            _templateObject17 = function _templateObject17() {
              return data;
            };

            return data;
          }

          function _templateObject16() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  import defineProperty from \"defineProperty\";\n\n  export default function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n      ownKeys.forEach(function(key) {\n        defineProperty(target, key, source[key]);\n      });\n    }\n    return target;\n  }\n",
              ]
            );

            _templateObject16 = function _templateObject16() {
              return data;
            };

            return data;
          }

          function _templateObject15() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n",
              ]
            );

            _templateObject15 = function _templateObject15() {
              return data;
            };

            return data;
          }

          function _templateObject14() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _defineProperty(obj, key, value) {\n    // Shortcircuit the slow defineProperty path when possible.\n    // We are trying to avoid issues where setters defined on the\n    // prototype cause side effects under the fast path of simple\n    // assignment. By checking for existence of the property with\n    // the in operator, we can optimize most of this overhead away.\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n",
              ]
            );

            _templateObject14 = function _templateObject14() {
              return data;
            };

            return data;
          }

          function _templateObject13() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n    return obj;\n  }\n",
              ]
            );

            _templateObject13 = function _templateObject13() {
              return data;
            };

            return data;
          }

          function _templateObject12() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if ("value" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    // Symbols are not enumerated over by for-in loops. If native\n    // Symbols are available, fetch all of the descs object\'s own\n    // symbol properties and define them on our target object too.\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if ("value" in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n    return obj;\n  }\n',
              ]
            );

            _templateObject12 = function _templateObject12() {
              return data;
            };

            return data;
          }

          function _templateObject11() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i ++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  export default function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n',
              ]
            );

            _templateObject11 = function _templateObject11() {
              return data;
            };

            return data;
          }

          function _templateObject10() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError("Cannot call a class as a function");\n    }\n  }\n',
              ]
            );

            _templateObject10 = function _templateObject10() {
              return data;
            };

            return data;
          }

          function _templateObject9() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  export default function _asyncToGenerator(fn) {\n    return function () {\n      var self = this, args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);\n        }\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n',
              ]
            );

            _templateObject9 = function _templateObject9() {
              return data;
            };

            return data;
          }

          function _templateObject8() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {}, waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\n      return { done: false, value: awaitWrap(value) };\n    };\n\n    if (typeof Symbol === "function" && Symbol.iterator) {\n      iter[Symbol.iterator] = function () { return this; };\n    }\n\n    iter.next = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n      return pump("next", value);\n    };\n\n    if (typeof inner.throw === "function") {\n      iter.throw = function (value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n        return pump("throw", value);\n      };\n    }\n\n    if (typeof inner.return === "function") {\n      iter.return = function (value) {\n        return pump("return", value);\n      };\n    }\n\n    return iter;\n  }\n',
              ]
            );

            _templateObject8 = function _templateObject8() {
              return data;
            };

            return data;
          }

          function _templateObject7() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import AwaitValue from "AwaitValue";\n\n  export default function _awaitAsyncGenerator(value) {\n    return new AwaitValue(value);\n  }\n',
              ]
            );

            _templateObject7 = function _templateObject7() {
              return data;
            };

            return data;
          }

          function _templateObject6() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import AsyncGenerator from "AsyncGenerator";\n\n  export default function _wrapAsyncGenerator(fn) {\n    return function () {\n      return new AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n',
              ]
            );

            _templateObject6 = function _templateObject6() {
              return data;
            };

            return data;
          }

          function _templateObject5() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  import AwaitValue from "AwaitValue";\n\n  export default function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null,\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg)\n        var value = result.value;\n        var wrappedAwait = value instanceof AwaitValue;\n\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function (arg) {\n            if (wrappedAwait) {\n              resume("next", arg);\n              return\n            }\n\n            settle(result.done ? "return" : "normal", arg);\n          },\n          function (err) { resume("throw", err); });\n      } catch (err) {\n        settle("throw", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case "return":\n          front.resolve({ value: value, done: true });\n          break;\n        case "throw":\n          front.reject(value);\n          break;\n        default:\n          front.resolve({ value: value, done: false });\n          break;\n      }\n\n      front = front.next;\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    // Hide "return" method if generator return is not supported\n    if (typeof gen.return !== "function") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === "function" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };\n  AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };\n  AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };\n',
              ]
            );

            _templateObject5 = function _templateObject5() {
              return data;
            };

            return data;
          }

          function _templateObject4() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                "\n  export default function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n",
              ]
            );

            _templateObject4 = function _templateObject4() {
              return data;
            };

            return data;
          }

          function _templateObject3() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _asyncIterator(iterable) {\n    var method\n    if (typeof Symbol === "function") {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator]\n        if (method != null) return method.call(iterable);\n      }\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator]\n        if (method != null) return method.call(iterable);\n      }\n    }\n    throw new TypeError("Object is not async iterable");\n  }\n',
              ]
            );

            _templateObject3 = function _templateObject3() {
              return data;
            };

            return data;
          }

          function _templateObject2() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  var REACT_ELEMENT_TYPE;\n\n  export default function _createRawReactElement(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE = (\n        typeof Symbol === "function" && Symbol.for && Symbol.for("react.element")\n      ) || 0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      // If we\'re going to assign props.children, we create a new object now\n      // to avoid mutating defaultProps.\n      props = {\n        children: void 0,\n      };\n    }\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : \'\' + key,\n      ref: null,\n      props: props,\n      _owner: null,\n    };\n  }\n',
              ]
            );

            _templateObject2 = function _templateObject2() {
              return data;
            };

            return data;
          }

          function _templateObject() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n  export default function _typeof(obj) {\n    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n      _typeof = function (obj) { return typeof obj; };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype\n          ? "symbol"\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n',
              ]
            );

            _templateObject = function _templateObject() {
              return data;
            };

            return data;
          }

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function _babelTemplate() {
            var data = _interopRequireDefault(__webpack_require__(45));

            _babelTemplate = function _babelTemplate() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var helpers = Object.create(null);
          var _default = helpers;
          exports.default = _default;

          var helper = function helper(minVersion) {
            return function(tpl) {
              return {
                minVersion: minVersion,
                ast: function ast() {
                  return _babelTemplate().default.program.ast(tpl);
                },
              };
            };
          };

          helpers.typeof = helper("7.0.0-beta.0")(_templateObject());
          helpers.jsx = helper("7.0.0-beta.0")(_templateObject2());
          helpers.asyncIterator = helper("7.0.0-beta.0")(_templateObject3());
          helpers.AwaitValue = helper("7.0.0-beta.0")(_templateObject4());
          helpers.AsyncGenerator = helper("7.0.0-beta.0")(_templateObject5());
          helpers.wrapAsyncGenerator = helper("7.0.0-beta.0")(
            _templateObject6()
          );
          helpers.awaitAsyncGenerator = helper("7.0.0-beta.0")(
            _templateObject7()
          );
          helpers.asyncGeneratorDelegate = helper("7.0.0-beta.0")(
            _templateObject8()
          );
          helpers.asyncToGenerator = helper("7.0.0-beta.0")(_templateObject9());
          helpers.classCallCheck = helper("7.0.0-beta.0")(_templateObject10());
          helpers.createClass = helper("7.0.0-beta.0")(_templateObject11());
          helpers.defineEnumerableProperties = helper("7.0.0-beta.0")(
            _templateObject12()
          );
          helpers.defaults = helper("7.0.0-beta.0")(_templateObject13());
          helpers.defineProperty = helper("7.0.0-beta.0")(_templateObject14());
          helpers.extends = helper("7.0.0-beta.0")(_templateObject15());
          helpers.objectSpread = helper("7.0.0-beta.0")(_templateObject16());
          helpers.inherits = helper("7.0.0-beta.0")(_templateObject17());
          helpers.inheritsLoose = helper("7.0.0-beta.0")(_templateObject18());
          helpers.getPrototypeOf = helper("7.0.0-beta.0")(_templateObject19());
          helpers.setPrototypeOf = helper("7.0.0-beta.0")(_templateObject20());
          helpers.construct = helper("7.0.0-beta.0")(_templateObject21());
          helpers.isNativeFunction = helper("7.0.0-beta.0")(
            _templateObject22()
          );
          helpers.wrapNativeSuper = helper("7.0.0-beta.0")(_templateObject23());
          helpers.instanceof = helper("7.0.0-beta.0")(_templateObject24());
          helpers.interopRequireDefault = helper("7.0.0-beta.0")(
            _templateObject25()
          );
          helpers.interopRequireWildcard = helper("7.0.0-beta.0")(
            _templateObject26()
          );
          helpers.newArrowCheck = helper("7.0.0-beta.0")(_templateObject27());
          helpers.objectDestructuringEmpty = helper("7.0.0-beta.0")(
            _templateObject28()
          );
          helpers.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")(
            _templateObject29()
          );
          helpers.objectWithoutProperties = helper("7.0.0-beta.0")(
            _templateObject30()
          );
          helpers.assertThisInitialized = helper("7.0.0-beta.0")(
            _templateObject31()
          );
          helpers.possibleConstructorReturn = helper("7.0.0-beta.0")(
            _templateObject32()
          );
          helpers.superPropBase = helper("7.0.0-beta.0")(_templateObject33());
          helpers.get = helper("7.0.0-beta.0")(_templateObject34());
          helpers.set = helper("7.0.0-beta.0")(_templateObject35());
          helpers.taggedTemplateLiteral = helper("7.0.0-beta.0")(
            _templateObject36()
          );
          helpers.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")(
            _templateObject37()
          );
          helpers.temporalRef = helper("7.0.0-beta.0")(_templateObject38());
          helpers.readOnlyError = helper("7.0.0-beta.0")(_templateObject39());
          helpers.classNameTDZError = helper("7.0.0-beta.0")(
            _templateObject40()
          );
          helpers.temporalUndefined = helper("7.0.0-beta.0")(
            _templateObject41()
          );
          helpers.slicedToArray = helper("7.0.0-beta.0")(_templateObject42());
          helpers.slicedToArrayLoose = helper("7.0.0-beta.0")(
            _templateObject43()
          );
          helpers.toArray = helper("7.0.0-beta.0")(_templateObject44());
          helpers.toConsumableArray = helper("7.0.0-beta.0")(
            _templateObject45()
          );
          helpers.arrayWithoutHoles = helper("7.0.0-beta.0")(
            _templateObject46()
          );
          helpers.arrayWithHoles = helper("7.0.0-beta.0")(_templateObject47());
          helpers.iterableToArray = helper("7.0.0-beta.0")(_templateObject48());
          helpers.iterableToArrayLimit = helper("7.0.0-beta.0")(
            _templateObject49()
          );
          helpers.iterableToArrayLimitLoose = helper("7.0.0-beta.0")(
            _templateObject50()
          );
          helpers.nonIterableSpread = helper("7.0.0-beta.0")(
            _templateObject51()
          );
          helpers.nonIterableRest = helper("7.0.0-beta.0")(_templateObject52());
          helpers.skipFirstGeneratorNext = helper("7.0.0-beta.0")(
            _templateObject53()
          );
          helpers.toPropertyKey = helper("7.0.0-beta.0")(_templateObject54());
          helpers.initializerWarningHelper = helper("7.0.0-beta.0")(
            _templateObject55()
          );
          helpers.initializerDefineProperty = helper("7.0.0-beta.0")(
            _templateObject56()
          );
          helpers.applyDecoratedDescriptor = helper("7.0.0-beta.0")(
            _templateObject57()
          );
          helpers.classPrivateFieldLooseKey = helper("7.0.0-beta.0")(
            _templateObject58()
          );
          helpers.classPrivateFieldLooseBase = helper("7.0.0-beta.0")(
            _templateObject59()
          );
          helpers.classPrivateFieldGet = helper("7.0.0-beta.0")(
            _templateObject60()
          );
          helpers.classPrivateFieldSet = helper("7.0.0-beta.0")(
            _templateObject61()
          );
          helpers.classStaticPrivateFieldSpecGet = helper("7.0.1")(
            _templateObject62()
          );
          helpers.classStaticPrivateFieldSpecSet = helper("7.0.1")(
            _templateObject63()
          );
        },
        /* 400 */
        function(module, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          /* harmony import */ var _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            0
          );
          /* harmony import */ var _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
            _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0__
          );

          function _templateObject() {
            var data = _gerhobbelt_babel_runtime_helpers_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_0___default()(
              [
                '\n    (function (root, factory) {\n      if (typeof define === "function" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === "object") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  ',
              ]
            );

            _templateObject = function _templateObject() {
              return data;
            };

            return data;
          }

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = _default;

          function helpers() {
            var data = _interopRequireWildcard(__webpack_require__(134));

            helpers = function helpers() {
              return data;
            };

            return data;
          }

          function _babelGenerator() {
            var data = _interopRequireDefault(__webpack_require__(78));

            _babelGenerator = function _babelGenerator() {
              return data;
            };

            return data;
          }

          function _babelTemplate() {
            var data = _interopRequireDefault(__webpack_require__(45));

            _babelTemplate = function _babelTemplate() {
              return data;
            };

            return data;
          }

          function t() {
            var data = _interopRequireWildcard(__webpack_require__(1));

            t = function t() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          var buildUmdWrapper = function buildUmdWrapper(replacements) {
            return _babelTemplate().default(_templateObject())(replacements);
          };

          function buildGlobal(whitelist) {
            var namespace = t().identifier("babelHelpers");
            var body = [];
            var container = t().functionExpression(
              null,
              [t().identifier("global")],
              t().blockStatement(body)
            );
            var tree = t().program([
              t().expressionStatement(
                t().callExpression(container, [
                  t().conditionalExpression(
                    t().binaryExpression(
                      "===",
                      t().unaryExpression("typeof", t().identifier("global")),
                      t().stringLiteral("undefined")
                    ),
                    t().identifier("self"),
                    t().identifier("global")
                  ),
                ])
              ),
            ]);
            body.push(
              t().variableDeclaration("var", [
                t().variableDeclarator(
                  namespace,
                  t().assignmentExpression(
                    "=",
                    t().memberExpression(t().identifier("global"), namespace),
                    t().objectExpression([])
                  )
                ),
              ])
            );
            buildHelpers(body, namespace, whitelist);
            return tree;
          }

          function buildModule(whitelist) {
            var body = [];
            var refs = buildHelpers(body, null, whitelist);
            body.unshift(
              t().exportNamedDeclaration(
                null,
                Object.keys(refs).map(function(name) {
                  return t().exportSpecifier(
                    t().cloneNode(refs[name]),
                    t().identifier(name)
                  );
                })
              )
            );
            return t().program(body, [], "module");
          }

          function buildUmd(whitelist) {
            var namespace = t().identifier("babelHelpers");
            var body = [];
            body.push(
              t().variableDeclaration("var", [
                t().variableDeclarator(namespace, t().identifier("global")),
              ])
            );
            buildHelpers(body, namespace, whitelist);
            return t().program([
              buildUmdWrapper({
                FACTORY_PARAMETERS: t().identifier("global"),
                BROWSER_ARGUMENTS: t().assignmentExpression(
                  "=",
                  t().memberExpression(t().identifier("root"), namespace),
                  t().objectExpression([])
                ),
                COMMON_ARGUMENTS: t().identifier("exports"),
                AMD_ARGUMENTS: t().arrayExpression([
                  t().stringLiteral("exports"),
                ]),
                FACTORY_BODY: body,
                UMD_ROOT: t().identifier("this"),
              }),
            ]);
          }

          function buildVar(whitelist) {
            var namespace = t().identifier("babelHelpers");
            var body = [];
            body.push(
              t().variableDeclaration("var", [
                t().variableDeclarator(namespace, t().objectExpression([])),
              ])
            );
            var tree = t().program(body);
            buildHelpers(body, namespace, whitelist);
            body.push(t().expressionStatement(namespace));
            return tree;
          }

          function buildHelpers(body, namespace, whitelist) {
            var getHelperReference = function getHelperReference(name) {
              return namespace
                ? t().memberExpression(namespace, t().identifier(name))
                : t().identifier("_" + name);
            };

            var refs = {};
            helpers().list.forEach(function(name) {
              if (whitelist && whitelist.indexOf(name) < 0) return;
              var ref = (refs[name] = getHelperReference(name));

              var _helpers$get = helpers().get(name, getHelperReference, ref),
                nodes = _helpers$get.nodes;

              body.push.apply(body, nodes);
            });
            return refs;
          }

          function _default(whitelist, outputType) {
            if (outputType === void 0) {
              outputType = "global";
            }

            var tree;
            var build = {
              global: buildGlobal,
              module: buildModule,
              umd: buildUmd,
              var: buildVar,
            }[outputType];

            if (build) {
              tree = build(whitelist);
            } else {
              throw new Error("Unsupported output type " + outputType);
            }

            return (0, _babelGenerator().default)(tree).code;
          }
        },
        /* 401 */
        function(module) {
          module.exports = {
            _from: "@gerhobbelt/babel-core@7.0.1-15",
            _id: "@gerhobbelt/babel-core@7.0.1-15",
            _inBundle: false,
            _integrity:
              "sha512-XCxn1ZzhJGyGdA7CjHzCRp/8i8k44V66PR/VoRroTLylACfV0KNqWjzWiI2T7JasAj2UptdNTc8wV2odlSm90A==",
            _location: "/@gerhobbelt/babel-core",
            _phantomChildren: { ms: "2.0.0" },
            _requested: {
              type: "version",
              registry: true,
              raw: "@gerhobbelt/babel-core@7.0.1-15",
              name: "@gerhobbelt/babel-core",
              escapedName: "@gerhobbelt%2fbabel-core",
              scope: "@gerhobbelt",
              rawSpec: "7.0.1-15",
              saveSpec: null,
              fetchSpec: "7.0.1-15",
            },
            _requiredBy: [
              "#DEV:/",
              "/@gerhobbelt/babel-helper-transform-fixture-test-runner",
            ],
            _resolved:
              "https://registry.npmjs.org/@gerhobbelt/babel-core/-/babel-core-7.0.1-15.tgz",
            _shasum: "cac103024edf6fa55862e28537e3695516339089",
            _spec: "@gerhobbelt/babel-core@7.0.1-15",
            _where:
              "W:\\Users\\Ger\\Projects\\sites\\library.visyond.gov\\80\\lib\\js\\babel",
            author: { name: "Sebastian McKenzie", email: "sebmck@gmail.com" },
            browser: {
              "./lib/config/files/index.js":
                "./lib/config/files/index-browser.js",
              "./lib/transform-file.js": "./lib/transform-file-browser.js",
            },
            bundleDependencies: false,
            dependencies: {
              "@gerhobbelt/babel-code-frame": "7.0.1-15",
              "@gerhobbelt/babel-generator": "7.0.1-15",
              "@gerhobbelt/babel-helpers": "7.0.1-15",
              "@gerhobbelt/babel-parser": "7.0.1-15",
              "@gerhobbelt/babel-template": "7.0.1-15",
              "@gerhobbelt/babel-traverse": "7.0.1-15",
              "@gerhobbelt/babel-types": "7.0.1-15",
              "@gerhobbelt/json5": "2.0.1-37",
              "convert-source-map": "^1.5.1",
              debug: "^3.1.0",
              lodash: "^4.17.10",
              resolve: "^1.8.1",
              semver: "^5.5.1",
              "source-map": "0.6.1",
            },
            deprecated: false,
            description: "Babel compiler core.",
            devDependencies: {
              "@gerhobbelt/babel-helper-transform-fixture-test-runner":
                "7.0.1-15",
              "@gerhobbelt/babel-register": "7.0.1-15",
            },
            engines: { node: ">=6.9.0" },
            homepage: "https://babeljs.io/",
            keywords: [
              "6to5",
              "babel",
              "classes",
              "const",
              "es6",
              "harmony",
              "let",
              "modules",
              "transpile",
              "transpiler",
              "var",
              "babel-core",
              "compiler",
            ],
            license: "MIT",
            main: "lib/index.js",
            name: "@gerhobbelt/babel-core",
            publishConfig: { access: "public" },
            repository: {
              type: "git",
              url:
                "https://github.com/babel/babel/tree/master/packages/babel-core",
            },
            version: "7.0.1-15",
          };
        },
        /* 402 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = loadFullConfig;

          var _util = __webpack_require__(153);

          var context = _interopRequireWildcard(__webpack_require__(72));

          var _plugin = _interopRequireDefault(__webpack_require__(83));

          var _item = __webpack_require__(46);

          var _configChain = __webpack_require__(154);

          function _babelTraverse() {
            var data = _interopRequireDefault(__webpack_require__(9));

            _babelTraverse = function _babelTraverse() {
              return data;
            };

            return data;
          }

          var _caching = __webpack_require__(47);

          var _options = __webpack_require__(84);

          var _plugins = __webpack_require__(407);

          var _configApi = _interopRequireDefault(__webpack_require__(408));

          var _partial = _interopRequireDefault(__webpack_require__(157));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};

              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};

                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }

              newObj.default = obj;
              return newObj;
            }
          }

          function loadFullConfig(inputOpts) {
            var result = (0, _partial.default)(inputOpts);

            if (!result) {
              return null;
            }

            var options = result.options,
              context = result.context;
            var optionDefaults = {};
            var passes = [[]];

            try {
              var plugins = options.plugins,
                presets = options.presets;

              if (!plugins || !presets) {
                throw new Error(
                  "Assertion failure - plugins and presets exist"
                );
              }

              var ignored = (function recurseDescriptors(config, pass) {
                var plugins = config.plugins.reduce(function(acc, descriptor) {
                  if (descriptor.options !== false) {
                    acc.push(loadPluginDescriptor(descriptor, context));
                  }

                  return acc;
                }, []);
                var presets = config.presets.reduce(function(acc, descriptor) {
                  if (descriptor.options !== false) {
                    acc.push({
                      preset: loadPresetDescriptor(descriptor, context),
                      pass: descriptor.ownPass ? [] : pass,
                    });
                  }

                  return acc;
                }, []);

                if (presets.length > 0) {
                  passes.splice.apply(
                    passes,
                    [1, 0].concat(
                      presets
                        .map(function(o) {
                          return o.pass;
                        })
                        .filter(function(p) {
                          return p !== pass;
                        })
                    )
                  );

                  for (
                    var _iterator = presets,
                      _isArray = Array.isArray(_iterator),
                      _i = 0,
                      _iterator = _isArray
                        ? _iterator
                        : _iterator[Symbol.iterator]();
                    ;

                  ) {
                    var _ref2;

                    if (_isArray) {
                      if (_i >= _iterator.length) break;
                      _ref2 = _iterator[_i++];
                    } else {
                      _i = _iterator.next();
                      if (_i.done) break;
                      _ref2 = _i.value;
                    }

                    var _ref = _ref2;
                    var preset = _ref.preset,
                      _pass = _ref.pass;
                    if (!preset) return true;

                    var _ignored = recurseDescriptors(
                      {
                        plugins: preset.plugins,
                        presets: preset.presets,
                      },
                      _pass
                    );

                    if (_ignored) return true;
                    preset.options.forEach(function(opts) {
                      (0, _util.mergeOptions)(optionDefaults, opts);
                    });
                  }
                }

                if (plugins.length > 0) {
                  pass.unshift.apply(pass, plugins);
                }
              })(
                {
                  plugins: plugins.map(function(item) {
                    var desc = (0, _item.getItemDescriptor)(item);

                    if (!desc) {
                      throw new Error(
                        "Assertion failure - must be config item"
                      );
                    }

                    return desc;
                  }),
                  presets: presets.map(function(item) {
                    var desc = (0, _item.getItemDescriptor)(item);

                    if (!desc) {
                      throw new Error(
                        "Assertion failure - must be config item"
                      );
                    }

                    return desc;
                  }),
                },
                passes[0]
              );

              if (ignored) return null;
            } catch (e) {
              if (!/^\[BABEL\]/.test(e.message)) {
                e.message =
                  "[BABEL] " +
                  (context.filename || "unknown") +
                  ": " +
                  e.message;
              }

              throw e;
            }

            var opts = optionDefaults;
            (0, _util.mergeOptions)(opts, options);
            opts.plugins = passes[0];
            opts.presets = passes
              .slice(1)
              .filter(function(plugins) {
                return plugins.length > 0;
              })
              .map(function(plugins) {
                return {
                  plugins: plugins,
                };
              });
            opts.passPerPreset = opts.presets.length > 0;
            return {
              options: opts,
              passes: passes,
            };
          }

          var loadDescriptor = (0, _caching.makeWeakCache)(function(
            _ref3,
            cache
          ) {
            var value = _ref3.value,
              options = _ref3.options,
              dirname = _ref3.dirname,
              alias = _ref3.alias;
            if (options === false) throw new Error("Assertion failure");
            options = options || {};
            var item = value;

            if (typeof value === "function") {
              var api = Object.assign(
                {},
                context,
                (0, _configApi.default)(cache)
              );

              try {
                item = value(api, options, dirname);
              } catch (e) {
                if (alias) {
                  e.message +=
                    " (While processing: " + JSON.stringify(alias) + ")";
                }

                throw e;
              }
            }

            if (!item || typeof item !== "object") {
              throw new Error("Plugin/Preset did not return an object.");
            }

            if (typeof item.then === "function") {
              throw new Error(
                "You appear to be using an async plugin, " +
                  "which your current version of Babel does not support." +
                  "If you're using a published plugin, " +
                  "you may need to upgrade your @gerhobbelt/babel-core version."
              );
            }

            return {
              value: item,
              options: options,
              dirname: dirname,
              alias: alias,
            };
          });

          function loadPluginDescriptor(descriptor, context) {
            if (descriptor.value instanceof _plugin.default) {
              if (descriptor.options) {
                throw new Error(
                  "Passed options to an existing Plugin instance will not work."
                );
              }

              return descriptor.value;
            }

            return instantiatePlugin(
              loadDescriptor(descriptor, context),
              context
            );
          }

          var instantiatePlugin = (0, _caching.makeWeakCache)(function(
            _ref4,
            cache
          ) {
            var value = _ref4.value,
              options = _ref4.options,
              dirname = _ref4.dirname,
              alias = _ref4.alias;
            var pluginObj = (0, _plugins.validatePluginObject)(value);
            var plugin = Object.assign({}, pluginObj);

            if (plugin.visitor) {
              plugin.visitor = _babelTraverse().default.explode(
                Object.assign({}, plugin.visitor)
              );
            }

            if (plugin.inherits) {
              var inheritsDescriptor = {
                name: undefined,
                alias: alias + "$inherits",
                value: plugin.inherits,
                options: options,
                dirname: dirname,
              };
              var inherits = cache.invalidate(function(data) {
                return loadPluginDescriptor(inheritsDescriptor, data);
              });
              plugin.pre = chain(inherits.pre, plugin.pre);
              plugin.post = chain(inherits.post, plugin.post);
              plugin.manipulateOptions = chain(
                inherits.manipulateOptions,
                plugin.manipulateOptions
              );
              plugin.visitor = _babelTraverse().default.visitors.merge([
                inherits.visitor || {},
                plugin.visitor || {},
              ]);
            }

            return new _plugin.default(plugin, options, alias);
          });

          var loadPresetDescriptor = function loadPresetDescriptor(
            descriptor,
            context
          ) {
            return (0, _configChain.buildPresetChain)(
              instantiatePreset(loadDescriptor(descriptor, context)),
              context
            );
          };

          var instantiatePreset = (0, _caching.makeWeakCache)(function(_ref5) {
            var value = _ref5.value,
              dirname = _ref5.dirname,
              alias = _ref5.alias;
            return {
              options: (0, _options.validate)("preset", value),
              alias: alias,
              dirname: dirname,
            };
          });

          function chain(a, b) {
            var fns = [a, b].filter(Boolean);
            if (fns.length <= 1) return fns[0];
            return function() {
              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key];
              }

              for (
                var _iterator2 = fns,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : _iterator2[Symbol.iterator]();
                ;

              ) {
                var _ref6;

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break;
                  _ref6 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done) break;
                  _ref6 = _i2.value;
                }

                var fn = _ref6;
                fn.apply(this, args);
              }
            };
          }
        },
        /* 403 */
        function(module, exports, __webpack_require__) {
          exports = module.exports = createDebug.debug = createDebug[
            "default"
          ] = createDebug;
          exports.coerce = coerce;
          exports.disable = disable;
          exports.enable = enable;
          exports.enabled = enabled;
          exports.humanize = __webpack_require__(136);
          exports.instances = [];
          exports.names = [];
          exports.skips = [];
          exports.formatters = {};

          function selectColor(namespace) {
            var hash = 0,
              i;

            for (i in namespace) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }

            return exports.colors[Math.abs(hash) % exports.colors.length];
          }

          function createDebug(namespace) {
            var prevTime;

            function debug() {
              if (!debug.enabled) return;
              var self = debug;
              var curr = +new Date();
              var ms = curr - (prevTime || curr);
              self.diff = ms;
              self.prev = prevTime;
              self.curr = curr;
              prevTime = curr;
              var args = new Array(arguments.length);

              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i];
              }

              args[0] = exports.coerce(args[0]);

              if ("string" !== typeof args[0]) {
                args.unshift("%O");
              }

              var index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, function(
                match,
                format
              ) {
                if (match === "%%") return match;
                index++;
                var formatter = exports.formatters[format];

                if ("function" === typeof formatter) {
                  var val = args[index];
                  match = formatter.call(self, val);
                  args.splice(index, 1);
                  index--;
                }

                return match;
              });
              exports.formatArgs.call(self, args);
              var logFn = debug.log || exports.log || console.log.bind(console);
              logFn.apply(self, args);
            }

            debug.namespace = namespace;
            debug.enabled = exports.enabled(namespace);
            debug.useColors = exports.useColors();
            debug.color = selectColor(namespace);
            debug.destroy = destroy;

            if ("function" === typeof exports.init) {
              exports.init(debug);
            }

            exports.instances.push(debug);
            return debug;
          }

          function destroy() {
            var index = exports.instances.indexOf(this);

            if (index !== -1) {
              exports.instances.splice(index, 1);
              return true;
            } else {
              return false;
            }
          }

          function enable(namespaces) {
            exports.save(namespaces);
            exports.names = [];
            exports.skips = [];
            var i;
            var split = (typeof namespaces === "string"
              ? namespaces
              : ""
            ).split(/[\s,]+/);
            var len = split.length;

            for (i = 0; i < len; i++) {
              if (!split[i]) continue;
              namespaces = split[i].replace(/\*/g, ".*?");

              if (namespaces[0] === "-") {
                exports.skips.push(
                  new RegExp("^" + namespaces.substr(1) + "$")
                );
              } else {
                exports.names.push(new RegExp("^" + namespaces + "$"));
              }
            }

            for (i = 0; i < exports.instances.length; i++) {
              var instance = exports.instances[i];
              instance.enabled = exports.enabled(instance.namespace);
            }
          }

          function disable() {
            exports.enable("");
          }

          function enabled(name) {
            if (name[name.length - 1] === "*") {
              return true;
            }

            var i, len;

            for (i = 0, len = exports.skips.length; i < len; i++) {
              if (exports.skips[i].test(name)) {
                return false;
              }
            }

            for (i = 0, len = exports.names.length; i < len; i++) {
              if (exports.names[i].test(name)) {
                return true;
              }
            }

            return false;
          }

          function coerce(val) {
            if (val instanceof Error) return val.stack || val.message;
            return val;
          }
        },
        /* 404 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;
          var _default = {
            auxiliaryComment: {
              message:
                "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`",
            },
            blacklist: {
              message:
                "Put the specific transforms you want in the `plugins` option",
            },
            breakConfig: {
              message: "This is not a necessary option in Babel 6",
            },
            experimental: {
              message:
                "Put the specific transforms you want in the `plugins` option",
            },
            externalHelpers: {
              message:
                "Use the `external-helpers` plugin instead. " +
                "Check out http://babeljs.io/docs/plugins/external-helpers/",
            },
            extra: {
              message: "",
            },
            jsxPragma: {
              message:
                "use the `pragma` option in the `react-jsx` plugin. " +
                "Check out http://babeljs.io/docs/plugins/transform-react-jsx/",
            },
            loose: {
              message:
                "Specify the `loose` option for the relevant plugin you are using " +
                "or use a preset that sets the option.",
            },
            metadataUsedHelpers: {
              message: "Not required anymore as this is enabled by default",
            },
            modules: {
              message:
                "Use the corresponding module transform plugin in the `plugins` option. " +
                "Check out http://babeljs.io/docs/plugins/#modules",
            },
            nonStandard: {
              message:
                "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. " +
                "Also check out the react preset http://babeljs.io/docs/plugins/preset-react/",
            },
            optional: {
              message:
                "Put the specific transforms you want in the `plugins` option",
            },
            sourceMapName: {
              message:
                "The `sourceMapName` option has been removed because it makes more sense for the " +
                "tooling that calls Babel to assign `map.file` themselves.",
            },
            stage: {
              message:
                "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets",
            },
            whitelist: {
              message:
                "Put the specific transforms you want in the `plugins` option",
            },
            resolveModuleSource: {
              version: 6,
              message:
                "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options",
            },
            metadata: {
              version: 6,
              message:
                "Generated plugin metadata is always included in the output result",
            },
            sourceMapTarget: {
              version: 6,
              message:
                "The `sourceMapTarget` option has been removed because it makes more sense for the tooling " +
                "that calls Babel to assign `map.file` themselves.",
            },
          };
          exports.default = _default;
        },
        /* 405 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = pathToPattern;

          function _path() {
            var data = _interopRequireDefault(__webpack_require__(15));

            _path = function _path() {
              return data;
            };

            return data;
          }

          function _escapeRegExp() {
            var data = _interopRequireDefault(__webpack_require__(406));

            _escapeRegExp = function _escapeRegExp() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var sep = "\\" + _path().default.sep;

          var endSep = "(?:" + sep + "|$)";
          var substitution = "[^" + sep + "]+";
          var starPat = "(?:" + substitution + sep + ")";
          var starPatLast = "(?:" + substitution + endSep + ")";
          var starStarPat = starPat + "*?";
          var starStarPatLast = starPat + "*?" + starPatLast + "?";

          function pathToPattern(pattern, dirname) {
            var parts = _path()
              .default.resolve(dirname, pattern)
              .split(_path().default.sep);

            return new RegExp(
              ["^"]
                .concat(
                  parts.map(function(part, i) {
                    var last = i === parts.length - 1;
                    if (part === "**")
                      return last ? starStarPatLast : starStarPat;
                    if (part === "*") return last ? starPatLast : starPat;

                    if (part.indexOf("*.") === 0) {
                      return (
                        substitution +
                        (0, _escapeRegExp().default)(part.slice(1)) +
                        (last ? endSep : sep)
                      );
                    }

                    return (
                      (0, _escapeRegExp().default)(part) + (last ? endSep : sep)
                    );
                  })
                )
                .join("")
            );
          }
        },
        /* 406 */
        function(module, exports, __webpack_require__) {
          var toString = __webpack_require__(77);

          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
            reHasRegExpChar = RegExp(reRegExpChar.source);

          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string)
              ? string.replace(reRegExpChar, "\\$&")
              : string;
          }

          module.exports = escapeRegExp;
        },
        /* 407 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.validatePluginObject = validatePluginObject;

          var _optionAssertions = __webpack_require__(156);

          var VALIDATORS = {
            name: _optionAssertions.assertString,
            manipulateOptions: _optionAssertions.assertFunction,
            pre: _optionAssertions.assertFunction,
            post: _optionAssertions.assertFunction,
            inherits: _optionAssertions.assertFunction,
            visitor: assertVisitorMap,
            parserOverride: _optionAssertions.assertFunction,
            generatorOverride: _optionAssertions.assertFunction,
          };

          function assertVisitorMap(key, value) {
            var obj = (0, _optionAssertions.assertObject)(key, value);

            if (obj) {
              Object.keys(obj).forEach(function(prop) {
                return assertVisitorHandler(prop, obj[prop]);
              });

              if (obj.enter || obj.exit) {
                throw new Error(
                  "." +
                    key +
                    ' cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.'
                );
              }
            }

            return obj;
          }

          function assertVisitorHandler(key, value) {
            if (value && typeof value === "object") {
              Object.keys(value).forEach(function(handler) {
                if (handler !== "enter" && handler !== "exit") {
                  throw new Error(
                    '.visitor["' +
                      key +
                      '"] may only have .enter and/or .exit handlers.'
                  );
                }
              });
            } else if (typeof value !== "function") {
              throw new Error('.visitor["' + key + '"] must be a function');
            }

            return value;
          }

          function validatePluginObject(obj) {
            Object.keys(obj).forEach(function(key) {
              var validator = VALIDATORS[key];
              if (validator) validator(key, obj[key]);
              else
                throw new Error("." + key + " is not a valid Plugin property");
            });
            return obj;
          }
        },
        /* 408 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = makeAPI;

          function _semver() {
            var data = _interopRequireDefault(__webpack_require__(16));

            _semver = function _semver() {
              return data;
            };

            return data;
          }

          var _ = __webpack_require__(72);

          var _caching = __webpack_require__(47);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function makeAPI(cache) {
            var env = function env(value) {
              return cache.using(function(data) {
                if (typeof value === "undefined") return data.envName;

                if (typeof value === "function") {
                  return (0, _caching.assertSimpleType)(value(data.envName));
                }

                if (!Array.isArray(value)) value = [value];
                return value.some(function(entry) {
                  if (typeof entry !== "string") {
                    throw new Error("Unexpected non-string value");
                  }

                  return entry === data.envName;
                });
              });
            };

            var caller = function caller(cb) {
              return cache.using(function(data) {
                return (0, _caching.assertSimpleType)(cb(data.caller));
              });
            };

            return {
              version: _.version,
              cache: cache.simple(),
              env: env,
              async: function async() {
                return false;
              },
              caller: caller,
              assertVersion: assertVersion,
            };
          }

          function assertVersion(range) {
            if (typeof range === "number") {
              if (!Number.isInteger(range)) {
                throw new Error("Expected string or integer value.");
              }

              var cv = _semver().default.parse(_.version);

              if (cv.major === range) return;
            } else {
              if (typeof range !== "string") {
                throw new Error("Expected string or integer value.");
              }

              if (_semver().default.satisfies(_.version, range)) return;
            }

            var limit = Error.stackTraceLimit;

            if (typeof limit === "number" && limit < 25) {
              Error.stackTraceLimit = 25;
            }

            var err = new Error(
              'Requires Babel "' +
                range +
                '", but was loaded with "' +
                _.version +
                '". ' +
                "If you are sure you have a compatible version of @gerhobbelt/babel-core, " +
                "it is likely that something in your build process is loading the " +
                "wrong version. Inspect the stack trace of this error to look for " +
                'the first entry that doesn\'t mention "@gerhobbelt/babel-core" or "babel-core" ' +
                "to see what is calling Babel."
            );

            if (typeof limit === "number") {
              Error.stackTraceLimit = limit;
            }

            throw Object.assign(err, {
              code: "BABEL_VERSION_UNSUPPORTED",
              version: _.version,
              range: range,
            });
          }
        },
        /* 409 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(process) {
            Object.defineProperty(exports, "__esModule", {
              value: true,
            });
            exports.transformSync = transformSync;
            exports.transformAsync = transformAsync;
            exports.transform = void 0;

            var _config = _interopRequireDefault(__webpack_require__(31));

            var _transformation = __webpack_require__(158);

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule
                ? obj
                : {
                    default: obj,
                  };
            }

            var transform = function transform(code, opts, callback) {
              if (typeof opts === "function") {
                callback = opts;
                opts = undefined;
              }

              if (callback === undefined) return transformSync(code, opts);
              var cb = callback;
              process.nextTick(function() {
                var cfg;

                try {
                  cfg = (0, _config.default)(opts);
                  if (cfg === null) return cb(null, null);
                } catch (err) {
                  return cb(err);
                }

                (0, _transformation.runAsync)(cfg, code, null, cb);
              });
            };

            exports.transform = transform;

            function transformSync(code, opts) {
              var config = (0, _config.default)(opts);
              if (config === null) return null;
              return (0, _transformation.runSync)(config, code);
            }

            function transformAsync(code, opts) {
              return new Promise(function(res, rej) {
                transform(code, opts, function(err, result) {
                  if (err == null) res(result);
                  else rej(err);
                });
              });
            }
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(3)));
        },
        /* 410 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          var PluginPass = (function() {
            function PluginPass(file, key, options) {
              this._map = new Map();
              this.key = key;
              this.file = file;
              this.opts = options || {};
              this.cwd = file.opts.cwd;
              this.filename = file.opts.filename;
            }

            var _proto = PluginPass.prototype;

            _proto.set = function set(key, val) {
              this._map.set(key, val);
            };

            _proto.get = function get(key) {
              return this._map.get(key);
            };

            _proto.availableHelper = function availableHelper(
              name,
              versionRange
            ) {
              return this.file.availableHelper(name, versionRange);
            };

            _proto.addHelper = function addHelper(name) {
              return this.file.addHelper(name);
            };

            _proto.addImport = function addImport() {
              return this.file.addImport();
            };

            _proto.getModuleName = function getModuleName() {
              return this.file.getModuleName();
            };

            _proto.buildCodeFrameError = function buildCodeFrameError(
              node,
              msg,
              Error
            ) {
              return this.file.buildCodeFrameError(node, msg, Error);
            };

            return PluginPass;
          })();

          exports.default = PluginPass;
        },
        /* 411 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = loadBlockHoistPlugin;

          function _sortBy() {
            var data = _interopRequireDefault(__webpack_require__(412));

            _sortBy = function _sortBy() {
              return data;
            };

            return data;
          }

          var _config = _interopRequireDefault(__webpack_require__(31));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var LOADED_PLUGIN;

          function loadBlockHoistPlugin() {
            if (!LOADED_PLUGIN) {
              var config = (0, _config.default)({
                babelrc: false,
                configFile: false,
                plugins: [blockHoistPlugin],
              });
              LOADED_PLUGIN = config ? config.passes[0][0] : undefined;
              if (!LOADED_PLUGIN) throw new Error("Assertion failure");
            }

            return LOADED_PLUGIN;
          }

          var blockHoistPlugin = {
            name: "internal.blockHoist",
            visitor: {
              Block: {
                exit: function exit(_ref) {
                  var node = _ref.node;
                  var hasChange = false;

                  for (var i = 0; i < node.body.length; i++) {
                    var bodyNode = node.body[i];

                    if (bodyNode && bodyNode._blockHoist != null) {
                      hasChange = true;
                      break;
                    }
                  }

                  if (!hasChange) return;
                  node.body = (0, _sortBy().default)(node.body, function(
                    bodyNode
                  ) {
                    var priority = bodyNode && bodyNode._blockHoist;
                    if (priority == null) priority = 1;
                    if (priority === true) priority = 2;
                    return -1 * priority;
                  });
                },
              },
            },
          };
        },
        /* 412 */
        function(module, exports, __webpack_require__) {
          var baseFlatten = __webpack_require__(413),
            baseOrderBy = __webpack_require__(415),
            baseRest = __webpack_require__(140),
            isIterateeCall = __webpack_require__(76);

          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }

            var length = iteratees.length;

            if (
              length > 1 &&
              isIterateeCall(collection, iteratees[0], iteratees[1])
            ) {
              iteratees = [];
            } else if (
              length > 2 &&
              isIterateeCall(iteratees[0], iteratees[1], iteratees[2])
            ) {
              iteratees = [iteratees[0]];
            }

            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          module.exports = sortBy;
        },
        /* 413 */
        function(module, exports, __webpack_require__) {
          var arrayPush = __webpack_require__(62),
            isFlattenable = __webpack_require__(414);

          function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1,
              length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);

            while (++index < length) {
              var value = array[index];

              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result);
                } else {
                  arrayPush(result, value);
                }
              } else if (!isStrict) {
                result[result.length] = value;
              }
            }

            return result;
          }

          module.exports = baseFlatten;
        },
        /* 414 */
        function(module, exports, __webpack_require__) {
          var Symbol = __webpack_require__(18),
            isArguments = __webpack_require__(55),
            isArray = __webpack_require__(5);

          var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

          function isFlattenable(value) {
            return (
              isArray(value) ||
              isArguments(value) ||
              !!(spreadableSymbol && value && value[spreadableSymbol])
            );
          }

          module.exports = isFlattenable;
        },
        /* 415 */
        function(module, exports, __webpack_require__) {
          var arrayMap = __webpack_require__(75),
            baseIteratee = __webpack_require__(416),
            baseMap = __webpack_require__(436),
            baseSortBy = __webpack_require__(442),
            baseUnary = __webpack_require__(26),
            compareMultiple = __webpack_require__(443),
            identity = __webpack_require__(42);

          function baseOrderBy(collection, iteratees, orders) {
            var index = -1;
            iteratees = arrayMap(
              iteratees.length ? iteratees : [identity],
              baseUnary(baseIteratee)
            );
            var result = baseMap(collection, function(value, key, collection) {
              var criteria = arrayMap(iteratees, function(iteratee) {
                return iteratee(value);
              });
              return {
                criteria: criteria,
                index: ++index,
                value: value,
              };
            });
            return baseSortBy(result, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }

          module.exports = baseOrderBy;
        },
        /* 416 */
        function(module, exports, __webpack_require__) {
          var baseMatches = __webpack_require__(417),
            baseMatchesProperty = __webpack_require__(425),
            identity = __webpack_require__(42),
            isArray = __webpack_require__(5),
            property = __webpack_require__(433);

          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }

            if (value == null) {
              return identity;
            }

            if (typeof value == "object") {
              return isArray(value)
                ? baseMatchesProperty(value[0], value[1])
                : baseMatches(value);
            }

            return property(value);
          }

          module.exports = baseIteratee;
        },
        /* 417 */
        function(module, exports, __webpack_require__) {
          var baseIsMatch = __webpack_require__(418),
            getMatchData = __webpack_require__(424),
            matchesStrictComparable = __webpack_require__(162);

          function baseMatches(source) {
            var matchData = getMatchData(source);

            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }

            return function(object) {
              return (
                object === source || baseIsMatch(object, source, matchData)
              );
            };
          }

          module.exports = baseMatches;
        },
        /* 418 */
        function(module, exports, __webpack_require__) {
          var Stack = __webpack_require__(52),
            baseIsEqual = __webpack_require__(159);

          var COMPARE_PARTIAL_FLAG = 1,
            COMPARE_UNORDERED_FLAG = 2;

          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length,
              length = index,
              noCustomizer = !customizer;

            if (object == null) {
              return !length;
            }

            object = Object(object);

            while (index--) {
              var data = matchData[index];

              if (
                noCustomizer && data[2]
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
              ) {
                return false;
              }
            }

            while (++index < length) {
              data = matchData[index];
              var key = data[0],
                objValue = object[key],
                srcValue = data[1];

              if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();

                if (customizer) {
                  var result = customizer(
                    objValue,
                    srcValue,
                    key,
                    object,
                    source,
                    stack
                  );
                }

                if (
                  !(result === undefined
                    ? baseIsEqual(
                        srcValue,
                        objValue,
                        COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG,
                        customizer,
                        stack
                      )
                    : result)
                ) {
                  return false;
                }
              }
            }

            return true;
          }

          module.exports = baseIsMatch;
        },
        /* 419 */
        function(module, exports, __webpack_require__) {
          var Stack = __webpack_require__(52),
            equalArrays = __webpack_require__(160),
            equalByTag = __webpack_require__(421),
            equalObjects = __webpack_require__(423),
            getTag = __webpack_require__(39),
            isArray = __webpack_require__(5),
            isBuffer = __webpack_require__(56),
            isTypedArray = __webpack_require__(98);

          var COMPARE_PARTIAL_FLAG = 1;
          var argsTag = "[object Arguments]",
            arrayTag = "[object Array]",
            objectTag = "[object Object]";
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;

          function baseIsEqualDeep(
            object,
            other,
            bitmask,
            customizer,
            equalFunc,
            stack
          ) {
            var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = objIsArr ? arrayTag : getTag(object),
              othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;

            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }

              objIsArr = true;
              objIsObj = false;
            }

            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object)
                ? equalArrays(
                    object,
                    other,
                    bitmask,
                    customizer,
                    equalFunc,
                    stack
                  )
                : equalByTag(
                    object,
                    other,
                    objTag,
                    bitmask,
                    customizer,
                    equalFunc,
                    stack
                  );
            }

            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped =
                  objIsObj && hasOwnProperty.call(object, "__wrapped__"),
                othIsWrapped =
                  othIsObj && hasOwnProperty.call(other, "__wrapped__");

              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object,
                  othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(
                  objUnwrapped,
                  othUnwrapped,
                  bitmask,
                  customizer,
                  stack
                );
              }
            }

            if (!isSameTag) {
              return false;
            }

            stack || (stack = new Stack());
            return equalObjects(
              object,
              other,
              bitmask,
              customizer,
              equalFunc,
              stack
            );
          }

          module.exports = baseIsEqualDeep;
        },
        /* 420 */
        function(module, exports) {
          function arraySome(array, predicate) {
            var index = -1,
              length = array == null ? 0 : array.length;

            while (++index < length) {
              if (predicate(array[index], index, array)) {
                return true;
              }
            }

            return false;
          }

          module.exports = arraySome;
        },
        /* 421 */
        function(module, exports, __webpack_require__) {
          var Symbol = __webpack_require__(18),
            Uint8Array = __webpack_require__(105),
            eq = __webpack_require__(25),
            equalArrays = __webpack_require__(160),
            mapToArray = __webpack_require__(422),
            setToArray = __webpack_require__(70);

          var COMPARE_PARTIAL_FLAG = 1,
            COMPARE_UNORDERED_FLAG = 2;
          var boolTag = "[object Boolean]",
            dateTag = "[object Date]",
            errorTag = "[object Error]",
            mapTag = "[object Map]",
            numberTag = "[object Number]",
            regexpTag = "[object RegExp]",
            setTag = "[object Set]",
            stringTag = "[object String]",
            symbolTag = "[object Symbol]";
          var arrayBufferTag = "[object ArrayBuffer]",
            dataViewTag = "[object DataView]";
          var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

          function equalByTag(
            object,
            other,
            tag,
            bitmask,
            customizer,
            equalFunc,
            stack
          ) {
            switch (tag) {
              case dataViewTag:
                if (
                  object.byteLength != other.byteLength ||
                  object.byteOffset != other.byteOffset
                ) {
                  return false;
                }

                object = object.buffer;
                other = other.buffer;

              case arrayBufferTag:
                if (
                  object.byteLength != other.byteLength ||
                  !equalFunc(new Uint8Array(object), new Uint8Array(other))
                ) {
                  return false;
                }

                return true;

              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);

              case errorTag:
                return (
                  object.name == other.name && object.message == other.message
                );

              case regexpTag:
              case stringTag:
                return object == other + "";

              case mapTag:
                var convert = mapToArray;

              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);

                if (object.size != other.size && !isPartial) {
                  return false;
                }

                var stacked = stack.get(object);

                if (stacked) {
                  return stacked == other;
                }

                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result = equalArrays(
                  convert(object),
                  convert(other),
                  bitmask,
                  customizer,
                  equalFunc,
                  stack
                );
                stack["delete"](object);
                return result;

              case symbolTag:
                if (symbolValueOf) {
                  return (
                    symbolValueOf.call(object) == symbolValueOf.call(other)
                  );
                }
            }

            return false;
          }

          module.exports = equalByTag;
        },
        /* 422 */
        function(module, exports) {
          function mapToArray(map) {
            var index = -1,
              result = Array(map.size);
            map.forEach(function(value, key) {
              result[++index] = [key, value];
            });
            return result;
          }

          module.exports = mapToArray;
        },
        /* 423 */
        function(module, exports, __webpack_require__) {
          var getAllKeys = __webpack_require__(102);

          var COMPARE_PARTIAL_FLAG = 1;
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;

          function equalObjects(
            object,
            other,
            bitmask,
            customizer,
            equalFunc,
            stack
          ) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              objProps = getAllKeys(object),
              objLength = objProps.length,
              othProps = getAllKeys(other),
              othLength = othProps.length;

            if (objLength != othLength && !isPartial) {
              return false;
            }

            var index = objLength;

            while (index--) {
              var key = objProps[index];

              if (
                !(isPartial ? key in other : hasOwnProperty.call(other, key))
              ) {
                return false;
              }
            }

            var stacked = stack.get(object);

            if (stacked && stack.get(other)) {
              return stacked == other;
            }

            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;

            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key],
                othValue = other[key];

              if (customizer) {
                var compared = isPartial
                  ? customizer(othValue, objValue, key, other, object, stack)
                  : customizer(objValue, othValue, key, object, other, stack);
              }

              if (
                !(compared === undefined
                  ? objValue === othValue ||
                    equalFunc(objValue, othValue, bitmask, customizer, stack)
                  : compared)
              ) {
                result = false;
                break;
              }

              skipCtor || (skipCtor = key == "constructor");
            }

            if (result && !skipCtor) {
              var objCtor = object.constructor,
                othCtor = other.constructor;

              if (
                objCtor != othCtor &&
                "constructor" in object &&
                "constructor" in other &&
                !(
                  typeof objCtor == "function" &&
                  objCtor instanceof objCtor &&
                  typeof othCtor == "function" &&
                  othCtor instanceof othCtor
                )
              ) {
                result = false;
              }
            }

            stack["delete"](object);
            stack["delete"](other);
            return result;
          }

          module.exports = equalObjects;
        },
        /* 424 */
        function(module, exports, __webpack_require__) {
          var isStrictComparable = __webpack_require__(161),
            keys = __webpack_require__(19);

          function getMatchData(object) {
            var result = keys(object),
              length = result.length;

            while (length--) {
              var key = result[length],
                value = object[key];
              result[length] = [key, value, isStrictComparable(value)];
            }

            return result;
          }

          module.exports = getMatchData;
        },
        /* 425 */
        function(module, exports, __webpack_require__) {
          var baseIsEqual = __webpack_require__(159),
            get = __webpack_require__(426),
            hasIn = __webpack_require__(430),
            isKey = __webpack_require__(85),
            isStrictComparable = __webpack_require__(161),
            matchesStrictComparable = __webpack_require__(162),
            toKey = __webpack_require__(48);

          var COMPARE_PARTIAL_FLAG = 1,
            COMPARE_UNORDERED_FLAG = 2;

          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }

            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined && objValue === srcValue
                ? hasIn(object, path)
                : baseIsEqual(
                    srcValue,
                    objValue,
                    COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG
                  );
            };
          }

          module.exports = baseMatchesProperty;
        },
        /* 426 */
        function(module, exports, __webpack_require__) {
          var baseGet = __webpack_require__(163);

          function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
          }

          module.exports = get;
        },
        /* 427 */
        function(module, exports, __webpack_require__) {
          var memoizeCapped = __webpack_require__(428);

          var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
          var reEscapeChar = /\\(\\)?/g;
          var stringToPath = memoizeCapped(function(string) {
            var result = [];

            if (string.charCodeAt(0) === 46) {
              result.push("");
            }

            string.replace(rePropName, function(
              match,
              number,
              quote,
              subString
            ) {
              result.push(
                quote ? subString.replace(reEscapeChar, "$1") : number || match
              );
            });
            return result;
          });
          module.exports = stringToPath;
        },
        /* 428 */
        function(module, exports, __webpack_require__) {
          var memoize = __webpack_require__(429);

          var MAX_MEMOIZE_SIZE = 500;

          function memoizeCapped(func) {
            var result = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }

              return key;
            });
            var cache = result.cache;
            return result;
          }

          module.exports = memoizeCapped;
        },
        /* 429 */
        function(module, exports, __webpack_require__) {
          var MapCache = __webpack_require__(54);

          var FUNC_ERROR_TEXT = "Expected a function";

          function memoize(func, resolver) {
            if (
              typeof func != "function" ||
              (resolver != null && typeof resolver != "function")
            ) {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            var memoized = function memoized() {
              var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;

              if (cache.has(key)) {
                return cache.get(key);
              }

              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result) || cache;
              return result;
            };

            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }

          memoize.Cache = MapCache;
          module.exports = memoize;
        },
        /* 430 */
        function(module, exports, __webpack_require__) {
          var baseHasIn = __webpack_require__(431),
            hasPath = __webpack_require__(432);

          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }

          module.exports = hasIn;
        },
        /* 431 */
        function(module, exports) {
          function baseHasIn(object, key) {
            return object != null && key in Object(object);
          }

          module.exports = baseHasIn;
        },
        /* 432 */
        function(module, exports, __webpack_require__) {
          var castPath = __webpack_require__(164),
            isArguments = __webpack_require__(55),
            isArray = __webpack_require__(5),
            isIndex = __webpack_require__(57),
            isLength = __webpack_require__(58),
            toKey = __webpack_require__(48);

          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1,
              length = path.length,
              result = false;

            while (++index < length) {
              var key = toKey(path[index]);

              if (!(result = object != null && hasFunc(object, key))) {
                break;
              }

              object = object[key];
            }

            if (result || ++index != length) {
              return result;
            }

            length = object == null ? 0 : object.length;
            return (
              !!length &&
              isLength(length) &&
              isIndex(key, length) &&
              (isArray(object) || isArguments(object))
            );
          }

          module.exports = hasPath;
        },
        /* 433 */
        function(module, exports, __webpack_require__) {
          var baseProperty = __webpack_require__(434),
            basePropertyDeep = __webpack_require__(435),
            isKey = __webpack_require__(85),
            toKey = __webpack_require__(48);

          function property(path) {
            return isKey(path)
              ? baseProperty(toKey(path))
              : basePropertyDeep(path);
          }

          module.exports = property;
        },
        /* 434 */
        function(module, exports) {
          function baseProperty(key) {
            return function(object) {
              return object == null ? undefined : object[key];
            };
          }

          module.exports = baseProperty;
        },
        /* 435 */
        function(module, exports, __webpack_require__) {
          var baseGet = __webpack_require__(163);

          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }

          module.exports = basePropertyDeep;
        },
        /* 436 */
        function(module, exports, __webpack_require__) {
          var baseEach = __webpack_require__(437),
            isArrayLike = __webpack_require__(20);

          function baseMap(collection, iteratee) {
            var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value, key, collection) {
              result[++index] = iteratee(value, key, collection);
            });
            return result;
          }

          module.exports = baseMap;
        },
        /* 437 */
        function(module, exports, __webpack_require__) {
          var baseForOwn = __webpack_require__(438),
            createBaseEach = __webpack_require__(441);

          var baseEach = createBaseEach(baseForOwn);
          module.exports = baseEach;
        },
        /* 438 */
        function(module, exports, __webpack_require__) {
          var baseFor = __webpack_require__(439),
            keys = __webpack_require__(19);

          function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
          }

          module.exports = baseForOwn;
        },
        /* 439 */
        function(module, exports, __webpack_require__) {
          var createBaseFor = __webpack_require__(440);

          var baseFor = createBaseFor();
          module.exports = baseFor;
        },
        /* 440 */
        function(module, exports) {
          function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
              var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;

              while (length--) {
                var key = props[fromRight ? length : ++index];

                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }

              return object;
            };
          }

          module.exports = createBaseFor;
        },
        /* 441 */
        function(module, exports, __webpack_require__) {
          var isArrayLike = __webpack_require__(20);

          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
              if (collection == null) {
                return collection;
              }

              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee);
              }

              var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection);

              while (fromRight ? index-- : ++index < length) {
                if (iteratee(iterable[index], index, iterable) === false) {
                  break;
                }
              }

              return collection;
            };
          }

          module.exports = createBaseEach;
        },
        /* 442 */
        function(module, exports) {
          function baseSortBy(array, comparer) {
            var length = array.length;
            array.sort(comparer);

            while (length--) {
              array[length] = array[length].value;
            }

            return array;
          }

          module.exports = baseSortBy;
        },
        /* 443 */
        function(module, exports, __webpack_require__) {
          var compareAscending = __webpack_require__(444);

          function compareMultiple(object, other, orders) {
            var index = -1,
              objCriteria = object.criteria,
              othCriteria = other.criteria,
              length = objCriteria.length,
              ordersLength = orders.length;

            while (++index < length) {
              var result = compareAscending(
                objCriteria[index],
                othCriteria[index]
              );

              if (result) {
                if (index >= ordersLength) {
                  return result;
                }

                var order = orders[index];
                return result * (order == "desc" ? -1 : 1);
              }
            }

            return object.index - other.index;
          }

          module.exports = compareMultiple;
        },
        /* 444 */
        function(module, exports, __webpack_require__) {
          var isSymbol = __webpack_require__(29);

          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined,
                valIsNull = value === null,
                valIsReflexive = value === value,
                valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined,
                othIsNull = other === null,
                othIsReflexive = other === other,
                othIsSymbol = isSymbol(other);

              if (
                (!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
                (valIsSymbol &&
                  othIsDefined &&
                  othIsReflexive &&
                  !othIsNull &&
                  !othIsSymbol) ||
                (valIsNull && othIsDefined && othIsReflexive) ||
                (!valIsDefined && othIsReflexive) ||
                !valIsReflexive
              ) {
                return 1;
              }

              if (
                (!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
                (othIsSymbol &&
                  valIsDefined &&
                  valIsReflexive &&
                  !valIsNull &&
                  !valIsSymbol) ||
                (othIsNull && valIsDefined && valIsReflexive) ||
                (!othIsDefined && valIsReflexive) ||
                !othIsReflexive
              ) {
                return -1;
              }
            }

            return 0;
          }

          module.exports = compareAscending;
        },
        /* 445 */
        function(module, exports, __webpack_require__) {
          var baseClone = __webpack_require__(90);

          var CLONE_DEEP_FLAG = 1,
            CLONE_SYMBOLS_FLAG = 4;

          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }

          module.exports = cloneDeep;
        },
        /* 446 */
        function(module, exports) {},
        /* 447 */
        function(module, exports, __webpack_require__) {
          var buffer = __webpack_require__(147);

          var Buffer = buffer.Buffer;

          function copyProps(src, dst) {
            for (var key in src) {
              dst[key] = src[key];
            }
          }

          if (
            Buffer.from &&
            Buffer.alloc &&
            Buffer.allocUnsafe &&
            Buffer.allocUnsafeSlow
          ) {
            module.exports = buffer;
          } else {
            copyProps(buffer, exports);
            exports.Buffer = SafeBuffer;
          }

          function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer(arg, encodingOrOffset, length);
          }

          copyProps(Buffer, SafeBuffer);

          SafeBuffer.from = function(arg, encodingOrOffset, length) {
            if (typeof arg === "number") {
              throw new TypeError("Argument must not be a number");
            }

            return Buffer(arg, encodingOrOffset, length);
          };

          SafeBuffer.alloc = function(size, fill, encoding) {
            if (typeof size !== "number") {
              throw new TypeError("Argument must be a number");
            }

            var buf = Buffer(size);

            if (fill !== undefined) {
              if (typeof encoding === "string") {
                buf.fill(fill, encoding);
              } else {
                buf.fill(fill);
              }
            } else {
              buf.fill(0);
            }

            return buf;
          };

          SafeBuffer.allocUnsafe = function(size) {
            if (typeof size !== "number") {
              throw new TypeError("Argument must be a number");
            }

            return Buffer(size);
          };

          SafeBuffer.allocUnsafeSlow = function(size) {
            if (typeof size !== "number") {
              throw new TypeError("Argument must be a number");
            }

            return buffer.SlowBuffer(size);
          };
        },
        /* 448 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = generateMissingPluginMessage;
          var pluginNameMap = {
            asyncGenerators: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-async-generators",
                url: "https://git.io/vb4SY",
              },
              transform: {
                name:
                  "@gerhobbelt/babel-plugin-proposal-async-generator-functions",
                url: "https://git.io/vb4yp",
              },
            },
            classProperties: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-class-properties",
                url: "https://git.io/vb4yQ",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-class-properties",
                url: "https://git.io/vb4SL",
              },
            },
            decorators: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-decorators",
                url: "https://git.io/vb4y9",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-decorators",
                url: "https://git.io/vb4ST",
              },
            },
            doExpressions: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-do-expressions",
                url: "https://git.io/vb4yh",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-do-expressions",
                url: "https://git.io/vb4S3",
              },
            },
            dynamicImport: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-dynamic-import",
                url: "https://git.io/vb4Sv",
              },
            },
            exportDefaultFrom: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-export-default-from",
                url: "https://git.io/vb4SO",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-export-default-from",
                url: "https://git.io/vb4yH",
              },
            },
            exportNamespaceFrom: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-export-namespace-from",
                url: "https://git.io/vb4Sf",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-export-namespace-from",
                url: "https://git.io/vb4SG",
              },
            },
            flow: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-flow",
                url: "https://git.io/vb4yb",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-transform-flow-strip-types",
                url: "https://git.io/vb49g",
              },
            },
            functionBind: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-function-bind",
                url: "https://git.io/vb4y7",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-function-bind",
                url: "https://git.io/vb4St",
              },
            },
            functionSent: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-function-sent",
                url: "https://git.io/vb4yN",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-function-sent",
                url: "https://git.io/vb4SZ",
              },
            },
            importMeta: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-import-meta",
                url: "https://git.io/vbKK6",
              },
            },
            jsx: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-jsx",
                url: "https://git.io/vb4yA",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-transform-react-jsx",
                url: "https://git.io/vb4yd",
              },
            },
            logicalAssignment: {
              syntax: {
                name:
                  "@gerhobbelt/babel-plugin-syntax-logical-assignment-operators",
                url: "https://git.io/vAlBp",
              },
              transform: {
                name:
                  "@gerhobbelt/babel-plugin-proposal-logical-assignment-operators",
                url: "https://git.io/vAlRe",
              },
            },
            nullishCoalescingOperator: {
              syntax: {
                name:
                  "@gerhobbelt/babel-plugin-syntax-nullish-coalescing-operator",
                url: "https://git.io/vb4yx",
              },
              transform: {
                name:
                  "@gerhobbelt/babel-plugin-proposal-nullish-coalescing-operator",
                url: "https://git.io/vb4Se",
              },
            },
            numericSeparator: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-numeric-separator",
                url: "https://git.io/vb4Sq",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-numeric-separator",
                url: "https://git.io/vb4yS",
              },
            },
            objectRestSpread: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-object-rest-spread",
                url: "https://git.io/vb4y5",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-object-rest-spread",
                url: "https://git.io/vb4Ss",
              },
            },
            optionalCatchBinding: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-optional-catch-binding",
                url: "https://git.io/vb4Sn",
              },
              transform: {
                name:
                  "@gerhobbelt/babel-plugin-proposal-optional-catch-binding",
                url: "https://git.io/vb4SI",
              },
            },
            optionalChaining: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-optional-chaining",
                url: "https://git.io/vb4Sc",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-optional-chaining",
                url: "https://git.io/vb4Sk",
              },
            },
            pipelineOperator: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-pipeline-operator",
                url: "https://git.io/vb4yj",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-pipeline-operator",
                url: "https://git.io/vb4SU",
              },
            },
            throwExpressions: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-throw-expressions",
                url: "https://git.io/vb4SJ",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-proposal-throw-expressions",
                url: "https://git.io/vb4yF",
              },
            },
            typescript: {
              syntax: {
                name: "@gerhobbelt/babel-plugin-syntax-typescript",
                url: "https://git.io/vb4SC",
              },
              transform: {
                name: "@gerhobbelt/babel-plugin-transform-typescript",
                url: "https://git.io/vb4Sm",
              },
            },
          };

          var getNameURLCombination = function getNameURLCombination(_ref) {
            var name = _ref.name,
              url = _ref.url;
            return name + " (" + url + ")";
          };

          function generateMissingPluginMessage(
            missingPluginName,
            loc,
            codeFrame
          ) {
            var helpMessage =
              "Support for the experimental syntax '" +
              missingPluginName +
              "' isn't currently enabled " +
              ("(" + loc.line + ":" + (loc.column + 1) + "):\n\n") +
              codeFrame;
            var pluginInfo = pluginNameMap[missingPluginName];

            if (pluginInfo) {
              var syntaxPlugin = pluginInfo.syntax,
                transformPlugin = pluginInfo.transform;

              if (syntaxPlugin) {
                if (transformPlugin) {
                  var transformPluginInfo = getNameURLCombination(
                    transformPlugin
                  );
                  helpMessage +=
                    "\n\nAdd " +
                    transformPluginInfo +
                    " to the 'plugins' section of your Babel config " +
                    "to enable transformation.";
                } else {
                  var syntaxPluginInfo = getNameURLCombination(syntaxPlugin);
                  helpMessage +=
                    "\n\nAdd " +
                    syntaxPluginInfo +
                    " to the 'plugins' section of your Babel config " +
                    "to enable parsing.";
                }
              }
            }

            return helpMessage;
          }
        },
        /* 449 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = generateCode;

          function _convertSourceMap() {
            var data = _interopRequireDefault(__webpack_require__(167));

            _convertSourceMap = function _convertSourceMap() {
              return data;
            };

            return data;
          }

          function _babelGenerator() {
            var data = _interopRequireDefault(__webpack_require__(78));

            _babelGenerator = function _babelGenerator() {
              return data;
            };

            return data;
          }

          var _mergeMap = _interopRequireDefault(__webpack_require__(450));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function generateCode(pluginPasses, file) {
            var opts = file.opts,
              ast = file.ast,
              code = file.code,
              inputMap = file.inputMap;
            var results = [];

            for (
              var _iterator = pluginPasses,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var plugins = _ref;

              for (
                var _iterator2 = plugins,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : _iterator2[Symbol.iterator]();
                ;

              ) {
                var _ref2;

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break;
                  _ref2 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done) break;
                  _ref2 = _i2.value;
                }

                var plugin = _ref2;
                var generatorOverride = plugin.generatorOverride;

                if (generatorOverride) {
                  var _result2 = generatorOverride(
                    ast,
                    opts.generatorOpts,
                    code,
                    _babelGenerator().default
                  );

                  if (_result2 !== undefined) results.push(_result2);
                }
              }
            }

            var result;

            if (results.length === 0) {
              result = (0, _babelGenerator().default)(
                ast,
                opts.generatorOpts,
                code
              );
            } else if (results.length === 1) {
              result = results[0];

              if (typeof result.then === "function") {
                throw new Error(
                  "You appear to be using an async parser plugin, " +
                    "which your current version of Babel does not support. " +
                    "If you're using a published plugin, " +
                    "you may need to upgrade your @gerhobbelt/babel-core version."
                );
              }
            } else {
              throw new Error(
                "More than one plugin attempted to override codegen."
              );
            }

            var _result = result,
              outputCode = _result.code,
              outputMap = _result.map;

            if (outputMap && inputMap) {
              outputMap = (0, _mergeMap.default)(
                inputMap.toObject(),
                outputMap
              );
            }

            if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
              outputCode +=
                "\n" +
                _convertSourceMap()
                  .default.fromObject(outputMap)
                  .toComment();
            }

            if (opts.sourceMaps === "inline") {
              outputMap = null;
            }

            return {
              outputCode: outputCode,
              outputMap: outputMap,
            };
          }
        },
        /* 450 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = mergeSourceMap;

          function _sourceMap() {
            var data = _interopRequireDefault(__webpack_require__(141));

            _sourceMap = function _sourceMap() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          function mergeSourceMap(inputMap, map) {
            var input = buildMappingData(inputMap);
            var output = buildMappingData(map);
            var mergedGenerator = new (_sourceMap()).default.SourceMapGenerator();

            for (
              var _iterator = input.sources,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref5;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref5 = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref5 = _i.value;
              }

              var _ref = _ref5;
              var source = _ref.source;

              if (typeof source.content === "string") {
                mergedGenerator.setSourceContent(source.path, source.content);
              }
            }

            if (output.sources.length === 1) {
              var defaultSource = output.sources[0];
              var insertedMappings = new Map();
              eachInputGeneratedRange(input, function(
                generated,
                original,
                source
              ) {
                eachOverlappingGeneratedOutputRange(
                  defaultSource,
                  generated,
                  function(item) {
                    var key = makeMappingKey(item);
                    if (insertedMappings.has(key)) return;
                    insertedMappings.set(key, item);
                    mergedGenerator.addMapping({
                      source: source.path,
                      original: {
                        line: original.line,
                        column: original.columnStart,
                      },
                      generated: {
                        line: item.line,
                        column: item.columnStart,
                      },
                      name: original.name,
                    });
                  }
                );
              });

              for (
                var _iterator2 = insertedMappings.values(),
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : _iterator2[Symbol.iterator]();
                ;

              ) {
                var _ref6;

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break;
                  _ref6 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done) break;
                  _ref6 = _i2.value;
                }

                var item = _ref6;

                if (item.columnEnd === Infinity) {
                  continue;
                }

                var clearItem = {
                  line: item.line,
                  columnStart: item.columnEnd,
                };
                var key = makeMappingKey(clearItem);

                if (insertedMappings.has(key)) {
                  continue;
                }

                mergedGenerator.addMapping({
                  generated: {
                    line: clearItem.line,
                    column: clearItem.columnStart,
                  },
                });
              }
            }

            var result = mergedGenerator.toJSON();

            if (typeof input.sourceRoot === "string") {
              result.sourceRoot = input.sourceRoot;
            }

            return result;
          }

          function makeMappingKey(item) {
            return JSON.stringify([item.line, item.columnStart]);
          }

          function eachOverlappingGeneratedOutputRange(
            outputFile,
            inputGeneratedRange,
            callback
          ) {
            var overlappingOriginal = filterApplicableOriginalRanges(
              outputFile,
              inputGeneratedRange
            );

            for (
              var _iterator3 = overlappingOriginal,
                _isArray3 = Array.isArray(_iterator3),
                _i3 = 0,
                _iterator3 = _isArray3
                  ? _iterator3
                  : _iterator3[Symbol.iterator]();
              ;

            ) {
              var _ref7;

              if (_isArray3) {
                if (_i3 >= _iterator3.length) break;
                _ref7 = _iterator3[_i3++];
              } else {
                _i3 = _iterator3.next();
                if (_i3.done) break;
                _ref7 = _i3.value;
              }

              var _ref2 = _ref7;
              var generated = _ref2.generated;

              for (
                var _iterator4 = generated,
                  _isArray4 = Array.isArray(_iterator4),
                  _i4 = 0,
                  _iterator4 = _isArray4
                    ? _iterator4
                    : _iterator4[Symbol.iterator]();
                ;

              ) {
                var _ref8;

                if (_isArray4) {
                  if (_i4 >= _iterator4.length) break;
                  _ref8 = _iterator4[_i4++];
                } else {
                  _i4 = _iterator4.next();
                  if (_i4.done) break;
                  _ref8 = _i4.value;
                }

                var item = _ref8;
                callback(item);
              }
            }
          }

          function filterApplicableOriginalRanges(_ref9, _ref10) {
            var mappings = _ref9.mappings;
            var line = _ref10.line,
              columnStart = _ref10.columnStart,
              columnEnd = _ref10.columnEnd;
            return filterSortedArray(mappings, function(_ref11) {
              var outOriginal = _ref11.original;
              if (line > outOriginal.line) return -1;
              if (line < outOriginal.line) return 1;
              if (columnStart >= outOriginal.columnEnd) return -1;
              if (columnEnd <= outOriginal.columnStart) return 1;
              return 0;
            });
          }

          function eachInputGeneratedRange(map, callback) {
            for (
              var _iterator5 = map.sources,
                _isArray5 = Array.isArray(_iterator5),
                _i5 = 0,
                _iterator5 = _isArray5
                  ? _iterator5
                  : _iterator5[Symbol.iterator]();
              ;

            ) {
              var _ref12;

              if (_isArray5) {
                if (_i5 >= _iterator5.length) break;
                _ref12 = _iterator5[_i5++];
              } else {
                _i5 = _iterator5.next();
                if (_i5.done) break;
                _ref12 = _i5.value;
              }

              var _ref3 = _ref12;
              var source = _ref3.source,
                mappings = _ref3.mappings;

              for (
                var _iterator6 = mappings,
                  _isArray6 = Array.isArray(_iterator6),
                  _i6 = 0,
                  _iterator6 = _isArray6
                    ? _iterator6
                    : _iterator6[Symbol.iterator]();
                ;

              ) {
                var _ref13;

                if (_isArray6) {
                  if (_i6 >= _iterator6.length) break;
                  _ref13 = _iterator6[_i6++];
                } else {
                  _i6 = _iterator6.next();
                  if (_i6.done) break;
                  _ref13 = _i6.value;
                }

                var _ref4 = _ref13;
                var original = _ref4.original,
                  generated = _ref4.generated;

                for (
                  var _iterator7 = generated,
                    _isArray7 = Array.isArray(_iterator7),
                    _i7 = 0,
                    _iterator7 = _isArray7
                      ? _iterator7
                      : _iterator7[Symbol.iterator]();
                  ;

                ) {
                  var _ref14;

                  if (_isArray7) {
                    if (_i7 >= _iterator7.length) break;
                    _ref14 = _iterator7[_i7++];
                  } else {
                    _i7 = _iterator7.next();
                    if (_i7.done) break;
                    _ref14 = _i7.value;
                  }

                  var item = _ref14;
                  callback(item, original, source);
                }
              }
            }
          }

          function buildMappingData(map) {
            var consumer = new (_sourceMap()).default.SourceMapConsumer(
              Object.assign({}, map, {
                sourceRoot: null,
              })
            );
            var sources = new Map();
            var mappings = new Map();
            var last = null;
            consumer.computeColumnSpans();
            consumer.eachMapping(
              function(m) {
                if (m.originalLine === null) return;
                var source = sources.get(m.source);

                if (!source) {
                  source = {
                    path: m.source,
                    content: consumer.sourceContentFor(m.source, true),
                  };
                  sources.set(m.source, source);
                }

                var sourceData = mappings.get(source);

                if (!sourceData) {
                  sourceData = {
                    source: source,
                    mappings: [],
                  };
                  mappings.set(source, sourceData);
                }

                var obj = {
                  line: m.originalLine,
                  columnStart: m.originalColumn,
                  columnEnd: Infinity,
                  name: m.name,
                };

                if (
                  last &&
                  last.source === source &&
                  last.mapping.line === m.originalLine
                ) {
                  last.mapping.columnEnd = m.originalColumn;
                }

                last = {
                  source: source,
                  mapping: obj,
                };
                sourceData.mappings.push({
                  original: obj,
                  generated: consumer
                    .allGeneratedPositionsFor({
                      source: m.source,
                      line: m.originalLine,
                      column: m.originalColumn,
                    })
                    .map(function(item) {
                      return {
                        line: item.line,
                        columnStart: item.column,
                        columnEnd: item.lastColumn + 1,
                      };
                    }),
                });
              },
              null,
              _sourceMap().default.SourceMapConsumer.ORIGINAL_ORDER
            );
            return {
              file: map.file,
              sourceRoot: map.sourceRoot,
              sources: Array.from(mappings.values()),
            };
          }

          function findInsertionLocation(array, callback) {
            var left = 0;
            var right = array.length;

            while (left < right) {
              var mid = Math.floor((left + right) / 2);
              var item = array[mid];
              var result = callback(item);

              if (result === 0) {
                left = mid;
                break;
              }

              if (result >= 0) {
                right = mid;
              } else {
                left = mid + 1;
              }
            }

            var i = left;

            if (i < array.length) {
              while (i >= 0 && callback(array[i]) >= 0) {
                i--;
              }

              return i + 1;
            }

            return i;
          }

          function filterSortedArray(array, callback) {
            var start = findInsertionLocation(array, callback);
            var results = [];

            for (
              var i = start;
              i < array.length && callback(array[i]) === 0;
              i++
            ) {
              results.push(array[i]);
            }

            return results;
          }
        },
        /* 451 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = transformFile;

          function transformFile(filename, opts, callback) {
            if (opts === void 0) {
              opts = {};
            }

            if (typeof opts === "function") {
              callback = opts;
            }

            callback(
              new Error("Transforming files is not supported in browsers"),
              null
            );
          }
        },
        /* 452 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(process) {
            Object.defineProperty(exports, "__esModule", {
              value: true,
            });
            exports.transformFromAstSync = transformFromAstSync;
            exports.transformFromAstAsync = transformFromAstAsync;
            exports.transformFromAst = void 0;

            var _config = _interopRequireDefault(__webpack_require__(31));

            var _transformation = __webpack_require__(158);

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule
                ? obj
                : {
                    default: obj,
                  };
            }

            var transformFromAst = function transformFromAst(
              ast,
              code,
              opts,
              callback
            ) {
              if (typeof opts === "function") {
                callback = opts;
                opts = undefined;
              }

              if (callback === undefined)
                return transformFromAstSync(ast, code, opts);
              var cb = callback;
              process.nextTick(function() {
                var cfg;

                try {
                  cfg = (0, _config.default)(opts);
                  if (cfg === null) return cb(null, null);
                } catch (err) {
                  return cb(err);
                }

                if (!ast) return cb(new Error("No AST given"));
                (0, _transformation.runAsync)(cfg, code, ast, cb);
              });
            };

            exports.transformFromAst = transformFromAst;

            function transformFromAstSync(ast, code, opts) {
              var config = (0, _config.default)(opts);
              if (config === null) return null;
              if (!ast) throw new Error("No AST given");
              return (0, _transformation.runSync)(config, code, ast);
            }

            function transformFromAstAsync(ast, code, opts) {
              return new Promise(function(res, rej) {
                transformFromAst(ast, code, opts, function(err, result) {
                  if (err == null) res(result);
                  else rej(err);
                });
              });
            }
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(3)));
        },
        /* 453 */
        function(module, exports, __webpack_require__) {
          "use strict";
          /* WEBPACK VAR INJECTION */ (function(process) {
            Object.defineProperty(exports, "__esModule", {
              value: true,
            });
            exports.parseSync = parseSync;
            exports.parseAsync = parseAsync;
            exports.parse = void 0;

            var _config = _interopRequireDefault(__webpack_require__(31));

            var _normalizeFile = _interopRequireDefault(
              __webpack_require__(166)
            );

            var _normalizeOpts = _interopRequireDefault(
              __webpack_require__(165)
            );

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule
                ? obj
                : {
                    default: obj,
                  };
            }

            var parse = function parse(code, opts, callback) {
              if (typeof opts === "function") {
                callback = opts;
                opts = undefined;
              }

              if (callback === undefined) return parseSync(code, opts);
              var config = (0, _config.default)(opts);

              if (config === null) {
                return null;
              }

              var cb = callback;
              process.nextTick(function() {
                var ast = null;

                try {
                  var cfg = (0, _config.default)(opts);
                  if (cfg === null) return cb(null, null);
                  ast = (0, _normalizeFile.default)(
                    cfg.passes,
                    (0, _normalizeOpts.default)(cfg),
                    code
                  ).ast;
                } catch (err) {
                  return cb(err);
                }

                cb(null, ast);
              });
            };

            exports.parse = parse;

            function parseSync(code, opts) {
              var config = (0, _config.default)(opts);

              if (config === null) {
                return null;
              }

              return (0, _normalizeFile.default)(
                config.passes,
                (0, _normalizeOpts.default)(config),
                code
              ).ast;
            }

            function parseAsync(code, opts) {
              return new Promise(function(res, rej) {
                parse(code, opts, function(err, result) {
                  if (err == null) res(result);
                  else rej(err);
                });
              });
            }
            /* WEBPACK VAR INJECTION */
          }.call(this, __webpack_require__(3)));
        },
        /* 454 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function _babelHelperPluginUtils() {
            var data = __webpack_require__(41);

            _babelHelperPluginUtils = function _babelHelperPluginUtils() {
              return data;
            };

            return data;
          }

          function _babelPluginSyntaxJsonStrings() {
            var data = _interopRequireDefault(__webpack_require__(455));

            _babelPluginSyntaxJsonStrings = function _babelPluginSyntaxJsonStrings() {
              return data;
            };

            return data;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var _default = (0, _babelHelperPluginUtils().declare)(function(api) {
            api.assertVersion(7);
            var regex = /(\\*)([\u2028\u2029])/g;

            function replace(match, escapes, separator) {
              var isEscaped = escapes.length % 2 === 1;
              if (isEscaped) return match;
              return escapes + "\\u" + separator.charCodeAt(0).toString(16);
            }

            return {
              inherits: _babelPluginSyntaxJsonStrings().default,
              visitor: {
                "DirectiveLiteral|StringLiteral": function DirectiveLiteralStringLiteral(
                  _ref
                ) {
                  var node = _ref.node;
                  var extra = node.extra;
                  if (!extra || !extra.raw) return;
                  extra.raw = extra.raw.replace(regex, replace);
                },
              },
            };
          });

          exports.default = _default;
        },
        /* 455 */
        function(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          exports.default = void 0;

          function _babelHelperPluginUtils() {
            var data = __webpack_require__(41);

            _babelHelperPluginUtils = function _babelHelperPluginUtils() {
              return data;
            };

            return data;
          }

          var _default = (0, _babelHelperPluginUtils().declare)(function(api) {
            api.assertVersion(7);
            return {
              manipulateOptions: function manipulateOptions(opts, parserOpts) {
                parserOpts.plugins.push("jsonStrings");
              },
            };
          });

          exports.default = _default;
        },
      ]
    );
  }
);
